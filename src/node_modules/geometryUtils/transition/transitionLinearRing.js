/*
  A lot of this code was taken from flubber:
  https://github.com/veltman/flubber

  Unfortunately, flubber couldn't deal with polygons with holes.
  So, I took the code and modified it.
*/

import { polygonLength } from 'd3-polygon'
import pointDistance from '../pointDistance.js' 

export function transitionLinearRing (from, to) {
  let fromRing = bisect(from, 10)
  let toRing = bisect(to, 10)
  return interpolateRing(fromRing, toRing)
}

function bisect (ring, maxSegmentLength = Infinity) {
  let ringClone = JSON.parse(JSON.stringify(ring))

  for (let i = 0; i < ringClone.length; i++) {
    let a = ringClone[i]
    let b = i === ringClone.length - 1 ? ringClone[0] : ringClone[i + 1]

    // Could splice the whole set for a segment instead, but a bit messy
    while (pointDistance(a, b) > maxSegmentLength) {
      b = pointAlong(a, b, 0.5)
      ringClone.splice(i + 1, 0, b)
    }
  }

  return ringClone
}

export function implodeLinearRing (linearRing) {
  // TODO implode to centroid
}

export function explodeLinearRing (linearRing) {
  // explode from centroid
}

function pointAlong (a, b, pct) {
  return [a[0] + (b[0] - a[0]) * pct, a[1] + (b[1] - a[1]) * pct]
}

function interpolateRing (fromRing, toRing, string) {
  let diff = fromRing.length - toRing.length

  addPoints(fromRing, diff < 0 ? diff * -1 : 0)
  addPoints(toRing, diff > 0 ? diff : 0)

  rotate(fromRing, toRing)

  return interpolatePoints(fromRing, toRing, string)
}

function addPoints (ring, numPoints) {
  const desiredLength = ring.length + numPoints
  const step = polygonLength(ring) / numPoints

  let i = 0
  let cursor = 0
  let insertAt = step / 2

  while (ring.length < desiredLength) {
    let a = ring[i]
    let b = ring[(i + 1) % ring.length]
    let segment = pointDistance(a, b)

    if (insertAt <= cursor + segment) {
      ring.splice(i + 1, 0, segment ? pointAlong(a, b, (insertAt - cursor) / segment) : a.slice(0))
      insertAt += step
      continue
    }

    cursor += segment
    i++
  }
}

function rotate (ring, vs) {
  let len = ring.length
  let min = Infinity
  let bestOffset
  let sumOfSquares
  let spliced

  for (let offset = 0; offset < len; offset++) {
    sumOfSquares = 0

    vs.forEach(function (p, i) {
      let d = pointDistance(ring[(offset + i) % len], p)
      sumOfSquares += d * d
    })

    if (sumOfSquares < min) {
      min = sumOfSquares
      bestOffset = offset
    }
  }

  if (bestOffset) {
    spliced = ring.splice(0, bestOffset)
    ring.splice(ring.length, 0, ...spliced)
  }
}

function interpolatePoints (a, b, string) {
  let interpolators = a.map((d, i) => interpolatePoint(d, b[i]))

  return function (t) {
    return interpolators.map(fn => fn(t))
  }
}

function interpolatePoint (a, b) {
  return function (t) {
    return a.map((d, i) => d + t * (b[i] - d))
  }
}
