import { interpolate } from 'd3-interpolate';
import earcut from 'earcut';
import { feature, mergeArcs } from 'topojson-client';
import { bisector } from 'd3-array';

function pointDistance (point1, point2) {
  return Math.sqrt(
    (point1[0] - point2[0]) ** 2 +
    (point1[1] - point2[1]) ** 2
  )
}

/*
  Why this weird map function when there is Array.map?
  Well, usually premature optimization is the root of all evil,
  but Array.map is just really really slow.

  See, for example,  https://jsperf.com/map-reduce-named-functions/2
  Array.map is more than 6x slower than a classical for loop,
  and almost 4x slower than a custom implementation like this one.
*/
function map (array, callback) {
  const result = [];

  for (let i = 0; i < array.length; i++) {
    result.push(callback(array[i], i));
  }

  return result
}

function every (array, condition) {
  for (let i = 0; i < array.length; i++) {
    if (condition(array[i], i)) return false
  }

  return true
}

function getOrderDescending (array) {
  const indexArray = map(array, (_, i) => i);
  indexArray.sort((a, b) => array[b] - array[a]);

  return indexArray
}

function sortIntoOrder (array, order) {
  return map(order, i => array[i])
}

function getInsertionIndexDescending (arraySortedDescending, value) {
  if (arraySortedDescending.length === 0) return 0

  for (let i = arraySortedDescending.length - 1; i >= 0; i--) {
    const arrayValue = arraySortedDescending[i];

    if (value <= arrayValue) return i
  }

  return 0
}

function removeClosingPoint (linearRing) {
  linearRing.pop();

  return linearRing
}

function closeRing (linearRing) {
  let firstPoint = linearRing[0];
  linearRing.push(firstPoint);

  return linearRing
}

function insertPointsLinearRing (inputLinearRing, numberOfAdditionalPoints) {
  let linearRing = cloneLinearRing(inputLinearRing);
  linearRing = removeClosingPoint(linearRing);

  const edgeLengths = getEdgeLengths(linearRing);
  let orderedEdgeIds = getOrderDescending(edgeLengths);

  for (let i = 0; i < numberOfAdditionalPoints; i++) {
    const longestEdgeId = orderedEdgeIds[0];

    const edge = getEdge(linearRing, longestEdgeId);

    const edgeLength = edgeLengths[longestEdgeId];

    const newEdges = splitEdge(edge);
    const newEdgesLength = edgeLength / 2;

    // Remove old edge
    orderedEdgeIds.shift();
    linearRing[longestEdgeId] = null;
    edgeLengths[longestEdgeId] = null;

    // Insert new edges
    orderedEdgeIds = insertOrderedId(orderedEdgeIds, edgeLengths, longestEdgeId, newEdgesLength);

    linearRing[longestEdgeId] = newEdges[0][0];
    linearRing.splice(longestEdgeId + 1, 0, newEdges[1][0]);

    edgeLengths[longestEdgeId] = newEdgesLength;
    edgeLengths.splice(longestEdgeId + 1, 0, newEdgesLength);
  }

  linearRing = closeRing(linearRing);

  return linearRing
}

function cloneLinearRing (linearRing) {
  const clonedLinearRing = [];

  for (let i = 0; i < linearRing.length; i++) {
    clonedLinearRing.push(linearRing[i].slice(0));
  }

  return clonedLinearRing
}

function getEdgeLengths (linearRing) {
  const edgeLengths = [];

  for (let i = 0; i < linearRing.length; i++) {
    const edge = getEdge(linearRing, i);

    edgeLengths.push(pointDistance(edge[0], edge[1]));
  }

  return edgeLengths
}

function getEdge (linearRing, index) {
  return [
    linearRing[index], linearRing[(index + 1) % linearRing.length]
  ]
}

function splitEdge (edge) {
  const pointInBetween = interpolate(edge[0], edge[1])(0.5);

  return [
    [edge[0], pointInBetween],
    [pointInBetween, edge[1]]
  ]
}

function insertOrderedId (orderedIds, edgeLengths, valueIndex, newValue) {
  // Insert new Ids right place
  let idsWereInserted = false;

  for (let i = 0; i < orderedIds.length; i++) {
    const index = orderedIds[i];

    // Increase all indices after the valueIndex with 1
    if (index > valueIndex) orderedIds[i] = orderedIds[i] + 1;

    const currentArrayValue = edgeLengths[index];
    if (currentArrayValue === null) continue

    if (newValue >= currentArrayValue) {
      orderedIds.splice(i, 0, valueIndex);
      orderedIds.splice(i + 1, 0, valueIndex + 1);

      idsWereInserted = true;
      break
    }
  }

  if (!idsWereInserted) {
    orderedIds.push(valueIndex);
    orderedIds.push(valueIndex + 1);
  }

  return orderedIds
}

/*
  Taken from flubber:
  https://github.com/veltman/flubber
*/

function rotatePointsLinearRing (inputLinearRing, toLinearRing) {
  let fromLinearRing = cloneLinearRing(inputLinearRing);
  fromLinearRing = removeClosingPoint(fromLinearRing);

  const fromLength = fromLinearRing.length;
  let min = Infinity;
  let bestOffset;
  let sumOfSquares;
  let spliced;

  for (let offset = 0; offset < fromLength; offset++) {
    sumOfSquares = 0;

    toLinearRing.forEach((point, i) => {
      const distance = pointDistance(fromLinearRing[(offset + i) % fromLength], point);
      sumOfSquares += distance * distance;
    });

    if (sumOfSquares < min) {
      min = sumOfSquares;
      bestOffset = offset;
    }
  }

  if (bestOffset) {
    spliced = fromLinearRing.splice(0, bestOffset);
    fromLinearRing.splice(fromLinearRing.length, 0, ...spliced);
  }

  fromLinearRing = closeRing(fromLinearRing);

  return fromLinearRing
}

function isLinearRing (polygon) {
  return polygon.constructor === Array
}

function isPolygon (polygon) {
  return polygon.constructor === Object && polygon.type === 'Polygon'
}

function isMultiPolygon (polygon) {
  return polygon.constructor === Object && polygon.type === 'MultiPolygon'
}

function isPolygonOrMultiPolygon (input) {
  return isPolygon(input) || isMultiPolygon(input)
}

function polygonArea (polygon) {
  if (isLinearRing(polygon)) {
    return getRingArea(polygon)
  }

  if (isPolygon(polygon)) {
    return getPolygonArea(polygon)
  }

  if (isMultiPolygon(polygon)) {
    return getMultiPolygonArea(polygon)
  }

  throw new Error('Invalid input')
}

function linearRingIsClockwise (ring) {
  return getSignedRingArea(ring) < 0
}

function getRingArea (ring) {
  return Math.abs(getSignedRingArea(ring))
}

// Taken from: https://stackoverflow.com/a/33670691/7237112
function getSignedRingArea (ring) {
  let total = 0;

  for (let i = 0, l = ring.length; i < l; i++) {
    const addX = ring[i][0];
    const addY = ring[i === ring.length - 1 ? 0 : i + 1][1];
    const subX = ring[i === ring.length - 1 ? 0 : i + 1][0];
    const subY = ring[i][1];

    total += (addX * addY * 0.5);
    total -= (subX * subY * 0.5);
  }

  return total
}

function getPolygonArea (polygon) {
  let totalArea = getRingArea(polygon.coordinates[0]);

  for (let i = 1; i < polygon.coordinates.length; i++) {
    const holeArea = getRingArea(polygon.coordinates[i]);
    totalArea -= holeArea;
  }

  return totalArea
}

function getMultiPolygonArea (multiPolygon) {
  let totalArea = 0;

  for (let i = 0; i < multiPolygon.coordinates.length; i++) {
    totalArea += getPolygonArea(multiPolygon.coordinates[i]);
  }

  return totalArea
}

function matchLinearRings (fromRings, toRings) {
  if (tooManyRings(fromRings)) {
    return map(fromRings, (_, i) => i)
  }

  return bestOrder(fromRings, toRings)
}

function tooManyRings (rings) {
  // with more than 9 rings, everything will be too chaotic to notice this stuff anyway.
  return rings.length > 9
}

function bestOrder (fromRings, toRings) {
  const fromAreas = map(fromRings, polygonArea);
  const toAreas = map(toRings, polygonArea);

  const fromAreasOrderDescending = getOrderDescending(fromAreas);
  const toAreasOrderDescending = getOrderDescending(toAreas);

  const pairs = {};

  for (let i = 0; i < toAreasOrderDescending.length; i++) {
    const fromIndex = fromAreasOrderDescending[i];
    const toIndex = toAreasOrderDescending[i];

    pairs[toIndex] = fromIndex;
  }

  const fromOrder = [];

  for (let i = 0; i < toRings.length; i++) {
    fromOrder.push(pairs[i]);
  }

  return fromOrder
}

function calculateCentroid (geometry) {
  if (isLinearRing(geometry)) {
    return calculateLinearRingCentroid(geometry)
  }

  if (isPolygon(geometry)) {
    return calculatePolygonCentroid(geometry)
  }

  if (isMultiPolygon(geometry)) {
    return calculateMultiPolygonCentroid(geometry)
  }
}

// https://stackoverflow.com/a/33852627/7237112
function calculateLinearRingCentroid (ring) {
  const nPts = ring.length;
  const off = ring[0];
  let twicearea = 0;
  let x = 0;
  let y = 0;
  let p1;
  let p2;
  let f;

  for (let i = 0, j = nPts - 1; i < nPts; j = i++) {
    p1 = ring[i];
    p2 = ring[j];
    f = (p1[0] - off[0]) * (p2[1] - off[1]) - (p2[0] - off[0]) * (p1[1] - off[1]);
    twicearea += f;
    x += (p1[0] + p2[0] - 2 * off[0]) * f;
    y += (p1[1] + p2[1] - 2 * off[1]) * f;
  }

  f = twicearea * 3;

  return [x / f + off[0], y / f + off[1]]
}

function calculatePolygonCentroid (polygon) {
  // We will ignore holes and just take the outer ring
  return calculateLinearRingCentroid(polygon.coordinates[0])
}

function calculateMultiPolygonCentroid (multiPolygon) {
  // We will take the centroid of each polygon (ignoring holes)
  // and take the weighted (by area) center of these.
  let x = 0;
  let y = 0;
  let totalArea = 0;

  for (let i = 0; i < multiPolygon.coordinates.length; i++) {
    const polygon = multiPolygon.coordinates[i];
    const polygonCentroid = calculateLinearRingCentroid(polygon[0]);
    const area = polygonArea(polygon[0]);

    x += polygonCentroid[0] * area;
    y += polygonCentroid[1] * area;
    totalArea += area;
  }

  return [x / totalArea, y / totalArea]
}

function polygonToPolygon (from, to) {
  const fromOuterRing = from.coordinates[0];
  const toOuterRing = to.coordinates[0];

  const [fromOuterRingPrepared, toOuterRingPrepared] = prepareLinearRings(fromOuterRing, toOuterRing);

  if (neitherHasHoles(from, to)) {
    return createInterpolatorNoHoles(from, to, fromOuterRingPrepared, toOuterRingPrepared)
  }

  const holeInterpolators = createHoleInterpolators(from, to);

  return createInterpolatorWithHoles(
    from, to, fromOuterRingPrepared, toOuterRingPrepared, holeInterpolators
  )
}

function prepareLinearRings (fromRing, toRing) {
  const lengthDifference = fromRing.length - toRing.length;

  if (lengthDifference > 0) {
    toRing = insertPointsLinearRing(toRing, lengthDifference);
  }

  if (lengthDifference < 0) {
    fromRing = insertPointsLinearRing(fromRing, -lengthDifference);
  }

  const rotatedFromRing = rotatePointsLinearRing(fromRing, toRing);

  return [rotatedFromRing, toRing]
}

function createInterpolatorNoHoles (from, to, fromOuterRingPrepared, toOuterRingPrepared) {
  const outerRingInterpolator = interpolate(fromOuterRingPrepared, toOuterRingPrepared);

  return function interpolator (t) {
    if (t === 0) return from
    if (t === 1) return to

    const interpolatedLinearRing = outerRingInterpolator(t);

    return {
      type: 'Polygon',
      coordinates: [interpolatedLinearRing]
    }
  }
}

function neitherHasHoles (from, to) {
  return from.coordinates.length === 1 && to.coordinates.length === 1
}

function getHoles (polygon, numberOfHoles) {
  const holes = [];

  for (let i = 1; i <= numberOfHoles; i++) {
    holes.push(polygon.coordinates[i]);
  }

  return holes
}

function createHoleInterpolators (from, to) {
  let holeInterpolators = [];

  const numberOfMatchableHoles = Math.min(from.coordinates.length, to.coordinates.length) - 1;

  if (numberOfMatchableHoles > 0) {
    holeInterpolators = holeInterpolators.concat(
      createMatchableHoleInterpolators(from, to, numberOfMatchableHoles)
    );
  }

  const differenceBetweenNumberOfHoles = from.coordinates.length - to.coordinates.length;

  if (differenceBetweenNumberOfHoles > 0) {
    holeInterpolators = holeInterpolators.concat(
      createHoleImploders(from, differenceBetweenNumberOfHoles)
    );
  }

  if (differenceBetweenNumberOfHoles < 0) {
    holeInterpolators = holeInterpolators.concat(
      createHoleExploders(to, -differenceBetweenNumberOfHoles)
    );
  }

  return holeInterpolators
}

function createMatchableHoleInterpolators (from, to, numberOfMatchableHoles) {
  const holeInterpolators = [];

  const fromHoles = getHoles(from, numberOfMatchableHoles);
  const toHoles = getHoles(to, numberOfMatchableHoles);

  const fromOrder = matchLinearRings(fromHoles, toHoles);
  const fromHolesSorted = map(fromOrder, i => fromHoles[i]);

  for (let i = 0; i < numberOfMatchableHoles; i++) {
    const fromHole = fromHolesSorted[i];
    const toHole = toHoles[i];

    const [fromHolePrepared, toHolePrepared] = prepareLinearRings(fromHole, toHole);

    const holeInterpolator = interpolate(fromHolePrepared, toHolePrepared);

    holeInterpolators.push(holeInterpolator);
  }

  return holeInterpolators
}

function createHoleImploders (polygon, differenceBetweenNumberOfHoles) {
  const interpolators = [];

  const firstHoleThatNeedsImplodingIndex = polygon.coordinates.length - differenceBetweenNumberOfHoles;

  for (let i = firstHoleThatNeedsImplodingIndex; i < polygon.coordinates.length; i++) {
    const hole = polygon.coordinates[i];
    const holeCentroid = calculateCentroid(hole);
    const smallRectangleAroundCentroid = makeSmallRectangleAroundPoint(holeCentroid);

    const [preparedPolygon, preparedImplodePoint] = prepareLinearRings(hole, smallRectangleAroundCentroid);

    interpolators.push(interpolate(preparedPolygon, preparedImplodePoint));
  }

  return interpolators
}

function createHoleExploders (polygon, differenceBetweenNumberOfHoles) {
  return map(createHoleImploders(polygon, differenceBetweenNumberOfHoles), holeInterpolator => {
    return t => holeInterpolator(1 - t)
  })
}

function makeSmallRectangleAroundPoint ([x, y]) {
  const epsilon = 1e-6;

  const x1 = x - epsilon;
  const x2 = x + epsilon;
  const y1 = y - epsilon;
  const y2 = y + epsilon;

  return [[x1, y1], [x1, y2], [x2, y2], [x2, y1], [x1, y1]]
}

function createInterpolatorWithHoles (
  from, to, fromOuterRingPrepared, toOuterRingPrepared, holeInterpolators
) {
  const outerRingInterpolator = interpolate(fromOuterRingPrepared, toOuterRingPrepared);

  return function interpolator (t) {
    if (t === 0) return from
    if (t === 1) return to

    const interpolatedLinearRing = outerRingInterpolator(t);

    return {
      type: 'Polygon',
      coordinates: [
        interpolatedLinearRing,
        ...map(holeInterpolators, holeInterpolator => holeInterpolator(t))
      ]
    }
  }
}

/*
  Taken from flubber:
  https://github.com/veltman/flubber
*/

function createTopology (vertices, triangleIndices) {
  const arcIndices = {};
  const topology = createEmptyTopology();

  for (let i = 0; i < triangleIndices.length; i += 3) {
    const geometry = [];

    const triangleIndexArcs = createTriangleIndexArcs(triangleIndices, i);

    triangleIndexArcs.forEach(arc => {
      const slug = createArcSlug(arc);

      const coordinates = map(arc, pointIndex => getPoint(vertices, pointIndex));

      if (slug in arcIndices) {
        geometry.push(~arcIndices[slug]); // Not sure what this is doing
      } else {
        geometry.push((arcIndices[slug] = topology.arcs.length));
        topology.arcs.push(coordinates);
      }
    });

    const area = getTriangleArea(vertices, triangleIndexArcs);
    const polygon = createTopoPolygon(area, geometry);

    topology.objects.triangles.geometries.push(polygon);
  }

  // Sort smallest first
  // TODO sorted insertion?
  topology.objects.triangles.geometries.sort((a, b) => a.area - b.area);

  return topology
}

function createEmptyTopology () {
  return {
    type: 'Topology',
    objects: {
      triangles: {
        type: 'GeometryCollection',
        geometries: []
      }
    },
    arcs: []
  }
}

function createTriangleIndexArcs (triangleIndices, i) {
  const a = triangleIndices[i];
  const b = triangleIndices[i + 1];
  const c = triangleIndices[i + 2];

  return [[a, b], [b, c], [c, a]]
}

function createArcSlug (arc) {
  return arc[0] < arc[1] ? arc.join(',') : arc[1] + ',' + arc[0]
}

function getPoint (vertices, i) {
  return [vertices[i * 2], vertices[(i * 2) + 1]]
}

function createTopoPolygon (area, geometry) {
  return {
    type: 'Polygon',
    area,
    arcs: [geometry]
  }
}

function getTriangleArea (vertices, triangleIndexArcs) {
  return Math.abs(
    polygonArea(map(triangleIndexArcs, arc => getPoint(vertices, arc[0])))
  )
}

/*
  Taken from flubber:
  https://github.com/veltman/flubber
*/

const bisect = bisector(d => d.area).left;

function findNeighbor (geoms) {
  // we assume the first geom is the candidate for which
  // we want to find a neighbor
  const sourceArcs = geoms[0].arcs[0].map(arc => arc < 0 ? ~arc : arc);

  let neighbor;

  // start loop at index 1, first possible neighbor
  for (let index = 1; index < geoms.length; index++) {
    const targetArcs = geoms[index].arcs[0].map(arc => arc < 0 ? ~arc : arc);
    if (sourceArcs.some(arc => targetArcs.includes(arc))) {
      neighbor = index;
      break
    }
  }
  return neighbor
}

function collapseTopology (topology, numberOfPieces) {
  const triangleGeometries = topology.objects.triangles.geometries;

  while (triangleGeometries.length > numberOfPieces) {
    mergeSmallestFeature();
  }

  if (numberOfPieces > triangleGeometries.length) {
    throw new RangeError('Can\'t collapse topology into ' + numberOfPieces + ' pieces.')
  }

  const geojson = feature(topology, topology.objects.triangles);
  const geojsonTriangleGeometries = map(geojson.features, feature => feature.geometry);

  return geojsonTriangleGeometries

  function mergeSmallestFeature () {
    const smallest = triangleGeometries[0];
    const neighborIndex = findNeighbor(triangleGeometries);
    const neighbor = triangleGeometries[neighborIndex];
    const merged = mergeArcs(topology, [smallest, neighbor]);

    // MultiPolygon -> Polygon
    merged.area = smallest.area + neighbor.area;
    merged.type = 'Polygon';
    merged.arcs = merged.arcs[0];

    // Delete smallest and its chosen neighbor
    triangleGeometries.splice(neighborIndex, 1);
    triangleGeometries.shift();

    // Add new merged shape in sorted order
    triangleGeometries.splice(bisect(triangleGeometries, merged.area), 0, merged);
  }
}

function createGeometries (vertices, triangleIndices) {
  const geometries = [];

  for (let i = 0; i < triangleIndices.length; i += 3) {
    const triangleIndexArcs = createTriangleIndexArcs(triangleIndices, i);

    let outerRing = map(triangleIndexArcs, arc => getPoint(vertices, arc[0]));
    outerRing.push(getPoint(vertices, triangleIndexArcs[0][0])); // close ring

    // earcut doesn't always give counterclockwise rings back
    if (linearRingIsClockwise(outerRing)) {
      outerRing = outerRing.reverse();
    }

    geometries.push({
      type: 'Polygon',
      coordinates: [outerRing]
    });
  }

  return geometries
}

function sliceUpTriangles (geometries, numberOfPieces) {
  const areas = map(geometries, polygonArea);

  const order = getOrderDescending(areas);

  const areasSorted = sortIntoOrder(areas, order);
  const geometriesSorted = sortIntoOrder(geometries, order);

  while (geometriesSorted.length < numberOfPieces) {
    areasSorted.shift();
    const biggestTriangle = geometriesSorted.shift();

    const cutTriangles = cutTriangleInTwo(biggestTriangle);

    const areaCutTriangles = map(cutTriangles, polygonArea);

    for (let i = 0; i < cutTriangles.length; i++) {
      const areaCutTriangle = areaCutTriangles[i];
      const cutTriangle = cutTriangles[i];

      const insertionIndex = getInsertionIndexDescending(areasSorted, areaCutTriangle);

      areasSorted.splice(insertionIndex, 0, areaCutTriangle);
      geometriesSorted.splice(insertionIndex, 0, cutTriangle);
    }
  }

  return geometriesSorted
}

function cutTriangleInTwo (triangle) {
  const a = triangle.coordinates[0][0];
  const b = triangle.coordinates[0][1];
  const c = triangle.coordinates[0][2];

  const pointBetweenAB = interpolate(a, b)(0.5);

  const firstTriangle = createTriangleGeometry([a, pointBetweenAB, c, a]);
  const secondTriangle = createTriangleGeometry([b, c, pointBetweenAB, b]);

  return [firstTriangle, secondTriangle]
}

function createTriangleGeometry (points) {
  return {
    type: 'Polygon',
    coordinates: [points]
  }
}

/*
  Inspired by flubber:
  https://github.com/veltman/flubber
*/

const dimensions = 2;

function cutPolygon (polygon, numberOfPieces) {
  if (numberOfPieces < 2) throw new Error('Cannot cut polygon in less than 2 pieces')

  const flattenedPolygon = earcut.flatten(polygon.coordinates);
  const triangleIndices = earcut(flattenedPolygon.vertices, flattenedPolygon.holes, dimensions);

  const numberOfTriangles = getNumberOfTriangles(triangleIndices);

  if (numberOfTriangles >= numberOfPieces) {
    const topology = createTopology(flattenedPolygon.vertices, triangleIndices);
    return collapseTopology(topology, numberOfPieces)
  }

  if (numberOfTriangles < numberOfPieces) {
    const triangleGeometries = createGeometries(flattenedPolygon.vertices, triangleIndices);
    return sliceUpTriangles(triangleGeometries, numberOfPieces)
  }
}

function getNumberOfTriangles (triangleIndices) {
  return triangleIndices.length / 3
}

function cutPolygons (polygons, numberOfDesiredAdditionalPolygons) {
  if (numberOfDesiredAdditionalPolygons < 1) throw wrongNumberOfPolygonsError

  const polygonAreas = map(polygons, polygonArea);
  const numberOfCutsPerPolygon = assignCuts(polygonAreas, numberOfDesiredAdditionalPolygons);

  let resultingPolygons = [];

  for (let i = 0; i < polygons.length; i++) {
    const polygon = polygons[i];
    const numberOfCuts = numberOfCutsPerPolygon[i];

    if (numberOfCuts === 0) {
      resultingPolygons.push(polygon);
    }

    if (numberOfCuts > 0) {
      const numberOfDesiredPolygons = numberOfCuts + 1;
      resultingPolygons = resultingPolygons.concat(cutPolygon(polygon, numberOfDesiredPolygons));
    }
  }

  return resultingPolygons
}

const wrongNumberOfPolygonsError = new Error('Number of desired additional polygons must be larger than 0');

// https://stackoverflow.com/a/38905829/7237112
function assignCuts (polygonAreas, numberOfPieces) {
  const numberOfCutsPerPolygon = [];
  let totalArea = sum(polygonAreas);

  for (let i = 0; i < polygonAreas.length; i++) {
    const area = polygonAreas[i];
    const numberOfCuts = Math.round(area / totalArea * numberOfPieces);

    numberOfCutsPerPolygon.push(numberOfCuts);
    totalArea -= area;
    numberOfPieces -= numberOfCuts;
  }

  return numberOfCutsPerPolygon
}

function sum (array) {
  let sum = 0;

  for (let i = 0; i < array.length; i++) {
    sum += array[i];
  }

  return sum
}

function combineIntoMultiPolygon (inputGeometries) {
  const multiPolygon = createEmptyMultiPolygon();

  for (const inputGeometry of inputGeometries) {
    if (inputGeometry.type === 'Polygon') {
      multiPolygon.coordinates.push(inputGeometry.coordinates);
    }

    if (inputGeometry.type === 'MultiPolygon') {
      for (const polygon of inputGeometry.coordinates) {
        multiPolygon.coordinates.push(polygon);
      }
    }
  }

  return multiPolygon
}

function splitMultiPolygon (multiPolygon) {
  const polygons = [];

  for (const polygonCoordinates of multiPolygon.coordinates) {
    const polygon = createEmptyPolygon();
    polygon.coordinates = polygonCoordinates;

    polygons.push(polygon);
  }

  return polygons
}

function createEmptyMultiPolygon () {
  return { type: 'MultiPolygon', coordinates: [] }
}

function createEmptyPolygon () {
  return { type: 'Polygon', coordinates: undefined }
}

function multiPolygonToMultiPolygon (from, to) {
  let fromPolygons = splitMultiPolygon(from);
  let toPolygons = splitMultiPolygon(to);

  const lengthDifference = fromPolygons.length - toPolygons.length;

  if (lengthDifference > 0) {
    toPolygons = cutPolygons(toPolygons, lengthDifference);
  }

  if (lengthDifference < 0) {
    fromPolygons = cutPolygons(fromPolygons, -lengthDifference);
  }

  return createInterpolatorPolygons(from, to, fromPolygons, toPolygons)
}

function createInterpolatorPolygons (from, to, fromPolygons, toPolygons) {
  const fromOuterRings = map(fromPolygons, polygon => polygon.coordinates[0]);
  const toOuterRings = map(toPolygons, polygon => polygon.coordinates[0]);

  const fromOrder = matchLinearRings(fromOuterRings, toOuterRings);
  fromPolygons = map(fromOrder, i => fromPolygons[i]);

  const polygonInterpolators = [];

  for (let i = 0; i < fromPolygons.length; i++) {
    const fromPolygon = fromPolygons[i];
    const toPolygon = toPolygons[i];

    polygonInterpolators.push(polygonToPolygon(fromPolygon, toPolygon));
  }

  return function interpolator (t) {
    if (t === 0) return from
    if (t === 1) return to

    const interpolatedPolygons = map(polygonInterpolators, polygonInterpolator => polygonInterpolator(t));

    return combineIntoMultiPolygon(
      map(polygonInterpolators, polygonInterpolator => polygonInterpolator(t))
    )
  }
}

function multiPolygonToPolygon (from, to) {
  const fromPolygons = splitMultiPolygon(from);
  let toPolygons = [to];

  const numberOfFromPolygons = fromPolygons.length;
  const numberOfAdditionalToPolygonsRequried = numberOfFromPolygons - 1;

  if (numberOfAdditionalToPolygonsRequried > 0) {
    toPolygons = cutPolygon(to, numberOfFromPolygons);
  }

  return createInterpolatorPolygons(from, to, fromPolygons, toPolygons)
}

function polygonToMultiPolygon (from, to) {
  const reverseInterpolator = multiPolygonToPolygon(to, from);

  return function interpolator (t) {
    return reverseInterpolator(1 - t)
  }
}

function transshape (from, to) {
  ensureValidInput(from, to);

  if (from.type === 'Polygon' && to.type === 'Polygon') {
    return polygonToPolygon(from, to)
  }

  if (from.type === 'MultiPolygon' && to.type === 'Polygon') {
    return multiPolygonToPolygon(from, to)
  }

  if (from.type === 'Polygon' && to.type === 'MultiPolygon') {
    return polygonToMultiPolygon(from, to)
  }

  if (from.type === 'MultiPolygon' && to.type === 'MultiPolygon') {
    return multiPolygonToMultiPolygon(from, to)
  }
}

function ensureValidInput (from, to) {
  if (!(
    isPolygonOrMultiPolygon(from) &&
    isPolygonOrMultiPolygon(to)
  )) {
    throw new Error('Invalid input')
  }
}

function implode (geometry) {
  ensureValidInput$1(geometry);

  const centroid = calculateCentroid(geometry);
  const implosionPoint = createSmallPolygonAroundPoint(centroid);

  return transshape(geometry, implosionPoint)
}

function explode (geometry) {
  ensureValidInput$1(geometry);

  const centroid = calculateCentroid(geometry);
  const explosionPoint = createSmallPolygonAroundPoint(centroid);

  return transshape(explosionPoint, geometry)
}

function ensureValidInput$1 (geometry) {
  if (!isPolygonOrMultiPolygon(geometry)) {
    throw new Error('Invalid input')
  }
}

function createSmallPolygonAroundPoint (point) {
  const linearRingAroundPoint = makeSmallRectangleAroundPoint(point);
  return {
    type: 'Polygon',
    coordinates: [linearRingAroundPoint]
  }
}

function transshapeLayer (fromLayer, toLayer) {
  ensureValidInput$2(fromLayer);

  const keyOverlap = getKeyOverlap(fromLayer, toLayer);
  const interpolatorObject = constructInterpolatorObject(fromLayer, toLayer, keyOverlap);

  return createLayerInterpolator(fromLayer, toLayer, interpolatorObject)
}

function ensureValidInput$2 (fromLayer, toLayer) {
  return every(Object.values(fromLayer), isPolygonOrMultiPolygon) &&
    every(Object.values(fromLayer), isPolygonOrMultiPolygon)
}

function getKeyOverlap (fromLayer, toLayer) {
  const keyOverlap = {};

  for (const key in fromLayer) {
    keyOverlap[key] = 'from';
  }

  for (const key in toLayer) {
    if (keyOverlap[key]) {
      keyOverlap[key] = 'both';
    } else {
      keyOverlap[key] = 'to';
    }
  }

  return keyOverlap
}

function constructInterpolatorObject (fromLayer, toLayer, keyOverlap) {
  const interpolatorObject = {};

  for (const key in keyOverlap) {
    const overlap = keyOverlap[key];

    if (overlap === 'both') {
      interpolatorObject[key] = transshape(fromLayer[key], toLayer[key]);
    }

    if (overlap === 'from') {
      interpolatorObject[key] = implode(fromLayer[key]);
    }

    if (overlap === 'to') {
      interpolatorObject[key] = explode(toLayer[key]);
    }
  }

  return interpolatorObject
}

function createLayerInterpolator (fromLayer, toLayer, interpolatorObject) {
  return function interpolator (t) {
    if (t === 0) return fromLayer
    if (t === 1) return toLayer

    const layerObject = {};

    for (const key in interpolatorObject) {
      layerObject[key] = interpolatorObject[key](t);
    }

    return layerObject
  }
}

export { cutPolygon, cutPolygons, explode, implode, insertPointsLinearRing, matchLinearRings, rotatePointsLinearRing, transshape, transshapeLayer };
