
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.head.appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function validate_store(store, name) {
        if (!store || typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, callback) {
        const unsub = store.subscribe(callback);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, fn) {
        return definition[1]
            ? assign({}, assign(ctx.$$scope.ctx, definition[1](fn ? fn(ctx) : {})))
            : ctx.$$scope.ctx;
    }
    function get_slot_changes(definition, ctx, changed, fn) {
        return definition[1]
            ? assign({}, assign(ctx.$$scope.changed || {}, definition[1](fn ? fn(changed) : {})))
            : ctx.$$scope.changed || {};
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    let running = false;
    function run_tasks() {
        tasks.forEach(task => {
            if (!task[0](now())) {
                tasks.delete(task);
                task[1]();
            }
        });
        running = tasks.size > 0;
        if (running)
            raf(run_tasks);
    }
    function loop(fn) {
        let task;
        if (!running) {
            running = true;
            raf(run_tasks);
        }
        return {
            promise: new Promise(fulfil => {
                tasks.add(task = [fn, fulfil]);
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function to_number(value) {
        return value === '' ? undefined : +value;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        if (value != null || input.value) {
            input.value = value;
        }
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error(`Function called outside component initialization`);
        return current_component;
    }
    function beforeUpdate(fn) {
        get_current_component().$$.before_update.push(fn);
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function flush() {
        const seen_callbacks = new Set();
        do {
            // first, call beforeUpdate functions
            // and update components
            while (dirty_components.length) {
                const component = dirty_components.shift();
                set_current_component(component);
                update(component.$$);
            }
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    callback();
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update($$.dirty);
            run_all($$.before_update);
            $$.fragment && $$.fragment.p($$.dirty, $$.ctx);
            $$.dirty = null;
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    const globals = (typeof window !== 'undefined' ? window : global);

    function destroy_block(block, lookup) {
        block.d(1);
        lookup.delete(block.key);
    }
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function update_keyed_each(old_blocks, changed, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(changed, child_ctx);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = {};
        }
    }
    function make_dirty(component, key) {
        if (!component.$$.dirty) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty = blank_object();
        }
        component.$$.dirty[key] = true;
    }
    function init(component, options, instance, create_fragment, not_equal, props) {
        const parent_component = current_component;
        set_current_component(component);
        const prop_values = options.props || {};
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty: null
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, prop_values, (key, ret, value = ret) => {
                if ($$.ctx && not_equal($$.ctx[key], $$.ctx[key] = value)) {
                    if ($$.bound[key])
                        $$.bound[key](value);
                    if (ready)
                        make_dirty(component, key);
                }
                return ret;
            })
            : prop_values;
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(children(options.target));
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set() {
            // overridden by instance, if it has props
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, detail));
    }
    function append_dev(target, node) {
        dispatch_dev("SvelteDOMInsert", { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev("SvelteDOMInsert", { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev("SvelteDOMRemove", { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev("SvelteDOMAddEventListener", { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev("SvelteDOMRemoveEventListener", { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
        else
            dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.data === data)
            return;
        dispatch_dev("SvelteDOMSetData", { node: text, data });
        text.data = data;
    }
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error(`'target' is a required option`);
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn(`Component was already destroyed`); // eslint-disable-line no-console
            };
        }
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe,
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => store.subscribe((value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    const LOCATION = {};
    const ROUTER = {};

    /**
     * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/history.js
     *
     * https://github.com/reach/router/blob/master/LICENSE
     * */

    function getLocation(source) {
      return {
        ...source.location,
        state: source.history.state,
        key: (source.history.state && source.history.state.key) || "initial"
      };
    }

    function createHistory(source, options) {
      const listeners = [];
      let location = getLocation(source);

      return {
        get location() {
          return location;
        },

        listen(listener) {
          listeners.push(listener);

          const popstateListener = () => {
            location = getLocation(source);
            listener({ location, action: "POP" });
          };

          source.addEventListener("popstate", popstateListener);

          return () => {
            source.removeEventListener("popstate", popstateListener);

            const index = listeners.indexOf(listener);
            listeners.splice(index, 1);
          };
        },

        navigate(to, { state, replace = false } = {}) {
          state = { ...state, key: Date.now() + "" };
          // try...catch iOS Safari limits to 100 pushState calls
          try {
            if (replace) {
              source.history.replaceState(state, null, to);
            } else {
              source.history.pushState(state, null, to);
            }
          } catch (e) {
            source.location[replace ? "replace" : "assign"](to);
          }

          location = getLocation(source);
          listeners.forEach(listener => listener({ location, action: "PUSH" }));
        }
      };
    }

    // Stores history entries in memory for testing or other platforms like Native
    function createMemorySource(initialPathname = "/") {
      let index = 0;
      const stack = [{ pathname: initialPathname, search: "" }];
      const states = [];

      return {
        get location() {
          return stack[index];
        },
        addEventListener(name, fn) {},
        removeEventListener(name, fn) {},
        history: {
          get entries() {
            return stack;
          },
          get index() {
            return index;
          },
          get state() {
            return states[index];
          },
          pushState(state, _, uri) {
            const [pathname, search = ""] = uri.split("?");
            index++;
            stack.push({ pathname, search });
            states.push(state);
          },
          replaceState(state, _, uri) {
            const [pathname, search = ""] = uri.split("?");
            stack[index] = { pathname, search };
            states[index] = state;
          }
        }
      };
    }

    // Global history uses window.history as the source if available,
    // otherwise a memory history
    const canUseDOM = Boolean(
      typeof window !== "undefined" &&
        window.document &&
        window.document.createElement
    );
    const globalHistory = createHistory(canUseDOM ? window : createMemorySource());
    const { navigate } = globalHistory;

    /**
     * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/utils.js
     *
     * https://github.com/reach/router/blob/master/LICENSE
     * */

    const paramRe = /^:(.+)/;

    const SEGMENT_POINTS = 4;
    const STATIC_POINTS = 3;
    const DYNAMIC_POINTS = 2;
    const SPLAT_PENALTY = 1;
    const ROOT_POINTS = 1;

    /**
     * Check if `string` starts with `search`
     * @param {string} string
     * @param {string} search
     * @return {boolean}
     */
    function startsWith(string, search) {
      return string.substr(0, search.length) === search;
    }

    /**
     * Check if `segment` is a root segment
     * @param {string} segment
     * @return {boolean}
     */
    function isRootSegment(segment) {
      return segment === "";
    }

    /**
     * Check if `segment` is a dynamic segment
     * @param {string} segment
     * @return {boolean}
     */
    function isDynamic(segment) {
      return paramRe.test(segment);
    }

    /**
     * Check if `segment` is a splat
     * @param {string} segment
     * @return {boolean}
     */
    function isSplat(segment) {
      return segment[0] === "*";
    }

    /**
     * Split up the URI into segments delimited by `/`
     * @param {string} uri
     * @return {string[]}
     */
    function segmentize(uri) {
      return (
        uri
          // Strip starting/ending `/`
          .replace(/(^\/+|\/+$)/g, "")
          .split("/")
      );
    }

    /**
     * Strip `str` of potential start and end `/`
     * @param {string} str
     * @return {string}
     */
    function stripSlashes(str) {
      return str.replace(/(^\/+|\/+$)/g, "");
    }

    /**
     * Score a route depending on how its individual segments look
     * @param {object} route
     * @param {number} index
     * @return {object}
     */
    function rankRoute(route, index) {
      const score = route.default
        ? 0
        : segmentize(route.path).reduce((score, segment) => {
            score += SEGMENT_POINTS;

            if (isRootSegment(segment)) {
              score += ROOT_POINTS;
            } else if (isDynamic(segment)) {
              score += DYNAMIC_POINTS;
            } else if (isSplat(segment)) {
              score -= SEGMENT_POINTS + SPLAT_PENALTY;
            } else {
              score += STATIC_POINTS;
            }

            return score;
          }, 0);

      return { route, score, index };
    }

    /**
     * Give a score to all routes and sort them on that
     * @param {object[]} routes
     * @return {object[]}
     */
    function rankRoutes(routes) {
      return (
        routes
          .map(rankRoute)
          // If two routes have the exact same score, we go by index instead
          .sort((a, b) =>
            a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index
          )
      );
    }

    /**
     * Ranks and picks the best route to match. Each segment gets the highest
     * amount of points, then the type of segment gets an additional amount of
     * points where
     *
     *  static > dynamic > splat > root
     *
     * This way we don't have to worry about the order of our routes, let the
     * computers do it.
     *
     * A route looks like this
     *
     *  { path, default, value }
     *
     * And a returned match looks like:
     *
     *  { route, params, uri }
     *
     * @param {object[]} routes
     * @param {string} uri
     * @return {?object}
     */
    function pick(routes, uri) {
      let match;
      let default_;

      const [uriPathname] = uri.split("?");
      const uriSegments = segmentize(uriPathname);
      const isRootUri = uriSegments[0] === "";
      const ranked = rankRoutes(routes);

      for (let i = 0, l = ranked.length; i < l; i++) {
        const route = ranked[i].route;
        let missed = false;

        if (route.default) {
          default_ = {
            route,
            params: {},
            uri
          };
          continue;
        }

        const routeSegments = segmentize(route.path);
        const params = {};
        const max = Math.max(uriSegments.length, routeSegments.length);
        let index = 0;

        for (; index < max; index++) {
          const routeSegment = routeSegments[index];
          const uriSegment = uriSegments[index];

          if (routeSegment !== undefined && isSplat(routeSegment)) {
            // Hit a splat, just grab the rest, and return a match
            // uri:   /files/documents/work
            // route: /files/* or /files/*splatname
            const splatName = routeSegment === "*" ? "*" : routeSegment.slice(1);

            params[splatName] = uriSegments
              .slice(index)
              .map(decodeURIComponent)
              .join("/");
            break;
          }

          if (uriSegment === undefined) {
            // URI is shorter than the route, no match
            // uri:   /users
            // route: /users/:userId
            missed = true;
            break;
          }

          let dynamicMatch = paramRe.exec(routeSegment);

          if (dynamicMatch && !isRootUri) {
            const value = decodeURIComponent(uriSegment);
            params[dynamicMatch[1]] = value;
          } else if (routeSegment !== uriSegment) {
            // Current segments don't match, not dynamic, not splat, so no match
            // uri:   /users/123/settings
            // route: /users/:id/profile
            missed = true;
            break;
          }
        }

        if (!missed) {
          match = {
            route,
            params,
            uri: "/" + uriSegments.slice(0, index).join("/")
          };
          break;
        }
      }

      return match || default_ || null;
    }

    /**
     * Check if the `path` matches the `uri`.
     * @param {string} path
     * @param {string} uri
     * @return {?object}
     */
    function match(route, uri) {
      return pick([route], uri);
    }

    /**
     * Add the query to the pathname if a query is given
     * @param {string} pathname
     * @param {string} [query]
     * @return {string}
     */
    function addQuery(pathname, query) {
      return pathname + (query ? `?${query}` : "");
    }

    /**
     * Resolve URIs as though every path is a directory, no files. Relative URIs
     * in the browser can feel awkward because not only can you be "in a directory",
     * you can be "at a file", too. For example:
     *
     *  browserSpecResolve('foo', '/bar/') => /bar/foo
     *  browserSpecResolve('foo', '/bar') => /foo
     *
     * But on the command line of a file system, it's not as complicated. You can't
     * `cd` from a file, only directories. This way, links have to know less about
     * their current path. To go deeper you can do this:
     *
     *  <Link to="deeper"/>
     *  // instead of
     *  <Link to=`{${props.uri}/deeper}`/>
     *
     * Just like `cd`, if you want to go deeper from the command line, you do this:
     *
     *  cd deeper
     *  # not
     *  cd $(pwd)/deeper
     *
     * By treating every path as a directory, linking to relative paths should
     * require less contextual information and (fingers crossed) be more intuitive.
     * @param {string} to
     * @param {string} base
     * @return {string}
     */
    function resolve(to, base) {
      // /foo/bar, /baz/qux => /foo/bar
      if (startsWith(to, "/")) {
        return to;
      }

      const [toPathname, toQuery] = to.split("?");
      const [basePathname] = base.split("?");
      const toSegments = segmentize(toPathname);
      const baseSegments = segmentize(basePathname);

      // ?a=b, /users?b=c => /users?a=b
      if (toSegments[0] === "") {
        return addQuery(basePathname, toQuery);
      }

      // profile, /users/789 => /users/789/profile
      if (!startsWith(toSegments[0], ".")) {
        const pathname = baseSegments.concat(toSegments).join("/");

        return addQuery((basePathname === "/" ? "" : "/") + pathname, toQuery);
      }

      // ./       , /users/123 => /users/123
      // ../      , /users/123 => /users
      // ../..    , /users/123 => /
      // ../../one, /a/b/c/d   => /a/b/one
      // .././one , /a/b/c/d   => /a/b/c/one
      const allSegments = baseSegments.concat(toSegments);
      const segments = [];

      allSegments.forEach(segment => {
        if (segment === "..") {
          segments.pop();
        } else if (segment !== ".") {
          segments.push(segment);
        }
      });

      return addQuery("/" + segments.join("/"), toQuery);
    }

    /**
     * Combines the `basepath` and the `path` into one path.
     * @param {string} basepath
     * @param {string} path
     */
    function combinePaths(basepath, path) {
      return `${stripSlashes(
    path === "/" ? basepath : `${stripSlashes(basepath)}/${stripSlashes(path)}`
  )}/`;
    }

    /**
     * Decides whether a given `event` should result in a navigation or not.
     * @param {object} event
     */
    function shouldNavigate(event) {
      return (
        !event.defaultPrevented &&
        event.button === 0 &&
        !(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)
      );
    }

    /* node_modules/svelte-routing/src/Router.svelte generated by Svelte v3.15.0 */

    function create_fragment(ctx) {
    	let current;
    	const default_slot_template = ctx.$$slots.default;
    	const default_slot = create_slot(default_slot_template, ctx, null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (default_slot && default_slot.p && changed.$$scope) {
    				default_slot.p(get_slot_changes(default_slot_template, ctx, changed, null), get_slot_context(default_slot_template, ctx, null));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let $base;
    	let $location;
    	let $routes;
    	let { basepath = "/" } = $$props;
    	let { url = null } = $$props;
    	const locationContext = getContext(LOCATION);
    	const routerContext = getContext(ROUTER);
    	const routes = writable([]);
    	validate_store(routes, "routes");
    	component_subscribe($$self, routes, value => $$invalidate("$routes", $routes = value));
    	const activeRoute = writable(null);
    	let hasActiveRoute = false;
    	const location = locationContext || writable(url ? { pathname: url } : globalHistory.location);
    	validate_store(location, "location");
    	component_subscribe($$self, location, value => $$invalidate("$location", $location = value));

    	const base = routerContext
    	? routerContext.routerBase
    	: writable({ path: basepath, uri: basepath });

    	validate_store(base, "base");
    	component_subscribe($$self, base, value => $$invalidate("$base", $base = value));

    	const routerBase = derived([base, activeRoute], ([base, activeRoute]) => {
    		if (activeRoute === null) {
    			return base;
    		}

    		const { path: basepath } = base;
    		const { route, uri } = activeRoute;

    		const path = route.default
    		? basepath
    		: route.path.replace(/\*.*$/, "");

    		return { path, uri };
    	});

    	function registerRoute(route) {
    		const { path: basepath } = $base;
    		let { path } = route;
    		route._path = path;
    		route.path = combinePaths(basepath, path);

    		if (typeof window === "undefined") {
    			if (hasActiveRoute) {
    				return;
    			}

    			const matchingRoute = match(route, $location.pathname);

    			if (matchingRoute) {
    				activeRoute.set(matchingRoute);
    				hasActiveRoute = true;
    			}
    		} else {
    			routes.update(rs => {
    				rs.push(route);
    				return rs;
    			});
    		}
    	}

    	function unregisterRoute(route) {
    		routes.update(rs => {
    			const index = rs.indexOf(route);
    			rs.splice(index, 1);
    			return rs;
    		});
    	}

    	if (!locationContext) {
    		onMount(() => {
    			const unlisten = globalHistory.listen(history => {
    				location.set(history.location);
    			});

    			return unlisten;
    		});

    		setContext(LOCATION, location);
    	}

    	setContext(ROUTER, {
    		activeRoute,
    		base,
    		routerBase,
    		registerRoute,
    		unregisterRoute
    	});

    	const writable_props = ["basepath", "url"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;

    	$$self.$set = $$props => {
    		if ("basepath" in $$props) $$invalidate("basepath", basepath = $$props.basepath);
    		if ("url" in $$props) $$invalidate("url", url = $$props.url);
    		if ("$$scope" in $$props) $$invalidate("$$scope", $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return {
    			basepath,
    			url,
    			hasActiveRoute,
    			$base,
    			$location,
    			$routes
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("basepath" in $$props) $$invalidate("basepath", basepath = $$props.basepath);
    		if ("url" in $$props) $$invalidate("url", url = $$props.url);
    		if ("hasActiveRoute" in $$props) hasActiveRoute = $$props.hasActiveRoute;
    		if ("$base" in $$props) base.set($base = $$props.$base);
    		if ("$location" in $$props) location.set($location = $$props.$location);
    		if ("$routes" in $$props) routes.set($routes = $$props.$routes);
    	};

    	$$self.$$.update = (changed = { $base: 1, $routes: 1, $location: 1 }) => {
    		if (changed.$base) {
    			 {
    				const { path: basepath } = $base;

    				routes.update(rs => {
    					rs.forEach(r => r.path = combinePaths(basepath, r._path));
    					return rs;
    				});
    			}
    		}

    		if (changed.$routes || changed.$location) {
    			 {
    				const bestMatch = pick($routes, $location.pathname);
    				activeRoute.set(bestMatch);
    			}
    		}
    	};

    	return {
    		basepath,
    		url,
    		routes,
    		location,
    		base,
    		$$slots,
    		$$scope
    	};
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, { basepath: 0, url: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment.name
    		});
    	}

    	get basepath() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set basepath(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get url() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-routing/src/Route.svelte generated by Svelte v3.15.0 */
    const get_default_slot_changes = ({ routeParams, $location }) => ({ params: routeParams, location: $location });
    const get_default_slot_context = ({ routeParams, $location }) => ({ params: routeParams, location: $location });

    // (40:0) {#if $activeRoute !== null && $activeRoute.route === route}
    function create_if_block(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1, create_else_block];
    	const if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (ctx.component !== null) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(null, ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(changed, ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(40:0) {#if $activeRoute !== null && $activeRoute.route === route}",
    		ctx
    	});

    	return block;
    }

    // (43:2) {:else}
    function create_else_block(ctx) {
    	let current;
    	const default_slot_template = ctx.$$slots.default;
    	const default_slot = create_slot(default_slot_template, ctx, get_default_slot_context);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (default_slot && default_slot.p && (changed.$$scope || changed.routeParams || changed.$location)) {
    				default_slot.p(get_slot_changes(default_slot_template, ctx, changed, get_default_slot_changes), get_slot_context(default_slot_template, ctx, get_default_slot_context));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(43:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (41:2) {#if component !== null}
    function create_if_block_1(ctx) {
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [{ location: ctx.$location }, ctx.routeParams, ctx.routeProps];
    	var switch_value = ctx.component;

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		var switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const switch_instance_changes = changed.$location || changed.routeParams || changed.routeProps
    			? get_spread_update(switch_instance_spread_levels, [
    					changed.$location && ({ location: ctx.$location }),
    					changed.routeParams && get_spread_object(ctx.routeParams),
    					changed.routeProps && get_spread_object(ctx.routeProps)
    				])
    			: {};

    			if (switch_value !== (switch_value = ctx.component)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(41:2) {#if component !== null}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = ctx.$activeRoute !== null && ctx.$activeRoute.route === ctx.route && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (ctx.$activeRoute !== null && ctx.$activeRoute.route === ctx.route) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $activeRoute;
    	let $location;
    	let { path = "" } = $$props;
    	let { component = null } = $$props;
    	const { registerRoute, unregisterRoute, activeRoute } = getContext(ROUTER);
    	validate_store(activeRoute, "activeRoute");
    	component_subscribe($$self, activeRoute, value => $$invalidate("$activeRoute", $activeRoute = value));
    	const location = getContext(LOCATION);
    	validate_store(location, "location");
    	component_subscribe($$self, location, value => $$invalidate("$location", $location = value));
    	const route = { path, default: path === "" };
    	let routeParams = {};
    	let routeProps = {};
    	registerRoute(route);

    	if (typeof window !== "undefined") {
    		onDestroy(() => {
    			unregisterRoute(route);
    		});
    	}

    	let { $$slots = {}, $$scope } = $$props;

    	$$self.$set = $$new_props => {
    		$$invalidate("$$props", $$props = assign(assign({}, $$props), $$new_props));
    		if ("path" in $$new_props) $$invalidate("path", path = $$new_props.path);
    		if ("component" in $$new_props) $$invalidate("component", component = $$new_props.component);
    		if ("$$scope" in $$new_props) $$invalidate("$$scope", $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return {
    			path,
    			component,
    			routeParams,
    			routeProps,
    			$activeRoute,
    			$location
    		};
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate("$$props", $$props = assign(assign({}, $$props), $$new_props));
    		if ("path" in $$props) $$invalidate("path", path = $$new_props.path);
    		if ("component" in $$props) $$invalidate("component", component = $$new_props.component);
    		if ("routeParams" in $$props) $$invalidate("routeParams", routeParams = $$new_props.routeParams);
    		if ("routeProps" in $$props) $$invalidate("routeProps", routeProps = $$new_props.routeProps);
    		if ("$activeRoute" in $$props) activeRoute.set($activeRoute = $$new_props.$activeRoute);
    		if ("$location" in $$props) location.set($location = $$new_props.$location);
    	};

    	$$self.$$.update = (changed = { $activeRoute: 1, $$props: 1 }) => {
    		if (changed.$activeRoute) {
    			 if ($activeRoute && $activeRoute.route === route) {
    				$$invalidate("routeParams", routeParams = $activeRoute.params);
    			}
    		}

    		 {
    			const { path, component, ...rest } = $$props;
    			$$invalidate("routeProps", routeProps = rest);
    		}
    	};

    	return {
    		path,
    		component,
    		activeRoute,
    		location,
    		route,
    		routeParams,
    		routeProps,
    		$activeRoute,
    		$location,
    		$$props: $$props = exclude_internal_props($$props),
    		$$slots,
    		$$scope
    	};
    }

    class Route extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, { path: 0, component: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Route",
    			options,
    			id: create_fragment$1.name
    		});
    	}

    	get path() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set path(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get component() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set component(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-routing/src/Link.svelte generated by Svelte v3.15.0 */
    const file = "node_modules/svelte-routing/src/Link.svelte";

    function create_fragment$2(ctx) {
    	let a;
    	let current;
    	let dispose;
    	const default_slot_template = ctx.$$slots.default;
    	const default_slot = create_slot(default_slot_template, ctx, null);
    	let a_levels = [{ href: ctx.href }, { "aria-current": ctx.ariaCurrent }, ctx.props];
    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			set_attributes(a, a_data);
    			add_location(a, file, 40, 0, 1249);
    			dispose = listen_dev(a, "click", ctx.onClick, false, false, false);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (default_slot && default_slot.p && changed.$$scope) {
    				default_slot.p(get_slot_changes(default_slot_template, ctx, changed, null), get_slot_context(default_slot_template, ctx, null));
    			}

    			set_attributes(a, get_spread_update(a_levels, [
    				changed.href && ({ href: ctx.href }),
    				changed.ariaCurrent && ({ "aria-current": ctx.ariaCurrent }),
    				changed.props && ctx.props
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let $base;
    	let $location;
    	let { to = "#" } = $$props;
    	let { replace = false } = $$props;
    	let { state = {} } = $$props;
    	let { getProps = () => ({}) } = $$props;
    	const { base } = getContext(ROUTER);
    	validate_store(base, "base");
    	component_subscribe($$self, base, value => $$invalidate("$base", $base = value));
    	const location = getContext(LOCATION);
    	validate_store(location, "location");
    	component_subscribe($$self, location, value => $$invalidate("$location", $location = value));
    	const dispatch = createEventDispatcher();
    	let href, isPartiallyCurrent, isCurrent, props;

    	function onClick(event) {
    		dispatch("click", event);

    		if (shouldNavigate(event)) {
    			event.preventDefault();
    			const shouldReplace = $location.pathname === href || replace;
    			navigate(href, { state, replace: shouldReplace });
    		}
    	}

    	const writable_props = ["to", "replace", "state", "getProps"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Link> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;

    	$$self.$set = $$props => {
    		if ("to" in $$props) $$invalidate("to", to = $$props.to);
    		if ("replace" in $$props) $$invalidate("replace", replace = $$props.replace);
    		if ("state" in $$props) $$invalidate("state", state = $$props.state);
    		if ("getProps" in $$props) $$invalidate("getProps", getProps = $$props.getProps);
    		if ("$$scope" in $$props) $$invalidate("$$scope", $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return {
    			to,
    			replace,
    			state,
    			getProps,
    			href,
    			isPartiallyCurrent,
    			isCurrent,
    			props,
    			$base,
    			$location,
    			ariaCurrent
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("to" in $$props) $$invalidate("to", to = $$props.to);
    		if ("replace" in $$props) $$invalidate("replace", replace = $$props.replace);
    		if ("state" in $$props) $$invalidate("state", state = $$props.state);
    		if ("getProps" in $$props) $$invalidate("getProps", getProps = $$props.getProps);
    		if ("href" in $$props) $$invalidate("href", href = $$props.href);
    		if ("isPartiallyCurrent" in $$props) $$invalidate("isPartiallyCurrent", isPartiallyCurrent = $$props.isPartiallyCurrent);
    		if ("isCurrent" in $$props) $$invalidate("isCurrent", isCurrent = $$props.isCurrent);
    		if ("props" in $$props) $$invalidate("props", props = $$props.props);
    		if ("$base" in $$props) base.set($base = $$props.$base);
    		if ("$location" in $$props) location.set($location = $$props.$location);
    		if ("ariaCurrent" in $$props) $$invalidate("ariaCurrent", ariaCurrent = $$props.ariaCurrent);
    	};

    	let ariaCurrent;

    	$$self.$$.update = (changed = { to: 1, $base: 1, $location: 1, href: 1, isCurrent: 1, getProps: 1, isPartiallyCurrent: 1 }) => {
    		if (changed.to || changed.$base) {
    			 $$invalidate("href", href = to === "/" ? $base.uri : resolve(to, $base.uri));
    		}

    		if (changed.$location || changed.href) {
    			 $$invalidate("isPartiallyCurrent", isPartiallyCurrent = startsWith($location.pathname, href));
    		}

    		if (changed.href || changed.$location) {
    			 $$invalidate("isCurrent", isCurrent = href === $location.pathname);
    		}

    		if (changed.isCurrent) {
    			 $$invalidate("ariaCurrent", ariaCurrent = isCurrent ? "page" : undefined);
    		}

    		if (changed.getProps || changed.$location || changed.href || changed.isPartiallyCurrent || changed.isCurrent) {
    			 $$invalidate("props", props = getProps({
    				location: $location,
    				href,
    				isPartiallyCurrent,
    				isCurrent
    			}));
    		}
    	};

    	return {
    		to,
    		replace,
    		state,
    		getProps,
    		base,
    		location,
    		href,
    		props,
    		onClick,
    		ariaCurrent,
    		$$slots,
    		$$scope
    	};
    }

    class Link extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, { to: 0, replace: 0, state: 0, getProps: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Link",
    			options,
    			id: create_fragment$2.name
    		});
    	}

    	get to() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set to(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get replace() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set replace(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get state() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set state(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getProps() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getProps(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function bisector(compare) {
      if (compare.length === 1) compare = ascendingComparator(compare);
      return {
        left: function(a, x, lo, hi) {
          if (lo == null) lo = 0;
          if (hi == null) hi = a.length;
          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (compare(a[mid], x) < 0) lo = mid + 1;
            else hi = mid;
          }
          return lo;
        },
        right: function(a, x, lo, hi) {
          if (lo == null) lo = 0;
          if (hi == null) hi = a.length;
          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (compare(a[mid], x) > 0) hi = mid;
            else lo = mid + 1;
          }
          return lo;
        }
      };
    }

    function ascendingComparator(f) {
      return function(d, x) {
        return ascending(f(d), x);
      };
    }

    var ascendingBisect = bisector(ascending);
    var bisectRight = ascendingBisect.right;

    function sequence(start, stop, step) {
      start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

      var i = -1,
          n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
          range = new Array(n);

      while (++i < n) {
        range[i] = start + i * step;
      }

      return range;
    }

    var e10 = Math.sqrt(50),
        e5 = Math.sqrt(10),
        e2 = Math.sqrt(2);

    function ticks(start, stop, count) {
      var reverse,
          i = -1,
          n,
          ticks,
          step;

      stop = +stop, start = +start, count = +count;
      if (start === stop && count > 0) return [start];
      if (reverse = stop < start) n = start, start = stop, stop = n;
      if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

      if (step > 0) {
        start = Math.ceil(start / step);
        stop = Math.floor(stop / step);
        ticks = new Array(n = Math.ceil(stop - start + 1));
        while (++i < n) ticks[i] = (start + i) * step;
      } else {
        start = Math.floor(start * step);
        stop = Math.ceil(stop * step);
        ticks = new Array(n = Math.ceil(start - stop + 1));
        while (++i < n) ticks[i] = (start - i) / step;
      }

      if (reverse) ticks.reverse();

      return ticks;
    }

    function tickIncrement(start, stop, count) {
      var step = (stop - start) / Math.max(0, count),
          power = Math.floor(Math.log(step) / Math.LN10),
          error = step / Math.pow(10, power);
      return power >= 0
          ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
          : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
    }

    function tickStep(start, stop, count) {
      var step0 = Math.abs(stop - start) / Math.max(0, count),
          step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
          error = step0 / step1;
      if (error >= e10) step1 *= 10;
      else if (error >= e5) step1 *= 5;
      else if (error >= e2) step1 *= 2;
      return stop < start ? -step1 : step1;
    }

    function initRange(domain, range) {
      switch (arguments.length) {
        case 0: break;
        case 1: this.range(domain); break;
        default: this.range(range).domain(domain); break;
      }
      return this;
    }

    function initInterpolator(domain, interpolator) {
      switch (arguments.length) {
        case 0: break;
        case 1: {
          if (typeof domain === "function") this.interpolator(domain);
          else this.range(domain);
          break;
        }
        default: {
          this.domain(domain);
          if (typeof interpolator === "function") this.interpolator(interpolator);
          else this.range(interpolator);
          break;
        }
      }
      return this;
    }

    const implicit = Symbol("implicit");

    function ordinal() {
      var index = new Map(),
          domain = [],
          range = [],
          unknown = implicit;

      function scale(d) {
        var key = d + "", i = index.get(key);
        if (!i) {
          if (unknown !== implicit) return unknown;
          index.set(key, i = domain.push(d));
        }
        return range[(i - 1) % range.length];
      }

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [], index = new Map();
        for (const value of _) {
          const key = value + "";
          if (index.has(key)) continue;
          index.set(key, domain.push(value));
        }
        return scale;
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), scale) : range.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return ordinal(domain, range).unknown(unknown);
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function band() {
      var scale = ordinal().unknown(undefined),
          domain = scale.domain,
          ordinalRange = scale.range,
          r0 = 0,
          r1 = 1,
          step,
          bandwidth,
          round = false,
          paddingInner = 0,
          paddingOuter = 0,
          align = 0.5;

      delete scale.unknown;

      function rescale() {
        var n = domain().length,
            reverse = r1 < r0,
            start = reverse ? r1 : r0,
            stop = reverse ? r0 : r1;
        step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
        if (round) step = Math.floor(step);
        start += (stop - start - step * (n - paddingInner)) * align;
        bandwidth = step * (1 - paddingInner);
        if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
        var values = sequence(n).map(function(i) { return start + step * i; });
        return ordinalRange(reverse ? values.reverse() : values);
      }

      scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };

      scale.range = function(_) {
        return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
      };

      scale.rangeRound = function(_) {
        return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
      };

      scale.bandwidth = function() {
        return bandwidth;
      };

      scale.step = function() {
        return step;
      };

      scale.round = function(_) {
        return arguments.length ? (round = !!_, rescale()) : round;
      };

      scale.padding = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
      };

      scale.paddingInner = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
      };

      scale.paddingOuter = function(_) {
        return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
      };

      scale.align = function(_) {
        return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
      };

      scale.copy = function() {
        return band(domain(), [r0, r1])
            .round(round)
            .paddingInner(paddingInner)
            .paddingOuter(paddingOuter)
            .align(align);
      };

      return initRange.apply(rescale(), arguments);
    }

    function pointish(scale) {
      var copy = scale.copy;

      scale.padding = scale.paddingOuter;
      delete scale.paddingInner;
      delete scale.paddingOuter;

      scale.copy = function() {
        return pointish(copy());
      };

      return scale;
    }

    function point() {
      return pointish(band.apply(null, arguments).paddingInner(1));
    }

    function define(constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }

    function extend(parent, definition) {
      var prototype = Object.create(parent.prototype);
      for (var key in definition) prototype[key] = definition[key];
      return prototype;
    }

    function Color() {}

    var darker = 0.7;
    var brighter = 1 / darker;

    var reI = "\\s*([+-]?\\d+)\\s*",
        reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
        reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
        reHex3 = /^#([0-9a-f]{3})$/,
        reHex6 = /^#([0-9a-f]{6})$/,
        reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
        reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
        reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
        reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
        reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
        reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

    var named = {
      aliceblue: 0xf0f8ff,
      antiquewhite: 0xfaebd7,
      aqua: 0x00ffff,
      aquamarine: 0x7fffd4,
      azure: 0xf0ffff,
      beige: 0xf5f5dc,
      bisque: 0xffe4c4,
      black: 0x000000,
      blanchedalmond: 0xffebcd,
      blue: 0x0000ff,
      blueviolet: 0x8a2be2,
      brown: 0xa52a2a,
      burlywood: 0xdeb887,
      cadetblue: 0x5f9ea0,
      chartreuse: 0x7fff00,
      chocolate: 0xd2691e,
      coral: 0xff7f50,
      cornflowerblue: 0x6495ed,
      cornsilk: 0xfff8dc,
      crimson: 0xdc143c,
      cyan: 0x00ffff,
      darkblue: 0x00008b,
      darkcyan: 0x008b8b,
      darkgoldenrod: 0xb8860b,
      darkgray: 0xa9a9a9,
      darkgreen: 0x006400,
      darkgrey: 0xa9a9a9,
      darkkhaki: 0xbdb76b,
      darkmagenta: 0x8b008b,
      darkolivegreen: 0x556b2f,
      darkorange: 0xff8c00,
      darkorchid: 0x9932cc,
      darkred: 0x8b0000,
      darksalmon: 0xe9967a,
      darkseagreen: 0x8fbc8f,
      darkslateblue: 0x483d8b,
      darkslategray: 0x2f4f4f,
      darkslategrey: 0x2f4f4f,
      darkturquoise: 0x00ced1,
      darkviolet: 0x9400d3,
      deeppink: 0xff1493,
      deepskyblue: 0x00bfff,
      dimgray: 0x696969,
      dimgrey: 0x696969,
      dodgerblue: 0x1e90ff,
      firebrick: 0xb22222,
      floralwhite: 0xfffaf0,
      forestgreen: 0x228b22,
      fuchsia: 0xff00ff,
      gainsboro: 0xdcdcdc,
      ghostwhite: 0xf8f8ff,
      gold: 0xffd700,
      goldenrod: 0xdaa520,
      gray: 0x808080,
      green: 0x008000,
      greenyellow: 0xadff2f,
      grey: 0x808080,
      honeydew: 0xf0fff0,
      hotpink: 0xff69b4,
      indianred: 0xcd5c5c,
      indigo: 0x4b0082,
      ivory: 0xfffff0,
      khaki: 0xf0e68c,
      lavender: 0xe6e6fa,
      lavenderblush: 0xfff0f5,
      lawngreen: 0x7cfc00,
      lemonchiffon: 0xfffacd,
      lightblue: 0xadd8e6,
      lightcoral: 0xf08080,
      lightcyan: 0xe0ffff,
      lightgoldenrodyellow: 0xfafad2,
      lightgray: 0xd3d3d3,
      lightgreen: 0x90ee90,
      lightgrey: 0xd3d3d3,
      lightpink: 0xffb6c1,
      lightsalmon: 0xffa07a,
      lightseagreen: 0x20b2aa,
      lightskyblue: 0x87cefa,
      lightslategray: 0x778899,
      lightslategrey: 0x778899,
      lightsteelblue: 0xb0c4de,
      lightyellow: 0xffffe0,
      lime: 0x00ff00,
      limegreen: 0x32cd32,
      linen: 0xfaf0e6,
      magenta: 0xff00ff,
      maroon: 0x800000,
      mediumaquamarine: 0x66cdaa,
      mediumblue: 0x0000cd,
      mediumorchid: 0xba55d3,
      mediumpurple: 0x9370db,
      mediumseagreen: 0x3cb371,
      mediumslateblue: 0x7b68ee,
      mediumspringgreen: 0x00fa9a,
      mediumturquoise: 0x48d1cc,
      mediumvioletred: 0xc71585,
      midnightblue: 0x191970,
      mintcream: 0xf5fffa,
      mistyrose: 0xffe4e1,
      moccasin: 0xffe4b5,
      navajowhite: 0xffdead,
      navy: 0x000080,
      oldlace: 0xfdf5e6,
      olive: 0x808000,
      olivedrab: 0x6b8e23,
      orange: 0xffa500,
      orangered: 0xff4500,
      orchid: 0xda70d6,
      palegoldenrod: 0xeee8aa,
      palegreen: 0x98fb98,
      paleturquoise: 0xafeeee,
      palevioletred: 0xdb7093,
      papayawhip: 0xffefd5,
      peachpuff: 0xffdab9,
      peru: 0xcd853f,
      pink: 0xffc0cb,
      plum: 0xdda0dd,
      powderblue: 0xb0e0e6,
      purple: 0x800080,
      rebeccapurple: 0x663399,
      red: 0xff0000,
      rosybrown: 0xbc8f8f,
      royalblue: 0x4169e1,
      saddlebrown: 0x8b4513,
      salmon: 0xfa8072,
      sandybrown: 0xf4a460,
      seagreen: 0x2e8b57,
      seashell: 0xfff5ee,
      sienna: 0xa0522d,
      silver: 0xc0c0c0,
      skyblue: 0x87ceeb,
      slateblue: 0x6a5acd,
      slategray: 0x708090,
      slategrey: 0x708090,
      snow: 0xfffafa,
      springgreen: 0x00ff7f,
      steelblue: 0x4682b4,
      tan: 0xd2b48c,
      teal: 0x008080,
      thistle: 0xd8bfd8,
      tomato: 0xff6347,
      turquoise: 0x40e0d0,
      violet: 0xee82ee,
      wheat: 0xf5deb3,
      white: 0xffffff,
      whitesmoke: 0xf5f5f5,
      yellow: 0xffff00,
      yellowgreen: 0x9acd32
    };

    define(Color, color, {
      copy: function(channels) {
        return Object.assign(new this.constructor, this, channels);
      },
      displayable: function() {
        return this.rgb().displayable();
      },
      hex: color_formatHex, // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });

    function color_formatHex() {
      return this.rgb().formatHex();
    }

    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }

    function color_formatRgb() {
      return this.rgb().formatRgb();
    }

    function color(format) {
      var m;
      format = (format + "").trim().toLowerCase();
      return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
          : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
          : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
          : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
          : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
          : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
          : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
          : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
          : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
          : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
          : null;
    }

    function rgbn(n) {
      return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }

    function rgba(r, g, b, a) {
      if (a <= 0) r = g = b = NaN;
      return new Rgb(r, g, b, a);
    }

    function rgbConvert(o) {
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Rgb;
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }

    function rgb(r, g, b, opacity) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }

    function Rgb(r, g, b, opacity) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Rgb, rgb, extend(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb: function() {
        return this;
      },
      displayable: function() {
        return (-0.5 <= this.r && this.r < 255.5)
            && (-0.5 <= this.g && this.g < 255.5)
            && (-0.5 <= this.b && this.b < 255.5)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex, // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));

    function rgb_formatHex() {
      return "#" + hex(this.r) + hex(this.g) + hex(this.b);
    }

    function rgb_formatRgb() {
      var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "rgb(" : "rgba(")
          + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
          + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
          + Math.max(0, Math.min(255, Math.round(this.b) || 0))
          + (a === 1 ? ")" : ", " + a + ")");
    }

    function hex(value) {
      value = Math.max(0, Math.min(255, Math.round(value) || 0));
      return (value < 16 ? "0" : "") + value.toString(16);
    }

    function hsla(h, s, l, a) {
      if (a <= 0) h = s = l = NaN;
      else if (l <= 0 || l >= 1) h = s = NaN;
      else if (s <= 0) h = NaN;
      return new Hsl(h, s, l, a);
    }

    function hslConvert(o) {
      if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Hsl;
      if (o instanceof Hsl) return o;
      o = o.rgb();
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          h = NaN,
          s = max - min,
          l = (max + min) / 2;
      if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;
        else if (g === max) h = (b - r) / s + 2;
        else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h;
      }
      return new Hsl(h, s, l, o.opacity);
    }

    function hsl(h, s, l, opacity) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }

    function Hsl(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Hsl, hsl, extend(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function() {
        var h = this.h % 360 + (this.h < 0) * 360,
            s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
            l = this.l,
            m2 = l + (l < 0.5 ? l : 1 - l) * s,
            m1 = 2 * l - m2;
        return new Rgb(
          hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
          hsl2rgb(h, m1, m2),
          hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
          this.opacity
        );
      },
      displayable: function() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s))
            && (0 <= this.l && this.l <= 1)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl: function() {
        var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "hsl(" : "hsla(")
            + (this.h || 0) + ", "
            + (this.s || 0) * 100 + "%, "
            + (this.l || 0) * 100 + "%"
            + (a === 1 ? ")" : ", " + a + ")");
      }
    }));

    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60
          : h < 180 ? m2
          : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
          : m1) * 255;
    }

    var deg2rad = Math.PI / 180;
    var rad2deg = 180 / Math.PI;

    // https://observablehq.com/@mbostock/lab-and-rgb
    var K = 18,
        Xn = 0.96422,
        Yn = 1,
        Zn = 0.82521,
        t0 = 4 / 29,
        t1 = 6 / 29,
        t2 = 3 * t1 * t1,
        t3 = t1 * t1 * t1;

    function labConvert(o) {
      if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
      if (o instanceof Hcl) return hcl2lab(o);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = rgb2lrgb(o.r),
          g = rgb2lrgb(o.g),
          b = rgb2lrgb(o.b),
          y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
      if (r === g && g === b) x = z = y; else {
        x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
        z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
      }
      return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
    }

    function lab(l, a, b, opacity) {
      return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
    }

    function Lab(l, a, b, opacity) {
      this.l = +l;
      this.a = +a;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Lab, lab, extend(Color, {
      brighter: function(k) {
        return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      darker: function(k) {
        return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      rgb: function() {
        var y = (this.l + 16) / 116,
            x = isNaN(this.a) ? y : y + this.a / 500,
            z = isNaN(this.b) ? y : y - this.b / 200;
        x = Xn * lab2xyz(x);
        y = Yn * lab2xyz(y);
        z = Zn * lab2xyz(z);
        return new Rgb(
          lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
          lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
          lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
          this.opacity
        );
      }
    }));

    function xyz2lab(t) {
      return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
    }

    function lab2xyz(t) {
      return t > t1 ? t * t * t : t2 * (t - t0);
    }

    function lrgb2rgb(x) {
      return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
    }

    function rgb2lrgb(x) {
      return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    }

    function hclConvert(o) {
      if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
      if (!(o instanceof Lab)) o = labConvert(o);
      if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
      var h = Math.atan2(o.b, o.a) * rad2deg;
      return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
    }

    function hcl(h, c, l, opacity) {
      return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }

    function Hcl(h, c, l, opacity) {
      this.h = +h;
      this.c = +c;
      this.l = +l;
      this.opacity = +opacity;
    }

    function hcl2lab(o) {
      if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
      var h = o.h * deg2rad;
      return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
    }

    define(Hcl, hcl, extend(Color, {
      brighter: function(k) {
        return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
      },
      darker: function(k) {
        return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
      },
      rgb: function() {
        return hcl2lab(this).rgb();
      }
    }));

    var A = -0.14861,
        B = +1.78277,
        C = -0.29227,
        D = -0.90649,
        E = +1.97294,
        ED = E * D,
        EB = E * B,
        BC_DA = B * C - D * A;

    function cubehelixConvert(o) {
      if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
          bl = b - l,
          k = (E * (g - l) - C * bl) / D,
          s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
          h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
      return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
    }

    function cubehelix(h, s, l, opacity) {
      return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
    }

    function Cubehelix(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Cubehelix, cubehelix, extend(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function() {
        var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
            l = +this.l,
            a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
            cosh = Math.cos(h),
            sinh = Math.sin(h);
        return new Rgb(
          255 * (l + a * (A * cosh + B * sinh)),
          255 * (l + a * (C * cosh + D * sinh)),
          255 * (l + a * (E * cosh)),
          this.opacity
        );
      }
    }));

    function constant(x) {
      return function() {
        return x;
      };
    }

    function linear(a, d) {
      return function(t) {
        return a + t * d;
      };
    }

    function exponential(a, b, y) {
      return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
        return Math.pow(a + t * b, y);
      };
    }

    function gamma(y) {
      return (y = +y) === 1 ? nogamma : function(a, b) {
        return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
      };
    }

    function nogamma(a, b) {
      var d = b - a;
      return d ? linear(a, d) : constant(isNaN(a) ? b : a);
    }

    var rgb$1 = (function rgbGamma(y) {
      var color = gamma(y);

      function rgb$1(start, end) {
        var r = color((start = rgb(start)).r, (end = rgb(end)).r),
            g = color(start.g, end.g),
            b = color(start.b, end.b),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.r = r(t);
          start.g = g(t);
          start.b = b(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }

      rgb$1.gamma = rgbGamma;

      return rgb$1;
    })(1);

    function numberArray(a, b) {
      if (!b) b = [];
      var n = a ? Math.min(b.length, a.length) : 0,
          c = b.slice(),
          i;
      return function(t) {
        for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
        return c;
      };
    }

    function isNumberArray(x) {
      return ArrayBuffer.isView(x) && !(x instanceof DataView);
    }

    function interpolateArray(a, b) {
      return (isNumberArray(b) ? numberArray : genericArray)(a, b);
    }

    function genericArray(a, b) {
      var nb = b ? b.length : 0,
          na = a ? Math.min(nb, a.length) : 0,
          x = new Array(na),
          c = new Array(nb),
          i;

      for (i = 0; i < na; ++i) x[i] = interpolate(a[i], b[i]);
      for (; i < nb; ++i) c[i] = b[i];

      return function(t) {
        for (i = 0; i < na; ++i) c[i] = x[i](t);
        return c;
      };
    }

    function date(a, b) {
      var d = new Date;
      return a = +a, b = +b, function(t) {
        return d.setTime(a * (1 - t) + b * t), d;
      };
    }

    function interpolateNumber(a, b) {
      return a = +a, b = +b, function(t) {
        return a * (1 - t) + b * t;
      };
    }

    function object(a, b) {
      var i = {},
          c = {},
          k;

      if (a === null || typeof a !== "object") a = {};
      if (b === null || typeof b !== "object") b = {};

      for (k in b) {
        if (k in a) {
          i[k] = interpolate(a[k], b[k]);
        } else {
          c[k] = b[k];
        }
      }

      return function(t) {
        for (k in i) c[k] = i[k](t);
        return c;
      };
    }

    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
        reB = new RegExp(reA.source, "g");

    function zero(b) {
      return function() {
        return b;
      };
    }

    function one(b) {
      return function(t) {
        return b(t) + "";
      };
    }

    function string(a, b) {
      var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
          am, // current match in a
          bm, // current match in b
          bs, // string preceding current number in b, if any
          i = -1, // index in s
          s = [], // string constants and placeholders
          q = []; // number interpolators

      // Coerce inputs to strings.
      a = a + "", b = b + "";

      // Interpolate pairs of numbers in a & b.
      while ((am = reA.exec(a))
          && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) { // a string precedes the next number in b
          bs = b.slice(bi, bs);
          if (s[i]) s[i] += bs; // coalesce with previous string
          else s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
          if (s[i]) s[i] += bm; // coalesce with previous string
          else s[++i] = bm;
        } else { // interpolate non-matching numbers
          s[++i] = null;
          q.push({i: i, x: interpolateNumber(am, bm)});
        }
        bi = reB.lastIndex;
      }

      // Add remains of b.
      if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }

      // Special optimization for only a single match.
      // Otherwise, interpolate each of the numbers and rejoin the string.
      return s.length < 2 ? (q[0]
          ? one(q[0].x)
          : zero(b))
          : (b = q.length, function(t) {
              for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
              return s.join("");
            });
    }

    function interpolate(a, b) {
      var t = typeof b, c;
      return b == null || t === "boolean" ? constant(b)
          : (t === "number" ? interpolateNumber
          : t === "string" ? ((c = color(b)) ? (b = c, rgb$1) : string)
          : b instanceof color ? rgb$1
          : b instanceof Date ? date
          : isNumberArray(b) ? numberArray
          : Array.isArray(b) ? genericArray
          : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
          : interpolateNumber)(a, b);
    }

    function interpolateRound(a, b) {
      return a = +a, b = +b, function(t) {
        return Math.round(a * (1 - t) + b * t);
      };
    }

    function constant$1(x) {
      return function() {
        return x;
      };
    }

    function number(x) {
      return +x;
    }

    var unit = [0, 1];

    function identity$1(x) {
      return x;
    }

    function normalize(a, b) {
      return (b -= (a = +a))
          ? function(x) { return (x - a) / b; }
          : constant$1(isNaN(b) ? NaN : 0.5);
    }

    function clamper(a, b) {
      var t;
      if (a > b) t = a, a = b, b = t;
      return function(x) { return Math.max(a, Math.min(b, x)); };
    }

    // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
    // interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
    function bimap(domain, range, interpolate) {
      var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
      if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
      else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
      return function(x) { return r0(d0(x)); };
    }

    function polymap(domain, range, interpolate) {
      var j = Math.min(domain.length, range.length) - 1,
          d = new Array(j),
          r = new Array(j),
          i = -1;

      // Reverse descending domains.
      if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range = range.slice().reverse();
      }

      while (++i < j) {
        d[i] = normalize(domain[i], domain[i + 1]);
        r[i] = interpolate(range[i], range[i + 1]);
      }

      return function(x) {
        var i = bisectRight(domain, x, 1, j) - 1;
        return r[i](d[i](x));
      };
    }

    function copy(source, target) {
      return target
          .domain(source.domain())
          .range(source.range())
          .interpolate(source.interpolate())
          .clamp(source.clamp())
          .unknown(source.unknown());
    }

    function transformer() {
      var domain = unit,
          range = unit,
          interpolate$1 = interpolate,
          transform,
          untransform,
          unknown,
          clamp = identity$1,
          piecewise,
          output,
          input;

      function rescale() {
        var n = Math.min(domain.length, range.length);
        if (clamp !== identity$1) clamp = clamper(domain[0], domain[n - 1]);
        piecewise = n > 2 ? polymap : bimap;
        output = input = null;
        return scale;
      }

      function scale(x) {
        return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate$1)))(transform(clamp(x)));
      }

      scale.invert = function(y) {
        return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
      };

      scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_, number), rescale()) : domain.slice();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
      };

      scale.rangeRound = function(_) {
        return range = Array.from(_), interpolate$1 = interpolateRound, rescale();
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = _ ? true : identity$1, rescale()) : clamp !== identity$1;
      };

      scale.interpolate = function(_) {
        return arguments.length ? (interpolate$1 = _, rescale()) : interpolate$1;
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t, u) {
        transform = t, untransform = u;
        return rescale();
      };
    }

    function continuous() {
      return transformer()(identity$1, identity$1);
    }

    // Computes the decimal coefficient and exponent of the specified number x with
    // significant digits p, where x is positive and p is in [1, 21] or undefined.
    // For example, formatDecimal(1.23) returns ["123", 0].
    function formatDecimal(x, p) {
      if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
      var i, coefficient = x.slice(0, i);

      // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
      // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
      return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x.slice(i + 1)
      ];
    }

    function exponent(x) {
      return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
    }

    function formatGroup(grouping, thousands) {
      return function(value, width) {
        var i = value.length,
            t = [],
            j = 0,
            g = grouping[0],
            length = 0;

        while (i > 0 && g > 0) {
          if (length + g + 1 > width) g = Math.max(1, width - length);
          t.push(value.substring(i -= g, i + g));
          if ((length += g + 1) > width) break;
          g = grouping[j = (j + 1) % grouping.length];
        }

        return t.reverse().join(thousands);
      };
    }

    function formatNumerals(numerals) {
      return function(value) {
        return value.replace(/[0-9]/g, function(i) {
          return numerals[+i];
        });
      };
    }

    // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
    var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

    function formatSpecifier(specifier) {
      return new FormatSpecifier(specifier);
    }

    formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

    function FormatSpecifier(specifier) {
      if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
      var match;
      this.fill = match[1] || " ";
      this.align = match[2] || ">";
      this.sign = match[3] || "-";
      this.symbol = match[4] || "";
      this.zero = !!match[5];
      this.width = match[6] && +match[6];
      this.comma = !!match[7];
      this.precision = match[8] && +match[8].slice(1);
      this.trim = !!match[9];
      this.type = match[10] || "";
    }

    FormatSpecifier.prototype.toString = function() {
      return this.fill
          + this.align
          + this.sign
          + this.symbol
          + (this.zero ? "0" : "")
          + (this.width == null ? "" : Math.max(1, this.width | 0))
          + (this.comma ? "," : "")
          + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
          + (this.trim ? "~" : "")
          + this.type;
    };

    // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
    function formatTrim(s) {
      out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (s[i]) {
          case ".": i0 = i1 = i; break;
          case "0": if (i0 === 0) i0 = i; i1 = i; break;
          default: if (i0 > 0) { if (!+s[i]) break out; i0 = 0; } break;
        }
      }
      return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
    }

    var prefixExponent;

    function formatPrefixAuto(x, p) {
      var d = formatDecimal(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1],
          i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
          n = coefficient.length;
      return i === n ? coefficient
          : i > n ? coefficient + new Array(i - n + 1).join("0")
          : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
          : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
    }

    function formatRounded(x, p) {
      var d = formatDecimal(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1];
      return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
          : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
          : coefficient + new Array(exponent - coefficient.length + 2).join("0");
    }

    var formatTypes = {
      "%": function(x, p) { return (x * 100).toFixed(p); },
      "b": function(x) { return Math.round(x).toString(2); },
      "c": function(x) { return x + ""; },
      "d": function(x) { return Math.round(x).toString(10); },
      "e": function(x, p) { return x.toExponential(p); },
      "f": function(x, p) { return x.toFixed(p); },
      "g": function(x, p) { return x.toPrecision(p); },
      "o": function(x) { return Math.round(x).toString(8); },
      "p": function(x, p) { return formatRounded(x * 100, p); },
      "r": formatRounded,
      "s": formatPrefixAuto,
      "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
      "x": function(x) { return Math.round(x).toString(16); }
    };

    function identity$2(x) {
      return x;
    }

    var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

    function formatLocale(locale) {
      var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity$2,
          currency = locale.currency,
          decimal = locale.decimal,
          numerals = locale.numerals ? formatNumerals(locale.numerals) : identity$2,
          percent = locale.percent || "%";

      function newFormat(specifier) {
        specifier = formatSpecifier(specifier);

        var fill = specifier.fill,
            align = specifier.align,
            sign = specifier.sign,
            symbol = specifier.symbol,
            zero = specifier.zero,
            width = specifier.width,
            comma = specifier.comma,
            precision = specifier.precision,
            trim = specifier.trim,
            type = specifier.type;

        // The "n" type is an alias for ",g".
        if (type === "n") comma = true, type = "g";

        // The "" type, and any invalid type, is an alias for ".12~g".
        else if (!formatTypes[type]) precision == null && (precision = 12), trim = true, type = "g";

        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

        // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.
        var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
            suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

        // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?
        var formatType = formatTypes[type],
            maybeSuffix = /[defgprs%]/.test(type);

        // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].
        precision = precision == null ? 6
            : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
            : Math.max(0, Math.min(20, precision));

        function format(value) {
          var valuePrefix = prefix,
              valueSuffix = suffix,
              i, n, c;

          if (type === "c") {
            valueSuffix = formatType(value) + valueSuffix;
            value = "";
          } else {
            value = +value;

            // Perform the initial formatting.
            var valueNegative = value < 0;
            value = formatType(Math.abs(value), precision);

            // Trim insignificant zeros.
            if (trim) value = formatTrim(value);

            // If a negative value rounds to zero during formatting, treat as positive.
            if (valueNegative && +value === 0) valueNegative = false;

            // Compute the prefix and suffix.
            valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
            valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

            // Break the formatted value into the integer “value” part that can be
            // grouped, and fractional or exponential “suffix” part that is not.
            if (maybeSuffix) {
              i = -1, n = value.length;
              while (++i < n) {
                if (c = value.charCodeAt(i), 48 > c || c > 57) {
                  valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                  value = value.slice(0, i);
                  break;
                }
              }
            }
          }

          // If the fill character is not "0", grouping is applied before padding.
          if (comma && !zero) value = group(value, Infinity);

          // Compute the padding.
          var length = valuePrefix.length + value.length + valueSuffix.length,
              padding = length < width ? new Array(width - length + 1).join(fill) : "";

          // If the fill character is "0", grouping is applied after padding.
          if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

          // Reconstruct the final output based on the desired alignment.
          switch (align) {
            case "<": value = valuePrefix + value + valueSuffix + padding; break;
            case "=": value = valuePrefix + padding + value + valueSuffix; break;
            case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
            default: value = padding + valuePrefix + value + valueSuffix; break;
          }

          return numerals(value);
        }

        format.toString = function() {
          return specifier + "";
        };

        return format;
      }

      function formatPrefix(specifier, value) {
        var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
            e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
            k = Math.pow(10, -e),
            prefix = prefixes[8 + e / 3];
        return function(value) {
          return f(k * value) + prefix;
        };
      }

      return {
        format: newFormat,
        formatPrefix: formatPrefix
      };
    }

    var locale;
    var format;
    var formatPrefix;

    defaultLocale({
      decimal: ".",
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });

    function defaultLocale(definition) {
      locale = formatLocale(definition);
      format = locale.format;
      formatPrefix = locale.formatPrefix;
      return locale;
    }

    function precisionFixed(step) {
      return Math.max(0, -exponent(Math.abs(step)));
    }

    function precisionPrefix(step, value) {
      return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
    }

    function precisionRound(step, max) {
      step = Math.abs(step), max = Math.abs(max) - step;
      return Math.max(0, exponent(max) - exponent(step)) + 1;
    }

    function tickFormat(start, stop, count, specifier) {
      var step = tickStep(start, stop, count),
          precision;
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      switch (specifier.type) {
        case "s": {
          var value = Math.max(Math.abs(start), Math.abs(stop));
          if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
          return formatPrefix(specifier, value);
        }
        case "":
        case "e":
        case "g":
        case "p":
        case "r": {
          if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
          break;
        }
        case "f":
        case "%": {
          if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
          break;
        }
      }
      return format(specifier);
    }

    function linearish(scale) {
      var domain = scale.domain;

      scale.ticks = function(count) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
      };

      scale.tickFormat = function(count, specifier) {
        var d = domain();
        return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
      };

      scale.nice = function(count) {
        if (count == null) count = 10;

        var d = domain(),
            i0 = 0,
            i1 = d.length - 1,
            start = d[i0],
            stop = d[i1],
            step;

        if (stop < start) {
          step = start, start = stop, stop = step;
          step = i0, i0 = i1, i1 = step;
        }

        step = tickIncrement(start, stop, count);

        if (step > 0) {
          start = Math.floor(start / step) * step;
          stop = Math.ceil(stop / step) * step;
          step = tickIncrement(start, stop, count);
        } else if (step < 0) {
          start = Math.ceil(start * step) / step;
          stop = Math.floor(stop * step) / step;
          step = tickIncrement(start, stop, count);
        }

        if (step > 0) {
          d[i0] = Math.floor(start / step) * step;
          d[i1] = Math.ceil(stop / step) * step;
          domain(d);
        } else if (step < 0) {
          d[i0] = Math.ceil(start * step) / step;
          d[i1] = Math.floor(stop * step) / step;
          domain(d);
        }

        return scale;
      };

      return scale;
    }

    function linear$1() {
      var scale = continuous();

      scale.copy = function() {
        return copy(scale, linear$1());
      };

      initRange.apply(scale, arguments);

      return linearish(scale);
    }

    function nice(domain, interval) {
      domain = domain.slice();

      var i0 = 0,
          i1 = domain.length - 1,
          x0 = domain[i0],
          x1 = domain[i1],
          t;

      if (x1 < x0) {
        t = i0, i0 = i1, i1 = t;
        t = x0, x0 = x1, x1 = t;
      }

      domain[i0] = interval.floor(x0);
      domain[i1] = interval.ceil(x1);
      return domain;
    }

    var t0$1 = new Date,
        t1$1 = new Date;

    function newInterval(floori, offseti, count, field) {

      function interval(date) {
        return floori(date = new Date(+date)), date;
      }

      interval.floor = interval;

      interval.ceil = function(date) {
        return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
      };

      interval.round = function(date) {
        var d0 = interval(date),
            d1 = interval.ceil(date);
        return date - d0 < d1 - date ? d0 : d1;
      };

      interval.offset = function(date, step) {
        return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
      };

      interval.range = function(start, stop, step) {
        var range = [], previous;
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
        do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
        while (previous < start && start < stop);
        return range;
      };

      interval.filter = function(test) {
        return newInterval(function(date) {
          if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
        }, function(date, step) {
          if (date >= date) {
            if (step < 0) while (++step <= 0) {
              while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
            } else while (--step >= 0) {
              while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
            }
          }
        });
      };

      if (count) {
        interval.count = function(start, end) {
          t0$1.setTime(+start), t1$1.setTime(+end);
          floori(t0$1), floori(t1$1);
          return Math.floor(count(t0$1, t1$1));
        };

        interval.every = function(step) {
          step = Math.floor(step);
          return !isFinite(step) || !(step > 0) ? null
              : !(step > 1) ? interval
              : interval.filter(field
                  ? function(d) { return field(d) % step === 0; }
                  : function(d) { return interval.count(0, d) % step === 0; });
        };
      }

      return interval;
    }

    var millisecond = newInterval(function() {
      // noop
    }, function(date, step) {
      date.setTime(+date + step);
    }, function(start, end) {
      return end - start;
    });

    // An optimized implementation for this simple case.
    millisecond.every = function(k) {
      k = Math.floor(k);
      if (!isFinite(k) || !(k > 0)) return null;
      if (!(k > 1)) return millisecond;
      return newInterval(function(date) {
        date.setTime(Math.floor(date / k) * k);
      }, function(date, step) {
        date.setTime(+date + step * k);
      }, function(start, end) {
        return (end - start) / k;
      });
    };

    var durationSecond = 1e3;
    var durationMinute = 6e4;
    var durationHour = 36e5;
    var durationDay = 864e5;
    var durationWeek = 6048e5;

    var second = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds());
    }, function(date, step) {
      date.setTime(+date + step * durationSecond);
    }, function(start, end) {
      return (end - start) / durationSecond;
    }, function(date) {
      return date.getUTCSeconds();
    });

    var minute = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getMinutes();
    });

    var hour = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getHours();
    });

    var day = newInterval(function(date) {
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setDate(date.getDate() + step);
    }, function(start, end) {
      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
    }, function(date) {
      return date.getDate() - 1;
    });

    function weekday(i) {
      return newInterval(function(date) {
        date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setDate(date.getDate() + step * 7);
      }, function(start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
      });
    }

    var sunday = weekday(0);
    var monday = weekday(1);
    var tuesday = weekday(2);
    var wednesday = weekday(3);
    var thursday = weekday(4);
    var friday = weekday(5);
    var saturday = weekday(6);

    var month = newInterval(function(date) {
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setMonth(date.getMonth() + step);
    }, function(start, end) {
      return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, function(date) {
      return date.getMonth();
    });

    var year = newInterval(function(date) {
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setFullYear(date.getFullYear() + step);
    }, function(start, end) {
      return end.getFullYear() - start.getFullYear();
    }, function(date) {
      return date.getFullYear();
    });

    // An optimized implementation for this simple case.
    year.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setFullYear(Math.floor(date.getFullYear() / k) * k);
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setFullYear(date.getFullYear() + step * k);
      });
    };

    var utcMinute = newInterval(function(date) {
      date.setUTCSeconds(0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getUTCMinutes();
    });

    var utcHour = newInterval(function(date) {
      date.setUTCMinutes(0, 0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getUTCHours();
    });

    var utcDay = newInterval(function(date) {
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCDate(date.getUTCDate() + step);
    }, function(start, end) {
      return (end - start) / durationDay;
    }, function(date) {
      return date.getUTCDate() - 1;
    });

    function utcWeekday(i) {
      return newInterval(function(date) {
        date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCDate(date.getUTCDate() + step * 7);
      }, function(start, end) {
        return (end - start) / durationWeek;
      });
    }

    var utcSunday = utcWeekday(0);
    var utcMonday = utcWeekday(1);
    var utcTuesday = utcWeekday(2);
    var utcWednesday = utcWeekday(3);
    var utcThursday = utcWeekday(4);
    var utcFriday = utcWeekday(5);
    var utcSaturday = utcWeekday(6);

    var utcMonth = newInterval(function(date) {
      date.setUTCDate(1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCMonth(date.getUTCMonth() + step);
    }, function(start, end) {
      return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, function(date) {
      return date.getUTCMonth();
    });

    var utcYear = newInterval(function(date) {
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCFullYear(date.getUTCFullYear() + step);
    }, function(start, end) {
      return end.getUTCFullYear() - start.getUTCFullYear();
    }, function(date) {
      return date.getUTCFullYear();
    });

    // An optimized implementation for this simple case.
    utcYear.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step * k);
      });
    };

    function localDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
        date.setFullYear(d.y);
        return date;
      }
      return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    }

    function utcDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
        date.setUTCFullYear(d.y);
        return date;
      }
      return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
    }

    function newYear(y) {
      return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
    }

    function formatLocale$1(locale) {
      var locale_dateTime = locale.dateTime,
          locale_date = locale.date,
          locale_time = locale.time,
          locale_periods = locale.periods,
          locale_weekdays = locale.days,
          locale_shortWeekdays = locale.shortDays,
          locale_months = locale.months,
          locale_shortMonths = locale.shortMonths;

      var periodRe = formatRe(locale_periods),
          periodLookup = formatLookup(locale_periods),
          weekdayRe = formatRe(locale_weekdays),
          weekdayLookup = formatLookup(locale_weekdays),
          shortWeekdayRe = formatRe(locale_shortWeekdays),
          shortWeekdayLookup = formatLookup(locale_shortWeekdays),
          monthRe = formatRe(locale_months),
          monthLookup = formatLookup(locale_months),
          shortMonthRe = formatRe(locale_shortMonths),
          shortMonthLookup = formatLookup(locale_shortMonths);

      var formats = {
        "a": formatShortWeekday,
        "A": formatWeekday,
        "b": formatShortMonth,
        "B": formatMonth,
        "c": null,
        "d": formatDayOfMonth,
        "e": formatDayOfMonth,
        "f": formatMicroseconds,
        "H": formatHour24,
        "I": formatHour12,
        "j": formatDayOfYear,
        "L": formatMilliseconds,
        "m": formatMonthNumber,
        "M": formatMinutes,
        "p": formatPeriod,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatSeconds,
        "u": formatWeekdayNumberMonday,
        "U": formatWeekNumberSunday,
        "V": formatWeekNumberISO,
        "w": formatWeekdayNumberSunday,
        "W": formatWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatYear,
        "Y": formatFullYear,
        "Z": formatZone,
        "%": formatLiteralPercent
      };

      var utcFormats = {
        "a": formatUTCShortWeekday,
        "A": formatUTCWeekday,
        "b": formatUTCShortMonth,
        "B": formatUTCMonth,
        "c": null,
        "d": formatUTCDayOfMonth,
        "e": formatUTCDayOfMonth,
        "f": formatUTCMicroseconds,
        "H": formatUTCHour24,
        "I": formatUTCHour12,
        "j": formatUTCDayOfYear,
        "L": formatUTCMilliseconds,
        "m": formatUTCMonthNumber,
        "M": formatUTCMinutes,
        "p": formatUTCPeriod,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatUTCSeconds,
        "u": formatUTCWeekdayNumberMonday,
        "U": formatUTCWeekNumberSunday,
        "V": formatUTCWeekNumberISO,
        "w": formatUTCWeekdayNumberSunday,
        "W": formatUTCWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatUTCYear,
        "Y": formatUTCFullYear,
        "Z": formatUTCZone,
        "%": formatLiteralPercent
      };

      var parses = {
        "a": parseShortWeekday,
        "A": parseWeekday,
        "b": parseShortMonth,
        "B": parseMonth,
        "c": parseLocaleDateTime,
        "d": parseDayOfMonth,
        "e": parseDayOfMonth,
        "f": parseMicroseconds,
        "H": parseHour24,
        "I": parseHour24,
        "j": parseDayOfYear,
        "L": parseMilliseconds,
        "m": parseMonthNumber,
        "M": parseMinutes,
        "p": parsePeriod,
        "Q": parseUnixTimestamp,
        "s": parseUnixTimestampSeconds,
        "S": parseSeconds,
        "u": parseWeekdayNumberMonday,
        "U": parseWeekNumberSunday,
        "V": parseWeekNumberISO,
        "w": parseWeekdayNumberSunday,
        "W": parseWeekNumberMonday,
        "x": parseLocaleDate,
        "X": parseLocaleTime,
        "y": parseYear,
        "Y": parseFullYear,
        "Z": parseZone,
        "%": parseLiteralPercent
      };

      // These recursive directive definitions must be deferred.
      formats.x = newFormat(locale_date, formats);
      formats.X = newFormat(locale_time, formats);
      formats.c = newFormat(locale_dateTime, formats);
      utcFormats.x = newFormat(locale_date, utcFormats);
      utcFormats.X = newFormat(locale_time, utcFormats);
      utcFormats.c = newFormat(locale_dateTime, utcFormats);

      function newFormat(specifier, formats) {
        return function(date) {
          var string = [],
              i = -1,
              j = 0,
              n = specifier.length,
              c,
              pad,
              format;

          if (!(date instanceof Date)) date = new Date(+date);

          while (++i < n) {
            if (specifier.charCodeAt(i) === 37) {
              string.push(specifier.slice(j, i));
              if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
              else pad = c === "e" ? " " : "0";
              if (format = formats[c]) c = format(date, pad);
              string.push(c);
              j = i + 1;
            }
          }

          string.push(specifier.slice(j, i));
          return string.join("");
        };
      }

      function newParse(specifier, newDate) {
        return function(string) {
          var d = newYear(1900),
              i = parseSpecifier(d, specifier, string += "", 0),
              week, day$1;
          if (i != string.length) return null;

          // If a UNIX timestamp is specified, return it.
          if ("Q" in d) return new Date(d.Q);

          // The am-pm flag is 0 for AM, and 1 for PM.
          if ("p" in d) d.H = d.H % 12 + d.p * 12;

          // Convert day-of-week and week-of-year to day-of-year.
          if ("V" in d) {
            if (d.V < 1 || d.V > 53) return null;
            if (!("w" in d)) d.w = 1;
            if ("Z" in d) {
              week = utcDate(newYear(d.y)), day$1 = week.getUTCDay();
              week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
              week = utcDay.offset(week, (d.V - 1) * 7);
              d.y = week.getUTCFullYear();
              d.m = week.getUTCMonth();
              d.d = week.getUTCDate() + (d.w + 6) % 7;
            } else {
              week = newDate(newYear(d.y)), day$1 = week.getDay();
              week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);
              week = day.offset(week, (d.V - 1) * 7);
              d.y = week.getFullYear();
              d.m = week.getMonth();
              d.d = week.getDate() + (d.w + 6) % 7;
            }
          } else if ("W" in d || "U" in d) {
            if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
            day$1 = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
            d.m = 0;
            d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;
          }

          // If a time zone is specified, all fields are interpreted as UTC and then
          // offset according to the specified time zone.
          if ("Z" in d) {
            d.H += d.Z / 100 | 0;
            d.M += d.Z % 100;
            return utcDate(d);
          }

          // Otherwise, all fields are in local time.
          return newDate(d);
        };
      }

      function parseSpecifier(d, specifier, string, j) {
        var i = 0,
            n = specifier.length,
            m = string.length,
            c,
            parse;

        while (i < n) {
          if (j >= m) return -1;
          c = specifier.charCodeAt(i++);
          if (c === 37) {
            c = specifier.charAt(i++);
            parse = parses[c in pads ? specifier.charAt(i++) : c];
            if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
          } else if (c != string.charCodeAt(j++)) {
            return -1;
          }
        }

        return j;
      }

      function parsePeriod(d, string, i) {
        var n = periodRe.exec(string.slice(i));
        return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseShortWeekday(d, string, i) {
        var n = shortWeekdayRe.exec(string.slice(i));
        return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseWeekday(d, string, i) {
        var n = weekdayRe.exec(string.slice(i));
        return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseShortMonth(d, string, i) {
        var n = shortMonthRe.exec(string.slice(i));
        return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseMonth(d, string, i) {
        var n = monthRe.exec(string.slice(i));
        return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseLocaleDateTime(d, string, i) {
        return parseSpecifier(d, locale_dateTime, string, i);
      }

      function parseLocaleDate(d, string, i) {
        return parseSpecifier(d, locale_date, string, i);
      }

      function parseLocaleTime(d, string, i) {
        return parseSpecifier(d, locale_time, string, i);
      }

      function formatShortWeekday(d) {
        return locale_shortWeekdays[d.getDay()];
      }

      function formatWeekday(d) {
        return locale_weekdays[d.getDay()];
      }

      function formatShortMonth(d) {
        return locale_shortMonths[d.getMonth()];
      }

      function formatMonth(d) {
        return locale_months[d.getMonth()];
      }

      function formatPeriod(d) {
        return locale_periods[+(d.getHours() >= 12)];
      }

      function formatUTCShortWeekday(d) {
        return locale_shortWeekdays[d.getUTCDay()];
      }

      function formatUTCWeekday(d) {
        return locale_weekdays[d.getUTCDay()];
      }

      function formatUTCShortMonth(d) {
        return locale_shortMonths[d.getUTCMonth()];
      }

      function formatUTCMonth(d) {
        return locale_months[d.getUTCMonth()];
      }

      function formatUTCPeriod(d) {
        return locale_periods[+(d.getUTCHours() >= 12)];
      }

      return {
        format: function(specifier) {
          var f = newFormat(specifier += "", formats);
          f.toString = function() { return specifier; };
          return f;
        },
        parse: function(specifier) {
          var p = newParse(specifier += "", localDate);
          p.toString = function() { return specifier; };
          return p;
        },
        utcFormat: function(specifier) {
          var f = newFormat(specifier += "", utcFormats);
          f.toString = function() { return specifier; };
          return f;
        },
        utcParse: function(specifier) {
          var p = newParse(specifier, utcDate);
          p.toString = function() { return specifier; };
          return p;
        }
      };
    }

    var pads = {"-": "", "_": " ", "0": "0"},
        numberRe = /^\s*\d+/, // note: ignores next directive
        percentRe = /^%/,
        requoteRe = /[\\^$*+?|[\]().{}]/g;

    function pad(value, fill, width) {
      var sign = value < 0 ? "-" : "",
          string = (sign ? -value : value) + "",
          length = string.length;
      return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }

    function requote(s) {
      return s.replace(requoteRe, "\\$&");
    }

    function formatRe(names) {
      return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
    }

    function formatLookup(names) {
      var map = {}, i = -1, n = names.length;
      while (++i < n) map[names[i].toLowerCase()] = i;
      return map;
    }

    function parseWeekdayNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.w = +n[0], i + n[0].length) : -1;
    }

    function parseWeekdayNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.u = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.U = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberISO(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.V = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.W = +n[0], i + n[0].length) : -1;
    }

    function parseFullYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 4));
      return n ? (d.y = +n[0], i + n[0].length) : -1;
    }

    function parseYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
    }

    function parseZone(d, string, i) {
      var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
      return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
    }

    function parseMonthNumber(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
    }

    function parseDayOfMonth(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.d = +n[0], i + n[0].length) : -1;
    }

    function parseDayOfYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
    }

    function parseHour24(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.H = +n[0], i + n[0].length) : -1;
    }

    function parseMinutes(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.M = +n[0], i + n[0].length) : -1;
    }

    function parseSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.S = +n[0], i + n[0].length) : -1;
    }

    function parseMilliseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.L = +n[0], i + n[0].length) : -1;
    }

    function parseMicroseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 6));
      return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
    }

    function parseLiteralPercent(d, string, i) {
      var n = percentRe.exec(string.slice(i, i + 1));
      return n ? i + n[0].length : -1;
    }

    function parseUnixTimestamp(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.Q = +n[0], i + n[0].length) : -1;
    }

    function parseUnixTimestampSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
    }

    function formatDayOfMonth(d, p) {
      return pad(d.getDate(), p, 2);
    }

    function formatHour24(d, p) {
      return pad(d.getHours(), p, 2);
    }

    function formatHour12(d, p) {
      return pad(d.getHours() % 12 || 12, p, 2);
    }

    function formatDayOfYear(d, p) {
      return pad(1 + day.count(year(d), d), p, 3);
    }

    function formatMilliseconds(d, p) {
      return pad(d.getMilliseconds(), p, 3);
    }

    function formatMicroseconds(d, p) {
      return formatMilliseconds(d, p) + "000";
    }

    function formatMonthNumber(d, p) {
      return pad(d.getMonth() + 1, p, 2);
    }

    function formatMinutes(d, p) {
      return pad(d.getMinutes(), p, 2);
    }

    function formatSeconds(d, p) {
      return pad(d.getSeconds(), p, 2);
    }

    function formatWeekdayNumberMonday(d) {
      var day = d.getDay();
      return day === 0 ? 7 : day;
    }

    function formatWeekNumberSunday(d, p) {
      return pad(sunday.count(year(d), d), p, 2);
    }

    function formatWeekNumberISO(d, p) {
      var day = d.getDay();
      d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
      return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
    }

    function formatWeekdayNumberSunday(d) {
      return d.getDay();
    }

    function formatWeekNumberMonday(d, p) {
      return pad(monday.count(year(d), d), p, 2);
    }

    function formatYear(d, p) {
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatFullYear(d, p) {
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatZone(d) {
      var z = d.getTimezoneOffset();
      return (z > 0 ? "-" : (z *= -1, "+"))
          + pad(z / 60 | 0, "0", 2)
          + pad(z % 60, "0", 2);
    }

    function formatUTCDayOfMonth(d, p) {
      return pad(d.getUTCDate(), p, 2);
    }

    function formatUTCHour24(d, p) {
      return pad(d.getUTCHours(), p, 2);
    }

    function formatUTCHour12(d, p) {
      return pad(d.getUTCHours() % 12 || 12, p, 2);
    }

    function formatUTCDayOfYear(d, p) {
      return pad(1 + utcDay.count(utcYear(d), d), p, 3);
    }

    function formatUTCMilliseconds(d, p) {
      return pad(d.getUTCMilliseconds(), p, 3);
    }

    function formatUTCMicroseconds(d, p) {
      return formatUTCMilliseconds(d, p) + "000";
    }

    function formatUTCMonthNumber(d, p) {
      return pad(d.getUTCMonth() + 1, p, 2);
    }

    function formatUTCMinutes(d, p) {
      return pad(d.getUTCMinutes(), p, 2);
    }

    function formatUTCSeconds(d, p) {
      return pad(d.getUTCSeconds(), p, 2);
    }

    function formatUTCWeekdayNumberMonday(d) {
      var dow = d.getUTCDay();
      return dow === 0 ? 7 : dow;
    }

    function formatUTCWeekNumberSunday(d, p) {
      return pad(utcSunday.count(utcYear(d), d), p, 2);
    }

    function formatUTCWeekNumberISO(d, p) {
      var day = d.getUTCDay();
      d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
      return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
    }

    function formatUTCWeekdayNumberSunday(d) {
      return d.getUTCDay();
    }

    function formatUTCWeekNumberMonday(d, p) {
      return pad(utcMonday.count(utcYear(d), d), p, 2);
    }

    function formatUTCYear(d, p) {
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCFullYear(d, p) {
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCZone() {
      return "+0000";
    }

    function formatLiteralPercent() {
      return "%";
    }

    function formatUnixTimestamp(d) {
      return +d;
    }

    function formatUnixTimestampSeconds(d) {
      return Math.floor(+d / 1000);
    }

    var locale$1;
    var timeFormat;
    var timeParse;
    var utcFormat;
    var utcParse;

    defaultLocale$1({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });

    function defaultLocale$1(definition) {
      locale$1 = formatLocale$1(definition);
      timeFormat = locale$1.format;
      timeParse = locale$1.parse;
      utcFormat = locale$1.utcFormat;
      utcParse = locale$1.utcParse;
      return locale$1;
    }

    var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

    function formatIsoNative(date) {
      return date.toISOString();
    }

    var formatIso = Date.prototype.toISOString
        ? formatIsoNative
        : utcFormat(isoSpecifier);

    function parseIsoNative(string) {
      var date = new Date(string);
      return isNaN(date) ? null : date;
    }

    var parseIso = +new Date("2000-01-01T00:00:00.000Z")
        ? parseIsoNative
        : utcParse(isoSpecifier);

    var durationSecond$1 = 1000,
        durationMinute$1 = durationSecond$1 * 60,
        durationHour$1 = durationMinute$1 * 60,
        durationDay$1 = durationHour$1 * 24,
        durationWeek$1 = durationDay$1 * 7,
        durationMonth = durationDay$1 * 30,
        durationYear = durationDay$1 * 365;

    function date$1(t) {
      return new Date(t);
    }

    function number$1(t) {
      return t instanceof Date ? +t : +new Date(+t);
    }

    function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
      var scale = continuous(),
          invert = scale.invert,
          domain = scale.domain;

      var formatMillisecond = format(".%L"),
          formatSecond = format(":%S"),
          formatMinute = format("%I:%M"),
          formatHour = format("%I %p"),
          formatDay = format("%a %d"),
          formatWeek = format("%b %d"),
          formatMonth = format("%B"),
          formatYear = format("%Y");

      var tickIntervals = [
        [second,  1,      durationSecond$1],
        [second,  5,  5 * durationSecond$1],
        [second, 15, 15 * durationSecond$1],
        [second, 30, 30 * durationSecond$1],
        [minute,  1,      durationMinute$1],
        [minute,  5,  5 * durationMinute$1],
        [minute, 15, 15 * durationMinute$1],
        [minute, 30, 30 * durationMinute$1],
        [  hour,  1,      durationHour$1  ],
        [  hour,  3,  3 * durationHour$1  ],
        [  hour,  6,  6 * durationHour$1  ],
        [  hour, 12, 12 * durationHour$1  ],
        [   day,  1,      durationDay$1   ],
        [   day,  2,  2 * durationDay$1   ],
        [  week,  1,      durationWeek$1  ],
        [ month,  1,      durationMonth ],
        [ month,  3,  3 * durationMonth ],
        [  year,  1,      durationYear  ]
      ];

      function tickFormat(date) {
        return (second(date) < date ? formatMillisecond
            : minute(date) < date ? formatSecond
            : hour(date) < date ? formatMinute
            : day(date) < date ? formatHour
            : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
            : year(date) < date ? formatMonth
            : formatYear)(date);
      }

      function tickInterval(interval, start, stop) {
        if (interval == null) interval = 10;

        // If a desired tick count is specified, pick a reasonable tick interval
        // based on the extent of the domain and a rough estimate of tick size.
        // Otherwise, assume interval is already a time interval and use it.
        if (typeof interval === "number") {
          var target = Math.abs(stop - start) / interval,
              i = bisector(function(i) { return i[2]; }).right(tickIntervals, target),
              step;
          if (i === tickIntervals.length) {
            step = tickStep(start / durationYear, stop / durationYear, interval);
            interval = year;
          } else if (i) {
            i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
            step = i[1];
            interval = i[0];
          } else {
            step = Math.max(tickStep(start, stop, interval), 1);
            interval = millisecond;
          }
          return interval.every(step);
        }

        return interval;
      }

      scale.invert = function(y) {
        return new Date(invert(y));
      };

      scale.domain = function(_) {
        return arguments.length ? domain(Array.from(_, number$1)) : domain().map(date$1);
      };

      scale.ticks = function(interval) {
        var d = domain(),
            t0 = d[0],
            t1 = d[d.length - 1],
            r = t1 < t0,
            t;
        if (r) t = t0, t0 = t1, t1 = t;
        t = tickInterval(interval, t0, t1);
        t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
        return r ? t.reverse() : t;
      };

      scale.tickFormat = function(count, specifier) {
        return specifier == null ? tickFormat : format(specifier);
      };

      scale.nice = function(interval) {
        var d = domain();
        return (interval = tickInterval(interval, d[0], d[d.length - 1]))
            ? domain(nice(d, interval))
            : scale;
      };

      scale.copy = function() {
        return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
      };

      return scale;
    }

    function scaleUtc() {
      return initRange.apply(calendar(utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, millisecond, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
    }

    function transformer$1() {
      var x0 = 0,
          x1 = 1,
          t0,
          t1,
          k10,
          transform,
          interpolator = identity$1,
          clamp = false,
          unknown;

      function scale(x) {
        return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      function range(interpolate) {
        return function(_) {
          var r0, r1;
          return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
        };
      }

      scale.range = range(interpolate);

      scale.rangeRound = range(interpolateRound);

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t) {
        transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
        return scale;
      };
    }

    function copy$1(source, target) {
      return target
          .domain(source.domain())
          .interpolator(source.interpolator())
          .clamp(source.clamp())
          .unknown(source.unknown());
    }

    function sequential() {
      var scale = linearish(transformer$1()(identity$1));

      scale.copy = function() {
        return copy$1(scale, sequential());
      };

      return initInterpolator.apply(scale, arguments);
    }

    class GraphicContext {
      constructor ({ renderer }) {
        if (!renderer) {
          this._rendererOptions = { output: 'svg' };
        }

        if (renderer) {
          validateRendererOptions(renderer);
          this._rendererOptions = renderer;
        }
      }

      output () {
        return this._rendererOptions.output
      }
    }

    function validateRendererOptions (options) {
      if (!(
        options.constructor === Object &&
        'output' in options &&
        ['svg'].includes(options.output)
      )) {
        throw new Error(`Invalid renderer options: ${JSON.stringify(options)}`)
      }
    }

    const key = {};

    function subscribe$1 () {
      return getContext(key)
    }

    function init$1 () {
      const graphicContext = writable();
      setContext(key, graphicContext);

      return graphicContext
    }

    function update$1 (graphicContext, options) {
      graphicContext.set(new GraphicContext(options));
    }

    class SectionContext {
      constructor ({ sectionId, rangeX, rangeY, scaleX, scaleY, padding, flipX, flipY, blockReindexing }) {
        this._sectionId = sectionId;

        this.rangeX = rangeX;
        this.rangeY = rangeY;

        this.minX = Math.min(...rangeX);
        this.maxX = Math.max(...rangeX);
        this.minY = Math.min(...rangeY);
        this.maxY = Math.max(...rangeY);

        this.padding = padding;

        this._handleScales(scaleX, scaleY);

        this.flipX = flipX;
        this.flipY = flipY;

        this.blockReindexing = blockReindexing;
      }

      _handleScales (scaleX, scaleY) {
        if (scaleX) {
          this.scaleX = scaleX.copy().range(this.rangeX);
          this.scaleX.invert = createInvertMethod(this.scaleX);
        } else {
          const domainX = [this.minX - this.padding.left, this.maxX + this.padding.right];
          this.scaleX = linear$1().domain(domainX).range(this.rangeX);
        }

        if (scaleY) {
          this.scaleY = scaleY.copy().range(this.rangeY);
          this.scaleY.invert = createInvertMethod(this.scaleY);
        } else {
          const domainY = [this.minY - this.padding.top, this.maxY + this.padding.bottom];
          this.scaleY = linear$1().domain(domainY).range(this.rangeY);
        }
      }
    }

    const key$1 = {};

    function subscribe$2 () {
      return getContext(key$1)
    }

    function init$2 () {
      const sectionContext = writable();
      setContext(key$1, sectionContext);

      return sectionContext
    }

    function update$2 (sectionContext, options) {
      sectionContext.set(new SectionContext(options));
    }

    /**
     * Taken from react-vis:
     * https://github.com/uber/react-vis/blob/master/src/utils/scales-utils.js#L161
     *
     * By default, d3.scaleBand and d3.scalePoint do not have an .invert method, which is why
     * we are doing this. There are some PRs open for this, though, so hopefully we can
     * get rid of this in the future:
     * - https://github.com/d3/d3-scale/pull/151
     * - https://github.com/d3/d3-scale/pull/60
     */
    function createInvertMethod (scale) {
      if (scale.invert) {
        return scale.invert
      }

      return function invert (value) {
        const [lower, upper] = scale.range();
        const start = Math.min(lower, upper);
        const stop = Math.max(lower, upper);

        const flipped = upper < lower;

        const domain = scale.domain();
        const lastIndex = domain.length - 1;

        if (value < start + scale.padding() * scale.step()) {
          return domain[0]
        }

        if (value > stop - scale.padding() * scale.step()) {
          return domain[lastIndex]
        }

        let index;

        if (isPointScale(scale)) {
          index = Math.round((value - start - scale.padding() * scale.step()) / scale.step());
        }

        if (isBandScale(scale)) {
          index = Math.round((value - start - scale.padding() * scale.step()) / scale.step());
          if (index > lastIndex) index = lastIndex;
        }

        return domain[flipped ? lastIndex - index : index]
      }
    }

    function isPointScale (scale) {
      return !('paddingInner' in scale)
    }

    function isBandScale (scale) {
      return 'paddingInner' in scale
    }

    const key$2 = {};

    function subscribe$3 () {
      return getContext(key$2)
    }

    function init$3 () {
      const eventManagerContext = writable();
      setContext(key$2, eventManagerContext);

      return eventManagerContext
    }

    function update$3 (eventManagerContext, eventManager) {
      eventManagerContext.set(eventManager);
    }

    const key$3 = {};

    function subscribe$4 () {
      return getContext(key$3)
    }

    function init$4 () {
      const interactionManagerContext = writable();
      setContext(key$3, interactionManagerContext);

      return interactionManagerContext
    }

    function update$4 (interactionManagerContext, interactionManager) {
      interactionManagerContext.set(interactionManager);
    }

    function createPolarTransformation (rangeX, rangeY) {
      const toTheta = linear$1().domain(rangeX).range([0, 2 * Math.PI]).clamp(true);
      const toRadius = linear$1().domain(rangeY).range([0, 1]).clamp(true);

      const fitX = linear$1().domain([-1, 1]).range(rangeX);
      const fitY = linear$1().domain([-1, 1]).range(rangeY);

      const transform = function transform ([x, y]) {
        const theta = toTheta(x);
        const radius = toRadius(y);
        const coords = polarToCartesian(theta, radius);

        return [fitX(coords[0]), fitY(coords[1])]
      };

      const invert = function invert ([x, y]) {
        const smallCoords = [fitX.invert(x), fitY.invert(y)];
        const [theta, radius] = cartesianToPolar(...smallCoords);

        return [toTheta.invert(theta), toRadius.invert(radius)]
      };

      transform.invert = invert;

      return transform
    }

    function polarToCartesian (theta, radius) {
      const x = radius * Math.sin(theta);
      const y = radius * Math.cos(theta);

      return [x, y]
    }

    // https://www.mathsisfun.com/polar-cartesian-coordinates.html
    function cartesianToPolar (x, y) {
      const quadrant = getQuadrant(x, y);

      const r = Math.sqrt(y ** 2 + x ** 2);
      let theta = Math.atan(x / y);

      if (quadrant === 2) {
        theta += Math.PI * 2;
      }

      if (quadrant === 3) {
        theta += Math.PI;
      }

      if (quadrant === 4) {
        theta += Math.PI;
      }

      return [theta, r]
    }

    function getQuadrant (x, y) {
      if (x >= 0 && y >= 0) return 1
      if (x < 0 && y >= 0) return 2
      if (x < 0 && y < 0) return 3
      if (x >= 0 && y < 0) return 4
    }

    class CoordinateTransformationContext {
      constructor ({ rangeX, rangeY, transformation }) {
        if (transformation.constructor === Function) {
          this._transformation = transformation(rangeX, rangeY);
          this._type = 'custom';
        }

        if (transformation.constructor === String) {
          this._type = transformation;

          switch (transformation) {
            case 'identity':
              this._transformation = c => c;
              this._transformation.invert = c => c;
              break

            case 'polar':
              this._transformation = createPolarTransformation(rangeX, rangeY);
              break

            default:
              throw new Error(`Invalid transformation name: '${transformation}'`)
          }
        }
      }

      transform (coordinatePair) {
        return this._transformation(coordinatePair)
      }

      type () {
        return this._type
      }
    }

    const key$4 = {};

    function subscribe$5 () {
      return getContext(key$4)
    }

    function init$5 () {
      const coordinateTransformationContext = writable();
      setContext(key$4, coordinateTransformationContext);

      return coordinateTransformationContext
    }

    function update$5 (coordinateTransformationContext, options) {
      if (options.transformation) {
        coordinateTransformationContext.set(new CoordinateTransformationContext(options));
      } else {
        coordinateTransformationContext.set(undefined);
      }
    }

    function ensureNotParent (ctx) {
      if (ctx) {
        throw new Error(
          'Sections with a coordinate transformation cannot contain anything other than Marks or Layers'
        )
      }
    }

    function isInvalid (value) {
      if (value === undefined || value === null) { return true }

      if (value.constructor === Number) {
        return !isFinite(value)
      }

      return false
    }

    function isDefined (value) {
      return value !== undefined
    }

    function isUndefined (value) {
      return value === undefined
    }

    const key$5 = {};

    function subscribe$6 () {
      return getContext(key$5)
    }

    function init$6 () {
      const zoomContext = writable();
      setContext(key$5, zoomContext);

      return zoomContext
    }

    function update$6 (zoomContext, zoomIdentity) {
      if (zoomIdentity) {
        zoomContext.set(zoomIdentity);
      }

      if (!zoomIdentity) {
        zoomContext.set(undefined);
      }
    }

    function createZoomTransformation (zoomContext, zoomIdentity) {
      if (isDefined(zoomContext)) {
        if (isUndefined(zoomIdentity)) {
          return createZoomFunction(zoomContext)
        }

        if (isDefined(zoomIdentity)) {
          const combinedZoomIdentity = reconcileZoomIdentities(zoomContext, zoomIdentity);
          return createZoomFunction(combinedZoomIdentity)
        }
      }

      if (isUndefined(zoomContext)) {
        if (isUndefined(zoomIdentity)) {
          return undefined
        }

        if (isDefined(zoomIdentity)) {
          return createZoomFunction(zoomIdentity)
        }
      }
    }

    function createZoomFunction (zoomIdentity) {
      ensureValidZoomIdentity(zoomIdentity);

      const { x, y, kx, ky } = zoomIdentity;
      const transformation = p => [p[0] * kx + x, p[1] * ky + y];
      const inverseTransformation = p => [(p[0] - x) / kx, (p[1] - y) / ky];
      transformation.invert = inverseTransformation;

      return transformation
    }

    function ensureValidZoomIdentity (zoomIdentity) {
      if (
        hasValid(zoomIdentity, 'x') &&
        hasValid(zoomIdentity, 'y') &&
        hasValid(zoomIdentity, 'kx') &&
        hasValid(zoomIdentity, 'ky') &&
        Object.keys(zoomIdentity).length === 4
      ) {
        return
      }

      throw new Error(`Invalid zoomIdentity: '${JSON.stringify(zoomIdentity)}`)
    }

    function hasValid (zoomIdentity, key) {
      return key in zoomIdentity && zoomIdentity[key].constructor === Number
    }

    function reconcileZoomIdentities (zoomContext, zoomIdentity) {
      const newZoomIdentity = {};
      Object.assign(newZoomIdentity, zoomContext);
      Object.assign(newZoomIdentity, zoomIdentity);

      return newZoomIdentity
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var lib = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var detectHover = {
      update: function update() {
        if (typeof window !== 'undefined' && typeof window.matchMedia === 'function') {
          detectHover.hover = window.matchMedia('(hover: hover)').matches;
          detectHover.none = window.matchMedia('(hover: none)').matches || window.matchMedia('(hover: on-demand)').matches;
          detectHover.anyHover = window.matchMedia('(any-hover: hover)').matches;
          detectHover.anyNone = window.matchMedia('(any-hover: none)').matches || window.matchMedia('(any-hover: on-demand)').matches;
        }
      }
    };

    detectHover.update();
    exports.default = detectHover;
    });

    unwrapExports(lib);

    var lib$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var detectPointer = {
      update: function update() {
        if (typeof window !== 'undefined' && typeof window.matchMedia === 'function') {
          detectPointer.fine = window.matchMedia('(pointer: fine)').matches;
          detectPointer.coarse = window.matchMedia('(pointer: coarse)').matches;
          detectPointer.none = window.matchMedia('(pointer: none)').matches;
          detectPointer.anyFine = window.matchMedia('(any-pointer: fine)').matches;
          detectPointer.anyCoarse = window.matchMedia('(any-pointer: coarse)').matches;
          detectPointer.anyNone = window.matchMedia('(any-pointer: none)').matches;
        }
      }
    };

    detectPointer.update();
    exports.default = detectPointer;
    });

    unwrapExports(lib$1);

    var lib$2 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var detectTouchEvents = {
      update: function update() {
        if (typeof window !== 'undefined') {
          detectTouchEvents.hasSupport = 'ontouchstart' in window;
          detectTouchEvents.browserSupportsApi = Boolean(window.TouchEvent);
        }
      }
    };

    detectTouchEvents.update();
    exports.default = detectTouchEvents;
    });

    unwrapExports(lib$2);

    var lib$3 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    // adapted from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
    var detectPassiveEvents = {
      update: function update() {
        if (typeof window !== 'undefined' && typeof window.addEventListener === 'function') {
          var passive = false;
          var options = Object.defineProperty({}, 'passive', {
            get: function get() {
              passive = true;
            }
          });
          // note: have to set and remove a no-op listener instead of null
          // (which was used previously), becasue Edge v15 throws an error
          // when providing a null callback.
          // https://github.com/rafrex/detect-passive-events/pull/3
          var noop = function noop() {};
          window.addEventListener('testPassiveEventSupport', noop, options);
          window.removeEventListener('testPassiveEventSupport', noop, options);
          detectPassiveEvents.hasSupport = passive;
        }
      }
    };

    detectPassiveEvents.update();
    exports.default = detectPassiveEvents;
    });

    unwrapExports(lib$3);

    var lib$4 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });



    var _detectHover2 = _interopRequireDefault(lib);



    var _detectPointer2 = _interopRequireDefault(lib$1);



    var _detectTouchEvents2 = _interopRequireDefault(lib$2);



    var _detectPassiveEvents2 = _interopRequireDefault(lib$3);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    /*
     * detectIt object structure
     * const detectIt = {
     *   deviceType: 'mouseOnly' / 'touchOnly' / 'hybrid',
     *   passiveEvents: boolean,
     *   hasTouch: boolean,
     *   hasMouse: boolean,
     *   maxTouchPoints: number,
     *   primaryHover: 'hover' / 'none',
     *   primaryPointer: 'fine' / 'coarse' / 'none',
     *   state: {
     *     detectHover,
     *     detectPointer,
     *     detectTouchEvents,
     *     detectPassiveEvents,
     *   },
     *   update() {...},
     * }
     */

    function determineDeviceType(hasTouch, anyHover, anyFine, state) {
      // A hybrid device is one that both hasTouch and any input device can hover
      // or has a fine pointer.
      if (hasTouch && (anyHover || anyFine)) return 'hybrid';

      // workaround for browsers that have the touch events api,
      // and have implemented Level 4 media queries but not the
      // hover and pointer media queries, so the tests are all false (notable Firefox)
      // if it hasTouch, no pointer and hover support, and on an android assume it's touchOnly
      // if it hasTouch, no pointer and hover support, and not on an android assume it's a hybrid
      if (hasTouch && Object.keys(state.detectHover).filter(function (key) {
        return key !== 'update';
      }).every(function (key) {
        return state.detectHover[key] === false;
      }) && Object.keys(state.detectPointer).filter(function (key) {
        return key !== 'update';
      }).every(function (key) {
        return state.detectPointer[key] === false;
      })) {
        if (window.navigator && /android/.test(window.navigator.userAgent.toLowerCase())) {
          return 'touchOnly';
        }
        return 'hybrid';
      }

      // In almost all cases a device that doesn’t support touch will have a mouse,
      // but there may be rare exceptions. Note that it doesn’t work to do additional tests
      // based on hover and pointer media queries as older browsers don’t support these.
      // Essentially, 'mouseOnly' is the default.
      return hasTouch ? 'touchOnly' : 'mouseOnly';
    }

    var detectIt = {
      state: {
        detectHover: _detectHover2.default,
        detectPointer: _detectPointer2.default,
        detectTouchEvents: _detectTouchEvents2.default,
        detectPassiveEvents: _detectPassiveEvents2.default
      },
      update: function update() {
        detectIt.state.detectHover.update();
        detectIt.state.detectPointer.update();
        detectIt.state.detectTouchEvents.update();
        detectIt.state.detectPassiveEvents.update();
        detectIt.updateOnlyOwnProperties();
      },
      updateOnlyOwnProperties: function updateOnlyOwnProperties() {
        if (typeof window !== 'undefined') {
          detectIt.passiveEvents = detectIt.state.detectPassiveEvents.hasSupport || false;

          detectIt.hasTouch = detectIt.state.detectTouchEvents.hasSupport || false;

          detectIt.deviceType = determineDeviceType(detectIt.hasTouch, detectIt.state.detectHover.anyHover, detectIt.state.detectPointer.anyFine, detectIt.state);

          detectIt.hasMouse = detectIt.deviceType !== 'touchOnly';

          detectIt.primaryInput = detectIt.deviceType === 'mouseOnly' && 'mouse' || detectIt.deviceType === 'touchOnly' && 'touch' ||
          // deviceType is hybrid:
          detectIt.state.detectPointer.fine && 'mouse' || detectIt.state.detectPointer.coarse && 'touch' ||
          // if there's no support for hover media queries but detectIt determined it's
          // a hybrid  device, then assume it's a mouse first device
          'mouse';

          // issue with Windows Chrome on hybrid devices starting in version 59 where
          // media queries represent a touch only device, so if the browser is an
          // affected Windows Chrome version and hasTouch,
          // then assume it's a hybrid with primaryInput mouse
          // note that version 62 of Chrome fixes this issue
          // see https://github.com/rafrex/detect-it/issues/8
          var inVersionRange = function inVersionRange(version) {
            return version >= 59 && version < 62;
          };
          var isAffectedWindowsChromeVersion = /windows/.test(window.navigator.userAgent.toLowerCase()) && /chrome/.test(window.navigator.userAgent.toLowerCase()) && inVersionRange(parseInt(/Chrome\/([0-9.]+)/.exec(navigator.userAgent)[1], 10));

          if (isAffectedWindowsChromeVersion && detectIt.hasTouch) {
            detectIt.deviceType = 'hybrid';
            detectIt.hasMouse = true;
            detectIt.primaryInput = 'mouse';
          }
        }
      }
    };

    detectIt.updateOnlyOwnProperties();
    exports.default = detectIt;
    });

    var detectIt = unwrapExports(lib$4);

    let handler;

    class MouseEventTracker {
      constructor (eventManager, { eventName, nativeEventName, useWindow, preventDefault }) {
        this._eventManager = eventManager;
        this._eventName = eventName;
        this._nativeEventName = nativeEventName;
        this._useWindow = useWindow;
        this._preventDefault = preventDefault;

        this._numberOfActiveListeners = 0;
        this._callbacks = {};
      }

      addListener (listenerId, callback) {
        this._callbacks[listenerId] = callback;

        if (this._eventManagerHasBeenMounted()) {
          this._attachNativeListenerIfNecessary();
        }
      }

      attachAllListeners () {
        /* eslint-disable-next-line */
        for (const _ in this._callbacks) {
          this._attachNativeListenerIfNecessary();
        }
      }

      removeListener (listenerId) {
        delete this._callbacks[listenerId];

        if (this._eventManagerHasBeenMounted()) {
          this._removeNativeListenerIfNecessary();
        }
      }

      _eventManagerHasBeenMounted () {
        return this._eventManager._mounted
      }

      _attachNativeListenerIfNecessary () {
        if (this._numberOfActiveListeners === 0) {
          handler = this._handleEvent.bind(this);
          const nativeEventName = this._nativeEventName;

          if (this._useWindow) {
            window.addEventListener(nativeEventName, handler);
          }

          if (!this._useWindow) {
            this._eventManager._domNode.addEventListener(nativeEventName, handler);
          }
        }

        this._numberOfActiveListeners++;
      }

      _removeNativeListenerIfNecessary () {
        this._numberOfActiveListeners--;

        if (this._numberOfActiveListeners === 0) {
          const nativeEventName = this._nativeEventName;

          if (this._useWindow) {
            window.removeEventListener(nativeEventName, handler);
          }

          if (!this._useWindow) {
            this._eventManager._domNode.removeEventListener(nativeEventName, handler);
          }
        }
      }

      _handleEvent (nativeEvent) {
        if (this._preventDefault) nativeEvent.preventDefault();

        const screenCoordinates = this._getScreenCoordinates(nativeEvent);

        for (const listenerId in this._callbacks) {
          this._callbacks[listenerId](screenCoordinates, nativeEvent);
        }
      }

      _getScreenCoordinates (nativeEvent) {
        return this._eventManager._getScreenCoordinates(nativeEvent)
      }
    }

    class BaseEventManager {
      constructor (EXPOSED_EVENTS) {
        this._domNode = undefined;
        this._svgPoint = undefined;
        this._mounted = false;
        this._trackers = {};

        for (const event of EXPOSED_EVENTS) {
          this._trackers[event.eventName] = new MouseEventTracker(this, event);
        }
      }

      // Svelte can only bind to DOM nodes after initialization
      addRootNode (domNode) {
        this._domNode = domNode;
        this._svgPoint = this._domNode.createSVGPoint();
        this._mounted = true;
      }

      attachEventListeners () {
        if (this._mounted === false) throw new Error('root node must be added first')

        for (const eventName in this._trackers) {
          this._trackers[eventName].attachAllListeners();
        }
      }

      eventTracker (eventName) {
        return this._trackers[eventName]
      }
    }

    var capitalize = str => str.charAt(0).toUpperCase() + str.slice(1);

    class MouseEventManager extends BaseEventManager {
      constructor () {
        super(EXPOSED_EVENTS);
      }

      _getScreenCoordinates (nativeEvent) {
        this._svgPoint.x = nativeEvent.clientX;
        this._svgPoint.y = nativeEvent.clientY;

        return this._svgPoint.matrixTransform(this._domNode.getScreenCTM().inverse())
      }
    }

    const BROWSER_TYPE = window.navigator.pointerEnabled
      ? 'IE11 / MSEdge'
      : window.navigator.msPointerEnabled
        ? 'IE10 / WP8'
        : 'other';

    const EVENT_NAMES = ['mousedown', 'mouseup', 'mousemove', 'mouseout', 'click', 'wheel'];
    const WINDOW_EVENTS = ['mousemove', 'mouseup'];
    const PREVENT_DEFAULT = ['mousedown'];

    const EXPOSED_EVENTS = EVENT_NAMES.map(eventName => ({
      eventName,
      nativeEventName: getNativeMouseEventName(eventName),
      useWindow: WINDOW_EVENTS.includes(eventName),
      preventDefault: PREVENT_DEFAULT.includes(eventName)
    }));

    function getNativeMouseEventName (exposedEventName) {
      // 'click' has the same name in every non-mobile browser
      if (exposedEventName === 'click') return 'click'

      // 'wheel' has the same name in every non-mobile browser
      if (exposedEventName === 'wheel') return 'wheel'

      // In this non-mobile browser type, events are called 'pointerup' etc
      if (BROWSER_TYPE === 'IE11 / MSEdge') {
        const lastPart = sliceOffMouse(exposedEventName);
        return 'pointer' + lastPart
      }

      // In this non-mobile browser type, events are called 'MSPointerUp' etc
      if (BROWSER_TYPE === 'IE10 / WP8') {
        const lastPart = sliceOffMouse(exposedEventName);
        return 'MSPointer' + capitalize(lastPart)
      }

      // In other non-mobile browsers, events are called like the exposed ones
      if (BROWSER_TYPE === 'other') {
        return exposedEventName
      }
    }

    const sliceOffMouse = str => str.slice(5, str.length);

    class TouchEventManager extends BaseEventManager {
      constructor () {
        super(EXPOSED_EVENTS$1);
      }
    }

    const BROWSER_TYPE$1 = window.navigator.pointerEnabled
      ? 'IE11 / MSEdge'
      : window.navigator.msPointerEnabled
        ? 'IE10 / WP8'
        : 'other';

    const EVENT_NAMES$1 = ['touchstart', 'touchend', 'touchmove', 'touchcancel'];

    const EXPOSED_EVENTS$1 = EVENT_NAMES$1.map(eventName => ({
      eventName,
      nativeEventName: getNativeTouchEventName(eventName),
      useWindow: eventName === 'touchmove'
    }));

    function getNativeTouchEventName (exposedEventName) {
      // In this mobile browser type, events are called 'pointerup' etc
      if (BROWSER_TYPE$1 === 'IE11 / MSEdge') {
        const lastPart = sliceOffTouch(exposedEventName);
        return 'pointer' + lastPart
      }

      // In this mobile browser type, events are called 'MSPointerUp' etc
      if (BROWSER_TYPE$1 === 'IE10 / WP8') {
        const lastPart = sliceOffTouch(exposedEventName);
        return 'MSPointer' + capitalize(lastPart)
      }

      // In other mobile browsers, events are called like the exposed ones
      if (BROWSER_TYPE$1 === 'other') {
        return exposedEventName
      }
    }

    const sliceOffTouch = str => str.slice(5, str.length);

    class EventManager {
      constructor () {
        if (detectIt.hasMouse) {
          this._mouseEventManager = new MouseEventManager();
        }

        if (detectIt.hasTouch) {
          this._touchEventManager = new TouchEventManager();
        }
      }

      // Initialization
      addRootNode (domNode) {
        this._forEachManager(manager => { manager.addRootNode(domNode); });
      }

      attachEventListeners () {
        this._forEachManager(manager => { manager.attachEventListeners(); });
      }

      mouse () {
        return this._mouseEventManager
      }

      touch () {
        return this._touchEventManager
      }

      _forEachManager (callback) {
        if (this._mouseEventManager) callback(this._mouseEventManager);
        if (this._touchEventManager) callback(this._touchEventManager);
      }
    }

    class BaseInteractionManager {
      constructor () {
        this._id = undefined;
        this._eventManager = undefined;

        this._section = undefined;
        this._coordinateTransformation = undefined;
        this._zoom = undefined;

        this._markInteractionInterface = undefined;
        this._sectionInteractionInterface = undefined;
      }

      // Initialization
      setId (id) {
        this._id = id;
      }

      linkEventManager (eventManager) {
        this._eventManager = eventManager;
      }

      // Section context loading
      loadSection (sectionData) {
        this._section = sectionData;
      }

      loadCoordinateTransformation (coordinateTransformation) {
        this._coordinateTransformation = coordinateTransformation;
      }

      loadZoom (zoom) {
        this._zoom = zoom;
      }

      // Mark and layer interactions interface
      marks () {
        return this._markInteractionInterface
      }

      // Section interactions interface
      section () {
        return this._sectionInteractionInterface
      }
    }

    class BaseInteractionInterface {
      constructor (interactionManager, InteractionHandlers) {
        this._interactionManager = interactionManager;
        this._handlers = {};

        for (const handlerName in InteractionHandlers) {
          this._handlers[handlerName] = new InteractionHandlers[handlerName](this._interactionManager);
        }
      }

      _getHandler (interactionName) {
        const handlerName = interactionNameToHandlerName(interactionName);
        return this._handlers[handlerName]
      }
    }

    const interactionNameToHandlerName = interactionName => {
      return capitalize(interactionName) + 'Handler'
    };

    function indexPoint (markData) {
      const pointAttributes = markData.attributes;

      const item = calculateBBoxPoint(pointAttributes);

      item.attributes = pointAttributes;
      item.markType = 'Point';
      item.markId = markData.markId;

      return item
    }

    function indexPointLayer ({ layerAttributes, keyArray, layerId }) {
      const items = [];

      for (let i = 0; i < keyArray.length; i++) {
        const key = keyArray[i];

        const pointAttributes = getPointAttributes(layerAttributes, key);
        const item = calculateBBoxPoint(pointAttributes);

        item.key = key;
        item.index = i;
        item.attributes = pointAttributes;
        item.markType = 'Point';
        item.layerId = layerId;

        items.push(item);
      }

      return items
    }

    function calculateBBoxPoint (pointAttributes) {
      const x = pointAttributes.pixelGeometry.coordinates[0];
      const y = pointAttributes.pixelGeometry.coordinates[1];

      return {
        minX: x - pointAttributes.radius,
        maxX: x + pointAttributes.radius,
        minY: y - pointAttributes.radius,
        maxY: y + pointAttributes.radius
      }
    }

    function getPointAttributes (layerAttributes, key) {
      return {
        pixelGeometry: layerAttributes.pixelGeometryObject[key],
        radius: layerAttributes.radiusObject[key]
      }
    }

    // Adds floating point numbers with twice the normal precision.
    // Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
    // Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
    // 305–363 (1997).
    // Code adapted from GeographicLib by Charles F. F. Karney,
    // http://geographiclib.sourceforge.net/

    function adder() {
      return new Adder;
    }

    function Adder() {
      this.reset();
    }

    Adder.prototype = {
      constructor: Adder,
      reset: function() {
        this.s = // rounded value
        this.t = 0; // exact error
      },
      add: function(y) {
        add(temp, y, this.t);
        add(this, temp.s, this.s);
        if (this.s) this.t += temp.t;
        else this.s = temp.t;
      },
      valueOf: function() {
        return this.s;
      }
    };

    var temp = new Adder;

    function add(adder, a, b) {
      var x = adder.s = a + b,
          bv = x - a,
          av = x - bv;
      adder.t = (a - av) + (b - bv);
    }

    var pi = Math.PI;
    var tau = pi * 2;

    var abs = Math.abs;
    var sqrt = Math.sqrt;

    function noop$1() {}

    function streamGeometry(geometry, stream) {
      if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
        streamGeometryType[geometry.type](geometry, stream);
      }
    }

    var streamObjectType = {
      Feature: function(object, stream) {
        streamGeometry(object.geometry, stream);
      },
      FeatureCollection: function(object, stream) {
        var features = object.features, i = -1, n = features.length;
        while (++i < n) streamGeometry(features[i].geometry, stream);
      }
    };

    var streamGeometryType = {
      Sphere: function(object, stream) {
        stream.sphere();
      },
      Point: function(object, stream) {
        object = object.coordinates;
        stream.point(object[0], object[1], object[2]);
      },
      MultiPoint: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
      },
      LineString: function(object, stream) {
        streamLine(object.coordinates, stream, 0);
      },
      MultiLineString: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamLine(coordinates[i], stream, 0);
      },
      Polygon: function(object, stream) {
        streamPolygon(object.coordinates, stream);
      },
      MultiPolygon: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamPolygon(coordinates[i], stream);
      },
      GeometryCollection: function(object, stream) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while (++i < n) streamGeometry(geometries[i], stream);
      }
    };

    function streamLine(coordinates, stream, closed) {
      var i = -1, n = coordinates.length - closed, coordinate;
      stream.lineStart();
      while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
      stream.lineEnd();
    }

    function streamPolygon(coordinates, stream) {
      var i = -1, n = coordinates.length;
      stream.polygonStart();
      while (++i < n) streamLine(coordinates[i], stream, 1);
      stream.polygonEnd();
    }

    function geoStream(object, stream) {
      if (object && streamObjectType.hasOwnProperty(object.type)) {
        streamObjectType[object.type](object, stream);
      } else {
        streamGeometry(object, stream);
      }
    }

    function identity$3(x) {
      return x;
    }

    var areaSum = adder(),
        areaRingSum = adder(),
        x00,
        y00,
        x0,
        y0;

    var areaStream = {
      point: noop$1,
      lineStart: noop$1,
      lineEnd: noop$1,
      polygonStart: function() {
        areaStream.lineStart = areaRingStart;
        areaStream.lineEnd = areaRingEnd;
      },
      polygonEnd: function() {
        areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop$1;
        areaSum.add(abs(areaRingSum));
        areaRingSum.reset();
      },
      result: function() {
        var area = areaSum / 2;
        areaSum.reset();
        return area;
      }
    };

    function areaRingStart() {
      areaStream.point = areaPointFirst;
    }

    function areaPointFirst(x, y) {
      areaStream.point = areaPoint;
      x00 = x0 = x, y00 = y0 = y;
    }

    function areaPoint(x, y) {
      areaRingSum.add(y0 * x - x0 * y);
      x0 = x, y0 = y;
    }

    function areaRingEnd() {
      areaPoint(x00, y00);
    }

    var x0$1 = Infinity,
        y0$1 = x0$1,
        x1 = -x0$1,
        y1 = x1;

    var boundsStream = {
      point: boundsPoint,
      lineStart: noop$1,
      lineEnd: noop$1,
      polygonStart: noop$1,
      polygonEnd: noop$1,
      result: function() {
        var bounds = [[x0$1, y0$1], [x1, y1]];
        x1 = y1 = -(y0$1 = x0$1 = Infinity);
        return bounds;
      }
    };

    function boundsPoint(x, y) {
      if (x < x0$1) x0$1 = x;
      if (x > x1) x1 = x;
      if (y < y0$1) y0$1 = y;
      if (y > y1) y1 = y;
    }

    // TODO Enforce positive area for exterior, negative area for interior?

    var X0 = 0,
        Y0 = 0,
        Z0 = 0,
        X1 = 0,
        Y1 = 0,
        Z1 = 0,
        X2 = 0,
        Y2 = 0,
        Z2 = 0,
        x00$1,
        y00$1,
        x0$2,
        y0$2;

    var centroidStream = {
      point: centroidPoint,
      lineStart: centroidLineStart,
      lineEnd: centroidLineEnd,
      polygonStart: function() {
        centroidStream.lineStart = centroidRingStart;
        centroidStream.lineEnd = centroidRingEnd;
      },
      polygonEnd: function() {
        centroidStream.point = centroidPoint;
        centroidStream.lineStart = centroidLineStart;
        centroidStream.lineEnd = centroidLineEnd;
      },
      result: function() {
        var centroid = Z2 ? [X2 / Z2, Y2 / Z2]
            : Z1 ? [X1 / Z1, Y1 / Z1]
            : Z0 ? [X0 / Z0, Y0 / Z0]
            : [NaN, NaN];
        X0 = Y0 = Z0 =
        X1 = Y1 = Z1 =
        X2 = Y2 = Z2 = 0;
        return centroid;
      }
    };

    function centroidPoint(x, y) {
      X0 += x;
      Y0 += y;
      ++Z0;
    }

    function centroidLineStart() {
      centroidStream.point = centroidPointFirstLine;
    }

    function centroidPointFirstLine(x, y) {
      centroidStream.point = centroidPointLine;
      centroidPoint(x0$2 = x, y0$2 = y);
    }

    function centroidPointLine(x, y) {
      var dx = x - x0$2, dy = y - y0$2, z = sqrt(dx * dx + dy * dy);
      X1 += z * (x0$2 + x) / 2;
      Y1 += z * (y0$2 + y) / 2;
      Z1 += z;
      centroidPoint(x0$2 = x, y0$2 = y);
    }

    function centroidLineEnd() {
      centroidStream.point = centroidPoint;
    }

    function centroidRingStart() {
      centroidStream.point = centroidPointFirstRing;
    }

    function centroidRingEnd() {
      centroidPointRing(x00$1, y00$1);
    }

    function centroidPointFirstRing(x, y) {
      centroidStream.point = centroidPointRing;
      centroidPoint(x00$1 = x0$2 = x, y00$1 = y0$2 = y);
    }

    function centroidPointRing(x, y) {
      var dx = x - x0$2,
          dy = y - y0$2,
          z = sqrt(dx * dx + dy * dy);

      X1 += z * (x0$2 + x) / 2;
      Y1 += z * (y0$2 + y) / 2;
      Z1 += z;

      z = y0$2 * x - x0$2 * y;
      X2 += z * (x0$2 + x);
      Y2 += z * (y0$2 + y);
      Z2 += z * 3;
      centroidPoint(x0$2 = x, y0$2 = y);
    }

    function PathContext(context) {
      this._context = context;
    }

    PathContext.prototype = {
      _radius: 4.5,
      pointRadius: function(_) {
        return this._radius = _, this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0) this._context.closePath();
        this._point = NaN;
      },
      point: function(x, y) {
        switch (this._point) {
          case 0: {
            this._context.moveTo(x, y);
            this._point = 1;
            break;
          }
          case 1: {
            this._context.lineTo(x, y);
            break;
          }
          default: {
            this._context.moveTo(x + this._radius, y);
            this._context.arc(x, y, this._radius, 0, tau);
            break;
          }
        }
      },
      result: noop$1
    };

    var lengthSum = adder(),
        lengthRing,
        x00$2,
        y00$2,
        x0$3,
        y0$3;

    var lengthStream = {
      point: noop$1,
      lineStart: function() {
        lengthStream.point = lengthPointFirst;
      },
      lineEnd: function() {
        if (lengthRing) lengthPoint(x00$2, y00$2);
        lengthStream.point = noop$1;
      },
      polygonStart: function() {
        lengthRing = true;
      },
      polygonEnd: function() {
        lengthRing = null;
      },
      result: function() {
        var length = +lengthSum;
        lengthSum.reset();
        return length;
      }
    };

    function lengthPointFirst(x, y) {
      lengthStream.point = lengthPoint;
      x00$2 = x0$3 = x, y00$2 = y0$3 = y;
    }

    function lengthPoint(x, y) {
      x0$3 -= x, y0$3 -= y;
      lengthSum.add(sqrt(x0$3 * x0$3 + y0$3 * y0$3));
      x0$3 = x, y0$3 = y;
    }

    function PathString() {
      this._string = [];
    }

    PathString.prototype = {
      _radius: 4.5,
      _circle: circle(4.5),
      pointRadius: function(_) {
        if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
        return this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0) this._string.push("Z");
        this._point = NaN;
      },
      point: function(x, y) {
        switch (this._point) {
          case 0: {
            this._string.push("M", x, ",", y);
            this._point = 1;
            break;
          }
          case 1: {
            this._string.push("L", x, ",", y);
            break;
          }
          default: {
            if (this._circle == null) this._circle = circle(this._radius);
            this._string.push("M", x, ",", y, this._circle);
            break;
          }
        }
      },
      result: function() {
        if (this._string.length) {
          var result = this._string.join("");
          this._string = [];
          return result;
        } else {
          return null;
        }
      }
    };

    function circle(radius) {
      return "m0," + radius
          + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
          + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
          + "z";
    }

    function geoPath(projection, context) {
      var pointRadius = 4.5,
          projectionStream,
          contextStream;

      function path(object) {
        if (object) {
          if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
          geoStream(object, projectionStream(contextStream));
        }
        return contextStream.result();
      }

      path.area = function(object) {
        geoStream(object, projectionStream(areaStream));
        return areaStream.result();
      };

      path.measure = function(object) {
        geoStream(object, projectionStream(lengthStream));
        return lengthStream.result();
      };

      path.bounds = function(object) {
        geoStream(object, projectionStream(boundsStream));
        return boundsStream.result();
      };

      path.centroid = function(object) {
        geoStream(object, projectionStream(centroidStream));
        return centroidStream.result();
      };

      path.projection = function(_) {
        return arguments.length ? (projectionStream = _ == null ? (projection = null, identity$3) : (projection = _).stream, path) : projection;
      };

      path.context = function(_) {
        if (!arguments.length) return context;
        contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
        if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
        return path;
      };

      path.pointRadius = function(_) {
        if (!arguments.length) return pointRadius;
        pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
        return path;
      };

      return path.projection(projection).context(context);
    }

    function calculateBBoxGeometry (geometry) {
      const bbox = path.bounds(geometry);

      const bboxObj = {
        x: [bbox[0][0], bbox[1][0]],
        y: [bbox[0][1], bbox[1][1]]
      };

      return bboxObj
    }

    const path = geoPath();

    function isLinearRing (ring) {
      return ring.constructor === Array
    }

    function isPolygon (geometry) {
      return geometry.constructor === Object && geometry.type === 'Polygon'
    }

    function isMultiPolygon (geometry) {
      return geometry.constructor === Object && geometry.type === 'MultiPolygon'
    }

    function isLineString (geometry) {
      return geometry.constructor === Object && geometry.type === 'LineString'
    }

    function isMultiLineString (geometry) {
      return geometry.constructor === Object && geometry.type === 'MultiLineString'
    }

    function polygonArea (polygon) {
      if (isLinearRing(polygon)) {
        return getRingArea(polygon)
      }

      if (isPolygon(polygon)) {
        return getPolygonArea(polygon)
      }

      if (isMultiPolygon(polygon)) {
        return getMultiPolygonArea(polygon)
      }

      throw new Error('Invalid input')
    }

    function linearRingIsClockwise (ring) {
      return getSignedRingArea(ring) < 0
    }

    function getRingArea (ring) {
      return Math.abs(getSignedRingArea(ring))
    }

    // Taken from: https://stackoverflow.com/a/33670691/7237112
    function getSignedRingArea (ring) {
      let total = 0;

      for (let i = 0, l = ring.length; i < l; i++) {
        const addX = ring[i][0];
        const addY = ring[i === ring.length - 1 ? 0 : i + 1][1];
        const subX = ring[i === ring.length - 1 ? 0 : i + 1][0];
        const subY = ring[i][1];

        total += (addX * addY * 0.5);
        total -= (subX * subY * 0.5);
      }

      return total
    }

    function getPolygonArea (polygon) {
      let totalArea = getRingArea(polygon.coordinates[0]);

      for (let i = 1; i < polygon.coordinates.length; i++) {
        const holeArea = getRingArea(polygon.coordinates[i]);
        totalArea -= holeArea;
      }

      return totalArea
    }

    function getMultiPolygonArea (multiPolygon) {
      let totalArea = 0;

      for (let i = 0; i < multiPolygon.coordinates.length; i++) {
        totalArea += getPolygonArea(multiPolygon.coordinates[i]);
      }

      return totalArea
    }

    function pointDistance (point1, point2) {
      return Math.sqrt(
        (point1[0] - point2[0]) ** 2 +
        (point1[1] - point2[1]) ** 2
      )
    }

    function linearRingLength (linearRing) {
      let totalLength = 0;

      for (let i = 0; i < linearRing.length - 1; i++) {
        const from = linearRing[i];
        const to = linearRing[i + 1];

        totalLength += pointDistance(from, to);
      }

      return totalLength
    }

    function calculateCentroid (geometry) {
      if (isLinearRing(geometry)) {
        return calculateLinearRingCentroid(geometry)
      }

      if (isPolygon(geometry)) {
        return calculatePolygonCentroid(geometry)
      }

      if (isMultiPolygon(geometry)) {
        return calculateMultiPolygonCentroid(geometry)
      }

      if (isLineString(geometry)) {
        return calculateLineStringCentroid(geometry)
      }

      if (isMultiLineString(geometry)) {
        return calculateMultiLineStringCentroid(geometry)
      }
    }

    // https://stackoverflow.com/a/33852627/7237112
    function calculateLinearRingCentroid (ring) {
      const nPts = ring.length;
      const off = ring[0];
      let twicearea = 0;
      let x = 0;
      let y = 0;
      let p1;
      let p2;
      let f;

      for (let i = 0, j = nPts - 1; i < nPts; j = i++) {
        p1 = ring[i];
        p2 = ring[j];
        f = (p1[0] - off[0]) * (p2[1] - off[1]) - (p2[0] - off[0]) * (p1[1] - off[1]);
        twicearea += f;
        x += (p1[0] + p2[0] - 2 * off[0]) * f;
        y += (p1[1] + p2[1] - 2 * off[1]) * f;
      }

      f = twicearea * 3;

      return [x / f + off[0], y / f + off[1]]
    }

    function calculatePolygonCentroid (polygon) {
      // We will ignore holes and just take the outer ring
      return calculateLinearRingCentroid(polygon.coordinates[0])
    }

    function calculateMultiPolygonCentroid (multiPolygon) {
      // We will take the centroid of each polygon (ignoring holes)
      // and take the weighted (by area) center of these.
      let x = 0;
      let y = 0;
      let totalArea = 0;

      for (let i = 0; i < multiPolygon.coordinates.length; i++) {
        const polygon = multiPolygon.coordinates[i];
        const polygonCentroid = calculateLinearRingCentroid(polygon[0]);
        const area = polygonArea(polygon[0]);

        x += polygonCentroid[0] * area;
        y += polygonCentroid[1] * area;
        totalArea += area;
      }

      return [x / totalArea, y / totalArea]
    }

    function calculateLineStringCentroid (lineString) {
      return calculateLinearRingCentroid(lineString.coordinates)
    }

    function calculateMultiLineStringCentroid (multiLineString) {
      // We will take the centroid of each LineString
      // and take the weighted (by length) center of these.
      let x = 0;
      let y = 0;
      let totalLength = 0;

      for (let i = 0; i < multiLineString.coordinates.length; i++) {
        const lineString = multiLineString.coordinates[i];
        const lineStringCentroid = calculateLinearRingCentroid(lineString);
        const length = linearRingLength(lineString);

        x += lineStringCentroid[0] * length;
        y += lineStringCentroid[1] * length;
        totalLength += length;
      }

      return [x / totalLength, y / totalLength]
    }

    function pointIntersectsLineSegment (point, lineSegment, lineWidth) {
      const distance = distanceClosestPointOnLineSegment(point, lineSegment);

      return distance < (lineWidth / 2)
    }

    function distanceClosestPointOnLineSegment (point, lineSegment) {
      const closestPoint = closestPointOnLineSegment(point, lineSegment);
      return pointDistance(point, closestPoint)
    }

    // https://stackoverflow.com/a/6853926/7237112
    function closestPointOnLineSegment (point, lineSegment) {
      // Point coordinates
      const x = point[0];
      const y = point[1];

      // Line segment coordinates
      const x1 = lineSegment[0][0];
      const y1 = lineSegment[0][1];
      const x2 = lineSegment[1][0];
      const y2 = lineSegment[1][1];

      const A = x - x1;
      const B = y - y1;
      const C = x2 - x1;
      const D = y2 - y1;

      const dot = A * C + B * D;
      const lengthSquared = C * C + D * D;
      let param = -1;
      if (lengthSquared !== 0) { // in case of 0 length line
        param = dot / lengthSquared;
      }

      let xx, yy;

      if (param < 0) {
        xx = x1;
        yy = y1;
      } else if (param > 1) {
        xx = x2;
        yy = y2;
      } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
      }

      return [xx, yy]
    }

    var twoProduct_1 = twoProduct;

    var SPLITTER = +(Math.pow(2, 27) + 1.0);

    function twoProduct(a, b, result) {
      var x = a * b;

      var c = SPLITTER * a;
      var abig = c - a;
      var ahi = c - abig;
      var alo = a - ahi;

      var d = SPLITTER * b;
      var bbig = d - b;
      var bhi = d - bbig;
      var blo = b - bhi;

      var err1 = x - (ahi * bhi);
      var err2 = err1 - (alo * bhi);
      var err3 = err2 - (ahi * blo);

      var y = alo * blo - err3;

      if(result) {
        result[0] = y;
        result[1] = x;
        return result
      }

      return [ y, x ]
    }

    var robustSum = linearExpansionSum;

    //Easy case: Add two scalars
    function scalarScalar(a, b) {
      var x = a + b;
      var bv = x - a;
      var av = x - bv;
      var br = b - bv;
      var ar = a - av;
      var y = ar + br;
      if(y) {
        return [y, x]
      }
      return [x]
    }

    function linearExpansionSum(e, f) {
      var ne = e.length|0;
      var nf = f.length|0;
      if(ne === 1 && nf === 1) {
        return scalarScalar(e[0], f[0])
      }
      var n = ne + nf;
      var g = new Array(n);
      var count = 0;
      var eptr = 0;
      var fptr = 0;
      var abs = Math.abs;
      var ei = e[eptr];
      var ea = abs(ei);
      var fi = f[fptr];
      var fa = abs(fi);
      var a, b;
      if(ea < fa) {
        b = ei;
        eptr += 1;
        if(eptr < ne) {
          ei = e[eptr];
          ea = abs(ei);
        }
      } else {
        b = fi;
        fptr += 1;
        if(fptr < nf) {
          fi = f[fptr];
          fa = abs(fi);
        }
      }
      if((eptr < ne && ea < fa) || (fptr >= nf)) {
        a = ei;
        eptr += 1;
        if(eptr < ne) {
          ei = e[eptr];
          ea = abs(ei);
        }
      } else {
        a = fi;
        fptr += 1;
        if(fptr < nf) {
          fi = f[fptr];
          fa = abs(fi);
        }
      }
      var x = a + b;
      var bv = x - a;
      var y = b - bv;
      var q0 = y;
      var q1 = x;
      var _x, _bv, _av, _br, _ar;
      while(eptr < ne && fptr < nf) {
        if(ea < fa) {
          a = ei;
          eptr += 1;
          if(eptr < ne) {
            ei = e[eptr];
            ea = abs(ei);
          }
        } else {
          a = fi;
          fptr += 1;
          if(fptr < nf) {
            fi = f[fptr];
            fa = abs(fi);
          }
        }
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if(y) {
          g[count++] = y;
        }
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
      }
      while(eptr < ne) {
        a = ei;
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if(y) {
          g[count++] = y;
        }
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        eptr += 1;
        if(eptr < ne) {
          ei = e[eptr];
        }
      }
      while(fptr < nf) {
        a = fi;
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if(y) {
          g[count++] = y;
        } 
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        fptr += 1;
        if(fptr < nf) {
          fi = f[fptr];
        }
      }
      if(q0) {
        g[count++] = q0;
      }
      if(q1) {
        g[count++] = q1;
      }
      if(!count) {
        g[count++] = 0.0;  
      }
      g.length = count;
      return g
    }

    var twoSum = fastTwoSum;

    function fastTwoSum(a, b, result) {
    	var x = a + b;
    	var bv = x - a;
    	var av = x - bv;
    	var br = b - bv;
    	var ar = a - av;
    	if(result) {
    		result[0] = ar + br;
    		result[1] = x;
    		return result
    	}
    	return [ar+br, x]
    }

    var robustScale = scaleLinearExpansion;

    function scaleLinearExpansion(e, scale) {
      var n = e.length;
      if(n === 1) {
        var ts = twoProduct_1(e[0], scale);
        if(ts[0]) {
          return ts
        }
        return [ ts[1] ]
      }
      var g = new Array(2 * n);
      var q = [0.1, 0.1];
      var t = [0.1, 0.1];
      var count = 0;
      twoProduct_1(e[0], scale, q);
      if(q[0]) {
        g[count++] = q[0];
      }
      for(var i=1; i<n; ++i) {
        twoProduct_1(e[i], scale, t);
        var pq = q[1];
        twoSum(pq, t[0], q);
        if(q[0]) {
          g[count++] = q[0];
        }
        var a = t[1];
        var b = q[1];
        var x = a + b;
        var bv = x - a;
        var y = b - bv;
        q[1] = x;
        if(y) {
          g[count++] = y;
        }
      }
      if(q[1]) {
        g[count++] = q[1];
      }
      if(count === 0) {
        g[count++] = 0.0;
      }
      g.length = count;
      return g
    }

    var robustDiff = robustSubtract;

    //Easy case: Add two scalars
    function scalarScalar$1(a, b) {
      var x = a + b;
      var bv = x - a;
      var av = x - bv;
      var br = b - bv;
      var ar = a - av;
      var y = ar + br;
      if(y) {
        return [y, x]
      }
      return [x]
    }

    function robustSubtract(e, f) {
      var ne = e.length|0;
      var nf = f.length|0;
      if(ne === 1 && nf === 1) {
        return scalarScalar$1(e[0], -f[0])
      }
      var n = ne + nf;
      var g = new Array(n);
      var count = 0;
      var eptr = 0;
      var fptr = 0;
      var abs = Math.abs;
      var ei = e[eptr];
      var ea = abs(ei);
      var fi = -f[fptr];
      var fa = abs(fi);
      var a, b;
      if(ea < fa) {
        b = ei;
        eptr += 1;
        if(eptr < ne) {
          ei = e[eptr];
          ea = abs(ei);
        }
      } else {
        b = fi;
        fptr += 1;
        if(fptr < nf) {
          fi = -f[fptr];
          fa = abs(fi);
        }
      }
      if((eptr < ne && ea < fa) || (fptr >= nf)) {
        a = ei;
        eptr += 1;
        if(eptr < ne) {
          ei = e[eptr];
          ea = abs(ei);
        }
      } else {
        a = fi;
        fptr += 1;
        if(fptr < nf) {
          fi = -f[fptr];
          fa = abs(fi);
        }
      }
      var x = a + b;
      var bv = x - a;
      var y = b - bv;
      var q0 = y;
      var q1 = x;
      var _x, _bv, _av, _br, _ar;
      while(eptr < ne && fptr < nf) {
        if(ea < fa) {
          a = ei;
          eptr += 1;
          if(eptr < ne) {
            ei = e[eptr];
            ea = abs(ei);
          }
        } else {
          a = fi;
          fptr += 1;
          if(fptr < nf) {
            fi = -f[fptr];
            fa = abs(fi);
          }
        }
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if(y) {
          g[count++] = y;
        }
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
      }
      while(eptr < ne) {
        a = ei;
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if(y) {
          g[count++] = y;
        }
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        eptr += 1;
        if(eptr < ne) {
          ei = e[eptr];
        }
      }
      while(fptr < nf) {
        a = fi;
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if(y) {
          g[count++] = y;
        } 
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        fptr += 1;
        if(fptr < nf) {
          fi = -f[fptr];
        }
      }
      if(q0) {
        g[count++] = q0;
      }
      if(q1) {
        g[count++] = q1;
      }
      if(!count) {
        g[count++] = 0.0;  
      }
      g.length = count;
      return g
    }

    var orientation_1 = createCommonjsModule(function (module) {






    var NUM_EXPAND = 5;

    var EPSILON     = 1.1102230246251565e-16;
    var ERRBOUND3   = (3.0 + 16.0 * EPSILON) * EPSILON;
    var ERRBOUND4   = (7.0 + 56.0 * EPSILON) * EPSILON;

    function cofactor(m, c) {
      var result = new Array(m.length-1);
      for(var i=1; i<m.length; ++i) {
        var r = result[i-1] = new Array(m.length-1);
        for(var j=0,k=0; j<m.length; ++j) {
          if(j === c) {
            continue
          }
          r[k++] = m[i][j];
        }
      }
      return result
    }

    function matrix(n) {
      var result = new Array(n);
      for(var i=0; i<n; ++i) {
        result[i] = new Array(n);
        for(var j=0; j<n; ++j) {
          result[i][j] = ["m", j, "[", (n-i-1), "]"].join("");
        }
      }
      return result
    }

    function sign(n) {
      if(n & 1) {
        return "-"
      }
      return ""
    }

    function generateSum(expr) {
      if(expr.length === 1) {
        return expr[0]
      } else if(expr.length === 2) {
        return ["sum(", expr[0], ",", expr[1], ")"].join("")
      } else {
        var m = expr.length>>1;
        return ["sum(", generateSum(expr.slice(0, m)), ",", generateSum(expr.slice(m)), ")"].join("")
      }
    }

    function determinant(m) {
      if(m.length === 2) {
        return [["sum(prod(", m[0][0], ",", m[1][1], "),prod(-", m[0][1], ",", m[1][0], "))"].join("")]
      } else {
        var expr = [];
        for(var i=0; i<m.length; ++i) {
          expr.push(["scale(", generateSum(determinant(cofactor(m, i))), ",", sign(i), m[0][i], ")"].join(""));
        }
        return expr
      }
    }

    function orientation(n) {
      var pos = [];
      var neg = [];
      var m = matrix(n);
      var args = [];
      for(var i=0; i<n; ++i) {
        if((i&1)===0) {
          pos.push.apply(pos, determinant(cofactor(m, i)));
        } else {
          neg.push.apply(neg, determinant(cofactor(m, i)));
        }
        args.push("m" + i);
      }
      var posExpr = generateSum(pos);
      var negExpr = generateSum(neg);
      var funcName = "orientation" + n + "Exact";
      var code = ["function ", funcName, "(", args.join(), "){var p=", posExpr, ",n=", negExpr, ",d=sub(p,n);\
return d[d.length-1];};return ", funcName].join("");
      var proc = new Function("sum", "prod", "scale", "sub", code);
      return proc(robustSum, twoProduct_1, robustScale, robustDiff)
    }

    var orientation3Exact = orientation(3);
    var orientation4Exact = orientation(4);

    var CACHED = [
      function orientation0() { return 0 },
      function orientation1() { return 0 },
      function orientation2(a, b) { 
        return b[0] - a[0]
      },
      function orientation3(a, b, c) {
        var l = (a[1] - c[1]) * (b[0] - c[0]);
        var r = (a[0] - c[0]) * (b[1] - c[1]);
        var det = l - r;
        var s;
        if(l > 0) {
          if(r <= 0) {
            return det
          } else {
            s = l + r;
          }
        } else if(l < 0) {
          if(r >= 0) {
            return det
          } else {
            s = -(l + r);
          }
        } else {
          return det
        }
        var tol = ERRBOUND3 * s;
        if(det >= tol || det <= -tol) {
          return det
        }
        return orientation3Exact(a, b, c)
      },
      function orientation4(a,b,c,d) {
        var adx = a[0] - d[0];
        var bdx = b[0] - d[0];
        var cdx = c[0] - d[0];
        var ady = a[1] - d[1];
        var bdy = b[1] - d[1];
        var cdy = c[1] - d[1];
        var adz = a[2] - d[2];
        var bdz = b[2] - d[2];
        var cdz = c[2] - d[2];
        var bdxcdy = bdx * cdy;
        var cdxbdy = cdx * bdy;
        var cdxady = cdx * ady;
        var adxcdy = adx * cdy;
        var adxbdy = adx * bdy;
        var bdxady = bdx * ady;
        var det = adz * (bdxcdy - cdxbdy) 
                + bdz * (cdxady - adxcdy)
                + cdz * (adxbdy - bdxady);
        var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz)
                      + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz)
                      + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz);
        var tol = ERRBOUND4 * permanent;
        if ((det > tol) || (-det > tol)) {
          return det
        }
        return orientation4Exact(a,b,c,d)
      }
    ];

    function slowOrient(args) {
      var proc = CACHED[args.length];
      if(!proc) {
        proc = CACHED[args.length] = orientation(args.length);
      }
      return proc.apply(undefined, args)
    }

    function generateOrientationProc() {
      while(CACHED.length <= NUM_EXPAND) {
        CACHED.push(orientation(CACHED.length));
      }
      var args = [];
      var procArgs = ["slow"];
      for(var i=0; i<=NUM_EXPAND; ++i) {
        args.push("a" + i);
        procArgs.push("o" + i);
      }
      var code = [
        "function getOrientation(", args.join(), "){switch(arguments.length){case 0:case 1:return 0;"
      ];
      for(var i=2; i<=NUM_EXPAND; ++i) {
        code.push("case ", i, ":return o", i, "(", args.slice(0, i).join(), ");");
      }
      code.push("}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation");
      procArgs.push(code.join(""));

      var proc = Function.apply(undefined, procArgs);
      module.exports = proc.apply(undefined, [slowOrient].concat(CACHED));
      for(var i=0; i<=NUM_EXPAND; ++i) {
        module.exports[i] = CACHED[i];
      }
    }

    generateOrientationProc();
    });

    var robustPnp = robustPointInPolygon;



    function robustPointInPolygon(vs, point) {
      var x = point[0];
      var y = point[1];
      var n = vs.length;
      var inside = 1;
      var lim = n;
      for(var i = 0, j = n-1; i<lim; j=i++) {
        var a = vs[i];
        var b = vs[j];
        var yi = a[1];
        var yj = b[1];
        if(yj < yi) {
          if(yj < y && y < yi) {
            var s = orientation_1(a, b, point);
            if(s === 0) {
              return 0
            } else {
              inside ^= (0 < s)|0;
            }
          } else if(y === yi) {
            var c = vs[(i+1)%n];
            var yk = c[1];
            if(yi < yk) {
              var s = orientation_1(a, b, point);
              if(s === 0) {
                return 0
              } else {
                inside ^= (0 < s)|0;
              }
            }
          }
        } else if(yi < yj) {
          if(yi < y && y < yj) {
            var s = orientation_1(a, b, point);
            if(s === 0) {
              return 0
            } else {
              inside ^= (s < 0)|0;
            }
          } else if(y === yi) {
            var c = vs[(i+1)%n];
            var yk = c[1];
            if(yk < yi) {
              var s = orientation_1(a, b, point);
              if(s === 0) {
                return 0
              } else {
                inside ^= (s < 0)|0;
              }
            }
          }
        } else if(y === yi) {
          var x0 = Math.min(a[0], b[0]);
          var x1 = Math.max(a[0], b[0]);
          if(i === 0) {
            while(j>0) {
              var k = (j+n-1)%n;
              var p = vs[k];
              if(p[1] !== y) {
                break
              }
              var px = p[0];
              x0 = Math.min(x0, px);
              x1 = Math.max(x1, px);
              j = k;
            }
            if(j === 0) {
              if(x0 <= x && x <= x1) {
                return 0
              }
              return 1 
            }
            lim = j+1;
          }
          var y0 = vs[(j+n-1)%n][1];
          while(i+1<lim) {
            var p = vs[i+1];
            if(p[1] !== y) {
              break
            }
            var px = p[0];
            x0 = Math.min(x0, px);
            x1 = Math.max(x1, px);
            i += 1;
          }
          if(x0 <= x && x <= x1) {
            return 0
          }
          var y1 = vs[(i+1)%n][1];
          if(x < x0 && (y0 < y !== y1 < y)) {
            inside ^= 1;
          }
        }
      }
      return 2 * inside - 1
    }

    function pointInPolygon (point, geometry) {
      switch (geometry.type) {
        case 'Polygon': return pointInPolygon$1(point, geometry)
        case 'MultiPolygon': return pointInMultiPolygon(point, geometry)
      }
    }

    function pointInPolygon$1 (point, geometry) {
      const coordinates = geometry.coordinates;
      return pointInPolygonCoordinates(point, coordinates)
    }

    function pointInPolygonCoordinates (point, coordinates) {
      const outerRing = coordinates[0];

      if (!pointInRing(point, outerRing)) return false

      for (let i = 1; i < coordinates.length; i++) {
        const hole = coordinates[i];

        if (pointInRing(point, hole)) return false
      }

      return true
    }

    function pointInMultiPolygon (point, geometry) {
      const coordinates = geometry.coordinates;

      for (let i = 0; i < coordinates.length; i++) {
        const polygonCoordinates = coordinates[i];

        if (pointInPolygonCoordinates(point, polygonCoordinates)) return true
      }

      return false
    }

    function pointInRing (point, coordinates) {
      return robustPnp(coordinates, point) === -1
    }

    // This function comes from Turf's wonderful geospatial lib
    // We only need this single function and importing it from @turf/meta
    // doesn't work well for in-browser compilation
    // https://github.com/Turfjs/turf

    // The MIT License (MIT)

    // Copyright (c) 2019 Morgan Herlocker

    // Permission is hereby granted, free of charge, to any person obtaining a copy of
    // this software and associated documentation files (the "Software"), to deal in
    // the Software without restriction, including without limitation the rights to
    // use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
    // the Software, and to permit persons to whom the Software is furnished to do so,
    // subject to the following conditions:

    // The above copyright notice and this permission notice shall be included in all
    // copies or substantial portions of the Software.

    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
    // FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
    // COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
    // IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    // CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

    function coordEach (geojson, callback, excludeWrapCoord) {
      // Handles null Geometry -- Skips this GeoJSON
      if (geojson === null) return
      var j; var k; var l; var geometry; var stopG; var coords;
      var geometryMaybeCollection;
      var wrapShrink = 0;
      var coordIndex = 0;
      var isGeometryCollection;
      var type = geojson.type;
      var isFeatureCollection = type === 'FeatureCollection';
      var isFeature = type === 'Feature';
      var stop = isFeatureCollection ? geojson.features.length : 1;

      // This logic may look a little weird. The reason why it is that way
      // is because it's trying to be fast. GeoJSON supports multiple kinds
      // of objects at its root: FeatureCollection, Features, Geometries.
      // This function has the responsibility of handling all of them, and that
      // means that some of the `for` loops you see below actually just don't apply
      // to certain inputs. For instance, if you give this just a
      // Point geometry, then both loops are short-circuited and all we do
      // is gradually rename the input until it's called 'geometry'.
      //
      // This also aims to allocate as few resources as possible: just a
      // few numbers and booleans, rather than any temporary arrays as would
      // be required with the normalization approach.
      for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry
          : (isFeature ? geojson.geometry : geojson));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
          var multiFeatureIndex = 0;
          var geometryIndex = 0;
          geometry = isGeometryCollection
            ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;

          // Handles null Geometry -- Skips this geometry
          if (geometry === null) continue
          coords = geometry.coordinates;
          var geomType = geometry.type;

          wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

          switch (geomType) {
            case null:
              break
            case 'Point':
              if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false
              coordIndex++;
              multiFeatureIndex++;
              break
            case 'LineString':
            case 'MultiPoint':
              for (j = 0; j < coords.length; j++) {
                if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false
                coordIndex++;
                if (geomType === 'MultiPoint') multiFeatureIndex++;
              }
              if (geomType === 'LineString') multiFeatureIndex++;
              break
            case 'Polygon':
            case 'MultiLineString':
              for (j = 0; j < coords.length; j++) {
                for (k = 0; k < coords[j].length - wrapShrink; k++) {
                  if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false
                  coordIndex++;
                }
                if (geomType === 'MultiLineString') multiFeatureIndex++;
                if (geomType === 'Polygon') geometryIndex++;
              }
              if (geomType === 'Polygon') multiFeatureIndex++;
              break
            case 'MultiPolygon':
              for (j = 0; j < coords.length; j++) {
                geometryIndex = 0;
                for (k = 0; k < coords[j].length; k++) {
                  for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                    if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false
                    coordIndex++;
                  }
                  geometryIndex++;
                }
                multiFeatureIndex++;
              }
              break
            case 'GeometryCollection':
              for (j = 0; j < geometry.geometries.length; j++) { if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false }
              break
            default:
              throw new Error('Unknown Geometry Type')
          }
        }
      }
    }

    function scaleGeometries (geometries, { scaleX, scaleY }) {
      const transformFunc = position => [scaleX(position[0]), scaleY(position[1])];

      return transformGeometries(geometries, transformFunc)
    }

    function transformGeometries (geometries, transformFunc) {
      const geometriesClone = JSON.parse(JSON.stringify(geometries));

      if (geometriesClone.constructor === Array) {
        for (let i = 0; i < geometriesClone.length; i++) {
          transformGeometryInplace(geometriesClone[i], transformFunc);
        }
      }

      if (geometriesClone.constructor === Object) {
        for (const key in geometriesClone) {
          transformGeometryInplace(geometriesClone[key], transformFunc);
        }
      }

      return geometriesClone
    }

    function scaleGeometry (geometry, { scaleX, scaleY }) {
      const transformFunc = position => [scaleX(position[0]), scaleY(position[1])];
      const geometryClone = JSON.parse(JSON.stringify(geometry));
      transformGeometryInplace(geometryClone, transformFunc);

      return geometryClone
    }

    function transformGeometry (geometry, transformFunc) {
      const geometryClone = JSON.parse(JSON.stringify(geometry));
      transformGeometryInplace(geometryClone, transformFunc);

      return geometryClone
    }

    function transformGeometryInplace (geometry, transformFunc) {
      coordEach(geometry, coord => {
        const transformedPosition = transformFunc(coord);
        coord[0] = transformedPosition[0];
        coord[1] = transformedPosition[1];
      });
    }

    function interpolateRing (points, transformFunc, visibilityTreshold) {
      const interpolatedPoints = [];

      let from;
      let to;

      for (let i = 0; i < points.length - 1; i++) {
        const j = i + 1;

        from = points[i];
        to = points[j];

        interpolatePointPair(from, to, transformFunc, visibilityTreshold, interpolatedPoints);
      }

      interpolatedPoints.push(transformFunc(to));

      return interpolatedPoints
    }

    function interpolatePointPair (from, to, transformFunc, treshold, resampledPoints) {
      if (interpolationBetweenPointsNecessary(from, to, transformFunc, treshold)) {
        const midPoint = interpolateNPoints(from, to, 1)[0];

        interpolatePointPair(from, midPoint, transformFunc, treshold, resampledPoints);
        interpolatePointPair(midPoint, to, transformFunc, treshold, resampledPoints);
      } else {
        const transformedFrom = transformFunc(from);
        resampledPoints.push(transformedFrom);
      }
    }

    function interpolateNPoints (from, to, numberOfPoints) {
      const interpolator = interpolateArray(from, to);
      const points = [];

      for (let i = 1; i < numberOfPoints + 1; i++) {
        const fraction = 1 / (numberOfPoints + 1) * i;
        points.push(interpolator(fraction));
      }

      return points
    }

    function interpolationBetweenPointsNecessary (from, to, transformFunc, treshold) {
      // We will sample two points between 'from' and' to' and put all 4 points in an Array.
      const pointsInBetween = interpolateNPoints(from, to, 2);
      const pointsPlusPointsInBetween = [from, ...pointsInBetween, to];
      const transformedPoints = pointsPlusPointsInBetween.map(transformFunc);

      // If the transformed points are really close together, we can skip the interpolation
      if (pointsCloseTogether(transformedPoints, treshold)) return false

      // If all the points are on the same line, we will also skip the interpolation
      if (pointsOnOneLine(transformedPoints, treshold)) return false

      return true
    }

    function pointsCloseTogether (points, treshold) {
      const firstPoint = points[0];
      const secondPoint = points[1];
      const lastPoint = points[points.length - 1];

      return pointDistance(firstPoint, lastPoint) < treshold &&
        pointDistance(secondPoint, lastPoint < treshold)
    }

    function pointsOnOneLine (points, treshold) {
      const firstPoint = points[0];
      const secondPoint = points[1];
      const thirdPoint = points[2];
      const lastPoint = points[points.length - 1];

      const lineSegment = [firstPoint, lastPoint];

      return pointIntersectsLineSegment(secondPoint, lineSegment, treshold) &&
        pointIntersectsLineSegment(thirdPoint, lineSegment, treshold)
    }

    function interpolateGeometry (geometry, transformFunc, visibilityTreshold = 1) {
      switch (geometry.type) {
        case 'LineString': return interpolateLineString(geometry, transformFunc, visibilityTreshold)
        case 'Polygon': return interpolatePolygon(geometry, transformFunc, visibilityTreshold)
        case 'MultiPolygon': return interpolateMultiPolygon(geometry, transformFunc, visibilityTreshold)
      }
    }

    function interpolateLineString (geometry, transformFunc, visibilityTreshold) {
      const coordinates = geometry.coordinates;
      const interpolatedCoordinates = interpolateRing(coordinates, transformFunc, visibilityTreshold);

      return {
        type: 'LineString',
        coordinates: interpolatedCoordinates
      }
    }

    function interpolatePolygon (geometry, transformFunc, visibilityTreshold) {
      const coordinates = geometry.coordinates;
      const interpolatedCoordinates = [];

      for (let i = 0; i < coordinates.length; i++) {
        const ring = coordinates[i];
        const interpolatedRing = interpolateRing(ring, transformFunc, visibilityTreshold);
        interpolatedCoordinates.push(interpolatedRing);
      }

      return {
        type: 'Polygon',
        coordinates: interpolatedCoordinates
      }
    }

    function interpolateMultiPolygon (geometry, transformFunc, visibilityTreshold) {
      const coordinates = geometry.coordinates;
      const interpolatedCoordinates = [];

      for (let i = 0; i < coordinates.length; i++) {
        const polygon = coordinates[i];
        const interpolatedPolygon = [];

        for (let j = 0; j < polygon.length; j++) {
          const ring = polygon[j];
          const interpolatedRing = interpolateRing(ring, transformFunc, visibilityTreshold);
          interpolatedPolygon.push(interpolatedRing);
        }

        interpolatedCoordinates.push(interpolatedPolygon);
      }

      return {
        type: 'MultiPolygon',
        coordinates: interpolatedCoordinates
      }
    }

    var transshape_umd = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
       factory(exports) ;
    }(commonjsGlobal, function (exports) {
      function define(constructor, factory, prototype) {
        constructor.prototype = factory.prototype = prototype;
        prototype.constructor = constructor;
      }

      function extend(parent, definition) {
        var prototype = Object.create(parent.prototype);
        for (var key in definition) prototype[key] = definition[key];
        return prototype;
      }

      function Color() {}

      var darker = 0.7;
      var brighter = 1 / darker;

      var reI = "\\s*([+-]?\\d+)\\s*",
          reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
          reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
          reHex3 = /^#([0-9a-f]{3})$/,
          reHex6 = /^#([0-9a-f]{6})$/,
          reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
          reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
          reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
          reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
          reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
          reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

      var named = {
        aliceblue: 0xf0f8ff,
        antiquewhite: 0xfaebd7,
        aqua: 0x00ffff,
        aquamarine: 0x7fffd4,
        azure: 0xf0ffff,
        beige: 0xf5f5dc,
        bisque: 0xffe4c4,
        black: 0x000000,
        blanchedalmond: 0xffebcd,
        blue: 0x0000ff,
        blueviolet: 0x8a2be2,
        brown: 0xa52a2a,
        burlywood: 0xdeb887,
        cadetblue: 0x5f9ea0,
        chartreuse: 0x7fff00,
        chocolate: 0xd2691e,
        coral: 0xff7f50,
        cornflowerblue: 0x6495ed,
        cornsilk: 0xfff8dc,
        crimson: 0xdc143c,
        cyan: 0x00ffff,
        darkblue: 0x00008b,
        darkcyan: 0x008b8b,
        darkgoldenrod: 0xb8860b,
        darkgray: 0xa9a9a9,
        darkgreen: 0x006400,
        darkgrey: 0xa9a9a9,
        darkkhaki: 0xbdb76b,
        darkmagenta: 0x8b008b,
        darkolivegreen: 0x556b2f,
        darkorange: 0xff8c00,
        darkorchid: 0x9932cc,
        darkred: 0x8b0000,
        darksalmon: 0xe9967a,
        darkseagreen: 0x8fbc8f,
        darkslateblue: 0x483d8b,
        darkslategray: 0x2f4f4f,
        darkslategrey: 0x2f4f4f,
        darkturquoise: 0x00ced1,
        darkviolet: 0x9400d3,
        deeppink: 0xff1493,
        deepskyblue: 0x00bfff,
        dimgray: 0x696969,
        dimgrey: 0x696969,
        dodgerblue: 0x1e90ff,
        firebrick: 0xb22222,
        floralwhite: 0xfffaf0,
        forestgreen: 0x228b22,
        fuchsia: 0xff00ff,
        gainsboro: 0xdcdcdc,
        ghostwhite: 0xf8f8ff,
        gold: 0xffd700,
        goldenrod: 0xdaa520,
        gray: 0x808080,
        green: 0x008000,
        greenyellow: 0xadff2f,
        grey: 0x808080,
        honeydew: 0xf0fff0,
        hotpink: 0xff69b4,
        indianred: 0xcd5c5c,
        indigo: 0x4b0082,
        ivory: 0xfffff0,
        khaki: 0xf0e68c,
        lavender: 0xe6e6fa,
        lavenderblush: 0xfff0f5,
        lawngreen: 0x7cfc00,
        lemonchiffon: 0xfffacd,
        lightblue: 0xadd8e6,
        lightcoral: 0xf08080,
        lightcyan: 0xe0ffff,
        lightgoldenrodyellow: 0xfafad2,
        lightgray: 0xd3d3d3,
        lightgreen: 0x90ee90,
        lightgrey: 0xd3d3d3,
        lightpink: 0xffb6c1,
        lightsalmon: 0xffa07a,
        lightseagreen: 0x20b2aa,
        lightskyblue: 0x87cefa,
        lightslategray: 0x778899,
        lightslategrey: 0x778899,
        lightsteelblue: 0xb0c4de,
        lightyellow: 0xffffe0,
        lime: 0x00ff00,
        limegreen: 0x32cd32,
        linen: 0xfaf0e6,
        magenta: 0xff00ff,
        maroon: 0x800000,
        mediumaquamarine: 0x66cdaa,
        mediumblue: 0x0000cd,
        mediumorchid: 0xba55d3,
        mediumpurple: 0x9370db,
        mediumseagreen: 0x3cb371,
        mediumslateblue: 0x7b68ee,
        mediumspringgreen: 0x00fa9a,
        mediumturquoise: 0x48d1cc,
        mediumvioletred: 0xc71585,
        midnightblue: 0x191970,
        mintcream: 0xf5fffa,
        mistyrose: 0xffe4e1,
        moccasin: 0xffe4b5,
        navajowhite: 0xffdead,
        navy: 0x000080,
        oldlace: 0xfdf5e6,
        olive: 0x808000,
        olivedrab: 0x6b8e23,
        orange: 0xffa500,
        orangered: 0xff4500,
        orchid: 0xda70d6,
        palegoldenrod: 0xeee8aa,
        palegreen: 0x98fb98,
        paleturquoise: 0xafeeee,
        palevioletred: 0xdb7093,
        papayawhip: 0xffefd5,
        peachpuff: 0xffdab9,
        peru: 0xcd853f,
        pink: 0xffc0cb,
        plum: 0xdda0dd,
        powderblue: 0xb0e0e6,
        purple: 0x800080,
        rebeccapurple: 0x663399,
        red: 0xff0000,
        rosybrown: 0xbc8f8f,
        royalblue: 0x4169e1,
        saddlebrown: 0x8b4513,
        salmon: 0xfa8072,
        sandybrown: 0xf4a460,
        seagreen: 0x2e8b57,
        seashell: 0xfff5ee,
        sienna: 0xa0522d,
        silver: 0xc0c0c0,
        skyblue: 0x87ceeb,
        slateblue: 0x6a5acd,
        slategray: 0x708090,
        slategrey: 0x708090,
        snow: 0xfffafa,
        springgreen: 0x00ff7f,
        steelblue: 0x4682b4,
        tan: 0xd2b48c,
        teal: 0x008080,
        thistle: 0xd8bfd8,
        tomato: 0xff6347,
        turquoise: 0x40e0d0,
        violet: 0xee82ee,
        wheat: 0xf5deb3,
        white: 0xffffff,
        whitesmoke: 0xf5f5f5,
        yellow: 0xffff00,
        yellowgreen: 0x9acd32
      };

      define(Color, color, {
        displayable: function() {
          return this.rgb().displayable();
        },
        hex: function() {
          return this.rgb().hex();
        },
        toString: function() {
          return this.rgb() + "";
        }
      });

      function color(format) {
        var m;
        format = (format + "").trim().toLowerCase();
        return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
            : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
            : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
            : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
            : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
            : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
            : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
            : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
            : named.hasOwnProperty(format) ? rgbn(named[format])
            : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
            : null;
      }

      function rgbn(n) {
        return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
      }

      function rgba(r, g, b, a) {
        if (a <= 0) r = g = b = NaN;
        return new Rgb(r, g, b, a);
      }

      function rgbConvert(o) {
        if (!(o instanceof Color)) o = color(o);
        if (!o) return new Rgb;
        o = o.rgb();
        return new Rgb(o.r, o.g, o.b, o.opacity);
      }

      function rgb(r, g, b, opacity) {
        return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
      }

      function Rgb(r, g, b, opacity) {
        this.r = +r;
        this.g = +g;
        this.b = +b;
        this.opacity = +opacity;
      }

      define(Rgb, rgb, extend(Color, {
        brighter: function(k) {
          k = k == null ? brighter : Math.pow(brighter, k);
          return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
        },
        darker: function(k) {
          k = k == null ? darker : Math.pow(darker, k);
          return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
        },
        rgb: function() {
          return this;
        },
        displayable: function() {
          return (-0.5 <= this.r && this.r < 255.5)
              && (-0.5 <= this.g && this.g < 255.5)
              && (-0.5 <= this.b && this.b < 255.5)
              && (0 <= this.opacity && this.opacity <= 1);
        },
        hex: function() {
          return "#" + hex(this.r) + hex(this.g) + hex(this.b);
        },
        toString: function() {
          var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
          return (a === 1 ? "rgb(" : "rgba(")
              + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
              + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
              + Math.max(0, Math.min(255, Math.round(this.b) || 0))
              + (a === 1 ? ")" : ", " + a + ")");
        }
      }));

      function hex(value) {
        value = Math.max(0, Math.min(255, Math.round(value) || 0));
        return (value < 16 ? "0" : "") + value.toString(16);
      }

      function hsla(h, s, l, a) {
        if (a <= 0) h = s = l = NaN;
        else if (l <= 0 || l >= 1) h = s = NaN;
        else if (s <= 0) h = NaN;
        return new Hsl(h, s, l, a);
      }

      function hslConvert(o) {
        if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
        if (!(o instanceof Color)) o = color(o);
        if (!o) return new Hsl;
        if (o instanceof Hsl) return o;
        o = o.rgb();
        var r = o.r / 255,
            g = o.g / 255,
            b = o.b / 255,
            min = Math.min(r, g, b),
            max = Math.max(r, g, b),
            h = NaN,
            s = max - min,
            l = (max + min) / 2;
        if (s) {
          if (r === max) h = (g - b) / s + (g < b) * 6;
          else if (g === max) h = (b - r) / s + 2;
          else h = (r - g) / s + 4;
          s /= l < 0.5 ? max + min : 2 - max - min;
          h *= 60;
        } else {
          s = l > 0 && l < 1 ? 0 : h;
        }
        return new Hsl(h, s, l, o.opacity);
      }

      function hsl(h, s, l, opacity) {
        return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
      }

      function Hsl(h, s, l, opacity) {
        this.h = +h;
        this.s = +s;
        this.l = +l;
        this.opacity = +opacity;
      }

      define(Hsl, hsl, extend(Color, {
        brighter: function(k) {
          k = k == null ? brighter : Math.pow(brighter, k);
          return new Hsl(this.h, this.s, this.l * k, this.opacity);
        },
        darker: function(k) {
          k = k == null ? darker : Math.pow(darker, k);
          return new Hsl(this.h, this.s, this.l * k, this.opacity);
        },
        rgb: function() {
          var h = this.h % 360 + (this.h < 0) * 360,
              s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
              l = this.l,
              m2 = l + (l < 0.5 ? l : 1 - l) * s,
              m1 = 2 * l - m2;
          return new Rgb(
            hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
            hsl2rgb(h, m1, m2),
            hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
            this.opacity
          );
        },
        displayable: function() {
          return (0 <= this.s && this.s <= 1 || isNaN(this.s))
              && (0 <= this.l && this.l <= 1)
              && (0 <= this.opacity && this.opacity <= 1);
        }
      }));

      /* From FvD 13.37, CSS Color Module Level 3 */
      function hsl2rgb(h, m1, m2) {
        return (h < 60 ? m1 + (m2 - m1) * h / 60
            : h < 180 ? m2
            : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
            : m1) * 255;
      }

      var deg2rad = Math.PI / 180;
      var rad2deg = 180 / Math.PI;

      // https://observablehq.com/@mbostock/lab-and-rgb
      var K = 18,
          Xn = 0.96422,
          Yn = 1,
          Zn = 0.82521,
          t0 = 4 / 29,
          t1 = 6 / 29,
          t2 = 3 * t1 * t1,
          t3 = t1 * t1 * t1;

      function labConvert(o) {
        if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
        if (o instanceof Hcl) return hcl2lab(o);
        if (!(o instanceof Rgb)) o = rgbConvert(o);
        var r = rgb2lrgb(o.r),
            g = rgb2lrgb(o.g),
            b = rgb2lrgb(o.b),
            y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
        if (r === g && g === b) x = z = y; else {
          x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
          z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
        }
        return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
      }

      function lab(l, a, b, opacity) {
        return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
      }

      function Lab(l, a, b, opacity) {
        this.l = +l;
        this.a = +a;
        this.b = +b;
        this.opacity = +opacity;
      }

      define(Lab, lab, extend(Color, {
        brighter: function(k) {
          return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
        },
        darker: function(k) {
          return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
        },
        rgb: function() {
          var y = (this.l + 16) / 116,
              x = isNaN(this.a) ? y : y + this.a / 500,
              z = isNaN(this.b) ? y : y - this.b / 200;
          x = Xn * lab2xyz(x);
          y = Yn * lab2xyz(y);
          z = Zn * lab2xyz(z);
          return new Rgb(
            lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
            lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
            lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
            this.opacity
          );
        }
      }));

      function xyz2lab(t) {
        return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
      }

      function lab2xyz(t) {
        return t > t1 ? t * t * t : t2 * (t - t0);
      }

      function lrgb2rgb(x) {
        return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
      }

      function rgb2lrgb(x) {
        return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
      }

      function hclConvert(o) {
        if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
        if (!(o instanceof Lab)) o = labConvert(o);
        if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
        var h = Math.atan2(o.b, o.a) * rad2deg;
        return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
      }

      function hcl(h, c, l, opacity) {
        return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
      }

      function Hcl(h, c, l, opacity) {
        this.h = +h;
        this.c = +c;
        this.l = +l;
        this.opacity = +opacity;
      }

      function hcl2lab(o) {
        if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
        var h = o.h * deg2rad;
        return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
      }

      define(Hcl, hcl, extend(Color, {
        brighter: function(k) {
          return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
        },
        darker: function(k) {
          return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
        },
        rgb: function() {
          return hcl2lab(this).rgb();
        }
      }));

      var A = -0.14861,
          B = +1.78277,
          C = -0.29227,
          D = -0.90649,
          E = +1.97294,
          ED = E * D,
          EB = E * B,
          BC_DA = B * C - D * A;

      function cubehelixConvert(o) {
        if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
        if (!(o instanceof Rgb)) o = rgbConvert(o);
        var r = o.r / 255,
            g = o.g / 255,
            b = o.b / 255,
            l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
            bl = b - l,
            k = (E * (g - l) - C * bl) / D,
            s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
            h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
        return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
      }

      function cubehelix(h, s, l, opacity) {
        return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
      }

      function Cubehelix(h, s, l, opacity) {
        this.h = +h;
        this.s = +s;
        this.l = +l;
        this.opacity = +opacity;
      }

      define(Cubehelix, cubehelix, extend(Color, {
        brighter: function(k) {
          k = k == null ? brighter : Math.pow(brighter, k);
          return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
        },
        darker: function(k) {
          k = k == null ? darker : Math.pow(darker, k);
          return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
        },
        rgb: function() {
          var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
              l = +this.l,
              a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
              cosh = Math.cos(h),
              sinh = Math.sin(h);
          return new Rgb(
            255 * (l + a * (A * cosh + B * sinh)),
            255 * (l + a * (C * cosh + D * sinh)),
            255 * (l + a * (E * cosh)),
            this.opacity
          );
        }
      }));

      function constant(x) {
        return function() {
          return x;
        };
      }

      function linear(a, d) {
        return function(t) {
          return a + t * d;
        };
      }

      function exponential(a, b, y) {
        return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
          return Math.pow(a + t * b, y);
        };
      }

      function gamma(y) {
        return (y = +y) === 1 ? nogamma : function(a, b) {
          return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
        };
      }

      function nogamma(a, b) {
        var d = b - a;
        return d ? linear(a, d) : constant(isNaN(a) ? b : a);
      }

      var rgb$1 = (function rgbGamma(y) {
        var color = gamma(y);

        function rgb$1(start, end) {
          var r = color((start = rgb(start)).r, (end = rgb(end)).r),
              g = color(start.g, end.g),
              b = color(start.b, end.b),
              opacity = nogamma(start.opacity, end.opacity);
          return function(t) {
            start.r = r(t);
            start.g = g(t);
            start.b = b(t);
            start.opacity = opacity(t);
            return start + "";
          };
        }

        rgb$1.gamma = rgbGamma;

        return rgb$1;
      })(1);

      function array(a, b) {
        var nb = b ? b.length : 0,
            na = a ? Math.min(nb, a.length) : 0,
            x = new Array(na),
            c = new Array(nb),
            i;

        for (i = 0; i < na; ++i) x[i] = interpolate(a[i], b[i]);
        for (; i < nb; ++i) c[i] = b[i];

        return function(t) {
          for (i = 0; i < na; ++i) c[i] = x[i](t);
          return c;
        };
      }

      function date(a, b) {
        var d = new Date;
        return a = +a, b -= a, function(t) {
          return d.setTime(a + b * t), d;
        };
      }

      function number(a, b) {
        return a = +a, b -= a, function(t) {
          return a + b * t;
        };
      }

      function object(a, b) {
        var i = {},
            c = {},
            k;

        if (a === null || typeof a !== "object") a = {};
        if (b === null || typeof b !== "object") b = {};

        for (k in b) {
          if (k in a) {
            i[k] = interpolate(a[k], b[k]);
          } else {
            c[k] = b[k];
          }
        }

        return function(t) {
          for (k in i) c[k] = i[k](t);
          return c;
        };
      }

      var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
          reB = new RegExp(reA.source, "g");

      function zero(b) {
        return function() {
          return b;
        };
      }

      function one(b) {
        return function(t) {
          return b(t) + "";
        };
      }

      function string(a, b) {
        var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
            am, // current match in a
            bm, // current match in b
            bs, // string preceding current number in b, if any
            i = -1, // index in s
            s = [], // string constants and placeholders
            q = []; // number interpolators

        // Coerce inputs to strings.
        a = a + "", b = b + "";

        // Interpolate pairs of numbers in a & b.
        while ((am = reA.exec(a))
            && (bm = reB.exec(b))) {
          if ((bs = bm.index) > bi) { // a string precedes the next number in b
            bs = b.slice(bi, bs);
            if (s[i]) s[i] += bs; // coalesce with previous string
            else s[++i] = bs;
          }
          if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
            if (s[i]) s[i] += bm; // coalesce with previous string
            else s[++i] = bm;
          } else { // interpolate non-matching numbers
            s[++i] = null;
            q.push({i: i, x: number(am, bm)});
          }
          bi = reB.lastIndex;
        }

        // Add remains of b.
        if (bi < b.length) {
          bs = b.slice(bi);
          if (s[i]) s[i] += bs; // coalesce with previous string
          else s[++i] = bs;
        }

        // Special optimization for only a single match.
        // Otherwise, interpolate each of the numbers and rejoin the string.
        return s.length < 2 ? (q[0]
            ? one(q[0].x)
            : zero(b))
            : (b = q.length, function(t) {
                for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
                return s.join("");
              });
      }

      function interpolate(a, b) {
        var t = typeof b, c;
        return b == null || t === "boolean" ? constant(b)
            : (t === "number" ? number
            : t === "string" ? ((c = color(b)) ? (b = c, rgb$1) : string)
            : b instanceof color ? rgb$1
            : b instanceof Date ? date
            : Array.isArray(b) ? array
            : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
            : number)(a, b);
      }

      function pointDistance (point1, point2) {
        return Math.sqrt(
          (point1[0] - point2[0]) ** 2 +
          (point1[1] - point2[1]) ** 2
        )
      }

      function linearRingLength (linearRing) {
        let totalLength = 0;

        for (let i = 0; i < linearRing.length - 1; i++) {
          const from = linearRing[i];
          const to = linearRing[i + 1];

          totalLength += pointDistance(from, to);
        }

        return totalLength
      }

      /*
        Why this weird map function when there is Array.map?
        Well, usually premature optimization is the root of all evil,
        but Array.map is just really really slow.

        See, for example,  https://jsperf.com/map-reduce-named-functions/2
        Array.map is more than 6x slower than a classical for loop,
        and almost 4x slower than a custom implementation like this one.
      */
      function map (array, callback) {
        const result = [];

        for (let i = 0; i < array.length; i++) {
          result.push(callback(array[i], i));
        }

        return result
      }

      function every (array, condition) {
        for (let i = 0; i < array.length; i++) {
          if (condition(array[i], i)) return false
        }

        return true
      }

      function getOrderDescending (array) {
        const indexArray = map(array, (_, i) => i);
        indexArray.sort((a, b) => array[b] - array[a]);

        return indexArray
      }

      function sortIntoOrder (array, order) {
        return map(order, i => array[i])
      }

      function getInsertionIndexDescending (arraySortedDescending, value) {
        if (arraySortedDescending.length === 0) return 0

        for (let i = arraySortedDescending.length - 1; i >= 0; i--) {
          const arrayValue = arraySortedDescending[i];

          if (value <= arrayValue) return i
        }

        return 0
      }

      function removeClosingPoint (linearRing) {
        linearRing.pop();

        return linearRing
      }

      function closeRing (linearRing) {
        let firstPoint = linearRing[0];
        linearRing.push(firstPoint);

        return linearRing
      }

      function insertPointsLinearRing (inputLinearRing, numberOfAdditionalPoints) {
        let linearRing = cloneLinearRing(inputLinearRing);
        linearRing = removeClosingPoint(linearRing);
        linearRing = insertPoints(linearRing, numberOfAdditionalPoints, { ring: true });
        linearRing = closeRing(linearRing);

        return linearRing
      }

      function insertPointsLineString (inputLineString, numberOfAdditionalPoints) {
        const lineString = cloneLinearRing(inputLineString);
        return insertPoints(lineString, numberOfAdditionalPoints, { ring: false })
      }

      function insertPoints (lineString, numberOfAdditionalPoints, { ring }) {
        const edgeLengths = getEdgeLengths(lineString, ring);
        let orderedEdgeIds = getOrderDescending(edgeLengths);

        for (let i = 0; i < numberOfAdditionalPoints; i++) {
          const longestEdgeId = orderedEdgeIds[0];

          const edge = getEdge(lineString, longestEdgeId);

          const edgeLength = edgeLengths[longestEdgeId];

          const newEdges = splitEdge(edge);
          const newEdgesLength = edgeLength / 2;

          // Remove old edge
          orderedEdgeIds.shift();
          lineString[longestEdgeId] = null;
          edgeLengths[longestEdgeId] = null;

          // Insert new edges
          orderedEdgeIds = insertOrderedId(orderedEdgeIds, edgeLengths, longestEdgeId, newEdgesLength);

          lineString[longestEdgeId] = newEdges[0][0];
          lineString.splice(longestEdgeId + 1, 0, newEdges[1][0]);

          edgeLengths[longestEdgeId] = newEdgesLength;
          edgeLengths.splice(longestEdgeId + 1, 0, newEdgesLength);
        }

        return lineString
      }

      function cloneLinearRing (linearRing) {
        const clonedLinearRing = [];

        for (let i = 0; i < linearRing.length; i++) {
          clonedLinearRing.push(linearRing[i].slice(0));
        }

        return clonedLinearRing
      }

      function getEdgeLengths (linearRing, ring) {
        const edgeLengths = [];
        const edges = ring ? linearRing.length : linearRing.length - 1;

        for (let i = 0; i < edges; i++) {
          const edge = getEdge(linearRing, i);

          edgeLengths.push(pointDistance(edge[0], edge[1]));
        }

        return edgeLengths
      }

      function getEdge (linearRing, index) {
        return [
          linearRing[index], linearRing[(index + 1) % linearRing.length]
        ]
      }

      function splitEdge (edge) {
        const pointInBetween = interpolate(edge[0], edge[1])(0.5);

        return [
          [edge[0], pointInBetween],
          [pointInBetween, edge[1]]
        ]
      }

      function insertOrderedId (orderedIds, edgeLengths, valueIndex, newValue) {
        // Insert new Ids right place
        let idsWereInserted = false;

        for (let i = 0; i < orderedIds.length; i++) {
          const index = orderedIds[i];

          // Increase all indices after the valueIndex with 1
          if (index > valueIndex) orderedIds[i] = orderedIds[i] + 1;

          const currentArrayValue = edgeLengths[index];
          if (currentArrayValue === null) continue

          if (newValue >= currentArrayValue) {
            orderedIds.splice(i, 0, valueIndex);
            orderedIds.splice(i + 1, 0, valueIndex + 1);

            idsWereInserted = true;
            break
          }
        }

        if (!idsWereInserted) {
          orderedIds.push(valueIndex);
          orderedIds.push(valueIndex + 1);
        }

        return orderedIds
      }

      /*
        Taken from flubber:
        https://github.com/veltman/flubber
      */

      function rotatePointsLinearRing (inputLinearRing, toLinearRing) {
        let fromLinearRing = cloneLinearRing(inputLinearRing);
        fromLinearRing = removeClosingPoint(fromLinearRing);

        const fromLength = fromLinearRing.length;
        let min = Infinity;
        let bestOffset;
        let sumOfSquares;
        let spliced;

        for (let offset = 0; offset < fromLength; offset++) {
          sumOfSquares = 0;

          toLinearRing.forEach((point, i) => {
            const distance = pointDistance(fromLinearRing[(offset + i) % fromLength], point);
            sumOfSquares += distance * distance;
          });

          if (sumOfSquares < min) {
            min = sumOfSquares;
            bestOffset = offset;
          }
        }

        if (bestOffset) {
          spliced = fromLinearRing.splice(0, bestOffset);
          fromLinearRing.splice(fromLinearRing.length, 0, ...spliced);
        }

        fromLinearRing = closeRing(fromLinearRing);

        return fromLinearRing
      }

      function isLinearRing (ring) {
        return ring.constructor === Array
      }

      function isPolygon (geometry) {
        return geometry.constructor === Object && geometry.type === 'Polygon'
      }

      function isMultiPolygon (geometry) {
        return geometry.constructor === Object && geometry.type === 'MultiPolygon'
      }

      function isPolygonOrMultiPolygon (geometry) {
        return isPolygon(geometry) || isMultiPolygon(geometry)
      }

      function isLineString (geometry) {
        return geometry.constructor === Object && geometry.type === 'LineString'
      }

      function isMultiLineString (geometry) {
        return geometry.constructor === Object && geometry.type === 'MultiLineString'
      }

      function isLineStringOrMultiLineString (geometry) {
        return isLineString(geometry) || isMultiLineString(geometry)
      }

      function polygonArea (polygon) {
        if (isLinearRing(polygon)) {
          return getRingArea(polygon)
        }

        if (isPolygon(polygon)) {
          return getPolygonArea(polygon)
        }

        if (isMultiPolygon(polygon)) {
          return getMultiPolygonArea(polygon)
        }

        throw new Error('Invalid input')
      }

      function linearRingIsClockwise (ring) {
        return getSignedRingArea(ring) < 0
      }

      function getRingArea (ring) {
        return Math.abs(getSignedRingArea(ring))
      }

      // Taken from: https://stackoverflow.com/a/33670691/7237112
      function getSignedRingArea (ring) {
        let total = 0;

        for (let i = 0, l = ring.length; i < l; i++) {
          const addX = ring[i][0];
          const addY = ring[i === ring.length - 1 ? 0 : i + 1][1];
          const subX = ring[i === ring.length - 1 ? 0 : i + 1][0];
          const subY = ring[i][1];

          total += (addX * addY * 0.5);
          total -= (subX * subY * 0.5);
        }

        return total
      }

      function getPolygonArea (polygon) {
        let totalArea = getRingArea(polygon.coordinates[0]);

        for (let i = 1; i < polygon.coordinates.length; i++) {
          const holeArea = getRingArea(polygon.coordinates[i]);
          totalArea -= holeArea;
        }

        return totalArea
      }

      function getMultiPolygonArea (multiPolygon) {
        let totalArea = 0;

        for (let i = 0; i < multiPolygon.coordinates.length; i++) {
          totalArea += getPolygonArea(multiPolygon.coordinates[i]);
        }

        return totalArea
      }

      function matchLinearRings (fromRings, toRings) {
        if (tooManyRings(fromRings)) {
          return map(fromRings, (_, i) => i)
        }

        return bestOrder(fromRings, toRings)
      }

      function tooManyRings (rings) {
        // with more than 9 rings, everything will be too chaotic to notice this stuff anyway.
        return rings.length > 9
      }

      function bestOrder (fromRings, toRings) {
        const fromAreas = map(fromRings, polygonArea);
        const toAreas = map(toRings, polygonArea);

        const fromAreasOrderDescending = getOrderDescending(fromAreas);
        const toAreasOrderDescending = getOrderDescending(toAreas);

        const pairs = {};

        for (let i = 0; i < toAreasOrderDescending.length; i++) {
          const fromIndex = fromAreasOrderDescending[i];
          const toIndex = toAreasOrderDescending[i];

          pairs[toIndex] = fromIndex;
        }

        const fromOrder = [];

        for (let i = 0; i < toRings.length; i++) {
          fromOrder.push(pairs[i]);
        }

        return fromOrder
      }

      function calculateCentroid (geometry) {
        if (isLinearRing(geometry)) {
          return calculateLinearRingCentroid(geometry)
        }

        if (isPolygon(geometry)) {
          return calculatePolygonCentroid(geometry)
        }

        if (isMultiPolygon(geometry)) {
          return calculateMultiPolygonCentroid(geometry)
        }
      }

      // https://stackoverflow.com/a/33852627/7237112
      function calculateLinearRingCentroid (ring) {
        const nPts = ring.length;
        const off = ring[0];
        let twicearea = 0;
        let x = 0;
        let y = 0;
        let p1;
        let p2;
        let f;

        for (let i = 0, j = nPts - 1; i < nPts; j = i++) {
          p1 = ring[i];
          p2 = ring[j];
          f = (p1[0] - off[0]) * (p2[1] - off[1]) - (p2[0] - off[0]) * (p1[1] - off[1]);
          twicearea += f;
          x += (p1[0] + p2[0] - 2 * off[0]) * f;
          y += (p1[1] + p2[1] - 2 * off[1]) * f;
        }

        f = twicearea * 3;

        return [x / f + off[0], y / f + off[1]]
      }

      function calculatePolygonCentroid (polygon) {
        // We will ignore holes and just take the outer ring
        return calculateLinearRingCentroid(polygon.coordinates[0])
      }

      function calculateMultiPolygonCentroid (multiPolygon) {
        // We will take the centroid of each polygon (ignoring holes)
        // and take the weighted (by area) center of these.
        let x = 0;
        let y = 0;
        let totalArea = 0;

        for (let i = 0; i < multiPolygon.coordinates.length; i++) {
          const polygon = multiPolygon.coordinates[i];
          const polygonCentroid = calculateLinearRingCentroid(polygon[0]);
          const area = polygonArea(polygon[0]);

          x += polygonCentroid[0] * area;
          y += polygonCentroid[1] * area;
          totalArea += area;
        }

        return [x / totalArea, y / totalArea]
      }

      function polygonToPolygon (from, to) {
        const fromOuterRing = from.coordinates[0];
        const toOuterRing = to.coordinates[0];

        const [fromOuterRingPrepared, toOuterRingPrepared] = prepareLinearRings(fromOuterRing, toOuterRing);

        if (neitherHasHoles(from, to)) {
          return createInterpolatorNoHoles(from, to, fromOuterRingPrepared, toOuterRingPrepared)
        }

        const holeInterpolators = createHoleInterpolators(from, to);

        return createInterpolatorWithHoles(
          from, to, fromOuterRingPrepared, toOuterRingPrepared, holeInterpolators
        )
      }

      function prepareLinearRings (fromRing, toRing) {
        const lengthDifference = fromRing.length - toRing.length;

        if (lengthDifference > 0) {
          toRing = insertPointsLinearRing(toRing, lengthDifference);
        }

        if (lengthDifference < 0) {
          fromRing = insertPointsLinearRing(fromRing, -lengthDifference);
        }

        const rotatedFromRing = rotatePointsLinearRing(fromRing, toRing);

        return [rotatedFromRing, toRing]
      }

      function createInterpolatorNoHoles (from, to, fromOuterRingPrepared, toOuterRingPrepared) {
        const outerRingInterpolator = interpolate(fromOuterRingPrepared, toOuterRingPrepared);

        return function interpolator (t) {
          if (t === 0) return from
          if (t === 1) return to

          const interpolatedLinearRing = outerRingInterpolator(t);

          return {
            type: 'Polygon',
            coordinates: [interpolatedLinearRing]
          }
        }
      }

      function neitherHasHoles (from, to) {
        return from.coordinates.length === 1 && to.coordinates.length === 1
      }

      function getHoles (polygon, numberOfHoles) {
        const holes = [];

        for (let i = 1; i <= numberOfHoles; i++) {
          holes.push(polygon.coordinates[i]);
        }

        return holes
      }

      function createHoleInterpolators (from, to) {
        let holeInterpolators = [];

        const numberOfMatchableHoles = Math.min(from.coordinates.length, to.coordinates.length) - 1;

        if (numberOfMatchableHoles > 0) {
          holeInterpolators = holeInterpolators.concat(
            createMatchableHoleInterpolators(from, to, numberOfMatchableHoles)
          );
        }

        const differenceBetweenNumberOfHoles = from.coordinates.length - to.coordinates.length;

        if (differenceBetweenNumberOfHoles > 0) {
          holeInterpolators = holeInterpolators.concat(
            createHoleImploders(from, differenceBetweenNumberOfHoles)
          );
        }

        if (differenceBetweenNumberOfHoles < 0) {
          holeInterpolators = holeInterpolators.concat(
            createHoleExploders(to, -differenceBetweenNumberOfHoles)
          );
        }

        return holeInterpolators
      }

      function createMatchableHoleInterpolators (from, to, numberOfMatchableHoles) {
        const holeInterpolators = [];

        const fromHoles = getHoles(from, numberOfMatchableHoles);
        const toHoles = getHoles(to, numberOfMatchableHoles);

        const fromOrder = matchLinearRings(fromHoles, toHoles);
        const fromHolesSorted = map(fromOrder, i => fromHoles[i]);

        for (let i = 0; i < numberOfMatchableHoles; i++) {
          const fromHole = fromHolesSorted[i];
          const toHole = toHoles[i];

          const [fromHolePrepared, toHolePrepared] = prepareLinearRings(fromHole, toHole);

          const holeInterpolator = interpolate(fromHolePrepared, toHolePrepared);

          holeInterpolators.push(holeInterpolator);
        }

        return holeInterpolators
      }

      function createHoleImploders (polygon, differenceBetweenNumberOfHoles) {
        const interpolators = [];

        const firstHoleThatNeedsImplodingIndex = polygon.coordinates.length - differenceBetweenNumberOfHoles;

        for (let i = firstHoleThatNeedsImplodingIndex; i < polygon.coordinates.length; i++) {
          const hole = polygon.coordinates[i];
          const holeCentroid = calculateCentroid(hole);
          const smallRectangleAroundCentroid = makeSmallRectangleAroundPoint(holeCentroid);

          const [preparedPolygon, preparedImplodePoint] = prepareLinearRings(hole, smallRectangleAroundCentroid);

          interpolators.push(interpolate(preparedPolygon, preparedImplodePoint));
        }

        return interpolators
      }

      function createHoleExploders (polygon, differenceBetweenNumberOfHoles) {
        return map(createHoleImploders(polygon, differenceBetweenNumberOfHoles), holeInterpolator => {
          return t => holeInterpolator(1 - t)
        })
      }

      function makeSmallRectangleAroundPoint ([x, y]) {
        const epsilon = 1e-6;

        const x1 = x - epsilon;
        const x2 = x + epsilon;
        const y1 = y - epsilon;
        const y2 = y + epsilon;

        return [[x1, y1], [x1, y2], [x2, y2], [x2, y1], [x1, y1]]
      }

      function createInterpolatorWithHoles (
        from, to, fromOuterRingPrepared, toOuterRingPrepared, holeInterpolators
      ) {
        const outerRingInterpolator = interpolate(fromOuterRingPrepared, toOuterRingPrepared);

        return function interpolator (t) {
          if (t === 0) return from
          if (t === 1) return to

          const interpolatedLinearRing = outerRingInterpolator(t);

          return {
            type: 'Polygon',
            coordinates: [
              interpolatedLinearRing,
              ...map(holeInterpolators, holeInterpolator => holeInterpolator(t))
            ]
          }
        }
      }

      var earcut_1 = earcut;
      var default_1 = earcut;

      function earcut(data, holeIndices, dim) {

          dim = dim || 2;

          var hasHoles = holeIndices && holeIndices.length,
              outerLen = hasHoles ? holeIndices[0] * dim : data.length,
              outerNode = linkedList(data, 0, outerLen, dim, true),
              triangles = [];

          if (!outerNode || outerNode.next === outerNode.prev) return triangles;

          var minX, minY, maxX, maxY, x, y, invSize;

          if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

          // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
          if (data.length > 80 * dim) {
              minX = maxX = data[0];
              minY = maxY = data[1];

              for (var i = dim; i < outerLen; i += dim) {
                  x = data[i];
                  y = data[i + 1];
                  if (x < minX) minX = x;
                  if (y < minY) minY = y;
                  if (x > maxX) maxX = x;
                  if (y > maxY) maxY = y;
              }

              // minX, minY and invSize are later used to transform coords into integers for z-order calculation
              invSize = Math.max(maxX - minX, maxY - minY);
              invSize = invSize !== 0 ? 1 / invSize : 0;
          }

          earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

          return triangles;
      }

      // create a circular doubly linked list from polygon points in the specified winding order
      function linkedList(data, start, end, dim, clockwise) {
          var i, last;

          if (clockwise === (signedArea(data, start, end, dim) > 0)) {
              for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
          } else {
              for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
          }

          if (last && equals(last, last.next)) {
              removeNode(last);
              last = last.next;
          }

          return last;
      }

      // eliminate colinear or duplicate points
      function filterPoints(start, end) {
          if (!start) return start;
          if (!end) end = start;

          var p = start,
              again;
          do {
              again = false;

              if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
                  removeNode(p);
                  p = end = p.prev;
                  if (p === p.next) break;
                  again = true;

              } else {
                  p = p.next;
              }
          } while (again || p !== end);

          return end;
      }

      // main ear slicing loop which triangulates a polygon (given as a linked list)
      function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
          if (!ear) return;

          // interlink polygon nodes in z-order
          if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

          var stop = ear,
              prev, next;

          // iterate through ears, slicing them one by one
          while (ear.prev !== ear.next) {
              prev = ear.prev;
              next = ear.next;

              if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
                  // cut off the triangle
                  triangles.push(prev.i / dim);
                  triangles.push(ear.i / dim);
                  triangles.push(next.i / dim);

                  removeNode(ear);

                  // skipping the next vertex leads to less sliver triangles
                  ear = next.next;
                  stop = next.next;

                  continue;
              }

              ear = next;

              // if we looped through the whole remaining polygon and can't find any more ears
              if (ear === stop) {
                  // try filtering points and slicing again
                  if (!pass) {
                      earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

                  // if this didn't work, try curing all small self-intersections locally
                  } else if (pass === 1) {
                      ear = cureLocalIntersections(ear, triangles, dim);
                      earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

                  // as a last resort, try splitting the remaining polygon into two
                  } else if (pass === 2) {
                      splitEarcut(ear, triangles, dim, minX, minY, invSize);
                  }

                  break;
              }
          }
      }

      // check whether a polygon node forms a valid ear with adjacent nodes
      function isEar(ear) {
          var a = ear.prev,
              b = ear,
              c = ear.next;

          if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

          // now make sure we don't have other points inside the potential ear
          var p = ear.next.next;

          while (p !== ear.prev) {
              if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                  area(p.prev, p, p.next) >= 0) return false;
              p = p.next;
          }

          return true;
      }

      function isEarHashed(ear, minX, minY, invSize) {
          var a = ear.prev,
              b = ear,
              c = ear.next;

          if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

          // triangle bbox; min & max are calculated like this for speed
          var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
              minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
              maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
              maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

          // z-order range for the current triangle bbox;
          var minZ = zOrder(minTX, minTY, minX, minY, invSize),
              maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

          var p = ear.prevZ,
              n = ear.nextZ;

          // look for points inside the triangle in both directions
          while (p && p.z >= minZ && n && n.z <= maxZ) {
              if (p !== ear.prev && p !== ear.next &&
                  pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                  area(p.prev, p, p.next) >= 0) return false;
              p = p.prevZ;

              if (n !== ear.prev && n !== ear.next &&
                  pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                  area(n.prev, n, n.next) >= 0) return false;
              n = n.nextZ;
          }

          // look for remaining points in decreasing z-order
          while (p && p.z >= minZ) {
              if (p !== ear.prev && p !== ear.next &&
                  pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                  area(p.prev, p, p.next) >= 0) return false;
              p = p.prevZ;
          }

          // look for remaining points in increasing z-order
          while (n && n.z <= maxZ) {
              if (n !== ear.prev && n !== ear.next &&
                  pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                  area(n.prev, n, n.next) >= 0) return false;
              n = n.nextZ;
          }

          return true;
      }

      // go through all polygon nodes and cure small local self-intersections
      function cureLocalIntersections(start, triangles, dim) {
          var p = start;
          do {
              var a = p.prev,
                  b = p.next.next;

              if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

                  triangles.push(a.i / dim);
                  triangles.push(p.i / dim);
                  triangles.push(b.i / dim);

                  // remove two nodes involved
                  removeNode(p);
                  removeNode(p.next);

                  p = start = b;
              }
              p = p.next;
          } while (p !== start);

          return p;
      }

      // try splitting polygon into two and triangulate them independently
      function splitEarcut(start, triangles, dim, minX, minY, invSize) {
          // look for a valid diagonal that divides the polygon into two
          var a = start;
          do {
              var b = a.next.next;
              while (b !== a.prev) {
                  if (a.i !== b.i && isValidDiagonal(a, b)) {
                      // split the polygon in two by the diagonal
                      var c = splitPolygon(a, b);

                      // filter colinear points around the cuts
                      a = filterPoints(a, a.next);
                      c = filterPoints(c, c.next);

                      // run earcut on each half
                      earcutLinked(a, triangles, dim, minX, minY, invSize);
                      earcutLinked(c, triangles, dim, minX, minY, invSize);
                      return;
                  }
                  b = b.next;
              }
              a = a.next;
          } while (a !== start);
      }

      // link every hole into the outer loop, producing a single-ring polygon without holes
      function eliminateHoles(data, holeIndices, outerNode, dim) {
          var queue = [],
              i, len, start, end, list;

          for (i = 0, len = holeIndices.length; i < len; i++) {
              start = holeIndices[i] * dim;
              end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
              list = linkedList(data, start, end, dim, false);
              if (list === list.next) list.steiner = true;
              queue.push(getLeftmost(list));
          }

          queue.sort(compareX);

          // process holes from left to right
          for (i = 0; i < queue.length; i++) {
              eliminateHole(queue[i], outerNode);
              outerNode = filterPoints(outerNode, outerNode.next);
          }

          return outerNode;
      }

      function compareX(a, b) {
          return a.x - b.x;
      }

      // find a bridge between vertices that connects hole with an outer ring and and link it
      function eliminateHole(hole, outerNode) {
          outerNode = findHoleBridge(hole, outerNode);
          if (outerNode) {
              var b = splitPolygon(outerNode, hole);
              filterPoints(b, b.next);
          }
      }

      // David Eberly's algorithm for finding a bridge between hole and outer polygon
      function findHoleBridge(hole, outerNode) {
          var p = outerNode,
              hx = hole.x,
              hy = hole.y,
              qx = -Infinity,
              m;

          // find a segment intersected by a ray from the hole's leftmost point to the left;
          // segment's endpoint with lesser x will be potential connection point
          do {
              if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                  var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                  if (x <= hx && x > qx) {
                      qx = x;
                      if (x === hx) {
                          if (hy === p.y) return p;
                          if (hy === p.next.y) return p.next;
                      }
                      m = p.x < p.next.x ? p : p.next;
                  }
              }
              p = p.next;
          } while (p !== outerNode);

          if (!m) return null;

          if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

          // look for points inside the triangle of hole point, segment intersection and endpoint;
          // if there are no points found, we have a valid connection;
          // otherwise choose the point of the minimum angle with the ray as connection point

          var stop = m,
              mx = m.x,
              my = m.y,
              tanMin = Infinity,
              tan;

          p = m.next;

          while (p !== stop) {
              if (hx >= p.x && p.x >= mx && hx !== p.x &&
                      pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

                  tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

                  if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                      m = p;
                      tanMin = tan;
                  }
              }

              p = p.next;
          }

          return m;
      }

      // interlink polygon nodes in z-order
      function indexCurve(start, minX, minY, invSize) {
          var p = start;
          do {
              if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
              p.prevZ = p.prev;
              p.nextZ = p.next;
              p = p.next;
          } while (p !== start);

          p.prevZ.nextZ = null;
          p.prevZ = null;

          sortLinked(p);
      }

      // Simon Tatham's linked list merge sort algorithm
      // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
      function sortLinked(list) {
          var i, p, q, e, tail, numMerges, pSize, qSize,
              inSize = 1;

          do {
              p = list;
              list = null;
              tail = null;
              numMerges = 0;

              while (p) {
                  numMerges++;
                  q = p;
                  pSize = 0;
                  for (i = 0; i < inSize; i++) {
                      pSize++;
                      q = q.nextZ;
                      if (!q) break;
                  }
                  qSize = inSize;

                  while (pSize > 0 || (qSize > 0 && q)) {

                      if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                          e = p;
                          p = p.nextZ;
                          pSize--;
                      } else {
                          e = q;
                          q = q.nextZ;
                          qSize--;
                      }

                      if (tail) tail.nextZ = e;
                      else list = e;

                      e.prevZ = tail;
                      tail = e;
                  }

                  p = q;
              }

              tail.nextZ = null;
              inSize *= 2;

          } while (numMerges > 1);

          return list;
      }

      // z-order of a point given coords and inverse of the longer side of data bbox
      function zOrder(x, y, minX, minY, invSize) {
          // coords are transformed into non-negative 15-bit integer range
          x = 32767 * (x - minX) * invSize;
          y = 32767 * (y - minY) * invSize;

          x = (x | (x << 8)) & 0x00FF00FF;
          x = (x | (x << 4)) & 0x0F0F0F0F;
          x = (x | (x << 2)) & 0x33333333;
          x = (x | (x << 1)) & 0x55555555;

          y = (y | (y << 8)) & 0x00FF00FF;
          y = (y | (y << 4)) & 0x0F0F0F0F;
          y = (y | (y << 2)) & 0x33333333;
          y = (y | (y << 1)) & 0x55555555;

          return x | (y << 1);
      }

      // find the leftmost node of a polygon ring
      function getLeftmost(start) {
          var p = start,
              leftmost = start;
          do {
              if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
              p = p.next;
          } while (p !== start);

          return leftmost;
      }

      // check if a point lies within a convex triangle
      function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
          return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
                 (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
                 (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
      }

      // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
      function isValidDiagonal(a, b) {
          return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
                 locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
      }

      // signed area of a triangle
      function area(p, q, r) {
          return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
      }

      // check if two points are equal
      function equals(p1, p2) {
          return p1.x === p2.x && p1.y === p2.y;
      }

      // check if two segments intersect
      function intersects(p1, q1, p2, q2) {
          if ((equals(p1, q1) && equals(p2, q2)) ||
              (equals(p1, q2) && equals(p2, q1))) return true;
          return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
                 area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
      }

      // check if a polygon diagonal intersects any polygon segments
      function intersectsPolygon(a, b) {
          var p = a;
          do {
              if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                      intersects(p, p.next, a, b)) return true;
              p = p.next;
          } while (p !== a);

          return false;
      }

      // check if a polygon diagonal is locally inside the polygon
      function locallyInside(a, b) {
          return area(a.prev, a, a.next) < 0 ?
              area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
              area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
      }

      // check if the middle point of a polygon diagonal is inside the polygon
      function middleInside(a, b) {
          var p = a,
              inside = false,
              px = (a.x + b.x) / 2,
              py = (a.y + b.y) / 2;
          do {
              if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                      (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
                  inside = !inside;
              p = p.next;
          } while (p !== a);

          return inside;
      }

      // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
      // if one belongs to the outer ring and another to a hole, it merges it into a single ring
      function splitPolygon(a, b) {
          var a2 = new Node(a.i, a.x, a.y),
              b2 = new Node(b.i, b.x, b.y),
              an = a.next,
              bp = b.prev;

          a.next = b;
          b.prev = a;

          a2.next = an;
          an.prev = a2;

          b2.next = a2;
          a2.prev = b2;

          bp.next = b2;
          b2.prev = bp;

          return b2;
      }

      // create a node and optionally link it with previous one (in a circular doubly linked list)
      function insertNode(i, x, y, last) {
          var p = new Node(i, x, y);

          if (!last) {
              p.prev = p;
              p.next = p;

          } else {
              p.next = last.next;
              p.prev = last;
              last.next.prev = p;
              last.next = p;
          }
          return p;
      }

      function removeNode(p) {
          p.next.prev = p.prev;
          p.prev.next = p.next;

          if (p.prevZ) p.prevZ.nextZ = p.nextZ;
          if (p.nextZ) p.nextZ.prevZ = p.prevZ;
      }

      function Node(i, x, y) {
          // vertex index in coordinates array
          this.i = i;

          // vertex coordinates
          this.x = x;
          this.y = y;

          // previous and next vertex nodes in a polygon ring
          this.prev = null;
          this.next = null;

          // z-order curve value
          this.z = null;

          // previous and next nodes in z-order
          this.prevZ = null;
          this.nextZ = null;

          // indicates whether this is a steiner point
          this.steiner = false;
      }

      // return a percentage difference between the polygon area and its triangulation area;
      // used to verify correctness of triangulation
      earcut.deviation = function (data, holeIndices, dim, triangles) {
          var hasHoles = holeIndices && holeIndices.length;
          var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

          var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
          if (hasHoles) {
              for (var i = 0, len = holeIndices.length; i < len; i++) {
                  var start = holeIndices[i] * dim;
                  var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                  polygonArea -= Math.abs(signedArea(data, start, end, dim));
              }
          }

          var trianglesArea = 0;
          for (i = 0; i < triangles.length; i += 3) {
              var a = triangles[i] * dim;
              var b = triangles[i + 1] * dim;
              var c = triangles[i + 2] * dim;
              trianglesArea += Math.abs(
                  (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
                  (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
          }

          return polygonArea === 0 && trianglesArea === 0 ? 0 :
              Math.abs((trianglesArea - polygonArea) / polygonArea);
      };

      function signedArea(data, start, end, dim) {
          var sum = 0;
          for (var i = start, j = end - dim; i < end; i += dim) {
              sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
              j = i;
          }
          return sum;
      }

      // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
      earcut.flatten = function (data) {
          var dim = data[0][0].length,
              result = {vertices: [], holes: [], dimensions: dim},
              holeIndex = 0;

          for (var i = 0; i < data.length; i++) {
              for (var j = 0; j < data[i].length; j++) {
                  for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
              }
              if (i > 0) {
                  holeIndex += data[i - 1].length;
                  result.holes.push(holeIndex);
              }
          }
          return result;
      };
      earcut_1.default = default_1;

      /*
        Taken from flubber:
        https://github.com/veltman/flubber
      */

      function createTopology (vertices, triangleIndices) {
        const arcIndices = {};
        const topology = createEmptyTopology();

        for (let i = 0; i < triangleIndices.length; i += 3) {
          const geometry = [];

          const triangleIndexArcs = createTriangleIndexArcs(triangleIndices, i);

          triangleIndexArcs.forEach(arc => {
            const slug = createArcSlug(arc);

            const coordinates = map(arc, pointIndex => getPoint(vertices, pointIndex));

            if (slug in arcIndices) {
              geometry.push(~arcIndices[slug]); // Not sure what this is doing
            } else {
              geometry.push((arcIndices[slug] = topology.arcs.length));
              topology.arcs.push(coordinates);
            }
          });

          const area = getTriangleArea(vertices, triangleIndexArcs);
          const polygon = createTopoPolygon(area, geometry);

          topology.objects.triangles.geometries.push(polygon);
        }

        // Sort smallest first
        // TODO sorted insertion?
        topology.objects.triangles.geometries.sort((a, b) => a.area - b.area);

        return topology
      }

      function createEmptyTopology () {
        return {
          type: 'Topology',
          objects: {
            triangles: {
              type: 'GeometryCollection',
              geometries: []
            }
          },
          arcs: []
        }
      }

      function createTriangleIndexArcs (triangleIndices, i) {
        const a = triangleIndices[i];
        const b = triangleIndices[i + 1];
        const c = triangleIndices[i + 2];

        return [[a, b], [b, c], [c, a]]
      }

      function createArcSlug (arc) {
        return arc[0] < arc[1] ? arc.join(',') : arc[1] + ',' + arc[0]
      }

      function getPoint (vertices, i) {
        return [vertices[i * 2], vertices[(i * 2) + 1]]
      }

      function createTopoPolygon (area, geometry) {
        return {
          type: 'Polygon',
          area,
          arcs: [geometry]
        }
      }

      function getTriangleArea (vertices, triangleIndexArcs) {
        return Math.abs(
          polygonArea(map(triangleIndexArcs, arc => getPoint(vertices, arc[0])))
        )
      }

      function identity(x) {
        return x;
      }

      function transform(transform) {
        if (transform == null) return identity;
        var x0,
            y0,
            kx = transform.scale[0],
            ky = transform.scale[1],
            dx = transform.translate[0],
            dy = transform.translate[1];
        return function(input, i) {
          if (!i) x0 = y0 = 0;
          var j = 2, n = input.length, output = new Array(n);
          output[0] = (x0 += input[0]) * kx + dx;
          output[1] = (y0 += input[1]) * ky + dy;
          while (j < n) output[j] = input[j], ++j;
          return output;
        };
      }

      function reverse(array, n) {
        var t, j = array.length, i = j - n;
        while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
      }

      function feature(topology, o) {
        return o.type === "GeometryCollection"
            ? {type: "FeatureCollection", features: o.geometries.map(function(o) { return feature$1(topology, o); })}
            : feature$1(topology, o);
      }

      function feature$1(topology, o) {
        var id = o.id,
            bbox = o.bbox,
            properties = o.properties == null ? {} : o.properties,
            geometry = object$1(topology, o);
        return id == null && bbox == null ? {type: "Feature", properties: properties, geometry: geometry}
            : bbox == null ? {type: "Feature", id: id, properties: properties, geometry: geometry}
            : {type: "Feature", id: id, bbox: bbox, properties: properties, geometry: geometry};
      }

      function object$1(topology, o) {
        var transformPoint = transform(topology.transform),
            arcs = topology.arcs;

        function arc(i, points) {
          if (points.length) points.pop();
          for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
            points.push(transformPoint(a[k], k));
          }
          if (i < 0) reverse(points, n);
        }

        function point(p) {
          return transformPoint(p);
        }

        function line(arcs) {
          var points = [];
          for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
          if (points.length < 2) points.push(points[0]); // This should never happen per the specification.
          return points;
        }

        function ring(arcs) {
          var points = line(arcs);
          while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.
          return points;
        }

        function polygon(arcs) {
          return arcs.map(ring);
        }

        function geometry(o) {
          var type = o.type, coordinates;
          switch (type) {
            case "GeometryCollection": return {type: type, geometries: o.geometries.map(geometry)};
            case "Point": coordinates = point(o.coordinates); break;
            case "MultiPoint": coordinates = o.coordinates.map(point); break;
            case "LineString": coordinates = line(o.arcs); break;
            case "MultiLineString": coordinates = o.arcs.map(line); break;
            case "Polygon": coordinates = polygon(o.arcs); break;
            case "MultiPolygon": coordinates = o.arcs.map(polygon); break;
            default: return null;
          }
          return {type: type, coordinates: coordinates};
        }

        return geometry(o);
      }

      function stitch(topology, arcs) {
        var stitchedArcs = {},
            fragmentByStart = {},
            fragmentByEnd = {},
            fragments = [],
            emptyIndex = -1;

        // Stitch empty arcs first, since they may be subsumed by other arcs.
        arcs.forEach(function(i, j) {
          var arc = topology.arcs[i < 0 ? ~i : i], t;
          if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
            t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
          }
        });

        arcs.forEach(function(i) {
          var e = ends(i),
              start = e[0],
              end = e[1],
              f, g;

          if (f = fragmentByEnd[start]) {
            delete fragmentByEnd[f.end];
            f.push(i);
            f.end = end;
            if (g = fragmentByStart[end]) {
              delete fragmentByStart[g.start];
              var fg = g === f ? f : f.concat(g);
              fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
            } else {
              fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
            }
          } else if (f = fragmentByStart[end]) {
            delete fragmentByStart[f.start];
            f.unshift(i);
            f.start = start;
            if (g = fragmentByEnd[start]) {
              delete fragmentByEnd[g.end];
              var gf = g === f ? f : g.concat(f);
              fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
            } else {
              fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
            }
          } else {
            f = [i];
            fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
          }
        });

        function ends(i) {
          var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
          if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
          else p1 = arc[arc.length - 1];
          return i < 0 ? [p1, p0] : [p0, p1];
        }

        function flush(fragmentByEnd, fragmentByStart) {
          for (var k in fragmentByEnd) {
            var f = fragmentByEnd[k];
            delete fragmentByStart[f.start];
            delete f.start;
            delete f.end;
            f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
            fragments.push(f);
          }
        }

        flush(fragmentByEnd, fragmentByStart);
        flush(fragmentByStart, fragmentByEnd);
        arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

        return fragments;
      }

      function planarRingArea(ring) {
        var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
        while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
        return Math.abs(area); // Note: doubled area!
      }

      function mergeArcs(topology, objects) {
        var polygonsByArc = {},
            polygons = [],
            groups = [];

        objects.forEach(geometry);

        function geometry(o) {
          switch (o.type) {
            case "GeometryCollection": o.geometries.forEach(geometry); break;
            case "Polygon": extract(o.arcs); break;
            case "MultiPolygon": o.arcs.forEach(extract); break;
          }
        }

        function extract(polygon) {
          polygon.forEach(function(ring) {
            ring.forEach(function(arc) {
              (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
            });
          });
          polygons.push(polygon);
        }

        function area(ring) {
          return planarRingArea(object$1(topology, {type: "Polygon", arcs: [ring]}).coordinates[0]);
        }

        polygons.forEach(function(polygon) {
          if (!polygon._) {
            var group = [],
                neighbors = [polygon];
            polygon._ = 1;
            groups.push(group);
            while (polygon = neighbors.pop()) {
              group.push(polygon);
              polygon.forEach(function(ring) {
                ring.forEach(function(arc) {
                  polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
                    if (!polygon._) {
                      polygon._ = 1;
                      neighbors.push(polygon);
                    }
                  });
                });
              });
            }
          }
        });

        polygons.forEach(function(polygon) {
          delete polygon._;
        });

        return {
          type: "MultiPolygon",
          arcs: groups.map(function(polygons) {
            var arcs = [], n;

            // Extract the exterior (unique) arcs.
            polygons.forEach(function(polygon) {
              polygon.forEach(function(ring) {
                ring.forEach(function(arc) {
                  if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
                    arcs.push(arc);
                  }
                });
              });
            });

            // Stitch the arcs into one or more rings.
            arcs = stitch(topology, arcs);

            // If more than one ring is returned,
            // at most one of these rings can be the exterior;
            // choose the one with the greatest absolute area.
            if ((n = arcs.length) > 1) {
              for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
                if ((ki = area(arcs[i])) > k) {
                  t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
                }
              }
            }

            return arcs;
          })
        };
      }

      function ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
      }

      function bisector(compare) {
        if (compare.length === 1) compare = ascendingComparator(compare);
        return {
          left: function(a, x, lo, hi) {
            if (lo == null) lo = 0;
            if (hi == null) hi = a.length;
            while (lo < hi) {
              var mid = lo + hi >>> 1;
              if (compare(a[mid], x) < 0) lo = mid + 1;
              else hi = mid;
            }
            return lo;
          },
          right: function(a, x, lo, hi) {
            if (lo == null) lo = 0;
            if (hi == null) hi = a.length;
            while (lo < hi) {
              var mid = lo + hi >>> 1;
              if (compare(a[mid], x) > 0) hi = mid;
              else lo = mid + 1;
            }
            return lo;
          }
        };
      }

      function ascendingComparator(f) {
        return function(d, x) {
          return ascending(f(d), x);
        };
      }

      var ascendingBisect = bisector(ascending);

      /*
        Taken from flubber:
        https://github.com/veltman/flubber
      */

      const bisect = bisector(d => d.area).left;

      function findNeighbor (geoms) {
        // we assume the first geom is the candidate for which
        // we want to find a neighbor
        const sourceArcs = geoms[0].arcs[0].map(arc => arc < 0 ? ~arc : arc);

        let neighbor;

        // start loop at index 1, first possible neighbor
        for (let index = 1; index < geoms.length; index++) {
          const targetArcs = geoms[index].arcs[0].map(arc => arc < 0 ? ~arc : arc);
          if (sourceArcs.some(arc => targetArcs.includes(arc))) {
            neighbor = index;
            break
          }
        }
        return neighbor
      }

      function collapseTopology (topology, numberOfPieces) {
        const triangleGeometries = topology.objects.triangles.geometries;

        while (triangleGeometries.length > numberOfPieces) {
          mergeSmallestFeature();
        }

        if (numberOfPieces > triangleGeometries.length) {
          throw new RangeError('Can\'t collapse topology into ' + numberOfPieces + ' pieces.')
        }

        const geojson = feature(topology, topology.objects.triangles);
        const geojsonTriangleGeometries = map(geojson.features, feature => feature.geometry);

        return geojsonTriangleGeometries

        function mergeSmallestFeature () {
          const smallest = triangleGeometries[0];
          const neighborIndex = findNeighbor(triangleGeometries);
          const neighbor = triangleGeometries[neighborIndex];
          const merged = mergeArcs(topology, [smallest, neighbor]);

          // MultiPolygon -> Polygon
          merged.area = smallest.area + neighbor.area;
          merged.type = 'Polygon';
          merged.arcs = merged.arcs[0];

          // Delete smallest and its chosen neighbor
          triangleGeometries.splice(neighborIndex, 1);
          triangleGeometries.shift();

          // Add new merged shape in sorted order
          triangleGeometries.splice(bisect(triangleGeometries, merged.area), 0, merged);
        }
      }

      function createGeometries (vertices, triangleIndices) {
        const geometries = [];

        for (let i = 0; i < triangleIndices.length; i += 3) {
          const triangleIndexArcs = createTriangleIndexArcs(triangleIndices, i);

          let outerRing = map(triangleIndexArcs, arc => getPoint(vertices, arc[0]));
          outerRing.push(getPoint(vertices, triangleIndexArcs[0][0])); // close ring

          // earcut doesn't always give counterclockwise rings back
          if (linearRingIsClockwise(outerRing)) {
            outerRing = outerRing.reverse();
          }

          geometries.push({
            type: 'Polygon',
            coordinates: [outerRing]
          });
        }

        return geometries
      }

      function sliceUpTriangles (geometries, numberOfPieces) {
        const areas = map(geometries, polygonArea);

        const order = getOrderDescending(areas);

        const areasSorted = sortIntoOrder(areas, order);
        const geometriesSorted = sortIntoOrder(geometries, order);

        while (geometriesSorted.length < numberOfPieces) {
          areasSorted.shift();
          const biggestTriangle = geometriesSorted.shift();

          const cutTriangles = cutTriangleInTwo(biggestTriangle);

          const areaCutTriangles = map(cutTriangles, polygonArea);

          for (let i = 0; i < cutTriangles.length; i++) {
            const areaCutTriangle = areaCutTriangles[i];
            const cutTriangle = cutTriangles[i];

            const insertionIndex = getInsertionIndexDescending(areasSorted, areaCutTriangle);

            areasSorted.splice(insertionIndex, 0, areaCutTriangle);
            geometriesSorted.splice(insertionIndex, 0, cutTriangle);
          }
        }

        return geometriesSorted
      }

      function cutTriangleInTwo (triangle) {
        const a = triangle.coordinates[0][0];
        const b = triangle.coordinates[0][1];
        const c = triangle.coordinates[0][2];

        const pointBetweenAB = interpolate(a, b)(0.5);

        const firstTriangle = createTriangleGeometry([a, pointBetweenAB, c, a]);
        const secondTriangle = createTriangleGeometry([b, c, pointBetweenAB, b]);

        return [firstTriangle, secondTriangle]
      }

      function createTriangleGeometry (points) {
        return {
          type: 'Polygon',
          coordinates: [points]
        }
      }

      /*
        Inspired by flubber:
        https://github.com/veltman/flubber
      */

      const dimensions = 2;

      function cutPolygon (polygon, numberOfPieces) {
        if (numberOfPieces < 2) throw new Error('Cannot cut polygon in less than 2 pieces')

        const flattenedPolygon = earcut_1.flatten(polygon.coordinates);
        const triangleIndices = earcut_1(flattenedPolygon.vertices, flattenedPolygon.holes, dimensions);

        const numberOfTriangles = getNumberOfTriangles(triangleIndices);

        if (numberOfTriangles >= numberOfPieces) {
          const topology = createTopology(flattenedPolygon.vertices, triangleIndices);
          return collapseTopology(topology, numberOfPieces)
        }

        if (numberOfTriangles < numberOfPieces) {
          const triangleGeometries = createGeometries(flattenedPolygon.vertices, triangleIndices);
          return sliceUpTriangles(triangleGeometries, numberOfPieces)
        }
      }

      function getNumberOfTriangles (triangleIndices) {
        return triangleIndices.length / 3
      }

      function cutPolygons (polygons, numberOfDesiredAdditionalPolygons) {
        if (numberOfDesiredAdditionalPolygons < 1) throw wrongNumberOfPolygonsError

        const polygonAreas = map(polygons, polygonArea);
        const numberOfCutsPerPolygon = assignCuts(polygonAreas, numberOfDesiredAdditionalPolygons);

        let resultingPolygons = [];

        for (let i = 0; i < polygons.length; i++) {
          const polygon = polygons[i];
          const numberOfCuts = numberOfCutsPerPolygon[i];

          if (numberOfCuts === 0) {
            resultingPolygons.push(polygon);
          }

          if (numberOfCuts > 0) {
            const numberOfDesiredPolygons = numberOfCuts + 1;
            resultingPolygons = resultingPolygons.concat(cutPolygon(polygon, numberOfDesiredPolygons));
          }
        }

        return resultingPolygons
      }

      const wrongNumberOfPolygonsError = new Error('Number of desired additional polygons must be larger than 0');

      // https://stackoverflow.com/a/38905829/7237112
      function assignCuts (polygonAreas, numberOfPieces) {
        const numberOfCutsPerPolygon = [];
        let totalArea = sum(polygonAreas);

        for (let i = 0; i < polygonAreas.length; i++) {
          const area = polygonAreas[i];
          const numberOfCuts = Math.round(area / totalArea * numberOfPieces);

          numberOfCutsPerPolygon.push(numberOfCuts);
          totalArea -= area;
          numberOfPieces -= numberOfCuts;
        }

        return numberOfCutsPerPolygon
      }

      function sum (array) {
        let sum = 0;

        for (let i = 0; i < array.length; i++) {
          sum += array[i];
        }

        return sum
      }

      function combineIntoMultiPolygon (inputGeometries) {
        const multiPolygon = createEmptyMultiPolygon();

        for (const inputGeometry of inputGeometries) {
          if (inputGeometry.type === 'Polygon') {
            multiPolygon.coordinates.push(inputGeometry.coordinates);
          }

          if (inputGeometry.type === 'MultiPolygon') {
            for (const polygon of inputGeometry.coordinates) {
              multiPolygon.coordinates.push(polygon);
            }
          }
        }

        return multiPolygon
      }

      function splitMultiPolygon (multiPolygon) {
        const polygons = [];

        for (const polygonCoordinates of multiPolygon.coordinates) {
          const polygon = createEmptyPolygon();
          polygon.coordinates = polygonCoordinates;

          polygons.push(polygon);
        }

        return polygons
      }

      function createEmptyMultiPolygon () {
        return { type: 'MultiPolygon', coordinates: [] }
      }

      function createEmptyPolygon () {
        return { type: 'Polygon', coordinates: undefined }
      }

      function multiPolygonToMultiPolygon (from, to) {
        let fromPolygons = splitMultiPolygon(from);
        let toPolygons = splitMultiPolygon(to);

        const lengthDifference = fromPolygons.length - toPolygons.length;

        if (lengthDifference > 0) {
          toPolygons = cutPolygons(toPolygons, lengthDifference);
        }

        if (lengthDifference < 0) {
          fromPolygons = cutPolygons(fromPolygons, -lengthDifference);
        }

        return createInterpolatorPolygons(from, to, fromPolygons, toPolygons)
      }

      function createInterpolatorPolygons (from, to, fromPolygons, toPolygons) {
        const fromOuterRings = map(fromPolygons, polygon => polygon.coordinates[0]);
        const toOuterRings = map(toPolygons, polygon => polygon.coordinates[0]);

        const fromOrder = matchLinearRings(fromOuterRings, toOuterRings);
        fromPolygons = map(fromOrder, i => fromPolygons[i]);

        const polygonInterpolators = [];

        for (let i = 0; i < fromPolygons.length; i++) {
          const fromPolygon = fromPolygons[i];
          const toPolygon = toPolygons[i];

          polygonInterpolators.push(polygonToPolygon(fromPolygon, toPolygon));
        }

        return function interpolator (t) {
          if (t === 0) return from
          if (t === 1) return to

          return combineIntoMultiPolygon(
            map(polygonInterpolators, polygonInterpolator => polygonInterpolator(t))
          )
        }
      }

      function multiPolygonToPolygon (from, to) {
        const fromPolygons = splitMultiPolygon(from);
        let toPolygons = [to];

        const numberOfFromPolygons = fromPolygons.length;
        const numberOfAdditionalToPolygonsRequried = numberOfFromPolygons - 1;

        if (numberOfAdditionalToPolygonsRequried > 0) {
          toPolygons = cutPolygon(to, numberOfFromPolygons);
        }

        return createInterpolatorPolygons(from, to, fromPolygons, toPolygons)
      }

      function polygonToMultiPolygon (from, to) {
        const reverseInterpolator = multiPolygonToPolygon(to, from);

        return function interpolator (t) {
          return reverseInterpolator(1 - t)
        }
      }

      function lineStringtoLineString (from, to) {
        const [preparedFromCoordinates, preparedToCoordinates] = prepareCoordinates(
          from.coordinates, to.coordinates
        );

        return createInterpolator(from, to, preparedFromCoordinates, preparedToCoordinates)
      }

      function prepareCoordinates (fromCoordinates, toCoordinates) {
        const lengthDifference = fromCoordinates.length - toCoordinates.length;

        let preparedFromCoordinates = fromCoordinates;
        let preparedToCoordinates = toCoordinates;

        if (lengthDifference > 0) {
          preparedToCoordinates = insertPointsLineString(toCoordinates, lengthDifference);
        }

        if (lengthDifference < 0) {
          preparedFromCoordinates = insertPointsLineString(fromCoordinates, -lengthDifference);
        }

        preparedFromCoordinates = reverseIfBetterMatching(preparedFromCoordinates, preparedToCoordinates);

        return [preparedFromCoordinates, preparedToCoordinates]
      }

      function createInterpolator (from, to, preparedFromCoordinates, preparedToCoordinates) {
        const coordinateInterpolator = interpolate(preparedFromCoordinates, preparedToCoordinates);

        return function interpolator (t) {
          if (t === 0) return from
          if (t === 1) return to

          return {
            type: 'LineString',
            coordinates: coordinateInterpolator(t)
          }
        }
      }

      function reverseIfBetterMatching (from, to) {
        const normalTotalSquareDistance = getTotalSquaredDistancePositions(from, to);
        const fromReversed = cloneLinearRing(from).reverse();
        const reversedTotalSquareDistance = getTotalSquaredDistancePositions(fromReversed, to);

        if (normalTotalSquareDistance <= reversedTotalSquareDistance) {
          return from
        } else {
          return fromReversed
        }
      }

      function getTotalSquaredDistancePositions (from, to) {
        let totalSquaredDistance = 0;

        for (let i = 0; i < from.length; i++) {
          totalSquaredDistance += pointDistance(from[i], to[i]);
        }

        return totalSquaredDistance
      }

      function movePointAlongLine (a, b, distance) {
        const unitVector = getUnitVector(a, b);
        return movePoint(a, unitVector, distance)
      }

      function getUnitVector (a, b) {
        const magnitude = pointDistance(a, b);
        const dx = b[0] - a[0];
        const dy = b[1] - a[1];

        return [dx / magnitude, dy / magnitude]
      }

      function movePoint (point, unitVector, distance) {
        return [
          point[0] + unitVector[0] * distance,
          point[1] + unitVector[1] * distance
        ]
      }

      function multiLineStringToLineString (from, to) {
        const numberOfFromLineStrings = from.coordinates.length;
        const preparedToCoordinates = cutLineString(to.coordinates, numberOfFromLineStrings);
        const lineStringInterpolators = createLineStringInterpolators(from.coordinates, preparedToCoordinates);

        return createMultiLineStringInterpolator(from, to, lineStringInterpolators)
      }

      function lineStringToMultiLineString (from, to) {
        const reverseInterpolator = multiLineStringToLineString(to, from);

        return function interpolator (t) {
          return reverseInterpolator(1 - t)
        }
      }

      function cutLineString (toCoordinates, numberOfLineStrings) {
        const multiLineStringCoordinates = [];

        const totalLengthTo = linearRingLength(toCoordinates);
        const desiredSegmentSize = totalLengthTo / numberOfLineStrings;

        const lastPointIndex = toCoordinates.length - 1;

        let currentSegment = [];
        let elapsedDistanceSinceLastCut = 0;

        for (let i = 0; i < lastPointIndex; i++) {
          const a = toCoordinates[i];
          currentSegment.push(a);
          const b = toCoordinates[i + 1];

          const distanceAB = pointDistance(a, b);
          const distanceIncludingCurrentSegment = elapsedDistanceSinceLastCut + distanceAB;

          if (distanceIncludingCurrentSegment < desiredSegmentSize) {
            elapsedDistanceSinceLastCut += distanceAB;
          }

          if (distanceIncludingCurrentSegment >= desiredSegmentSize) {
            const numberOfCuts = Math.floor(distanceIncludingCurrentSegment / desiredSegmentSize);

            const cutCoordinates = calculateCutCoordinates(
              a, b, elapsedDistanceSinceLastCut, desiredSegmentSize, numberOfCuts
            );

            currentSegment = currentSegment.concat(cutCoordinates);
            multiLineStringCoordinates.push(currentSegment);

            const lastCut = cutCoordinates[cutCoordinates.length - 1];

            if (pointsEqual(lastCut, b)) {
              currentSegment = [];
            } else {
              currentSegment = [lastCut];
            }

            elapsedDistanceSinceLastCut = pointDistance(lastCut, b);
          }
        }

        return multiLineStringCoordinates
      }

      function calculateCutCoordinates (a, b, offset, size, numberOfCuts) {
        const cuts = [];

        for (let i = 1; i <= numberOfCuts; i++) {
          cuts.push(movePointAlongLine(a, b, ((size * i) - offset)));
        }

        return cuts
      }

      function pointsEqual (a, b) {
        return a[0] === b[0] && a[1] === b[1]
      }

      function createLineStringInterpolators (fromCoordinates, toCoordinates) {
        const interpolators = [];

        for (let i = 0; i < fromCoordinates.length; i++) {
          const fromLineString = fromCoordinates[i];
          const toLineString = toCoordinates[i];

          const [preparedFromLineString, preparedToLineString] = prepareCoordinates(fromLineString, toLineString);
          const interpolator = interpolate(preparedFromLineString, preparedToLineString);
          interpolators.push(interpolator);
        }

        return interpolators
      }

      function createMultiLineStringInterpolator (from, to, lineStringInterpolators) {
        return function interpolator (t) {
          if (t === 0) return from
          if (t === 1) return to

          return {
            type: 'MultiLineString',
            coordinates: map(
              lineStringInterpolators,
              lineStringInterpolator => lineStringInterpolator(t)
            )
          }
        }
      }

      function matchLineStrings (input, target) {
        const inputOrder = getInputOrder(input, target);
        return inputOrder.map(i => input[i])
      }

      function getInputOrder (input, target) {
        const inputLengths = map(input, linearRingLength);
        const targetLengths = map(target, linearRingLength);

        const inputLengthOrderDescending = getOrderDescending(inputLengths);
        const targetLengthOrderDescending = getOrderDescending(targetLengths);

        const pairs = {};

        for (let i = 0; i < targetLengthOrderDescending.length; i++) {
          const inputIndex = inputLengthOrderDescending[i];
          const targetIndex = targetLengthOrderDescending[i];

          pairs[inputIndex] = targetIndex;
        }

        const inputOrder = [];

        for (let i = 0; i < target.length; i++) {
          inputOrder.push(pairs[i]);
        }

        return inputOrder
      }

      function multiLineStringToMultiLineString (from, to) {
        let fromLineStrings = from.coordinates;
        let toLineStrings = to.coordinates;

        const lengthDifference = fromLineStrings.length - toLineStrings.length;

        if (lengthDifference > 0) {
          toLineStrings = splitLineStrings(toLineStrings, lengthDifference);
        }

        if (lengthDifference < 0) {
          fromLineStrings = splitLineStrings(fromLineStrings, -lengthDifference);
        }

        fromLineStrings = matchLineStrings(fromLineStrings, toLineStrings);

        const lineStringInterpolators = createLineStringInterpolators(fromLineStrings, toLineStrings);

        return createMultiLineStringInterpolator(from, to, lineStringInterpolators)
      }

      function splitLineStrings (lineStrings, numberOfDesiredLineStrings) {
        const lineStringLengths = getLengths(lineStrings);
        const numberOfCutsPerLineString = assignCuts(lineStringLengths, numberOfDesiredLineStrings);

        let resultingLineStrings = [];

        for (let i = 0; i < numberOfCutsPerLineString.length; i++) {
          const lineString = lineStrings[i];
          const numberOfCuts = numberOfCutsPerLineString[i];

          if (numberOfCuts === 0) {
            resultingLineStrings.push(lineString);
          }

          if (numberOfCuts > 0) {
            const numberOfDesiredPieces = numberOfCuts + 1;

            resultingLineStrings = resultingLineStrings.concat(
              cutLineString(lineString, numberOfDesiredPieces)
            );
          }
        }

        return resultingLineStrings
      }

      function getLengths (lineStrings) {
        const lengths = [];

        for (let i = 0; i < lineStrings.length; i++) {
          lengths.push(
            linearRingLength(lineStrings[i])
          );
        }

        return lengths
      }

      function transshape (from, to) {
        ensureValidInput(from, to);

        // Polygon transitions
        if (from.type === 'Polygon' && to.type === 'Polygon') {
          return polygonToPolygon(from, to)
        }

        if (from.type === 'MultiPolygon' && to.type === 'Polygon') {
          return multiPolygonToPolygon(from, to)
        }

        if (from.type === 'Polygon' && to.type === 'MultiPolygon') {
          return polygonToMultiPolygon(from, to)
        }

        if (from.type === 'MultiPolygon' && to.type === 'MultiPolygon') {
          return multiPolygonToMultiPolygon(from, to)
        }

        // LineString transitions
        if (from.type === 'LineString' && to.type === 'LineString') {
          return lineStringtoLineString(from, to)
        }

        if (from.type === 'MultiLineString' && to.type === 'LineString') {
          return multiLineStringToLineString(from, to)
        }

        if (from.type === 'LineString' && to.type === 'MultiLineString') {
          return lineStringToMultiLineString(from, to)
        }

        if (from.type === 'MultiLineString' && to.type === 'MultiLineString') {
          return multiLineStringToMultiLineString(from, to)
        }
      }

      function ensureValidInput (from, to) {
        if (bothPolygons(from, to) || bothLines(from, to)) {
          return
        }

        throw new Error('Invalid input')
      }

      function bothPolygons (from, to) {
        return isPolygonOrMultiPolygon(from) && isPolygonOrMultiPolygon(to)
      }

      function bothLines (from, to) {
        return isLineStringOrMultiLineString(from) && isLineStringOrMultiLineString(to)
      }

      function implode (geometry) {
        ensureValidInput$1(geometry);

        const centroid = calculateCentroid(geometry);
        const implosionPoint = createSmallPolygonAroundPoint(centroid);

        return transshape(geometry, implosionPoint)
      }

      function explode (geometry) {
        ensureValidInput$1(geometry);

        const centroid = calculateCentroid(geometry);
        const explosionPoint = createSmallPolygonAroundPoint(centroid);

        return transshape(explosionPoint, geometry)
      }

      function ensureValidInput$1 (geometry) {
        if (!isPolygonOrMultiPolygon(geometry)) {
          throw new Error('Invalid input')
        }
      }

      function createSmallPolygonAroundPoint (point) {
        const linearRingAroundPoint = makeSmallRectangleAroundPoint(point);
        return {
          type: 'Polygon',
          coordinates: [linearRingAroundPoint]
        }
      }

      function transshapeLayer (fromLayer, toLayer) {
        ensureValidInput$2(fromLayer);

        const keyOverlap = getKeyOverlap(fromLayer, toLayer);
        const interpolatorObject = constructInterpolatorObject(fromLayer, toLayer, keyOverlap);

        return createLayerInterpolator(fromLayer, toLayer, interpolatorObject)
      }

      function ensureValidInput$2 (fromLayer, toLayer) {
        return every(Object.values(fromLayer), isPolygonOrMultiPolygon) &&
          every(Object.values(fromLayer), isPolygonOrMultiPolygon)
      }

      function getKeyOverlap (fromLayer, toLayer) {
        const keyOverlap = {};

        for (const key in fromLayer) {
          keyOverlap[key] = 'from';
        }

        for (const key in toLayer) {
          if (keyOverlap[key]) {
            keyOverlap[key] = 'both';
          } else {
            keyOverlap[key] = 'to';
          }
        }

        return keyOverlap
      }

      function constructInterpolatorObject (fromLayer, toLayer, keyOverlap) {
        const interpolatorObject = {};

        for (const key in keyOverlap) {
          const overlap = keyOverlap[key];

          if (overlap === 'both') {
            interpolatorObject[key] = transshape(fromLayer[key], toLayer[key]);
          }

          if (overlap === 'from') {
            interpolatorObject[key] = implode(fromLayer[key]);
          }

          if (overlap === 'to') {
            interpolatorObject[key] = explode(toLayer[key]);
          }
        }

        return interpolatorObject
      }

      function createLayerInterpolator (fromLayer, toLayer, interpolatorObject) {
        return function interpolator (t) {
          if (t === 0) return fromLayer
          if (t === 1) return toLayer

          const layerObject = {};

          for (const key in interpolatorObject) {
            layerObject[key] = interpolatorObject[key](t);
          }

          return layerObject
        }
      }

      exports.cutPolygon = cutPolygon;
      exports.cutPolygons = cutPolygons;
      exports.explode = explode;
      exports.implode = implode;
      exports.insertPointsLinearRing = insertPointsLinearRing;
      exports.matchLinearRings = matchLinearRings;
      exports.rotatePointsLinearRing = rotatePointsLinearRing;
      exports.transshape = transshape;
      exports.transshapeLayer = transshapeLayer;

      Object.defineProperty(exports, '__esModule', { value: true });

    }));
    });

    var transshape = unwrapExports(transshape_umd);

    function transitionGeometry (fromGeometry, toGeometry) {
      if (pointTransition(fromGeometry, toGeometry)) {
        return interpolate(fromGeometry, toGeometry)
      }

      if (polygonTransition(fromGeometry, toGeometry)) {
        return transshape.transshape(fromGeometry, toGeometry)
      }

      if (lineStringTransition(fromGeometry, toGeometry)) {
        return transshape.transshape(fromGeometry, toGeometry)
      }

      throw new Error('Invalid input')
    }

    function transitionGeometries (fromLayer, toLayer) {
      const firstFromGeometry = getFirstGeometry(fromLayer);
      const firstToGeometry = getFirstGeometry(toLayer);

      if (pointTransition(firstFromGeometry, firstToGeometry)) {
        return transitionLayer(fromLayer, toLayer, interpolate)
      }

      if (polygonTransition(firstFromGeometry, firstToGeometry)) {
        return transitionLayer(fromLayer, toLayer, transshape.transshape)
      }

      if (lineStringTransition(firstFromGeometry, firstToGeometry)) {
        return transitionLayer(fromLayer, toLayer, transshape.transshape)
      }

      throw new Error('Invalid input')
    }

    function pointTransition (fromGeometry, toGeometry) {
      return fromGeometry.type === 'Point' && toGeometry.type === 'Point'
    }

    const polygonTypes = ['Polygon', 'MultiPolygon'];

    function polygonTransition (fromGeometry, toGeometry) {
      return polygonTypes.includes(fromGeometry.type) &&
        polygonTypes.includes(toGeometry.type)
    }

    const lineStringTypes = ['LineString', 'MultiLineString'];

    function lineStringTransition (fromGeometry, toGeometry) {
      return lineStringTypes.includes(fromGeometry.type) &&
        lineStringTypes.includes(toGeometry.type)
    }

    function getFirstGeometry (layer) {
      return layer[Object.keys(layer)[0]]
    }

    function transitionLayer (fromLayer, toLayer, interpolationMethod) {
      const interpolatorObject = {};

      for (const key in toLayer) {
        if (key in fromLayer) {
          interpolatorObject[key] = interpolationMethod(fromLayer[key], toLayer[key]);
        } else {
          interpolatorObject[key] = () => toLayer[key];
        }
      }

      return function interpolator (t) {
        if (t === 0) return fromLayer
        if (t === 1) return toLayer

        const layer = {};
        for (const key in interpolatorObject) {
          layer[key] = interpolatorObject[key](t);
        }

        return layer
      }
    }

    function createItemFromBBox (bbox) {
      return {
        minX: bbox.x[0],
        maxX: bbox.x[1],
        minY: bbox.y[0],
        maxY: bbox.y[1]
      }
    }

    function indexRectangle (markData) {
      const rectangleAttributes = markData.attributes;

      const bbox = calculateBBoxGeometry(rectangleAttributes.screenGeometry);
      const item = createItemFromBBox(bbox);

      item.attributes = rectangleAttributes;
      item.markType = 'Rectangle';
      item.markId = markData.markId;

      return item
    }

    function indexRectangleLayer ({ layerAttributes, keyArray, layerId }) {
      const items = [];

      for (let i = 0; i < keyArray.length; i++) {
        const key = keyArray[i];

        const rectangleAttributes = getRectangleAttributes(layerAttributes, key);
        const bbox = calculateBBoxGeometry(rectangleAttributes.screenGeometry);
        const item = createItemFromBBox(bbox);

        item.key = key;
        item.index = i;
        item.attributes = rectangleAttributes;
        item.markType = 'Rectangle';
        item.layerId = layerId;

        items.push(item);
      }

      return items
    }

    function getRectangleAttributes (layerAttributes, key) {
      return { screenGeometry: layerAttributes.screenGeometryObject[key] }
    }

    function indexPolygon (markData) {
      const polygonAttributes = markData.attributes;

      const bbox = calculateBBoxGeometry(polygonAttributes.screenGeometry);
      const item = createItemFromBBox(bbox);

      item.attributes = polygonAttributes;
      item.markType = 'Polygon';
      item.markId = markData.markId;

      return item
    }

    function indexPolygonLayer ({ layerAttributes, keyArray, layerId }) {
      const items = [];

      for (let i = 0; i < keyArray.length; i++) {
        const key = keyArray[i];

        const polygonAttributes = getPolygonAttributes(layerAttributes, key);
        const bbox = calculateBBoxGeometry(polygonAttributes.screenGeometry);
        const item = createItemFromBBox(bbox);

        item.key = key;
        item.index = i;
        item.attributes = polygonAttributes;
        item.markType = 'Polygon';
        item.layerId = layerId;

        items.push(item);
      }

      return items
    }

    function getPolygonAttributes (layerAttributes, key) {
      return { screenGeometry: layerAttributes.screenGeometryObject[key] }
    }

    function indexLine (markData) {
      const lineAttributes = markData.attributes;
      const markId = markData.markId;

      const pixelGeometry = lineAttributes.pixelGeometry;
      const lineStringCoords = pixelGeometry.coordinates;

      if (pixelGeometry.type === 'LineString') {
        return indexLineString(lineStringCoords, lineAttributes, markId)
      }

      if (pixelGeometry.type === 'MultiLineString') {
        return indexMultiLineString(lineStringCoords, lineAttributes, markId)
      }
    }

    function indexLineString (lineStringCoords, lineAttributes, markId, lineStringIndex) {
      const indexableSegments = [];

      for (let i = 0; i < lineStringCoords.length - 1; i++) {
        const segment = [lineStringCoords[i], lineStringCoords[i + 1]];

        const item = createSegmentItem(segment, lineAttributes, i);
        if (lineStringIndex) {
          // Only for MultiLineStrings
          item.lineStringIndex = lineStringIndex;
        }
        item.markId = markId;
        indexableSegments.push(item);
      }

      return indexableSegments
    }

    function indexMultiLineString (lineStringCoords, lineAttributes, markId) {
      let indexableSegments = [];

      for (let lineStringIndex = 0; lineStringIndex < lineStringCoords.length; lineStringIndex++) {
        indexableSegments = indexableSegments.concat(indexLineString(
          lineStringCoords[lineStringIndex], lineAttributes, markId, lineStringIndex
        ));
      }

      return indexableSegments
    }

    function createSegmentItem (segment, attributes, i) {
      const segmentGeometry = { type: 'LineString', coordinates: segment };
      const bbox = calculateBBoxGeometry(segmentGeometry);
      let item = createItemFromBBox(bbox);
      item = takeIntoAccountStrokeWidth(item, attributes.strokeWidth);

      item.attributes = {};
      item.attributes.strokeWidth = attributes.strokeWidth;
      item.attributes.segmentGeometry = segmentGeometry;
      item.markType = 'Line';
      item.segmentIndex = i;

      return item
    }

    function takeIntoAccountStrokeWidth (item, strokeWidth) {
      const halfStrokeWidth = strokeWidth / 2;

      const newBbox = {
        minX: item.minX - halfStrokeWidth,
        maxX: item.maxX + halfStrokeWidth,
        minY: item.minY - halfStrokeWidth,
        maxY: item.maxY + halfStrokeWidth
      };

      return Object.assign(item, newBbox)
    }

    function indexLineLayer ({ layerAttributes, keyArray, layerId }) {
      let items = [];

      for (let i = 0; i < keyArray.length; i++) {
        const key = keyArray[i];
        const lineAttributes = createLineAttributes(layerAttributes, key);
        const pixelGeometry = lineAttributes.pixelGeometry;
        const lineStringCoords = pixelGeometry.coordinates;

        if (pixelGeometry.type === 'LineString') {
          let segments = indexLineString(
            lineStringCoords, lineAttributes, key
          );

          segments = modifyForLayer(segments, layerId, key, i);
          items = items.concat(segments);
        }

        if (pixelGeometry.type === 'MultiLineString') {
          let segments = indexMultiLineString(
            lineStringCoords, lineAttributes, key
          );

          segments = modifyForLayer(segments, layerId, key, i);
          items = items.concat(segments);
        }
      }

      return items
    }

    function createLineAttributes (attributes, key) {
      return {
        pixelGeometry: attributes.pixelGeometryObject[key],
        strokeWidth: attributes.strokeWidthObject[key]
      }
    }

    function modifyForLayer (segments, layerId, key, index) {
      for (let i = 0; i < segments.length; i++) {
        const segmentItem = segments[i];
        delete segmentItem.markId;

        segmentItem.layerId = layerId;
        segmentItem.key = key;
        segmentItem.index = index;
      }

      return segments
    }

    function indexArea (markData) {
      const areaAttributes = markData.attributes;

      const bbox = calculateBBoxGeometry(areaAttributes.screenGeometry);
      const item = createItemFromBBox(bbox);

      item.attributes = areaAttributes;
      item.markType = 'Area';
      item.markId = markData.markId;

      return item
    }

    function indexAreaLayer ({ layerAttributes, keyArray, layerId }) {
      const items = [];

      for (let i = 0; i < keyArray.length; i++) {
        const key = keyArray[i];

        const areaAttributes = getAreaAttributes(layerAttributes, key);
        const bbox = calculateBBoxGeometry(areaAttributes.screenGeometry);
        const item = createItemFromBBox(bbox);

        item.key = key;
        item.index = i;
        item.attributes = areaAttributes;
        item.markType = 'Area';
        item.layerId = layerId;

        items.push(item);
      }

      return items
    }

    function getAreaAttributes (layerAttributes, key) {
      return { screenGeometry: layerAttributes.screenGeometryObject[key] }
    }

    const markIndexing = {
      Point: indexPoint,
      Rectangle: indexRectangle,
      Polygon: indexPolygon,
      Line: indexLine,
      Label: indexPoint,
      Area: indexArea
    };

    const layerIndexing = {
      Point: indexPointLayer,
      Rectangle: indexRectangleLayer,
      Polygon: indexPolygonLayer,
      Line: indexLineLayer,
      Label: indexPointLayer,
      Area: indexAreaLayer
    };

    class MarkInteractionInterface extends BaseInteractionInterface {
      constructor (interactionManager, InteractionHandlers) {
        super(interactionManager, InteractionHandlers);

        this._indexableMarks = {};
        this._indexableLayers = {};
      }

      // Mark loading and removing
      loadMark (markType, markData) {
        const indexingFunction = markIndexing[markType];
        const indexableMark = indexingFunction(markData);

        const markId = markData.markId;
        this._indexableMarks[markId] = indexableMark;
      }

      markIsLoaded (markId) {
        return markId in this._indexableMarks
      }

      removeMark (markId) {
        delete this._indexableMarks[markId];
      }

      // Layer loading and removing
      loadLayer (layerType, layerData) {
        const indexingFunction = layerIndexing[layerType];
        const indexableLayer = indexingFunction(layerData);

        const layerId = layerData.layerId;
        this._indexableLayers[layerId] = indexableLayer;
      }

      layerIsLoaded (layerId) {
        return layerId in this._indexableLayers
      }

      removeLayer (layerId) {
        delete this._indexableLayers[layerId];
      }

      // Add/remove mark interactions
      addMarkInteraction (interactionName, markId, callback) {
        this._getHandler(interactionName).addMarkInteraction(markId, callback);
      }

      removeAllMarkInteractions (markId) {
        for (const handlerName in this._handlers) {
          const handler = this._handlers[handlerName];

          if (handler.hasMark(markId)) {
            handler.removeMarkInteraction(markId);
          }
        }
      }

      // Add/remove layer interactions
      addLayerInteraction (interactionName, layerId, callback) {
        this._getHandler(interactionName).addLayerInteraction(layerId, callback);
      }

      removeAllLayerInteractions (layerId) {
        for (const handlerName in this._handlers) {
          const handler = this._handlers[handlerName];

          if (handler.hasLayer(layerId)) {
            handler.removeLayerInteraction(layerId);
          }
        }
      }
    }

    class SectionInteractionInterface extends BaseInteractionInterface {
      addInteraction (interactionName, callback) {
        this._getHandler(interactionName).addInteraction(callback);
      }

      removeAllInteractions () {
        for (const handlerName in this._handlers) {
          const handler = this._handlers[handlerName];

          if (handler.hasInteraction()) {
            handler.removeInteraction();
          }
        }
      }
    }

    class BaseInteractionHandler {
      constructor (interactionManager, { eventName, interactionName }) {
        this._interactionManager = interactionManager;
        this._eventName = eventName;
        this._interactionName = interactionName;
      }

      interactionManager () {
        return this._interactionManager
      }

      eventManager () {
        return this._interactionManager._eventManager
      }

      section () {
        return this._interactionManager._section
      }

      id () {
        return this._interactionManager._id
      }

      _addEventListener () {
        const handler = this._handleEvent.bind(this);

        const eventManager = this.eventManager();
        const listenerId = this.getId();

        const events = isArray(this._eventName) ? this._eventName : [this._eventName];

        for (const event of events) {
          eventManager
            .eventTracker(event)
            .addListener(listenerId, handler);
        }
      }

      _removeEventListener () {
        const eventManager = this.eventManager();
        const listenerId = this.getId();

        const events = isArray(this._eventName) ? this._eventName : [this._eventName];

        for (const event of events) {
          eventManager
            .eventTracker(event)
            .removeListener(listenerId);
        }
      }
    }

    function isArray (value) {
      return value.constructor === Array
    }

    var rbush_min = createCommonjsModule(function (module, exports) {
    !function(t,i){module.exports=i();}(commonjsGlobal,function(){function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h);}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--;}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1);}}(t,r,e||0,a||t.length-1,h||n);}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r;}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear();};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return -1}function a(t,i){h(t,0,t.children.length,i,t);}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h);}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return (t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return {children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r);}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h));}i=e.pop();}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return !1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return !0;n.push(e);}}i=n.pop();}return !1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r;}this._insert(n,this.data.height-n.height-1,!0);}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0]);}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1));}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s);}i=h||i.children[0];}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i);},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o);},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox);},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p);}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r);},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a);}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s);}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t);},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox);},r});
    });

    function pointCollision (coordinates, pointAttributes) {
      const distance = pointDistance(
        [coordinates.x, coordinates.y],
        pointAttributes.pixelGeometry.coordinates
      );

      return distance < pointAttributes.radius
    }

    function rectangleCollision (coordinates, rectangleAttributes) {
      const point = [coordinates.x, coordinates.y];
      return pointInPolygon(point, rectangleAttributes.screenGeometry)
    }

    function polygonCollision (coordinates, polygonAttributes) {
      const point = [coordinates.x, coordinates.y];
      return pointInPolygon(point, polygonAttributes.screenGeometry)
    }

    function lineCollision (coordinates, lineAttributes) {
      const mouseCoordinates = [coordinates.x, coordinates.y];
      return pointIntersectsLineSegment(
        mouseCoordinates,
        lineAttributes.segmentGeometry.coordinates,
        lineAttributes.strokeWidth
      )
    }

    function areaCollision (coordinates, areaAttributes) {
      const point = [coordinates.x, coordinates.y];
      return pointInPolygon(point, areaAttributes.screenGeometry)
    }

    var collisionTests = {
      Point: pointCollision,
      Rectangle: rectangleCollision,
      Polygon: polygonCollision,
      Line: lineCollision,
      Label: pointCollision,
      Area: areaCollision
    };

    class SpatialIndex {
      constructor (interactionHandler, getMark, getLayer) {
        this._rbush = new rbush_min();
        this._interactionHandler = interactionHandler;

        this._getMark = getMark.bind(interactionHandler);
        this._getLayer = getLayer.bind(interactionHandler);
      }

      // Layer indexing and unindexing
      indexLayer (layerId) {
        const layer = this._getLayer(layerId);
        this._rbush.load(layer);
      }

      unindexLayer (layerId) {
        const layer = this._getLayer(layerId);

        for (let i = 0; i < layer.length; i++) {
          const item = layer[i];
          this._rbush.remove(item);
        }
      }

      // Mark loading and removing
      indexMark (markId) {
        const mark = this._getMark(markId);

        if (multipleSegments(mark)) {
          this._rbush.load(mark);
        } else {
          this._rbush.insert(mark);
        }
      }

      unindexMark (markId) {
        const mark = this._getMark(markId);

        if (multipleSegments(mark)) {
          for (let i = 0; i < mark.length; i++) {
            const item = mark[i];
            this._rbush.remove(item);
          }
        } else {
          this._rbush.remove(mark);
        }
      }

      // Query functions
      queryMouseCoordinates (mouseCoordinates, radius) {
        const searchArea = searchAreaFromCoordinates(mouseCoordinates, radius);
        const indexQueryResults = this._rbush.search(searchArea);

        return this._getHits(mouseCoordinates, indexQueryResults)
      }

      queryBoundingBox (boundingBox) {
        return this._rbush.search(boundingBox)
      }

      // Internal
      _getHits (coordinates, indexQueryResults) {
        const hits = [];

        for (let i = 0; i < indexQueryResults.length; i++) {
          const indexQueryResult = indexQueryResults[i];
          const collisionTest = collisionTests[indexQueryResult.markType];

          if (collisionTest(coordinates, indexQueryResult.attributes)) {
            hits.push(indexQueryResult);
          }
        }

        return hits
      }
    }

    function searchAreaFromCoordinates (coordinates, radius = 3) {
      return {
        minX: coordinates.x - radius,
        maxX: coordinates.x + radius,
        minY: coordinates.y - radius,
        maxY: coordinates.y + radius
      }
    }

    function multipleSegments (indexableItem) {
      return indexableItem.constructor === Array
    }

    class MarkInteractionHandler extends BaseInteractionHandler {
      constructor (interactionManager, options) {
        super(interactionManager, options);

        const getMark = function (markId) {
          return this._interactionManager.marks()._indexableMarks[markId]
        };

        const getLayer = function (layerId) {
          return this._interactionManager.marks()._indexableLayers[layerId]
        };

        this._spatialIndex = new SpatialIndex(this, getMark, getLayer);

        this._numberOfInteractions = 0;

        this._markCallbacks = {};
        this._layerCallbacks = {};
      }

      // Add/remove mark interactions
      addMarkInteraction (markId, callback) {
        this._addEventListenerIfNecessary();
        this._numberOfInteractions++;
        this._markCallbacks[markId] = callback;

        this._spatialIndex.indexMark(markId);
      }

      hasMark (markId) {
        return markId in this._markCallbacks
      }

      removeMarkInteraction (markId) {
        this._removeEventListenerIfNecessary();
        delete this._markCallbacks[markId];
        this._numberOfInteractions--;

        this._spatialIndex.unindexMark(markId);
      }

      // Add/remove layer interactions
      addLayerInteraction (layerId, callback) {
        if (!(layerId in this._layerCallbacks)) {
          this._addEventListenerIfNecessary();
          this._numberOfInteractions++;
          this._layerCallbacks[layerId] = callback;

          this._spatialIndex.indexLayer(layerId);
        }
      }

      hasLayer (layerId) {
        return layerId in this._layerCallbacks
      }

      removeLayerInteraction (layerId) {
        if (layerId in this._layerCallbacks) {
          this._numberOfInteractions--;
          delete this._layerCallbacks[layerId];
          this._removeEventListenerIfNecessary();

          this._spatialIndex.unindexLayer(layerId);
        }
      }

      _addEventListenerIfNecessary () {
        if (this._numberOfInteractions === 0) {
          this._addEventListener();
        }
      }

      _removeEventListenerIfNecessary () {
        if (this._numberOfInteractions === 0) {
          this._removeEventListener();
        }
      }

      getId () {
        return `${this.id()}-mark-${this._interactionName}`
      }
    }

    function createMarkEvent (eventType, eventOptions, hit, nativeEvent) {
      eventOptions.markType = hit.markType;
      eventOptions.hitBBox = extractBBox(hit);
      eventOptions.hitSource = 'mark';

      return createEvent(eventType, eventOptions, nativeEvent)
    }

    function createLayerEvent (eventType, eventOptions, hit, nativeEvent) {
      eventOptions.markType = hit.markType;
      eventOptions.hitBBox = extractBBox(hit);
      eventOptions.key = hit.key;
      eventOptions.index = hit.index;
      eventOptions.hitSource = 'layer';

      return createEvent(eventType, eventOptions, nativeEvent)
    }

    function createSectionEvent (eventType, eventOptions, nativeEvent) {
      eventOptions.hitSource = 'section';

      return createEvent(eventType, eventOptions, nativeEvent)
    }

    function extractBBox (hit) {
      return { minX: hit.minX, maxX: hit.maxX, minY: hit.minY, maxY: hit.maxY }
    }

    function createEvent (eventType, eventOptions, nativeEvent) {
      const event = eventOptions;

      event.type = eventType;
      event.nativeType = nativeEvent.type;

      for (const key of INTERESTING_NATIVE_KEYS) {
        event[key] = nativeEvent[key];
      }

      return event
    }

    const INTERESTING_NATIVE_KEYS = [
      'altKey', 'ctrlKey', 'shiftKey',
      'clientX', 'clientY',
      'pageX', 'pageY',
      'screenX', 'screenY',
      'timeStamp'
    ];

    function createSelectMarkEvent (eventType, hit) {
      const event = {
        type: eventType,
        markType: hit.markType,
        hitSource: 'mark'
      };

      return event
    }

    function createSelectLayerEvent (eventType, hit) {
      const event = {
        type: eventType,
        markType: hit.markType,
        key: hit.key,
        index: hit.index,
        hitSource: 'layer'
      };

      return event
    }

    function getLocalCoordinates (screenCoordinates, interactionManager) {
      const section = interactionManager._section;

      const coordinateTransformation = interactionManager._coordinateTransformation
        ? interactionManager._coordinateTransformation._transformation
        : undefined;

      const zoom = interactionManager._zoom
        ? createZoomFunction(interactionManager._zoom)
        : undefined;

      const { scaleX, scaleY } = section;

      const clampedX = clamp(screenCoordinates.x, section.minX, section.maxX);
      const clampedY = clamp(screenCoordinates.y, section.minY, section.maxY);

      let localX = clampedX;
      let localY = clampedY;

      if (zoom) {
        [localX, localY] = zoom.invert([localX, localY]);
      }

      if (coordinateTransformation) {
        [localX, localY] = coordinateTransformation.invert([localX, localY]);
      }

      localX = scaleX.invert(localX);
      localY = scaleY.invert(localY);

      return { x: localX, y: localY }
    }

    function clamp (value, min, max) {
      return Math.max(min, Math.min(value, max))
    }

    function coordinatesAreInsideSection (hit, section) {
      return (
        hit.x >= section.minX &&
        hit.x <= section.maxX &&
        hit.y >= section.minY &&
        hit.y <= section.maxY
      )
    }

    function hitIsMark (hit) {
      return 'markId' in hit
    }

    function hitIsInLayer (hit) {
      return 'layerId' in hit
    }

    function getHitId (hit) {
      if (hitIsMark(hit)) return hit.markId
      if (hitIsInLayer(hit)) return hit.layerId + '-' + hit.key
    }

    class ClickHandler extends MarkInteractionHandler {
      constructor (interactionManager) {
        super(interactionManager, {
          interactionName: 'click',
          eventName: 'click'
        });
      }

      _handleEvent (screenCoordinates, nativeEvent) {
        if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
          return
        }

        const spatialIndex = this._spatialIndex;
        const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);
        const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());

        for (let i = 0; i < hits.length; i++) {
          const hit = hits[i];

          if (hitIsMark(hit)) {
            const clickEvent = createMarkEvent('click', {
              screenCoordinates,
              localCoordinates
            }, hit, nativeEvent);

            this._markCallbacks[hit.markId](clickEvent);
          }

          if (hitIsInLayer(hit)) {
            const clickEvent = createLayerEvent('click', {
              screenCoordinates,
              localCoordinates
            }, hit, nativeEvent);

            this._layerCallbacks[hit.layerId](clickEvent);
          }
        }
      }
    }

    class MouseoverHandler extends MarkInteractionHandler {
      constructor (interactionManager) {
        super(interactionManager, {
          interactionName: 'mouseover',
          eventName: 'mousemove'
        });

        this._previousMouseoverIds = {};
        this._currentMouseoverIds = {};
      }

      _handleEvent (screenCoordinates, nativeEvent) {
        const spatialIndex = this._spatialIndex;
        const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);

        for (let i = 0; i < hits.length; i++) {
          const hit = hits[i];
          const hitId = getHitId(hit);

          this._currentMouseoverIds[hitId] = true;

          if (!(hitId in this._previousMouseoverIds)) {
            this._fireCallback(hit, screenCoordinates, nativeEvent);
          }
        }

        this._previousMouseoverIds = this._currentMouseoverIds;
        this._currentMouseoverIds = {};
      }

      _fireCallback (hit, screenCoordinates, nativeEvent) {
        const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());

        if (hitIsMark(hit)) {
          const mouseoverEvent = createMarkEvent('mouseover', {
            screenCoordinates,
            localCoordinates
          }, hit, nativeEvent);

          this._markCallbacks[hit.markId](mouseoverEvent);
        }

        if (hitIsInLayer(hit)) {
          const mouseoverEvent = createLayerEvent('mouseover', {
            screenCoordinates,
            localCoordinates
          }, hit, nativeEvent);

          this._layerCallbacks[hit.layerId](mouseoverEvent);
        }
      }
    }

    class MouseoutHandler extends MarkInteractionHandler {
      constructor (interactionManager) {
        super(interactionManager, {
          interactionName: 'mouseout',
          eventName: 'mousemove'
        });

        this._previousMouseoverHits = {};
        this._currentMouseoverHits = {};
      }

      _handleEvent (screenCoordinates, nativeEvent) {
        const spatialIndex = this._spatialIndex;
        const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);

        for (let i = 0; i < hits.length; i++) {
          const hit = hits[i];
          const hitId = getHitId(hit);

          this._currentMouseoverHits[hitId] = hit;
        }

        for (const hitId in this._previousMouseoverHits) {
          if (!(hitId in this._currentMouseoverHits)) {
            const hit = this._previousMouseoverHits[hitId];
            this._fireCallback(hit, screenCoordinates, nativeEvent);
          }
        }

        this._previousMouseoverHits = this._currentMouseoverHits;
        this._currentMouseoverHits = {};
      }

      _fireCallback (hit, screenCoordinates, nativeEvent) {
        const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());

        if (hitIsMark(hit)) {
          const mouseoutEvent = createMarkEvent('mouseout', {
            screenCoordinates,
            localCoordinates
          }, hit, nativeEvent);

          this._markCallbacks[hit.markId](mouseoutEvent);
        }

        if (hitIsInLayer(hit)) {
          const mouseoutEvent = createLayerEvent('mouseout', {
            screenCoordinates,
            localCoordinates
          }, hit, nativeEvent);

          this._layerCallbacks[hit.layerId](mouseoutEvent);
        }
      }
    }

    class MousedownHandler extends MarkInteractionHandler {
      constructor (interactionManager) {
        super(interactionManager, {
          interactionName: 'mousedown',
          eventName: 'mousedown'
        });
      }

      _handleEvent (screenCoordinates, nativeEvent) {
        if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
          return
        }

        const spatialIndex = this._spatialIndex;
        const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);
        const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());

        for (let i = 0; i < hits.length; i++) {
          const hit = hits[i];

          if (hitIsMark(hit)) {
            const mousedownEvent = createMarkEvent('mousedown', {
              screenCoordinates,
              localCoordinates
            }, hit, nativeEvent);

            this._markCallbacks[hit.markId](mousedownEvent);
          }

          if (hitIsInLayer(hit)) {
            const mousedownEvent = createLayerEvent('mousedown', {
              screenCoordinates,
              localCoordinates
            }, hit, nativeEvent);

            this._layerCallbacks[hit.layerId](mousedownEvent);
          }
        }
      }
    }

    class MouseupHandler extends MarkInteractionHandler {
      constructor (interactionManager) {
        super(interactionManager, {
          interactionName: 'mouseup',
          eventName: 'mouseup'
        });
      }

      _handleEvent (screenCoordinates, nativeEvent) {
        if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
          return
        }

        const spatialIndex = this._spatialIndex;
        const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);
        const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());

        for (let i = 0; i < hits.length; i++) {
          const hit = hits[i];

          if (hitIsMark(hit)) {
            const mouseupEvent = createMarkEvent('mouseup', {
              screenCoordinates,
              localCoordinates
            }, hit, nativeEvent);

            this._markCallbacks[hit.markId](mouseupEvent);
          }

          if (hitIsInLayer(hit)) {
            const mouseupEvent = createLayerEvent('mouseup', {
              screenCoordinates,
              localCoordinates
            }, hit, nativeEvent);

            this._layerCallbacks[hit.layerId](mouseupEvent);
          }
        }
      }
    }

    class MousedragHandler extends MarkInteractionHandler {
      constructor (interactionManager) {
        super(interactionManager, {
          interactionName: 'mousedrag',
          eventName: ['mousedown', 'mousemove', 'mouseup']
        });

        this._currentHits = {};
      }

      _handleEvent (screenCoordinates, nativeEvent) {
        if (nativeEvent.type === 'mousedown') {
          this._handleMousedown(screenCoordinates, nativeEvent);
        }

        if (nativeEvent.type === 'mousemove') {
          this._handleMousemove(screenCoordinates, nativeEvent);
        }

        if (nativeEvent.type === 'mouseup') {
          this._handleMouseup(screenCoordinates, nativeEvent);
        }
      }

      _handleMousedown (screenCoordinates, nativeEvent) {
        if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
          return
        }

        const spatialIndex = this._spatialIndex;
        const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);

        for (let i = 0; i < hits.length; i++) {
          const hit = hits[i];
          const hitId = getHitId(hit);

          this._currentHits[hitId] = hit;

          this._fireCallback(hit, screenCoordinates, nativeEvent, 'start');
        }
      }

      _handleMousemove (screenCoordinates, nativeEvent) {
        if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
          return
        }

        for (const hitId in this._currentHits) {
          const hit = this._currentHits[hitId];
          this._fireCallback(hit, screenCoordinates, nativeEvent, 'drag');
        }
      }

      _handleMouseup (screenCoordinates, nativeEvent) {
        for (const hitId in this._currentHits) {
          const hit = this._currentHits[hitId];
          this._fireCallback(hit, screenCoordinates, nativeEvent, 'end');
        }

        this._currentHits = {};
      }

      _fireCallback (hit, screenCoordinates, nativeEvent, dragType) {
        const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());

        if (hitIsMark(hit)) {
          const mouseoutEvent = createMarkEvent('drag', {
            screenCoordinates,
            localCoordinates,
            dragType
          }, hit, nativeEvent);

          this._markCallbacks[hit.markId](mouseoutEvent);
        }

        if (hitIsInLayer(hit)) {
          const mouseoutEvent = createLayerEvent('drag', {
            screenCoordinates,
            localCoordinates,
            dragType
          }, hit, nativeEvent);

          this._layerCallbacks[hit.layerId](mouseoutEvent);
        }
      }
    }



    var MarkInteractionHandlers = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ClickHandler: ClickHandler,
        MouseoverHandler: MouseoverHandler,
        MouseoutHandler: MouseoutHandler,
        MousedownHandler: MousedownHandler,
        MouseupHandler: MouseupHandler,
        MousedragHandler: MousedragHandler
    });

    class SectionInteractionHandler extends BaseInteractionHandler {
      constructor (interactionManager, options) {
        super(interactionManager, options);
        this._callback = undefined;
      }

      addInteraction (callback) {
        this._addEventListener();
        this._callback = callback;
      }

      hasInteraction () {
        return this._callback !== undefined
      }

      removeInteraction () {
        if (this._callback) {
          this._callback = undefined;
          this._removeEventListener();
        }
      }

      getId () {
        return `${this.id()}-section-${this._interactionName}`
      }
    }

    // Taken from:
    // https://stackoverflow.com/a/37474225/7237112

    function getScrollLineHeight () {
      var r;
      var iframe = document.createElement('iframe');
      iframe.src = '#';
      document.body.appendChild(iframe);
      var iwin = iframe.contentWindow;
      var idoc = iwin.document;
      idoc.open();
      idoc.write('<!DOCTYPE html><html><head></head><body><span>a</span></body></html>');
      idoc.close();
      var span = idoc.body.firstElementChild;
      r = span.offsetHeight;
      document.body.removeChild(iframe);

      return r
    }

    class WheelHandler extends SectionInteractionHandler {
      constructor (interactionManager) {
        super(interactionManager, {
          interactionName: 'wheel',
          eventName: 'wheel'
        });
      }

      _handleEvent (screenCoordinates, nativeEvent) {
        nativeEvent.preventDefault();
        nativeEvent.stopPropagation();

        const interactionManager = this.interactionManager();
        const section = this.section();

        if (coordinatesAreInsideSection(screenCoordinates, section)) {
          const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);
          const wheelDelta = getWheelDelta(nativeEvent);

          const wheelEvent = createSectionEvent('wheel', {
            screenCoordinates,
            localCoordinates,
            wheelDelta
          }, nativeEvent);

          this._callback(wheelEvent);
        }
      }
    }

    let scrollLineHeight;

    function getWheelDelta (nativeEvent) {
      let delta;

      // Legacy
      // IE pixels
      if ('wheelDelta' in nativeEvent && nativeEvent.wheelDelta !== 0) {
        delta = -nativeEvent.wheelDelta;
      }

      // Mozilla
      if ('detail' in nativeEvent && nativeEvent.detail !== 0) {
        delta = -nativeEvent.detail;
      }

      // Most other cases
      if ('deltaY' in nativeEvent && nativeEvent.deltaY !== 0) {
        delta = -nativeEvent.deltaY;
      }

      if (!scrollLineHeight) {
        scrollLineHeight = getScrollLineHeight();
      }

      return delta * (nativeEvent.deltaMode ? scrollLineHeight : 1) / 500
    }

    class ClickHandler$1 extends SectionInteractionHandler {
      constructor (interactionManager) {
        super(interactionManager, {
          interactionName: 'click',
          eventName: 'click'
        });
      }

      _handleEvent (screenCoordinates, nativeEvent) {
        const interactionManager = this.interactionManager();
        const section = this.section();

        if (coordinatesAreInsideSection(screenCoordinates, section)) {
          const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);

          const clickEvent = createSectionEvent('click', {
            screenCoordinates,
            localCoordinates
          }, nativeEvent);

          this._callback(clickEvent);
        }
      }
    }

    class MousedownHandler$1 extends SectionInteractionHandler {
      constructor (interactionManager) {
        super(interactionManager, {
          interactionName: 'mousedown',
          eventName: 'mousedown'
        });
      }

      _handleEvent (screenCoordinates, nativeEvent) {
        const interactionManager = this.interactionManager();
        const section = this.section();

        if (coordinatesAreInsideSection(screenCoordinates, section)) {
          const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);

          const mousedownEvent = createSectionEvent('mousedown', {
            screenCoordinates,
            localCoordinates
          }, nativeEvent);

          this._callback(mousedownEvent);
        }
      }
    }

    class MouseupHandler$1 extends SectionInteractionHandler {
      constructor (interactionManager) {
        super(interactionManager, {
          interactionName: 'mouseup',
          eventName: 'mouseup'
        });
      }

      _handleEvent (screenCoordinates, nativeEvent) {
        const interactionManager = this.interactionManager();
        const section = this.section();

        if (coordinatesAreInsideSection(screenCoordinates, section)) {
          const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);

          const mouseupEvent = createSectionEvent('mouseup', {
            screenCoordinates,
            localCoordinates
          }, nativeEvent);

          this._callback(mouseupEvent);
        }
      }
    }

    class MouseoverHandler$1 extends SectionInteractionHandler {
      constructor (interactionManager) {
        super(interactionManager, {
          interactionName: 'mouseover',
          eventName: 'mousemove'
        });

        this._mouseCurrentlyOverSection = false;
      }

      _handleEvent (screenCoordinates, nativeEvent) {
        const interactionManager = this.interactionManager();
        const section = this.section();

        if (coordinatesAreInsideSection(screenCoordinates, section)) {
          if (!this._mouseCurrentlyOverSection) {
            const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);

            const mousedownEvent = createSectionEvent('mousedown', {
              screenCoordinates,
              localCoordinates
            }, nativeEvent);

            this._callback(mousedownEvent);
            this._mouseCurrentlyOverSection = true;
          }
        } else {
          if (this._mouseCurrentlyOverSection) {
            this._mouseCurrentlyOverSection = false;
          }
        }
      }
    }

    class MouseoutHandler$1 extends SectionInteractionHandler {
      constructor (interactionManager) {
        super(interactionManager, {
          interactionName: 'mouseout',
          eventName: 'mousemove'
        });

        this._mouseCurrentlyOverSection = false;
      }

      _handleEvent (screenCoordinates, nativeEvent) {
        const interactionManager = this.interactionManager();
        const section = this.section();

        if (coordinatesAreInsideSection(screenCoordinates, section)) {
          if (!this._mouseCurrentlyOverSection) {
            this._mouseCurrentlyOverSection = true;
          }
        } else {
          if (this._mouseCurrentlyOverSection) {
            const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);

            const mouseoutEvent = createSectionEvent('mouseout', {
              screenCoordinates,
              localCoordinates
            }, nativeEvent);

            this._callback(mouseoutEvent);
            this._mouseCurrentlyOverSection = false;
          }
        }
      }
    }

    class MousemoveHandler extends SectionInteractionHandler {
      constructor (interactionManager) {
        super(interactionManager, {
          interactionName: 'mouseover',
          eventName: 'mousemove'
        });
      }

      _handleEvent (screenCoordinates, nativeEvent) {
        const interactionManager = this.interactionManager();
        const section = this.section();

        if (coordinatesAreInsideSection(screenCoordinates, section)) {
          const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);

          const mousemoveEvent = createSectionEvent('mousemove', {
            screenCoordinates,
            localCoordinates
          }, nativeEvent);

          this._callback(mousemoveEvent);
        }
      }
    }



    var SectionInteractionHandlers = /*#__PURE__*/Object.freeze({
        __proto__: null,
        WheelHandler: WheelHandler,
        ClickHandler: ClickHandler$1,
        MousedownHandler: MousedownHandler$1,
        MouseupHandler: MouseupHandler$1,
        MouseoverHandler: MouseoverHandler$1,
        MouseoutHandler: MouseoutHandler$1,
        MousemoveHandler: MousemoveHandler
    });

    class MouseInteractionManager extends BaseInteractionManager {
      constructor () {
        super();

        this._markInteractionInterface = new MarkInteractionInterface(this, MarkInteractionHandlers);
        this._sectionInteractionInterface = new SectionInteractionInterface(this, SectionInteractionHandlers);
      }
    }

    // import MarkInteractionInterface from '../base/interfaces/MarkInteractionInterface.js'
    // import SectionInteractionInterface from '../base/interfaces/SectionInteractionInterface.js'

    // import * as MarkInteractionHandlers from './mark'
    // import * as SectionInteractionHandlers from './section'

    class TouchInteractionManager extends BaseInteractionManager {
      constructor () {
        super();

        this._ = null;
        // this._markInteractionInterface = new MarkInteractionInterface(this, MarkInteractionHandlers)
        // this._sectionInteractionInterface = new SectionInteractionInterface(this, SectionInteractionHandlers)
      }
    }

    function bboxPoint (point) {
      return {
        x: [point[0], point[0]],
        y: [point[1], point[1]]
      }
    }

    function indexPoint$1 (markData) {
      const pointAttributes = markData.attributes;

      const bbox = bboxPoint(pointAttributes.pixelGeometry.coordinates);
      const item = createItemFromBBox(bbox);

      item.attributes = pointAttributes;
      item.markType = 'Point';
      item.markId = markData.markId;

      return item
    }

    function indexPointLayer$1 ({ layerAttributes, keyArray, layerId }) {
      const items = [];

      for (let i = 0; i < keyArray.length; i++) {
        const key = keyArray[i];

        const pointAttributes = getPointAttributes$1(layerAttributes, key);
        const bbox = bboxPoint(pointAttributes.pixelGeometry.coordinates);
        const item = createItemFromBBox(bbox);

        item.key = key;
        item.index = i;
        item.attributes = pointAttributes;
        item.markType = 'Point';
        item.layerId = layerId;

        items.push(item);
      }

      return items
    }

    function getPointAttributes$1 (layerAttributes, key) {
      return {
        pixelGeometry: layerAttributes.pixelGeometryObject[key],
        radius: layerAttributes.radiusObject[key]
      }
    }

    function indexRectangle$1 (markData) {
      const rectangleAttributes = markData.attributes;

      const centroid = calculateCentroid(rectangleAttributes.screenGeometry);
      const bbox = bboxPoint(centroid);
      const item = createItemFromBBox(bbox);

      item.attributes = rectangleAttributes;
      item.markType = 'Rectangle';
      item.markId = markData.markId;

      return item
    }

    function indexRectangleLayer$1 ({ layerAttributes, keyArray, layerId }) {
      const items = [];

      for (let i = 0; i < keyArray.length; i++) {
        const key = keyArray[i];

        const rectangleAttributes = getRectangleAttributes$1(layerAttributes, key);

        const centroid = calculateCentroid(rectangleAttributes.screenGeometry);
        const bbox = bboxPoint(centroid);
        const item = createItemFromBBox(bbox);

        item.key = key;
        item.index = i;
        item.attributes = rectangleAttributes;
        item.markType = 'Rectangle';
        item.layerId = layerId;

        items.push(item);
      }

      return items
    }

    function getRectangleAttributes$1 (layerAttributes, key) {
      return { screenGeometry: layerAttributes.screenGeometryObject[key] }
    }

    function indexPolygon$1 (markData) {
      const polygonAttributes = markData.attributes;

      const centroid = calculateCentroid(polygonAttributes.screenGeometry);
      const bbox = bboxPoint(centroid);
      const item = createItemFromBBox(bbox);

      item.attributes = polygonAttributes;
      item.markType = 'Polygon';
      item.markId = markData.markId;

      return item
    }

    function indexPolygonLayer$1 ({ layerAttributes, keyArray, layerId }) {
      const items = [];

      for (let i = 0; i < keyArray.length; i++) {
        const key = keyArray[i];

        const polygonAttributes = getPolygonAttributes$1(layerAttributes, key);

        const centroid = calculateCentroid(polygonAttributes.screenGeometry);
        const bbox = bboxPoint(centroid);
        const item = createItemFromBBox(bbox);

        item.key = key;
        item.index = i;
        item.attributes = polygonAttributes;
        item.markType = 'Polygon';
        item.layerId = layerId;

        items.push(item);
      }

      return items
    }

    function getPolygonAttributes$1 (layerAttributes, key) {
      return { screenGeometry: layerAttributes.screenGeometryObject[key] }
    }

    function indexLine$1 (markData) {
      const lineAttributes = markData.attributes;

      const centroid = calculateCentroid(lineAttributes.pixelGeometry);
      const bbox = bboxPoint(centroid);
      const item = createItemFromBBox(bbox);

      item.attributes = lineAttributes;
      item.markType = 'Line';
      item.markId = markData.markId;

      return item
    }

    function indexLineLayer$1 ({ layerAttributes, keyArray, layerId }) {
      const items = [];

      for (let i = 0; i < keyArray.length; i++) {
        const key = keyArray[i];

        const lineAttributes = getLineAttributes(layerAttributes, key);

        const centroid = calculateCentroid(lineAttributes.screenGeometry);
        const bbox = bboxPoint(centroid);
        const item = createItemFromBBox(bbox);

        item.key = key;
        item.index = i;
        item.attributes = lineAttributes;
        item.markType = 'Line';
        item.layerId = layerId;

        items.push(item);
      }

      return items
    }

    function getLineAttributes (layerAttributes, key) {
      return { screenGeometry: layerAttributes.pixelGeometryObject[key] }
    }

    function indexArea$1 (markData) {
      const areaAttributes = markData.attributes;

      const centroid = calculateCentroid(areaAttributes.screenGeometry);
      const bbox = bboxPoint(centroid);
      const item = createItemFromBBox(bbox);

      item.attributes = areaAttributes;
      item.markType = 'Area';
      item.markId = markData.markId;

      return item
    }

    function indexAreaLayer$1 ({ layerAttributes, keyArray, layerId }) {
      const items = [];

      for (let i = 0; i < keyArray.length; i++) {
        const key = keyArray[i];

        const areaAttributes = getAreaAttributes$1(layerAttributes, key);

        const centroid = calculateCentroid(areaAttributes.screenGeometry);
        const bbox = bboxPoint(centroid);
        const item = createItemFromBBox(bbox);

        item.key = key;
        item.index = i;
        item.attributes = areaAttributes;
        item.markType = 'Area';
        item.layerId = layerId;

        items.push(item);
      }

      return items
    }

    function getAreaAttributes$1 (layerAttributes, key) {
      return { screenGeometry: layerAttributes.screenGeometryObject[key] }
    }

    const markIndexing$1 = {
      Point: indexPoint$1,
      Rectangle: indexRectangle$1,
      Polygon: indexPolygon$1,
      Line: indexLine$1,
      Label: indexPoint$1,
      Area: indexArea$1
    };

    const layerIndexing$1 = {
      Point: indexPointLayer$1,
      Rectangle: indexRectangleLayer$1,
      Polygon: indexPolygonLayer$1,
      Line: indexLineLayer$1,
      Label: indexPointLayer$1,
      Area: indexAreaLayer$1
    };

    class SelectManager {
      constructor () {
        this._selectableMarks = {};
        this._selectableLayers = {};

        this._markCallbacks = {};
        this._layerCallbacks = {};

        this._previousSelection = {};
        this._currentSelection = {};

        const getMark = function (markId) {
          return this._selectableMarks[markId]
        };

        const getLayer = function (layerId) {
          return this._selectableLayers[layerId]
        };

        this._spatialIndex = new SpatialIndex(this, getMark, getLayer);

        this._selectPolygon = { start: undefined, points: [] };
      }

      // Loading/indexing
      loadMark (markType, markData, callbacks) {
        const indexingFunction = markIndexing$1[markType];
        const indexableMark = indexingFunction(markData);

        const markId = markData.markId;

        this._selectableMarks[markId] = indexableMark;
        this._markCallbacks[markId] = callbacks;

        this._spatialIndex.indexMark(markId);
      }

      markIsLoaded (markId) {
        return markId in this._selectableMarks
      }

      removeMark (markId) {
        this._spatialIndex.unindexMark(markId);

        delete this._selectableMarks[markId];
        delete this._markCallbacks[markId];
      }

      loadLayer (layerType, layerData, callbacks) {
        const indexingFunction = layerIndexing$1[layerType];
        const indexableLayer = indexingFunction(layerData);

        const layerId = layerData.layerId;

        this._selectableLayers[layerId] = indexableLayer;
        this._layerCallbacks[layerId] = callbacks;

        this._spatialIndex.indexLayer(layerId);
      }

      layerIsLoaded (layerId) {
        return layerId in this._selectableLayers
      }

      removeLayer (layerId) {
        this._spatialIndex.unindexLayer(layerId);

        delete this._selectableLayers[layerId];
        delete this._layerCallbacks[layerId];
      }

      // Rectangle
      selectRectangle (rectangle) {
        const hits = this._spatialIndex.queryBoundingBox(rectangleToRBushBBox(rectangle));

        for (let i = 0; i < hits.length; i++) {
          const hit = hits[i];
          const hitId = getHitId(hit);

          this._currentSelection[hitId] = hit;

          this._fireSelectCallback(hit);
        }
      }

      updateSelectRectangle (rectangle) {
        this._previousSelection = this._currentSelection;
        this._currentSelection = {};

        const hits = this._spatialIndex.queryBoundingBox(rectangleToRBushBBox(rectangle));

        for (let i = 0; i < hits.length; i++) {
          const hit = hits[i];
          const hitId = getHitId(hit);

          this._currentSelection[hitId] = hit;

          if (!(hitId in this._previousSelection)) {
            this._fireSelectCallback(hit);
          }
        }

        for (const hitId in this._previousSelection) {
          if (!(hitId in this._currentSelection)) {
            const hit = this._previousSelection[hitId];

            this._fireDeselectCallback(hit);
          }
        }
      }

      resetSelectRectangle () {
        for (const hitId in this._currentSelection) {
          const hit = this._currentSelection[hitId];

          this._fireDeselectCallback(hit);
        }

        this._previousSelection = {};
        this._currentSelection = {};
      }

      // Polygon
      startSelectPolygon (startCoordinates) {
        this._selectPolygon.start = parseCoordinates(startCoordinates);
      }

      addPointToSelectPolygon (coordinates) {
        this._selectPolygon.points.push(parseCoordinates(coordinates));

        if (this._selectPolygon.points.length > 1) {
          const lastThreePointsPolygon = this._getLastThreePointsPolygon();
          const bbox = calculateBBoxGeometry(lastThreePointsPolygon);

          const hits = this._spatialIndex.queryBoundingBox(bboxToRBushBBox(bbox));

          for (let i = 0; i < hits.length; i++) {
            const hit = hits[i];
            const hitCentroid = [hit.minX, hit.minY];

            if (pointInPolygon(hitCentroid, lastThreePointsPolygon)) {
              const hitId = getHitId(hit);

              if (hitId in this._currentSelection) {
                this._fireDeselectCallback(hit);
                delete this._currentSelection[hitId];
              } else {
                this._fireSelectCallback(hit);
                this._currentSelection[hitId] = hit;
              }
            }
          }
        }
      }

      moveSelectPolygon (_delta) {
        this._previousSelection = this._currentSelection;
        this._currentSelection = {};

        const delta = parseCoordinates(_delta);

        const start = this._selectPolygon.start;
        const points = this._selectPolygon.points;

        this._selectPolygon.start = [start[0] + delta[0], start[1] + delta[1]];
        this._selectPolygon.points = points.map(point => [point[0] + delta[0], point[1] + delta[1]]);

        const polygon = this.getSelectPolygon();
        const bbox = calculateBBoxGeometry(polygon);

        const hits = this._spatialIndex.queryBoundingBox(bboxToRBushBBox(bbox));

        for (let i = 0; i < hits.length; i++) {
          const hit = hits[i];
          const hitCentroid = [hit.minX, hit.minY];

          if (pointInPolygon(hitCentroid, polygon)) {
            const hitId = getHitId(hit);

            this._currentSelection[hitId] = hit;

            if (!(hitId in this._previousSelection)) {
              this._fireSelectCallback(hit);
            }
          }
        }

        for (const hitId in this._previousSelection) {
          if (!(hitId in this._currentSelection)) {
            const hit = this._previousSelection[hitId];

            this._fireDeselectCallback(hit);
          }
        }
      }

      getSelectPolygon () {
        if (this._selectPolygon.start) {
          return {
            type: 'Polygon',
            coordinates: [[
              this._selectPolygon.start,
              ...this._selectPolygon.points,
              this._selectPolygon.start
            ]]
          }
        }
      }

      resetSelectPolygon () {
        for (const hitId in this._currentSelection) {
          const hit = this._currentSelection[hitId];

          this._fireDeselectCallback(hit);
        }

        this._selectPolygon = { start: undefined, points: [] };
        this._currentSelection = {};
      }

      _fireSelectCallback (hit) {
        if (hitIsMark(hit)) {
          const selectEvent = createSelectMarkEvent('select', hit);
          const callback = this._markCallbacks[hit.markId].onSelect;

          if (callback) callback(selectEvent);
        }

        if (hitIsInLayer(hit)) {
          const selectEvent = createSelectLayerEvent('select', hit);
          const callback = this._layerCallbacks[hit.layerId].onSelect;

          if (callback) callback(selectEvent);
        }
      }

      _fireDeselectCallback (hit) {
        if (hitIsMark(hit)) {
          const deselectEvent = createSelectMarkEvent('deselect', hit);
          const callback = this._markCallbacks[hit.markId].onDeselect;

          if (callback) callback(deselectEvent);
        }

        if (hitIsInLayer(hit)) {
          const deselectEvent = createSelectLayerEvent('deselect', hit);
          const callback = this._layerCallbacks[hit.layerId].onDeselect;

          if (callback) callback(deselectEvent);
        }
      }

      _getLastThreePointsPolygon () {
        const points = this._selectPolygon.points;
        const lastPointIndex = points.length - 1;
        const start = this._selectPolygon.start;

        return {
          type: 'Polygon',
          coordinates: [
            [start, points[lastPointIndex - 1], points[lastPointIndex], start]
          ]
        }
      }
    }

    function rectangleToRBushBBox (rectangle) {
      return {
        minX: Math.min(rectangle.x1, rectangle.x2),
        maxX: Math.max(rectangle.x1, rectangle.x2),
        minY: Math.min(rectangle.y1, rectangle.y2),
        maxY: Math.max(rectangle.y1, rectangle.y2)
      }
    }

    function parseCoordinates (coordinates) {
      if (is2dArray(coordinates)) return coordinates
      if (isXYObject(coordinates)) return [coordinates.x, coordinates.y]

      throw new Error(`Invalid input: ${coordinates}`)
    }

    function is2dArray (coordinates) {
      return coordinates.constructor === Array &&
        coordinates.length === 2 &&
        coordinates.every(c => c && c.constructor === Number)
    }

    function isXYObject (coordinates) {
      return 'x' in coordinates && 'y' in coordinates &&
        coordinates.x.constructor === Number &&
        coordinates.y.constructor === Number
    }

    function bboxToRBushBBox (bbox) {
      return {
        minX: Math.min(...bbox.x),
        maxX: Math.max(...bbox.x),
        minY: Math.min(...bbox.y),
        maxY: Math.max(...bbox.y)
      }
    }

    class InteractionManager {
      constructor () {
        if (detectIt.hasMouse) {
          this._mouseInteractionManager = new MouseInteractionManager();
        }

        if (detectIt.hasTouch) {
          this._touchInteractionManager = new TouchInteractionManager();
        }

        this._selectManager = new SelectManager();
      }

      // Initialization
      setId (id) {
        this._forEachManager(manager => { manager.setId(id); });
      }

      linkEventManager (eventManager) {
        if (this._mouseInteractionManager) {
          this._mouseInteractionManager.linkEventManager(eventManager.mouse());
        }

        if (this._touchInteractionManager) {
          this._touchInteractionManager.linkEventManager(eventManager.touch());
        }
      }

      // Section context loading
      loadSection (sectionData) {
        this._forEachManager(manager => { manager.loadSection(sectionData); });
      }

      loadCoordinateTransformation (coordinateTransformation) {
        this._forEachManager(manager => { manager.loadCoordinateTransformation(coordinateTransformation); });
      }

      loadZoom (zoom) {
        this._forEachManager(manager => { manager.loadZoom(zoom); });
      }

      mouse () {
        return this._mouseInteractionManager
      }

      touch () {
        return this._touchInteractionManager
      }

      select () {
        return this._selectManager
      }

      _forEachManager (callback) {
        if (this._mouseInteractionManager) callback(this._mouseInteractionManager);
        if (this._touchInteractionManager) callback(this._touchInteractionManager);
      }
    }

    function parsePadding (padding) {
      if (padding.constructor === Number) {
        return { left: padding, right: padding, top: padding, bottom: padding }
      }

      if (padding.constructor === Object) {
        if (Object.keys(padding).length !== 4) throw invalidPaddingError

        for (const key of ['left', 'right', 'top', 'bottom']) {
          if (!(key in padding)) throw invalidPaddingError
        }

        return padding
      }

      throw invalidPaddingError
    }

    const invalidPaddingError = new Error('Invalid padding specification');

    function applyPadding (range, offsetMin, offsetMax) {
      if (range[0] < range[1]) {
        return [range[0] + offsetMin, range[1] - offsetMax]
      } else {
        return [range[0] - offsetMax, range[1] + offsetMin]
      }
    }

    function removePadding (range, offsetMin, offsetMax) {
      if (range[0] < range[1]) {
        return [range[0] - offsetMin, range[1] + offsetMax]
      } else {
        return [range[0] + offsetMax, range[1] - offsetMin]
      }
    }

    /* src/components/Core/Graphic/Graphic.svelte generated by Svelte v3.15.0 */
    const file$1 = "src/components/Core/Graphic/Graphic.svelte";

    function create_fragment$3(ctx) {
    	let svg;
    	let current;
    	const default_slot_template = ctx.$$slots.default;
    	const default_slot = create_slot(default_slot_template, ctx, null);

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			if (default_slot) default_slot.c();
    			attr_dev(svg, "width", ctx.width);
    			attr_dev(svg, "height", ctx.height);
    			add_location(svg, file$1, 75, 0, 2384);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);

    			if (default_slot) {
    				default_slot.m(svg, null);
    			}

    			ctx.svg_binding(svg);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (default_slot && default_slot.p && changed.$$scope) {
    				default_slot.p(get_slot_changes(default_slot_template, ctx, changed, null), get_slot_context(default_slot_template, ctx, null));
    			}

    			if (!current || changed.width) {
    				attr_dev(svg, "width", ctx.width);
    			}

    			if (!current || changed.height) {
    				attr_dev(svg, "height", ctx.height);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (default_slot) default_slot.d(detaching);
    			ctx.svg_binding(null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let $interactionManagerContext;
    	let $sectionContext;
    	let { width } = $$props;
    	let { height } = $$props;
    	let { padding = 0 } = $$props;
    	let { scaleX } = $$props;
    	let { scaleY } = $$props;
    	let { flipX = false } = $$props;
    	let { flipY = false } = $$props;
    	let { renderer } = $$props;
    	let { blockReindexing = false } = $$props;
    	const graphicContext = init$1();
    	const sectionContext = init$2();
    	validate_store(sectionContext, "sectionContext");
    	component_subscribe($$self, sectionContext, value => $$invalidate("$sectionContext", $sectionContext = value));
    	const eventManagerContext = init$3();
    	const interactionManagerContext = init$4();
    	validate_store(interactionManagerContext, "interactionManagerContext");
    	component_subscribe($$self, interactionManagerContext, value => $$invalidate("$interactionManagerContext", $interactionManagerContext = value));
    	init$5();
    	init$6();
    	let rootNode;
    	const eventManager = new EventManager();
    	update$3(eventManagerContext, eventManager);
    	const interactionManager = new InteractionManager();
    	interactionManager.setId("graphic");
    	interactionManager.linkEventManager(eventManager);
    	update$4(interactionManagerContext, interactionManager);
    	let _padding;

    	onMount(() => {
    		eventManager.addRootNode(rootNode);
    		eventManager.attachEventListeners();
    	});

    	const writable_props = [
    		"width",
    		"height",
    		"padding",
    		"scaleX",
    		"scaleY",
    		"flipX",
    		"flipY",
    		"renderer",
    		"blockReindexing"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Graphic> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;

    	function svg_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate("rootNode", rootNode = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("width" in $$props) $$invalidate("width", width = $$props.width);
    		if ("height" in $$props) $$invalidate("height", height = $$props.height);
    		if ("padding" in $$props) $$invalidate("padding", padding = $$props.padding);
    		if ("scaleX" in $$props) $$invalidate("scaleX", scaleX = $$props.scaleX);
    		if ("scaleY" in $$props) $$invalidate("scaleY", scaleY = $$props.scaleY);
    		if ("flipX" in $$props) $$invalidate("flipX", flipX = $$props.flipX);
    		if ("flipY" in $$props) $$invalidate("flipY", flipY = $$props.flipY);
    		if ("renderer" in $$props) $$invalidate("renderer", renderer = $$props.renderer);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    		if ("$$scope" in $$props) $$invalidate("$$scope", $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return {
    			width,
    			height,
    			padding,
    			scaleX,
    			scaleY,
    			flipX,
    			flipY,
    			renderer,
    			blockReindexing,
    			rootNode,
    			_padding,
    			$interactionManagerContext,
    			$sectionContext
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("width" in $$props) $$invalidate("width", width = $$props.width);
    		if ("height" in $$props) $$invalidate("height", height = $$props.height);
    		if ("padding" in $$props) $$invalidate("padding", padding = $$props.padding);
    		if ("scaleX" in $$props) $$invalidate("scaleX", scaleX = $$props.scaleX);
    		if ("scaleY" in $$props) $$invalidate("scaleY", scaleY = $$props.scaleY);
    		if ("flipX" in $$props) $$invalidate("flipX", flipX = $$props.flipX);
    		if ("flipY" in $$props) $$invalidate("flipY", flipY = $$props.flipY);
    		if ("renderer" in $$props) $$invalidate("renderer", renderer = $$props.renderer);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    		if ("rootNode" in $$props) $$invalidate("rootNode", rootNode = $$props.rootNode);
    		if ("_padding" in $$props) $$invalidate("_padding", _padding = $$props._padding);
    		if ("$interactionManagerContext" in $$props) interactionManagerContext.set($interactionManagerContext = $$props.$interactionManagerContext);
    		if ("$sectionContext" in $$props) sectionContext.set($sectionContext = $$props.$sectionContext);
    	};

    	$$self.$$.update = (changed = { renderer: 1, width: 1, height: 1, flipX: 1, flipY: 1, padding: 1, _padding: 1, scaleX: 1, scaleY: 1, blockReindexing: 1, $interactionManagerContext: 1, $sectionContext: 1 }) => {
    		if (changed.renderer) {
    			 {
    				update$1(graphicContext, { renderer });
    			}
    		}

    		if (changed.width || changed.height || changed.flipX || changed.flipY || changed.padding || changed._padding || changed.scaleX || changed.scaleY || changed.blockReindexing || changed.$interactionManagerContext || changed.$sectionContext) {
    			 {
    				let rangeX = [0, width];
    				let rangeY = [0, height];
    				if (flipX) rangeX.reverse();
    				if (flipY) rangeY.reverse();
    				$$invalidate("_padding", _padding = parsePadding(padding));
    				rangeX = applyPadding(rangeX, _padding.left, _padding.right);
    				rangeY = applyPadding(rangeY, _padding.top, _padding.bottom);

    				update$2(sectionContext, {
    					sectionId: "graphic",
    					rangeX,
    					rangeY,
    					scaleX,
    					scaleY,
    					padding: _padding,
    					blockReindexing
    				});

    				$interactionManagerContext.loadSection($sectionContext);
    			}
    		}
    	};

    	return {
    		width,
    		height,
    		padding,
    		scaleX,
    		scaleY,
    		flipX,
    		flipY,
    		renderer,
    		blockReindexing,
    		sectionContext,
    		interactionManagerContext,
    		rootNode,
    		svg_binding,
    		$$slots,
    		$$scope
    	};
    }

    class Graphic extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
    			width: 0,
    			height: 0,
    			padding: 0,
    			scaleX: 0,
    			scaleY: 0,
    			flipX: 0,
    			flipY: 0,
    			renderer: 0,
    			blockReindexing: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Graphic",
    			options,
    			id: create_fragment$3.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || ({});

    		if (ctx.width === undefined && !("width" in props)) {
    			console.warn("<Graphic> was created without expected prop 'width'");
    		}

    		if (ctx.height === undefined && !("height" in props)) {
    			console.warn("<Graphic> was created without expected prop 'height'");
    		}

    		if (ctx.scaleX === undefined && !("scaleX" in props)) {
    			console.warn("<Graphic> was created without expected prop 'scaleX'");
    		}

    		if (ctx.scaleY === undefined && !("scaleY" in props)) {
    			console.warn("<Graphic> was created without expected prop 'scaleY'");
    		}

    		if (ctx.renderer === undefined && !("renderer" in props)) {
    			console.warn("<Graphic> was created without expected prop 'renderer'");
    		}
    	}

    	get width() {
    		throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get padding() {
    		throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set padding(value) {
    		throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scaleX() {
    		throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scaleX(value) {
    		throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scaleY() {
    		throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scaleY(value) {
    		throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flipX() {
    		throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flipX(value) {
    		throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flipY() {
    		throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flipY(value) {
    		throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get renderer() {
    		throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set renderer(value) {
    		throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blockReindexing() {
    		throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blockReindexing(value) {
    		throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function createCoordSysGeometry (
      geometry, coordinateTransformationContext, interpolate, visibilityTreshold = 1
    ) {
      if (transformationNecessary(coordinateTransformationContext)) {
        const transformFunc = coordinateTransformationContext.transform.bind(coordinateTransformationContext);

        if (interpolate) {
          return interpolateGeometry(geometry, transformFunc, visibilityTreshold)
        } else {
          return transformGeometry(geometry, transformFunc)
        }
      } else {
        return geometry
      }
    }

    function transformationNecessary (coordinateTransformationContext) {
      return coordinateTransformationContext &&
      coordinateTransformationContext.type() !== 'identity'
    }

    function createCoordSysGeometryObject (
      scaledGeometryArray, coordinateTransformationContext, keyArray, interpolate, visibilityTreshold = 1
    ) {
      const screenGeometryObject = {};

      for (let i = 0; i < scaledGeometryArray.length; i++) {
        const scaledGeometry = scaledGeometryArray[i];
        const screenGeometry = createCoordSysGeometry(
          scaledGeometry, coordinateTransformationContext, interpolate, visibilityTreshold
        );

        const key = keyArray[i];

        screenGeometryObject[key] = screenGeometry;
      }

      return screenGeometryObject
    }

    function createCoordSysGeometryRectangle (coordinateProps, sectionContext, coordinateTransformationContext, interpolate) {
      const scaledCoordinates = scaleCoordinates(coordinateProps, sectionContext);
      const scaledGeometry = createScaledGeometry(scaledCoordinates);

      const coordSysGeometry = createCoordSysGeometry(
        scaledGeometry,
        coordinateTransformationContext,
        interpolate
      );

      return coordSysGeometry
    }

    function scaleCoordinates (coordinateProps, sectionContext) {
      ensureValidCombination(coordinateProps);
      validateTypes(coordinateProps);

      const { x1, x2, y1, y2 } = coordinateProps;

      const scaledCoordinates = {};

      if (wereSpecified(x1, x2)) {
        scaledCoordinates.x1 = scaleCoordinate(x1, 'x1', sectionContext);
        scaledCoordinates.x2 = scaleCoordinate(x2, 'x2', sectionContext);
      } else {
        scaledCoordinates.x1 = sectionContext.minX;
        scaledCoordinates.x2 = sectionContext.maxX;
      }

      if (wereSpecified(y1, y2)) {
        scaledCoordinates.y1 = scaleCoordinate(y1, 'y1', sectionContext);
        scaledCoordinates.y2 = scaleCoordinate(y2, 'y2', sectionContext);
      } else {
        scaledCoordinates.y1 = sectionContext.minY;
        scaledCoordinates.y2 = sectionContext.maxY;
      }

      return scaledCoordinates
    }

    const s = JSON.stringify;

    function ensureValidCombination (c) {
      if (onlyOne(c.x1, c.x2)) {
        throw new Error(`Rectangle: invalid combination of 'x1' and 'x2': ${s(c.x1)}, ${s(c.x2)}. Either provide both or none.`)
      }

      if (onlyOne(c.y1, c.y2)) {
        throw new Error(`Rectangle: invalid combination of 'y1' and 'y2': ${s(c.y1)}, ${s(c.y2)}. Either provide both or none.`)
      }
    }

    function onlyOne (a, b) {
      return isUndefined(a) ? isDefined(b) : isUndefined(b)
    }

    const invalidCoordinateValueError = (value, name) => new Error(`Rectangle: invalid coordinate value for '${name}': ${s(value)}`);

    function validateTypes (coordinates) {
      for (const coordinateName in coordinates) {
        const coordinate = coordinates[coordinateName];

        if (isDefined(coordinate)) {
          if (isInvalid(coordinate)) throw invalidCoordinateValueError(coordinate, coordinateName)

          if (![Number, String, Date, Function].includes(coordinate.constructor)) {
            throw invalidCoordinateValueError(coordinate, coordinateName)
          }
        }
      }
    }

    function wereSpecified (a, b) {
      return isDefined(a) && isDefined(b)
    }

    function scaleCoordinate (coordinate, coordinateName, sectionContext) {
      if (coordinate.constructor === Function) {
        return coordinate(sectionContext)
      } else {
        const scale = ['x1', 'x2'].includes(coordinateName) ? sectionContext.scaleX : sectionContext.scaleY;
        const scaledCoordinate = scale(coordinate);
        throwErrorIfInvalidScaledCoordinate(coordinate, scaledCoordinate, coordinateName);

        return scaledCoordinate
      }
    }

    function throwErrorIfInvalidScaledCoordinate (input, output, coordinateName) {
      const parentScale = ['x1', 'x2'].includes(coordinateName) ? 'scaleX' : 'scaleY';
      if (isInvalid(output)) throw new Error(`Scale '${parentScale}' received '${s(input)}' and returned '${s(output)}`)
    }

    function createScaledGeometry (c) {
      return {
        type: 'Polygon',
        coordinates: [
          [
            [c.x1, c.y1],
            [c.x2, c.y1],
            [c.x2, c.y2],
            [c.x1, c.y2],
            [c.x1, c.y1]
          ]
        ]
      }
    }

    /* src/components/Core/Section/Section.svelte generated by Svelte v3.15.0 */
    const file$2 = "src/components/Core/Section/Section.svelte";

    // (198:2) {#if paddingColor}
    function create_if_block_1$1(ctx) {
    	let rect;
    	let rect_mask_value;

    	const block = {
    		c: function create() {
    			rect = svg_element("rect");
    			attr_dev(rect, "class", "padding-background");
    			attr_dev(rect, "mask", rect_mask_value = `url(#clip-${ctx.sectionId}-data)`);
    			attr_dev(rect, "width", "100%");
    			attr_dev(rect, "height", "100%");
    			attr_dev(rect, "fill", ctx.paddingColor);
    			add_location(rect, file$2, 198, 4, 6138);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, rect, anchor);
    		},
    		p: function update(changed, ctx) {
    			if (changed.paddingColor) {
    				attr_dev(rect, "fill", ctx.paddingColor);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(rect);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(198:2) {#if paddingColor}",
    		ctx
    	});

    	return block;
    }

    // (206:2) {#if backgroundColor}
    function create_if_block$1(ctx) {
    	let rect;
    	let rect_x_value;
    	let rect_y_value;
    	let rect_width_value;
    	let rect_height_value;

    	const block = {
    		c: function create() {
    			rect = svg_element("rect");
    			attr_dev(rect, "class", "content-background");
    			attr_dev(rect, "x", rect_x_value = Math.min(...ctx.rangeX));
    			attr_dev(rect, "y", rect_y_value = Math.min(...ctx.rangeY));
    			attr_dev(rect, "width", rect_width_value = Math.abs(ctx.rangeX[0] - ctx.rangeX[1]));
    			attr_dev(rect, "height", rect_height_value = Math.abs(ctx.rangeY[0] - ctx.rangeY[1]));
    			attr_dev(rect, "fill", ctx.backgroundColor);
    			add_location(rect, file$2, 206, 4, 6324);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, rect, anchor);
    		},
    		p: function update(changed, ctx) {
    			if (changed.rangeX && rect_x_value !== (rect_x_value = Math.min(...ctx.rangeX))) {
    				attr_dev(rect, "x", rect_x_value);
    			}

    			if (changed.rangeY && rect_y_value !== (rect_y_value = Math.min(...ctx.rangeY))) {
    				attr_dev(rect, "y", rect_y_value);
    			}

    			if (changed.rangeX && rect_width_value !== (rect_width_value = Math.abs(ctx.rangeX[0] - ctx.rangeX[1]))) {
    				attr_dev(rect, "width", rect_width_value);
    			}

    			if (changed.rangeY && rect_height_value !== (rect_height_value = Math.abs(ctx.rangeY[0] - ctx.rangeY[1]))) {
    				attr_dev(rect, "height", rect_height_value);
    			}

    			if (changed.backgroundColor) {
    				attr_dev(rect, "fill", ctx.backgroundColor);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(rect);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(206:2) {#if backgroundColor}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let defs;
    	let clipPath0;
    	let rect0;
    	let rect0_x_value;
    	let rect0_y_value;
    	let rect0_width_value;
    	let rect0_height_value;
    	let clipPath0_id_value;
    	let clipPath1;
    	let rect1;
    	let rect1_x_value;
    	let rect1_y_value;
    	let rect1_width_value;
    	let rect1_height_value;
    	let clipPath1_id_value;
    	let t;
    	let g;
    	let if_block0_anchor;
    	let if_block1_anchor;
    	let g_clip_path_value;
    	let current;
    	let if_block0 = ctx.paddingColor && create_if_block_1$1(ctx);
    	let if_block1 = ctx.backgroundColor && create_if_block$1(ctx);
    	const default_slot_template = ctx.$$slots.default;
    	const default_slot = create_slot(default_slot_template, ctx, null);

    	const block = {
    		c: function create() {
    			defs = svg_element("defs");
    			clipPath0 = svg_element("clipPath");
    			rect0 = svg_element("rect");
    			clipPath1 = svg_element("clipPath");
    			rect1 = svg_element("rect");
    			t = space();
    			g = svg_element("g");
    			if (if_block0) if_block0.c();
    			if_block0_anchor = empty();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    			if (default_slot) default_slot.c();
    			attr_dev(rect0, "x", rect0_x_value = Math.min(ctx.scaledCoordinates.x1, ctx.scaledCoordinates.x2));
    			attr_dev(rect0, "y", rect0_y_value = Math.min(ctx.scaledCoordinates.y1, ctx.scaledCoordinates.y2));
    			attr_dev(rect0, "width", rect0_width_value = Math.abs(ctx.scaledCoordinates.x2 - ctx.scaledCoordinates.x1));
    			attr_dev(rect0, "height", rect0_height_value = Math.abs(ctx.scaledCoordinates.y2 - ctx.scaledCoordinates.y1));
    			add_location(rect0, file$2, 178, 4, 5507);
    			attr_dev(clipPath0, "id", clipPath0_id_value = `clip-${ctx.sectionId}`);
    			add_location(clipPath0, file$2, 177, 2, 5467);
    			attr_dev(rect1, "x", rect1_x_value = Math.min(...ctx.rangeX));
    			attr_dev(rect1, "y", rect1_y_value = Math.min(...ctx.rangeY));
    			attr_dev(rect1, "width", rect1_width_value = Math.abs(ctx.rangeX[0] - ctx.rangeX[1]));
    			attr_dev(rect1, "height", rect1_height_value = Math.abs(ctx.rangeY[0] - ctx.rangeY[1]));
    			attr_dev(rect1, "fill", "white");
    			add_location(rect1, file$2, 186, 4, 5845);
    			attr_dev(clipPath1, "id", clipPath1_id_value = `clip-${ctx.sectionId}-data`);
    			add_location(clipPath1, file$2, 185, 2, 5800);
    			add_location(defs, file$2, 176, 0, 5458);
    			attr_dev(g, "class", "section");
    			attr_dev(g, "clip-path", g_clip_path_value = `url(#clip-${ctx.sectionId})`);
    			add_location(g, file$2, 196, 0, 6054);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, defs, anchor);
    			append_dev(defs, clipPath0);
    			append_dev(clipPath0, rect0);
    			append_dev(defs, clipPath1);
    			append_dev(clipPath1, rect1);
    			insert_dev(target, t, anchor);
    			insert_dev(target, g, anchor);
    			if (if_block0) if_block0.m(g, null);
    			append_dev(g, if_block0_anchor);
    			if (if_block1) if_block1.m(g, null);
    			append_dev(g, if_block1_anchor);

    			if (default_slot) {
    				default_slot.m(g, null);
    			}

    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (!current || changed.scaledCoordinates && rect0_x_value !== (rect0_x_value = Math.min(ctx.scaledCoordinates.x1, ctx.scaledCoordinates.x2))) {
    				attr_dev(rect0, "x", rect0_x_value);
    			}

    			if (!current || changed.scaledCoordinates && rect0_y_value !== (rect0_y_value = Math.min(ctx.scaledCoordinates.y1, ctx.scaledCoordinates.y2))) {
    				attr_dev(rect0, "y", rect0_y_value);
    			}

    			if (!current || changed.scaledCoordinates && rect0_width_value !== (rect0_width_value = Math.abs(ctx.scaledCoordinates.x2 - ctx.scaledCoordinates.x1))) {
    				attr_dev(rect0, "width", rect0_width_value);
    			}

    			if (!current || changed.scaledCoordinates && rect0_height_value !== (rect0_height_value = Math.abs(ctx.scaledCoordinates.y2 - ctx.scaledCoordinates.y1))) {
    				attr_dev(rect0, "height", rect0_height_value);
    			}

    			if (!current || changed.rangeX && rect1_x_value !== (rect1_x_value = Math.min(...ctx.rangeX))) {
    				attr_dev(rect1, "x", rect1_x_value);
    			}

    			if (!current || changed.rangeY && rect1_y_value !== (rect1_y_value = Math.min(...ctx.rangeY))) {
    				attr_dev(rect1, "y", rect1_y_value);
    			}

    			if (!current || changed.rangeX && rect1_width_value !== (rect1_width_value = Math.abs(ctx.rangeX[0] - ctx.rangeX[1]))) {
    				attr_dev(rect1, "width", rect1_width_value);
    			}

    			if (!current || changed.rangeY && rect1_height_value !== (rect1_height_value = Math.abs(ctx.rangeY[0] - ctx.rangeY[1]))) {
    				attr_dev(rect1, "height", rect1_height_value);
    			}

    			if (ctx.paddingColor) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_1$1(ctx);
    					if_block0.c();
    					if_block0.m(g, if_block0_anchor);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (ctx.backgroundColor) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block$1(ctx);
    					if_block1.c();
    					if_block1.m(g, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (default_slot && default_slot.p && changed.$$scope) {
    				default_slot.p(get_slot_changes(default_slot_template, ctx, changed, null), get_slot_context(default_slot_template, ctx, null));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(defs);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(g);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let idCounter = 0;

    function getId() {
    	return "sc" + idCounter++;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let $eventManagerContext;
    	let $sectionContext;
    	let $interactionManagerContext;
    	let $newSectionContext;
    	let $newCoordinateTransformationContext;
    	let $zoomContext;
    	let $coordinateTransformationContext;
    	const sectionId = getId();
    	let { x1 } = $$props;
    	let { x2 } = $$props;
    	let { y1 } = $$props;
    	let { y2 } = $$props;
    	let { padding = 0 } = $$props;
    	let { scaleX } = $$props;
    	let { scaleY } = $$props;
    	let { flipX = false } = $$props;
    	let { flipY = false } = $$props;
    	let { zoomIdentity } = $$props;
    	let { transformation } = $$props;
    	let { blockReindexing = false } = $$props;
    	let { backgroundColor } = $$props;
    	let { paddingColor } = $$props;
    	let { onWheel } = $$props;
    	let { onClick } = $$props;
    	let { onMousedown } = $$props;
    	let { onMouseup } = $$props;
    	let { onMouseover } = $$props;
    	let { onMouseout } = $$props;
    	let { onMousemove } = $$props;
    	const graphicContext = subscribe$1();
    	const sectionContext = subscribe$2();
    	validate_store(sectionContext, "sectionContext");
    	component_subscribe($$self, sectionContext, value => $$invalidate("$sectionContext", $sectionContext = value));
    	const newSectionContext = init$2();
    	validate_store(newSectionContext, "newSectionContext");
    	component_subscribe($$self, newSectionContext, value => $$invalidate("$newSectionContext", $newSectionContext = value));
    	const coordinateTransformationContext = subscribe$5();
    	validate_store(coordinateTransformationContext, "coordinateTransformationContext");
    	component_subscribe($$self, coordinateTransformationContext, value => $$invalidate("$coordinateTransformationContext", $coordinateTransformationContext = value));
    	const newCoordinateTransformationContext = init$5();
    	validate_store(newCoordinateTransformationContext, "newCoordinateTransformationContext");
    	component_subscribe($$self, newCoordinateTransformationContext, value => $$invalidate("$newCoordinateTransformationContext", $newCoordinateTransformationContext = value));
    	const eventManagerContext = subscribe$3();
    	validate_store(eventManagerContext, "eventManagerContext");
    	component_subscribe($$self, eventManagerContext, value => $$invalidate("$eventManagerContext", $eventManagerContext = value));
    	const interactionManagerContext = init$4();
    	validate_store(interactionManagerContext, "interactionManagerContext");
    	component_subscribe($$self, interactionManagerContext, value => $$invalidate("$interactionManagerContext", $interactionManagerContext = value));
    	const zoomContext = init$6();
    	validate_store(zoomContext, "zoomContext");
    	component_subscribe($$self, zoomContext, value => $$invalidate("$zoomContext", $zoomContext = value));
    	let scaledCoordinates;
    	let rangeX;
    	let rangeY;
    	const interactionManager = new InteractionManager();
    	interactionManager.setId(sectionId);
    	interactionManager.linkEventManager($eventManagerContext);
    	update$4(interactionManagerContext, interactionManager);
    	let _padding;

    	beforeUpdate(() => {
    		ensureNotParent($coordinateTransformationContext);
    	});

    	function removeSectionInteractionsIfNecessary() {
    		if (detectIt.hasMouse) {
    			const sectionInterface = $interactionManagerContext.mouse().section();
    			sectionInterface.removeAllInteractions();
    			if (onWheel) sectionInterface.addInteraction("wheel", onWheel);
    			if (onClick) sectionInterface.addInteraction("click", onClick);
    			if (onMousedown) sectionInterface.addInteraction("mousedown", onMousedown);
    			if (onMouseup) sectionInterface.addInteraction("mouseup", onMouseup);
    			if (onMouseover) sectionInterface.addInteraction("mouseover", onMouseover);
    			if (onMouseout) sectionInterface.addInteraction("mouseout", onMouseout);
    			if (onMousemove) sectionInterface.addInteraction("mousemove", onMousemove);
    		}

    		if (detectIt.hasTouch) ;
    	}

    	const selectManager = $interactionManagerContext.select();

    	function selectRectangle(rectangle) {
    		selectManager.selectRectangle(rectangle);
    	}

    	function updateSelectRectangle(rectangle) {
    		selectManager.updateSelectRectangle(rectangle);
    	}

    	function resetSelectRectangle() {
    		selectManager.resetSelectRectangle();
    	}

    	function startSelectPolygon(startCoordinates) {
    		selectManager.startSelectPolygon(startCoordinates);
    	}

    	function addPointToSelectPolygon(pointCoordinates) {
    		selectManager.addPointToSelectPolygon(pointCoordinates);
    	}

    	function moveSelectPolygon(delta) {
    		selectManager.moveSelectPolygon(delta);
    	}

    	function getSelectPolygon() {
    		return selectManager.getSelectPolygon();
    	}

    	function resetSelectPolygon() {
    		selectManager.resetSelectPolygon();
    	}

    	const writable_props = [
    		"x1",
    		"x2",
    		"y1",
    		"y2",
    		"padding",
    		"scaleX",
    		"scaleY",
    		"flipX",
    		"flipY",
    		"zoomIdentity",
    		"transformation",
    		"blockReindexing",
    		"backgroundColor",
    		"paddingColor",
    		"onWheel",
    		"onClick",
    		"onMousedown",
    		"onMouseup",
    		"onMouseover",
    		"onMouseout",
    		"onMousemove"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Section> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;

    	$$self.$set = $$props => {
    		if ("x1" in $$props) $$invalidate("x1", x1 = $$props.x1);
    		if ("x2" in $$props) $$invalidate("x2", x2 = $$props.x2);
    		if ("y1" in $$props) $$invalidate("y1", y1 = $$props.y1);
    		if ("y2" in $$props) $$invalidate("y2", y2 = $$props.y2);
    		if ("padding" in $$props) $$invalidate("padding", padding = $$props.padding);
    		if ("scaleX" in $$props) $$invalidate("scaleX", scaleX = $$props.scaleX);
    		if ("scaleY" in $$props) $$invalidate("scaleY", scaleY = $$props.scaleY);
    		if ("flipX" in $$props) $$invalidate("flipX", flipX = $$props.flipX);
    		if ("flipY" in $$props) $$invalidate("flipY", flipY = $$props.flipY);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("transformation" in $$props) $$invalidate("transformation", transformation = $$props.transformation);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    		if ("backgroundColor" in $$props) $$invalidate("backgroundColor", backgroundColor = $$props.backgroundColor);
    		if ("paddingColor" in $$props) $$invalidate("paddingColor", paddingColor = $$props.paddingColor);
    		if ("onWheel" in $$props) $$invalidate("onWheel", onWheel = $$props.onWheel);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousemove" in $$props) $$invalidate("onMousemove", onMousemove = $$props.onMousemove);
    		if ("$$scope" in $$props) $$invalidate("$$scope", $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return {
    			idCounter,
    			x1,
    			x2,
    			y1,
    			y2,
    			padding,
    			scaleX,
    			scaleY,
    			flipX,
    			flipY,
    			zoomIdentity,
    			transformation,
    			blockReindexing,
    			backgroundColor,
    			paddingColor,
    			onWheel,
    			onClick,
    			onMousedown,
    			onMouseup,
    			onMouseover,
    			onMouseout,
    			onMousemove,
    			scaledCoordinates,
    			rangeX,
    			rangeY,
    			_padding,
    			$eventManagerContext,
    			$sectionContext,
    			$interactionManagerContext,
    			$newSectionContext,
    			$newCoordinateTransformationContext,
    			$zoomContext,
    			$coordinateTransformationContext
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("x1" in $$props) $$invalidate("x1", x1 = $$props.x1);
    		if ("x2" in $$props) $$invalidate("x2", x2 = $$props.x2);
    		if ("y1" in $$props) $$invalidate("y1", y1 = $$props.y1);
    		if ("y2" in $$props) $$invalidate("y2", y2 = $$props.y2);
    		if ("padding" in $$props) $$invalidate("padding", padding = $$props.padding);
    		if ("scaleX" in $$props) $$invalidate("scaleX", scaleX = $$props.scaleX);
    		if ("scaleY" in $$props) $$invalidate("scaleY", scaleY = $$props.scaleY);
    		if ("flipX" in $$props) $$invalidate("flipX", flipX = $$props.flipX);
    		if ("flipY" in $$props) $$invalidate("flipY", flipY = $$props.flipY);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("transformation" in $$props) $$invalidate("transformation", transformation = $$props.transformation);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    		if ("backgroundColor" in $$props) $$invalidate("backgroundColor", backgroundColor = $$props.backgroundColor);
    		if ("paddingColor" in $$props) $$invalidate("paddingColor", paddingColor = $$props.paddingColor);
    		if ("onWheel" in $$props) $$invalidate("onWheel", onWheel = $$props.onWheel);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousemove" in $$props) $$invalidate("onMousemove", onMousemove = $$props.onMousemove);
    		if ("scaledCoordinates" in $$props) $$invalidate("scaledCoordinates", scaledCoordinates = $$props.scaledCoordinates);
    		if ("rangeX" in $$props) $$invalidate("rangeX", rangeX = $$props.rangeX);
    		if ("rangeY" in $$props) $$invalidate("rangeY", rangeY = $$props.rangeY);
    		if ("_padding" in $$props) $$invalidate("_padding", _padding = $$props._padding);
    		if ("$eventManagerContext" in $$props) eventManagerContext.set($eventManagerContext = $$props.$eventManagerContext);
    		if ("$sectionContext" in $$props) sectionContext.set($sectionContext = $$props.$sectionContext);
    		if ("$interactionManagerContext" in $$props) interactionManagerContext.set($interactionManagerContext = $$props.$interactionManagerContext);
    		if ("$newSectionContext" in $$props) newSectionContext.set($newSectionContext = $$props.$newSectionContext);
    		if ("$newCoordinateTransformationContext" in $$props) newCoordinateTransformationContext.set($newCoordinateTransformationContext = $$props.$newCoordinateTransformationContext);
    		if ("$zoomContext" in $$props) zoomContext.set($zoomContext = $$props.$zoomContext);
    		if ("$coordinateTransformationContext" in $$props) coordinateTransformationContext.set($coordinateTransformationContext = $$props.$coordinateTransformationContext);
    	};

    	$$self.$$.update = (changed = { x1: 1, x2: 1, y1: 1, y2: 1, $sectionContext: 1, scaledCoordinates: 1, flipX: 1, rangeX: 1, flipY: 1, rangeY: 1, padding: 1, _padding: 1, scaleX: 1, scaleY: 1, blockReindexing: 1, transformation: 1, $interactionManagerContext: 1, $newSectionContext: 1, $newCoordinateTransformationContext: 1, onWheel: 1, onClick: 1, onMousedown: 1, onMouseup: 1, onMouseover: 1, onMouseout: 1, zoomIdentity: 1, $zoomContext: 1 }) => {
    		if (changed.x1 || changed.x2 || changed.y1 || changed.y2 || changed.$sectionContext || changed.scaledCoordinates || changed.flipX || changed.rangeX || changed.flipY || changed.rangeY || changed.padding || changed._padding || changed.scaleX || changed.scaleY || changed.blockReindexing || changed.transformation || changed.$interactionManagerContext || changed.$newSectionContext || changed.$newCoordinateTransformationContext) {
    			 {
    				$$invalidate("scaledCoordinates", scaledCoordinates = scaleCoordinates({ x1, x2, y1, y2 }, $sectionContext));
    				$$invalidate("rangeX", rangeX = [scaledCoordinates.x1, scaledCoordinates.x2]);
    				$$invalidate("rangeY", rangeY = [scaledCoordinates.y1, scaledCoordinates.y2]);
    				if (flipX) rangeX.reverse();
    				if (flipY) rangeY.reverse();
    				$$invalidate("_padding", _padding = parsePadding(padding));
    				$$invalidate("rangeX", rangeX = applyPadding(rangeX, _padding.left, _padding.right));
    				$$invalidate("rangeY", rangeY = applyPadding(rangeY, _padding.top, _padding.bottom));

    				const updatedSectionContext = {
    					sectionId,
    					rangeX,
    					rangeY,
    					scaleX,
    					scaleY,
    					padding: _padding,
    					flipX,
    					flipY,
    					blockReindexing
    				};

    				update$2(newSectionContext, updatedSectionContext);
    				update$5(newCoordinateTransformationContext, { rangeX, rangeY, transformation });
    				$interactionManagerContext.loadSection($newSectionContext);
    				$interactionManagerContext.loadCoordinateTransformation($newCoordinateTransformationContext);
    			}
    		}

    		if (changed.onWheel || changed.onClick || changed.onMousedown || changed.onMouseup || changed.onMouseover || changed.onMouseout) {
    			 {
    				removeSectionInteractionsIfNecessary();
    			}
    		}

    		if (changed.zoomIdentity || changed.$interactionManagerContext || changed.$zoomContext) {
    			 {
    				update$6(zoomContext, zoomIdentity);
    				$interactionManagerContext.loadZoom($zoomContext);
    			}
    		}
    	};

    	return {
    		sectionId,
    		x1,
    		x2,
    		y1,
    		y2,
    		padding,
    		scaleX,
    		scaleY,
    		flipX,
    		flipY,
    		zoomIdentity,
    		transformation,
    		blockReindexing,
    		backgroundColor,
    		paddingColor,
    		onWheel,
    		onClick,
    		onMousedown,
    		onMouseup,
    		onMouseover,
    		onMouseout,
    		onMousemove,
    		sectionContext,
    		newSectionContext,
    		coordinateTransformationContext,
    		newCoordinateTransformationContext,
    		eventManagerContext,
    		interactionManagerContext,
    		zoomContext,
    		scaledCoordinates,
    		rangeX,
    		rangeY,
    		selectRectangle,
    		updateSelectRectangle,
    		resetSelectRectangle,
    		startSelectPolygon,
    		addPointToSelectPolygon,
    		moveSelectPolygon,
    		getSelectPolygon,
    		resetSelectPolygon,
    		$$slots,
    		$$scope
    	};
    }

    class Section extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
    			x1: 0,
    			x2: 0,
    			y1: 0,
    			y2: 0,
    			padding: 0,
    			scaleX: 0,
    			scaleY: 0,
    			flipX: 0,
    			flipY: 0,
    			zoomIdentity: 0,
    			transformation: 0,
    			blockReindexing: 0,
    			backgroundColor: 0,
    			paddingColor: 0,
    			onWheel: 0,
    			onClick: 0,
    			onMousedown: 0,
    			onMouseup: 0,
    			onMouseover: 0,
    			onMouseout: 0,
    			onMousemove: 0,
    			selectRectangle: 0,
    			updateSelectRectangle: 0,
    			resetSelectRectangle: 0,
    			startSelectPolygon: 0,
    			addPointToSelectPolygon: 0,
    			moveSelectPolygon: 0,
    			getSelectPolygon: 0,
    			resetSelectPolygon: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Section",
    			options,
    			id: create_fragment$4.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || ({});

    		if (ctx.x1 === undefined && !("x1" in props)) {
    			console.warn("<Section> was created without expected prop 'x1'");
    		}

    		if (ctx.x2 === undefined && !("x2" in props)) {
    			console.warn("<Section> was created without expected prop 'x2'");
    		}

    		if (ctx.y1 === undefined && !("y1" in props)) {
    			console.warn("<Section> was created without expected prop 'y1'");
    		}

    		if (ctx.y2 === undefined && !("y2" in props)) {
    			console.warn("<Section> was created without expected prop 'y2'");
    		}

    		if (ctx.scaleX === undefined && !("scaleX" in props)) {
    			console.warn("<Section> was created without expected prop 'scaleX'");
    		}

    		if (ctx.scaleY === undefined && !("scaleY" in props)) {
    			console.warn("<Section> was created without expected prop 'scaleY'");
    		}

    		if (ctx.zoomIdentity === undefined && !("zoomIdentity" in props)) {
    			console.warn("<Section> was created without expected prop 'zoomIdentity'");
    		}

    		if (ctx.transformation === undefined && !("transformation" in props)) {
    			console.warn("<Section> was created without expected prop 'transformation'");
    		}

    		if (ctx.backgroundColor === undefined && !("backgroundColor" in props)) {
    			console.warn("<Section> was created without expected prop 'backgroundColor'");
    		}

    		if (ctx.paddingColor === undefined && !("paddingColor" in props)) {
    			console.warn("<Section> was created without expected prop 'paddingColor'");
    		}

    		if (ctx.onWheel === undefined && !("onWheel" in props)) {
    			console.warn("<Section> was created without expected prop 'onWheel'");
    		}

    		if (ctx.onClick === undefined && !("onClick" in props)) {
    			console.warn("<Section> was created without expected prop 'onClick'");
    		}

    		if (ctx.onMousedown === undefined && !("onMousedown" in props)) {
    			console.warn("<Section> was created without expected prop 'onMousedown'");
    		}

    		if (ctx.onMouseup === undefined && !("onMouseup" in props)) {
    			console.warn("<Section> was created without expected prop 'onMouseup'");
    		}

    		if (ctx.onMouseover === undefined && !("onMouseover" in props)) {
    			console.warn("<Section> was created without expected prop 'onMouseover'");
    		}

    		if (ctx.onMouseout === undefined && !("onMouseout" in props)) {
    			console.warn("<Section> was created without expected prop 'onMouseout'");
    		}

    		if (ctx.onMousemove === undefined && !("onMousemove" in props)) {
    			console.warn("<Section> was created without expected prop 'onMousemove'");
    		}

    		if (ctx.selectRectangle === undefined && !("selectRectangle" in props)) {
    			console.warn("<Section> was created without expected prop 'selectRectangle'");
    		}

    		if (ctx.updateSelectRectangle === undefined && !("updateSelectRectangle" in props)) {
    			console.warn("<Section> was created without expected prop 'updateSelectRectangle'");
    		}

    		if (ctx.resetSelectRectangle === undefined && !("resetSelectRectangle" in props)) {
    			console.warn("<Section> was created without expected prop 'resetSelectRectangle'");
    		}

    		if (ctx.startSelectPolygon === undefined && !("startSelectPolygon" in props)) {
    			console.warn("<Section> was created without expected prop 'startSelectPolygon'");
    		}

    		if (ctx.addPointToSelectPolygon === undefined && !("addPointToSelectPolygon" in props)) {
    			console.warn("<Section> was created without expected prop 'addPointToSelectPolygon'");
    		}

    		if (ctx.moveSelectPolygon === undefined && !("moveSelectPolygon" in props)) {
    			console.warn("<Section> was created without expected prop 'moveSelectPolygon'");
    		}

    		if (ctx.getSelectPolygon === undefined && !("getSelectPolygon" in props)) {
    			console.warn("<Section> was created without expected prop 'getSelectPolygon'");
    		}

    		if (ctx.resetSelectPolygon === undefined && !("resetSelectPolygon" in props)) {
    			console.warn("<Section> was created without expected prop 'resetSelectPolygon'");
    		}
    	}

    	get x1() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x1(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get x2() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x2(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y1() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y1(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y2() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y2(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get padding() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set padding(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scaleX() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scaleX(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scaleY() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scaleY(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flipX() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flipX(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flipY() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flipY(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zoomIdentity() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoomIdentity(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transformation() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transformation(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blockReindexing() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blockReindexing(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backgroundColor() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backgroundColor(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get paddingColor() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set paddingColor(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onWheel() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onWheel(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClick() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClick(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedown() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedown(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseup() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseup(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseover() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseover(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseout() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseout(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousemove() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousemove(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectRectangle() {
    		return this.$$.ctx.selectRectangle;
    	}

    	set selectRectangle(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get updateSelectRectangle() {
    		return this.$$.ctx.updateSelectRectangle;
    	}

    	set updateSelectRectangle(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get resetSelectRectangle() {
    		return this.$$.ctx.resetSelectRectangle;
    	}

    	set resetSelectRectangle(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get startSelectPolygon() {
    		return this.$$.ctx.startSelectPolygon;
    	}

    	set startSelectPolygon(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get addPointToSelectPolygon() {
    		return this.$$.ctx.addPointToSelectPolygon;
    	}

    	set addPointToSelectPolygon(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get moveSelectPolygon() {
    		return this.$$.ctx.moveSelectPolygon;
    	}

    	set moveSelectPolygon(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getSelectPolygon() {
    		return this.$$.ctx.getSelectPolygon;
    	}

    	set getSelectPolygon(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get resetSelectPolygon() {
    		return this.$$.ctx.resetSelectPolygon;
    	}

    	set resetSelectPolygon(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var global$1 = (typeof global !== "undefined" ? global :
                typeof self !== "undefined" ? self :
                typeof window !== "undefined" ? window : {});

    // shim for using process in browser
    // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }
    var cachedSetTimeout = defaultSetTimout;
    var cachedClearTimeout = defaultClearTimeout;
    if (typeof global$1.setTimeout === 'function') {
        cachedSetTimeout = setTimeout;
    }
    if (typeof global$1.clearTimeout === 'function') {
        cachedClearTimeout = clearTimeout;
    }

    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }


    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }



    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }
    function nextTick(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    }
    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    var title = 'browser';
    var platform = 'browser';
    var browser = true;
    var env = {};
    var argv = [];
    var version = ''; // empty string to avoid regexp issues
    var versions = {};
    var release = {};
    var config = {};

    function noop$2() {}

    var on = noop$2;
    var addListener = noop$2;
    var once = noop$2;
    var off = noop$2;
    var removeListener = noop$2;
    var removeAllListeners = noop$2;
    var emit = noop$2;

    function binding(name) {
        throw new Error('process.binding is not supported');
    }

    function cwd () { return '/' }
    function chdir (dir) {
        throw new Error('process.chdir is not supported');
    }function umask() { return 0; }

    // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
    var performance = global$1.performance || {};
    var performanceNow =
      performance.now        ||
      performance.mozNow     ||
      performance.msNow      ||
      performance.oNow       ||
      performance.webkitNow  ||
      function(){ return (new Date()).getTime() };

    // generate timestamp or delta
    // see http://nodejs.org/api/process.html#process_process_hrtime
    function hrtime(previousTimestamp){
      var clocktime = performanceNow.call(performance)*1e-3;
      var seconds = Math.floor(clocktime);
      var nanoseconds = Math.floor((clocktime%1)*1e9);
      if (previousTimestamp) {
        seconds = seconds - previousTimestamp[0];
        nanoseconds = nanoseconds - previousTimestamp[1];
        if (nanoseconds<0) {
          seconds--;
          nanoseconds += 1e9;
        }
      }
      return [seconds,nanoseconds]
    }

    var startTime = new Date();
    function uptime() {
      var currentTime = new Date();
      var dif = currentTime - startTime;
      return dif / 1000;
    }

    var process = {
      nextTick: nextTick,
      title: title,
      browser: browser,
      env: env,
      argv: argv,
      version: version,
      versions: versions,
      on: on,
      addListener: addListener,
      once: once,
      off: off,
      removeListener: removeListener,
      removeAllListeners: removeAllListeners,
      emit: emit,
      binding: binding,
      cwd: cwd,
      chdir: chdir,
      umask: umask,
      hrtime: hrtime,
      platform: platform,
      release: release,
      config: config,
      uptime: uptime
    };

    function warn (message) {
      if (!process) console.warn(message);

      if (process && process.env.NODE_ENV !== 'test') {
        console.warn(message);
      }
    }

    // Gets all cells in grid in format { areaName: {x1, x2, y1, y2}, ... }
    // given the template specs and definition
    function getAllCells (templateRows, templateCols, rowGap, colGap, coords) {
      let numCols;

      // Divide svg into rows first
      const getRows = getRowCells(templateRows, rowGap, coords);
      const numRows = getRows.length;

      let colSizes = [];
      const rowSizes = [];

      let allCells = [];

      // Divide each row into columns
      // Practically speaking, it doesn't make a difference
      // which comes first
      for (const i of getRows) {
        const rowCols = getColCells(templateCols, colGap, i);

        allCells = allCells.concat(rowCols);

        rowSizes.push(i);
        colSizes = rowCols;

        numCols = rowCols.length;
      }

      return [allCells, rowSizes, colSizes, numRows, numCols]
    }

    // Divides each row into columns
    function getColCells (specs, colGap, ranges) {
      let start = ranges.x1;
      const cells = [];

      specs = validateGridSpec(specs, 'gridTemplateColumns');

      if (specs.constructor === String) {
        const individualSpecs = specs.split(/\s/);
        const frameStep = getFrameStep(individualSpecs, ranges.x2 - ranges.x1);

        for (const i of individualSpecs) {
          const value = parseInt(i.slice(0, -2));
          if (i.endsWith('px')) {
            cells.push(value);
          } else if (i.endsWith('fr')) {
            cells.push(frameStep * value);
          }
        }
      } else if (specs.constructor === Array) {
        const stepX = (ranges.x2 - ranges.x1) / specs.length;

        for (let j = 0; j < specs.length; j++) {
          cells.push(stepX);
        }
      } else if (specs.constructor === Number) {
        const stepX = (ranges.x2 - ranges.x1) / specs;

        for (let k = 0; k < specs; k++) {
          cells.push(stepX);
        }
      }

      const numCells = cells.length;

      const cellSpecs = [];

      for (let i = 0; i < numCells; i++) {
        cellSpecs.push({
          x1: start,
          x2: start + cells[i] - colGap / 2,
          y1: ranges.y1,
          y2: ranges.y2
        });

        start = start + cells[i] + colGap / 2;
      }

      return cellSpecs
    }

    // Divides each column into rows
    // Logic should probably be refactored since this function
    // is similar to getColCells
    function getRowCells (specs, rowGap, ranges) {
      let start = ranges.y1;
      const cells = [];

      specs = validateGridSpec(specs, 'gridTemplateColumns');

      if (specs.constructor === String) {
        const individualSpecs = specs.split(/\s/);
        const frameStep = getFrameStep(individualSpecs, ranges.y2 - ranges.y1);

        for (const i of individualSpecs) {
          if (i.endsWith('px')) {
            cells.push(parseInt(i.slice(0, -2)));
          } else if (i.endsWith('fr')) {
            cells.push(frameStep * parseInt(i.slice(0, -2)));
          }
        }
      } else if (specs.constructor === Array) {
        const stepY = (ranges.y2 - ranges.y1) / specs.length;

        for (let j = 0; j < specs.length; j++) {
          cells.push(stepY);
        }
      } else if (specs.constructor === Number) {
        const stepY = (ranges.y2 - ranges.y1) / specs;

        for (let k = 0; k < specs; k++) {
          cells.push(stepY);
        }
      }

      const numCells = cells.length;

      const cellSpecs = [];

      for (let i = 0; i < numCells; i++) {
        cellSpecs.push({
          y1: start,
          y2: start + cells[i] - rowGap / 2,
          x1: ranges.x1,
          x2: ranges.x2
        });

        start = start + cells[i] + rowGap / 2;
      }

      return cellSpecs
    }

    // If 'fr' definition is used, get the size of 1fr
    // Allows for mixed definitions, e.g. 150px 1fr 2fr
    function getFrameStep (specs, range) {
      let frameCount = 0;

      for (const i of specs) {
        const value = parseInt(i.slice(0, -2));

        if (i.endsWith('px')) {
          range = range - value;
        } else if (i.endsWith('fr')) {
          frameCount = frameCount + value;
        } else {
          warn(`Grid cell size should be specified in -px or -fr. Ignoring input ${i}`);
        }
      }

      if (frameCount === 0) { return 0 }

      return range / frameCount
    }

    // Adjacent cells with the same name are merged into a single area
    function mergeNameSpecs (cellNames, cellSpecs, numCols) {
      const namesLength = cellNames.length;
      const specsLength = cellSpecs.length;

      if (namesLength < specsLength) {
        warn('Cell names do not match up with number of cells specified, this may cause errors in your chart.');

        // Nameless cells are given their index as names
        for (let i = 0; i < specsLength; i++) {
          if (cellNames[i]) continue
          else { cellNames.push(i); }
        }
      } else if (namesLength > specsLength) {
        warn('Cell names do not match up with number of cells specified, this may cause errors in your chart.');
      }

      const allSpecs = {};
      const cellStartEnd = {};

      // Some logic for merging cells
      for (let j = 0; j < specsLength; j++) {
        const cellName = cellNames[j];

        if (cellName === undefined) {
          allSpecs[j] = cellSpecs[j];
        } else if (!(cellName in allSpecs)) {
          allSpecs[cellName] = cellSpecs[j];
          cellStartEnd[cellName] = { startRow: Math.floor(j / numCols), startCol: j % numCols, endRow: Math.floor(j / numCols), endCol: j % numCols };
        } else {
          allSpecs[cellName] = cellMerge(cellName, allSpecs[cellName], cellSpecs[j]);

          const newRow = Math.floor(j / numCols);
          const newCol = j % numCols;

          const currentRow = cellStartEnd[cellName].endRow;
          const currentCol = cellStartEnd[cellName].endCol;

          cellStartEnd[cellName].endRow = newRow > currentRow ? newRow : currentRow;
          cellStartEnd[cellName].endCol = newCol > currentCol ? newCol : currentCol;
        }
      }

      // Check that grid areas are rectangular
      validateCellSpaces(cellStartEnd, cellNames, numCols);

      return allSpecs
    }

    // This function is intentionally quite dumb so that incorrect specs
    // do not crash the graph but cause visibly incorrect rendering
    function cellMerge (cellName, cell1, cell2) {
      const newSpecs = {};

      newSpecs.x1 = cell1.x1 < cell2.x1 ? cell1.x1 : cell2.x1;
      newSpecs.x2 = cell1.x2 > cell2.x2 ? cell1.x2 : cell2.x2;
      newSpecs.y1 = cell1.y1 < cell2.y1 ? cell1.y1 : cell2.y1;
      newSpecs.y2 = cell1.y2 > cell2.y2 ? cell1.y2 : cell2.y2;

      return newSpecs
    }

    // Checks that gridTemplateRows and gridTemplateAreas are defined
    function validateGridSpec (a, direction) {
      if (a.constructor === String && a === '') {
        warn(`Please specify at least one cell in ${direction}. Automatically adding 1 cell to ${direction}.`);
        return '1fr'
      }

      if (a.constructor === Number && a === 0) {
        warn(`Please specify at least one cell in ${direction}. Automatically adding 1 cell to ${direction}.`);
        return 1
      } else if (a.constructor === Number && (a % 1) !== 0) {
        warn(`Please specify ${direction} with integers only. Using rounded value ${Math.ceil(a)}.`);
        return Math.ceil(a)
      }

      if (a.constructor === Array && a.length === 0) {
        warn(`Please specify at least one cell in ${direction}. Automatically adding 1 cell to ${direction}.`);
        return [0]
      }

      if ([Array, Number, String].indexOf(a.constructor) === -1) {
        warn(`Please specify ${direction} with Number, String or Array. Assuming 1 cell specified.`);
        return 1
      }

      return a
    }

    // Checks that grid areas are rectangular
    // This function is quite inefficient, can be optimized at a later date
    // Only console warnings are issued, the graph is still rendered (but incorrectly)
    function validateCellSpaces (spaces, indvCells, numCols) {
      for (const areaName in spaces) {
        const area = spaces[areaName];

        const startRow = area.startRow;
        const startCol = area.startCol;
        const endRow = area.endRow;
        const endCol = area.endCol;

        for (let r = startRow; r <= endRow; r++) {
          for (let c = startCol; c <= endCol; c++) {
            const index = r * numCols + c;
            if (indvCells[index] !== areaName) {
              warn(`Area ${areaName} may not be rectangular in prop gridTemplateAreas, this can cause errors in your chart.`);
            }
          }
        }
      }
    }

    function printGrid (rowSizes, colSizes) {
      let layout = '';
      let firstRow = '';
      let genericRow = '';
      let genericCol = '';
      let colWidth;
      let rowHeight;

      for (const i of colSizes) {
        colWidth = i.x2 - i.x1;

        const value = Math.round(colWidth).toString() + 'px';
        const valueLength = value.length;
        const placeHolder = new Array(valueLength + 1).join('-');
        const placeHolderEmpty = new Array(valueLength + 1).join(' ');

        firstRow = firstRow + '-- ' + value + ' --|';
        genericRow = genericRow + '---' + placeHolder + '---|';
        genericCol = genericCol + '   ' + placeHolderEmpty + '   |';
      }

      layout = firstRow + '\n';

      for (const j of rowSizes) {
        rowHeight = j.y2 - j.y1;

        const value = Math.round(rowHeight).toString() + 'px';
        const valueLength = value.length;

        const emptyCol = genericCol.substring(1) + '\n';
        const valueCol = genericCol.substring(valueLength) + '\n';

        layout = layout + '|' + emptyCol + value + valueCol + '|' + emptyCol + genericRow + '\n';
      }

      console.log(layout);
    }

    /* src/components/Core/Grid/Grid.svelte generated by Svelte v3.15.0 */

    const { console: console_1 } = globals;
    const file$3 = "src/components/Core/Grid/Grid.svelte";
    const get_default_slot_changes$1 = ({ allSpecs }) => ({ cells: allSpecs });
    const get_default_slot_context$1 = ({ allSpecs }) => ({ cells: allSpecs });

    function create_fragment$5(ctx) {
    	let g;
    	let current;
    	const default_slot_template = ctx.$$slots.default;
    	const default_slot = create_slot(default_slot_template, ctx, get_default_slot_context$1);

    	const block = {
    		c: function create() {
    			g = svg_element("g");
    			if (default_slot) default_slot.c();
    			add_location(g, file$3, 47, 0, 1578);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);

    			if (default_slot) {
    				default_slot.m(g, null);
    			}

    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (default_slot && default_slot.p && (changed.$$scope || changed.allSpecs)) {
    				default_slot.p(get_slot_changes(default_slot_template, ctx, changed, get_default_slot_changes$1), get_slot_context(default_slot_template, ctx, get_default_slot_context$1));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let $sectionContext;
    	let $coordinateTransformationContext;
    	let { x1 } = $$props;
    	let { x2 } = $$props;
    	let { y1 } = $$props;
    	let { y2 } = $$props;
    	let { rows = 1 } = $$props;
    	let { columns = 1 } = $$props;
    	let { rowGap = 0 } = $$props;
    	let { columnGap = 0 } = $$props;
    	let { areaNames } = $$props;
    	let { viewGridTemplate = false } = $$props;
    	let { viewGridShape = false } = $$props;
    	const coordinateTransformationContext = subscribe$5();
    	validate_store(coordinateTransformationContext, "coordinateTransformationContext");
    	component_subscribe($$self, coordinateTransformationContext, value => $$invalidate("$coordinateTransformationContext", $coordinateTransformationContext = value));
    	const sectionContext = subscribe$2();
    	validate_store(sectionContext, "sectionContext");
    	component_subscribe($$self, sectionContext, value => $$invalidate("$sectionContext", $sectionContext = value));
    	let scaledCoordinates;
    	let allCells;
    	let allNames;

    	beforeUpdate(() => {
    		ensureNotParent($coordinateTransformationContext);
    	});

    	const writable_props = [
    		"x1",
    		"x2",
    		"y1",
    		"y2",
    		"rows",
    		"columns",
    		"rowGap",
    		"columnGap",
    		"areaNames",
    		"viewGridTemplate",
    		"viewGridShape"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Grid> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;

    	$$self.$set = $$props => {
    		if ("x1" in $$props) $$invalidate("x1", x1 = $$props.x1);
    		if ("x2" in $$props) $$invalidate("x2", x2 = $$props.x2);
    		if ("y1" in $$props) $$invalidate("y1", y1 = $$props.y1);
    		if ("y2" in $$props) $$invalidate("y2", y2 = $$props.y2);
    		if ("rows" in $$props) $$invalidate("rows", rows = $$props.rows);
    		if ("columns" in $$props) $$invalidate("columns", columns = $$props.columns);
    		if ("rowGap" in $$props) $$invalidate("rowGap", rowGap = $$props.rowGap);
    		if ("columnGap" in $$props) $$invalidate("columnGap", columnGap = $$props.columnGap);
    		if ("areaNames" in $$props) $$invalidate("areaNames", areaNames = $$props.areaNames);
    		if ("viewGridTemplate" in $$props) $$invalidate("viewGridTemplate", viewGridTemplate = $$props.viewGridTemplate);
    		if ("viewGridShape" in $$props) $$invalidate("viewGridShape", viewGridShape = $$props.viewGridShape);
    		if ("$$scope" in $$props) $$invalidate("$$scope", $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return {
    			x1,
    			x2,
    			y1,
    			y2,
    			rows,
    			columns,
    			rowGap,
    			columnGap,
    			areaNames,
    			viewGridTemplate,
    			viewGridShape,
    			scaledCoordinates,
    			allCells,
    			allNames,
    			$sectionContext,
    			rowSizes,
    			colSizes,
    			numRows,
    			numCols,
    			allSpecs,
    			$coordinateTransformationContext
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("x1" in $$props) $$invalidate("x1", x1 = $$props.x1);
    		if ("x2" in $$props) $$invalidate("x2", x2 = $$props.x2);
    		if ("y1" in $$props) $$invalidate("y1", y1 = $$props.y1);
    		if ("y2" in $$props) $$invalidate("y2", y2 = $$props.y2);
    		if ("rows" in $$props) $$invalidate("rows", rows = $$props.rows);
    		if ("columns" in $$props) $$invalidate("columns", columns = $$props.columns);
    		if ("rowGap" in $$props) $$invalidate("rowGap", rowGap = $$props.rowGap);
    		if ("columnGap" in $$props) $$invalidate("columnGap", columnGap = $$props.columnGap);
    		if ("areaNames" in $$props) $$invalidate("areaNames", areaNames = $$props.areaNames);
    		if ("viewGridTemplate" in $$props) $$invalidate("viewGridTemplate", viewGridTemplate = $$props.viewGridTemplate);
    		if ("viewGridShape" in $$props) $$invalidate("viewGridShape", viewGridShape = $$props.viewGridShape);
    		if ("scaledCoordinates" in $$props) $$invalidate("scaledCoordinates", scaledCoordinates = $$props.scaledCoordinates);
    		if ("allCells" in $$props) $$invalidate("allCells", allCells = $$props.allCells);
    		if ("allNames" in $$props) allNames = $$props.allNames;
    		if ("$sectionContext" in $$props) sectionContext.set($sectionContext = $$props.$sectionContext);
    		if ("rowSizes" in $$props) $$invalidate("rowSizes", rowSizes = $$props.rowSizes);
    		if ("colSizes" in $$props) $$invalidate("colSizes", colSizes = $$props.colSizes);
    		if ("numRows" in $$props) $$invalidate("numRows", numRows = $$props.numRows);
    		if ("numCols" in $$props) $$invalidate("numCols", numCols = $$props.numCols);
    		if ("allSpecs" in $$props) $$invalidate("allSpecs", allSpecs = $$props.allSpecs);
    		if ("$coordinateTransformationContext" in $$props) coordinateTransformationContext.set($coordinateTransformationContext = $$props.$coordinateTransformationContext);
    	};

    	let rowSizes;
    	let colSizes;
    	let numRows;
    	let numCols;
    	let allSpecs;

    	$$self.$$.update = (changed = { x1: 1, x2: 1, y1: 1, y2: 1, $sectionContext: 1, rows: 1, columns: 1, rowGap: 1, columnGap: 1, scaledCoordinates: 1, viewGridTemplate: 1, rowSizes: 1, colSizes: 1, viewGridShape: 1, numRows: 1, numCols: 1, areaNames: 1, allCells: 1 }) => {
    		if (changed.x1 || changed.x2 || changed.y1 || changed.y2 || changed.$sectionContext) {
    			 $$invalidate("scaledCoordinates", scaledCoordinates = scaleCoordinates({ x1, x2, y1, y2 }, $sectionContext));
    		}

    		if (changed.rows || changed.columns || changed.rowGap || changed.columnGap || changed.scaledCoordinates) {
    			 $$invalidate("allCells", [allCells, rowSizes, colSizes, numRows, numCols] = getAllCells(rows, columns, rowGap, columnGap, scaledCoordinates), allCells, (((((((((($$invalidate("rowSizes", rowSizes), $$invalidate("rows", rows)), $$invalidate("columns", columns)), $$invalidate("rowGap", rowGap)), $$invalidate("columnGap", columnGap)), $$invalidate("scaledCoordinates", scaledCoordinates)), $$invalidate("x1", x1)), $$invalidate("x2", x2)), $$invalidate("y1", y1)), $$invalidate("y2", y2)), $$invalidate("$sectionContext", $sectionContext)), (((((((((($$invalidate("colSizes", colSizes), $$invalidate("rows", rows)), $$invalidate("columns", columns)), $$invalidate("rowGap", rowGap)), $$invalidate("columnGap", columnGap)), $$invalidate("scaledCoordinates", scaledCoordinates)), $$invalidate("x1", x1)), $$invalidate("x2", x2)), $$invalidate("y1", y1)), $$invalidate("y2", y2)), $$invalidate("$sectionContext", $sectionContext)), (((((((((($$invalidate("numRows", numRows), $$invalidate("rows", rows)), $$invalidate("columns", columns)), $$invalidate("rowGap", rowGap)), $$invalidate("columnGap", columnGap)), $$invalidate("scaledCoordinates", scaledCoordinates)), $$invalidate("x1", x1)), $$invalidate("x2", x2)), $$invalidate("y1", y1)), $$invalidate("y2", y2)), $$invalidate("$sectionContext", $sectionContext)), (((((((((($$invalidate("numCols", numCols), $$invalidate("rows", rows)), $$invalidate("columns", columns)), $$invalidate("rowGap", rowGap)), $$invalidate("columnGap", columnGap)), $$invalidate("scaledCoordinates", scaledCoordinates)), $$invalidate("x1", x1)), $$invalidate("x2", x2)), $$invalidate("y1", y1)), $$invalidate("y2", y2)), $$invalidate("$sectionContext", $sectionContext)));
    		}

    		if (changed.viewGridTemplate || changed.rowSizes || changed.colSizes) {
    			 if (viewGridTemplate) {
    				printGrid(rowSizes, colSizes);
    			}
    		}

    		if (changed.viewGridShape || changed.numRows || changed.numCols) {
    			 if (viewGridShape) {
    				console.log("rows:", numRows, " columns:", numCols);
    			}
    		}

    		if (changed.areaNames || changed.allCells || changed.numCols) {
    			 $$invalidate("allSpecs", allSpecs = mergeNameSpecs(areaNames, allCells, numCols));
    		}
    	};

    	return {
    		x1,
    		x2,
    		y1,
    		y2,
    		rows,
    		columns,
    		rowGap,
    		columnGap,
    		areaNames,
    		viewGridTemplate,
    		viewGridShape,
    		coordinateTransformationContext,
    		sectionContext,
    		allSpecs,
    		$$slots,
    		$$scope
    	};
    }

    class Grid extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
    			x1: 0,
    			x2: 0,
    			y1: 0,
    			y2: 0,
    			rows: 0,
    			columns: 0,
    			rowGap: 0,
    			columnGap: 0,
    			areaNames: 0,
    			viewGridTemplate: 0,
    			viewGridShape: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Grid",
    			options,
    			id: create_fragment$5.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || ({});

    		if (ctx.x1 === undefined && !("x1" in props)) {
    			console_1.warn("<Grid> was created without expected prop 'x1'");
    		}

    		if (ctx.x2 === undefined && !("x2" in props)) {
    			console_1.warn("<Grid> was created without expected prop 'x2'");
    		}

    		if (ctx.y1 === undefined && !("y1" in props)) {
    			console_1.warn("<Grid> was created without expected prop 'y1'");
    		}

    		if (ctx.y2 === undefined && !("y2" in props)) {
    			console_1.warn("<Grid> was created without expected prop 'y2'");
    		}

    		if (ctx.areaNames === undefined && !("areaNames" in props)) {
    			console_1.warn("<Grid> was created without expected prop 'areaNames'");
    		}
    	}

    	get x1() {
    		throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x1(value) {
    		throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get x2() {
    		throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x2(value) {
    		throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y1() {
    		throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y1(value) {
    		throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y2() {
    		throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y2(value) {
    		throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rows() {
    		throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rows(value) {
    		throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get columns() {
    		throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set columns(value) {
    		throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rowGap() {
    		throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rowGap(value) {
    		throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get columnGap() {
    		throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set columnGap(value) {
    		throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get areaNames() {
    		throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set areaNames(value) {
    		throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get viewGridTemplate() {
    		throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set viewGridTemplate(value) {
    		throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get viewGridShape() {
    		throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set viewGridShape(value) {
    		throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var pointAesthetics = {
      x: {
        required: false
      },
      y: {
        required: false
      },
      geometry: {
        required: false
      },
      radius: {
        required: false,
        default: 3
      },
      fill: {
        required: false,
        default: 'black'
      },
      stroke: {
        required: false,
        default: 'none'
      },
      strokeWidth: {
        required: false,
        default: 0
      },
      fillOpacity: {
        required: false
      },
      strokeOpacity: {
        required: false
      },
      opacity: {
        required: false,
        default: 1
      }
    };

    var rectangleAesthetics = {
      x1: {
        required: false
      },
      x2: {
        required: false
      },
      y1: {
        required: false
      },
      y2: {
        required: false
      },
      fill: {
        required: false,
        default: 'black'
      },
      stroke: {
        required: false,
        default: 'none'
      },
      strokeWidth: {
        required: false,
        default: 0
      },
      fillOpacity: {
        required: false
      },
      strokeOpacity: {
        required: false
      },
      opacity: {
        required: false,
        default: 1
      }
    };

    var polygonAesthetics = {
      x: {
        required: false
      },
      y: {
        required: false
      },
      geometry: {
        required: false
      },
      fill: {
        required: false,
        default: 'black'
      },
      stroke: {
        required: false,
        default: 'none'
      },
      strokeWidth: {
        required: false,
        default: 0
      },
      fillOpacity: {
        required: false
      },
      strokeOpacity: {
        required: false
      },
      opacity: {
        required: false,
        default: 1
      }
    };

    var lineAesthetics = {
      x: {
        required: false
      },
      y: {
        required: false
      },
      geometry: {
        required: false
      },
      strokeWidth: {
        required: false,
        default: 3
      },
      stroke: {
        required: false,
        default: 'black'
      },
      opacity: {
        required: false,
        default: 1
      }
    };

    var labelAesthetics = {
      x: {
        required: false
      },
      y: {
        required: false
      },
      geometry: {
        required: false
      },
      fill: {
        required: false,
        default: 'black'
      },
      stroke: {
        required: false,
        default: 'none'
      },
      strokeWidth: {
        required: false,
        default: 0
      },
      fillOpacity: {
        required: false
      },
      strokeOpacity: {
        required: false
      },
      opacity: {
        required: false,
        default: 1
      },
      text: {
        required: false
      },
      fontFamily: {
        required: false,
        default: 'Helvetica'
      },
      fontSize: {
        required: false,
        default: 16
      },
      fontWeight: {
        required: false,
        default: 'normal'
      },
      rotation: {
        required: false,
        default: 0
      },
      anchorPoint: {
        required: false,
        default: 'center'
      }
    };

    var areaAesthetics = {
      x1: {
        required: false
      },
      x2: {
        required: false
      },
      y1: {
        required: false
      },
      y2: {
        required: false
      },
      independentAxis: {
        required: false
      },
      fill: {
        required: false,
        default: 'black'
      },
      stroke: {
        required: false,
        default: 'none'
      },
      strokeWidth: {
        required: false,
        default: 0
      },
      strokeOpacity: {
        required: false
      },
      fillOpacity: {
        required: false
      },
      opacity: {
        required: false,
        default: 1
      }
    };

    function validateAesthetics (type, aesthetics) {
      if (type === 'Point') {
        return validateAesthetics$1(aesthetics, pointAesthetics)
      }

      if (type === 'Rectangle') {
        return validateAesthetics$1(aesthetics, rectangleAesthetics)
      }

      if (type === 'Polygon') {
        return validateAesthetics$1(aesthetics, polygonAesthetics)
      }

      if (type === 'Line') {
        return validateAesthetics$1(aesthetics, lineAesthetics)
      }

      if (type === 'Label') {
        return validateAesthetics$1(aesthetics, labelAesthetics)
      }

      if (type === 'Area') {
        return validateAesthetics$1(aesthetics, areaAesthetics)
      }
    }

    function validateAesthetics$1 (passedAesthetics, allowedAesthetics) {
      const aesthetics = {};

      for (const aestheticName in passedAesthetics) {
        const aestheticValue = passedAesthetics[aestheticName];
        const aestheticRequirements = allowedAesthetics[aestheticName];

        if (isDefined(aestheticValue)) {
          if (!(aestheticName in allowedAesthetics)) throw aestheticNotAllowedError(aestheticName)
          aesthetics[aestheticName] = aestheticValue;
        }

        if (isUndefined(aestheticValue)) {
          if (aestheticName in allowedAesthetics) {
            if (aestheticRequirements.required) throw aestheticRequiredError(aestheticName)
            if (isDefined(aestheticRequirements.default)) {
              aesthetics[aestheticName] = aestheticRequirements.default;
            } else {
              aesthetics[aestheticName] = aestheticValue;
            }
          }
        }
      }

      return aesthetics
    }

    const aestheticNotAllowedError = name => {
      return new Error(`Aesthetic '${name}' not allowed`)
    };

    const aestheticRequiredError = name => {
      return new Error(`Required aesthetic '${name}' is missing`)
    };

    function createCoordSysGeometryPoint (geometryProps, sectionContext, coordinateTransformationContext) {
      const scaledGeometry = createScaledGeometry$1(geometryProps, sectionContext);
      const coordSysGeometry = createCoordSysGeometry(scaledGeometry, coordinateTransformationContext);

      return coordSysGeometry
    }

    function createScaledGeometry$1 (geometryProps, sectionContext) {
      ensureValidCombination$1(geometryProps);

      if (isDefined(geometryProps.geometry)) {
        return scaleGeometryProp(geometryProps.geometry, sectionContext)
      }

      if (isUndefined(geometryProps.geometry)) {
        return createScaledGeometryFromCoordinates(geometryProps.x, geometryProps.y, sectionContext)
      }
    }

    function ensureValidCombination$1 (geometryProps) {
      if (isDefined(geometryProps.geometry)) {
        if (isDefined(geometryProps.x) || isDefined(geometryProps.y)) throw invalidCombinationError
      } else {
        if (!(isDefined(geometryProps.x) && isDefined(geometryProps.y))) throw invalidCombinationError
      }
    }

    const invalidCombinationError = new Error('Point: invalid combination of props \'x\', \'y\' and \'geometry\'');

    function scaleGeometryProp (geometry, sectionContext) {
      if (geometry.constructor === Function) {
        return geometry(sectionContext)
      } else {
        return scaleGeometry(geometry, sectionContext)
      }
    }

    function createScaledGeometryFromCoordinates (x, y, sectionContext) {
      const { scaleX, scaleY } = sectionContext;

      const scaledX = x.constructor === Function ? x(sectionContext) : scaleX(x);
      const scaledY = y.constructor === Function ? y(sectionContext) : scaleY(y);

      return {
        type: 'Point',
        coordinates: [scaledX, scaledY]
      }
    }

    function getNumberOfMarks (x, y, markType) {
      if (x.constructor !== Array && y.constructor !== Array) {
        throw new Error(`${markType}Layer: at least 'x' or 'y' must evaluate to an Array`)
      }

      const length = x.constructor === Array ? x.length : y.length;

      if (x.constructor === Array && y.constructor === Array) {
        if (x.length !== length || y.length !== length) {
          throw new Error(`${markType}Layer: 'x' and 'y' have different lengths`)
        }
      }

      return length
    }

    function createScaledGeometryFromXYProps (x, y, scales, markType) {
      const scaledX = getValueX(x, scales, markType);
      const scaledY = getValueY(y, scales, markType);

      return createGeometryFromScaledProps(scaledX, scaledY, markType)
    }

    function makeValueGetter (scaleName) {
      return function getValue (coordinateProp, scales) {
        const scale = scales[scaleName];

        if (coordinateProp.constructor === Function) {
          return handleFunctionProp(coordinateProp, scales)
        } else {
          return handleOtherProp(coordinateProp, scale)
        }
      }
    }

    const getValueX = makeValueGetter('scaleX');
    const getValueY = makeValueGetter('scaleY');

    function handleFunctionProp (coordinateProp, scales, markType) {
      const value = coordinateProp(scales);
      if (value.constructor === Array) return value

      throw noArrayError(markType)
    }

    function handleOtherProp (coordinateProp, scale, markType) {
      if (coordinateProp.constructor === Array) return coordinateProp.map(scale)

      throw noArrayError(markType)
    }

    const noArrayError = markType => new Error(`${markType}: 'x' and 'y' must evaluate to an Array`);

    function createGeometryFromScaledProps (x, y, markType) {
      ensureCorrectLength(x, y, markType);

      const coordinates = [];

      for (let i = 0; i < x.length; i++) {
        coordinates.push([x[i], y[i]]);
      }

      if (markType === 'Polygon') {
        return createPolygon(coordinates)
      }

      if (markType === 'Line') {
        return createLineString(coordinates)
      }
    }

    function ensureCorrectLength (x, y, markType) {
      if (x.length !== y.length) throw notSameLengthError(markType)
      if (markType === 'Polygon' && x.length < 3) throw notEnoughPointsError(markType, 3)
      if (markType === 'Line' && x.length < 2) throw notEnoughPointsError(markType, 2)
    }

    const notSameLengthError = markType => new Error(`${markType}: 'x' and 'y' must have same length`);
    const notEnoughPointsError = (markType, numberOfPoints) => {
      return new Error(`${markType}: must consist of at least ${numberOfPoints} points`)
    };

    function createPolygon (coordinates) {
      // To adhere to the GeoJSON spec, outer rings must always be closed
      if (isNotClosed(coordinates)) {
        const firstPosition = coordinates[0];
        coordinates.push([firstPosition[0], firstPosition[1]]);
      }

      // To adhere to the GeoJSON spec, outer rings must always be counter-clockwise
      if (linearRingIsClockwise(coordinates)) {
        coordinates.reverse();
      }

      return {
        type: 'Polygon',
        coordinates: [coordinates]
      }
    }

    function createLineString (coordinates) {
      return {
        type: 'LineString',
        coordinates
      }
    }

    function isNotClosed (ring) {
      const first = ring[0];
      const last = ring[ring.length - 1];

      return first[0] !== last[0] || first[1] !== last[1]
    }

    function ensureValidCombination$2 (geometryProps, markType) {
      if (isDefined(geometryProps.geometry)) {
        if (isDefined(geometryProps.x) || isDefined(geometryProps.y)) throw invalidCombinationError$1(markType)
      } else {
        if (!(isDefined(geometryProps.x) && isDefined(geometryProps.y))) throw invalidCombinationError$1(markType)
      }
    }

    const invalidCombinationError$1 = mark => new Error(`${mark}: Invalid combination of 'x', 'y', and 'geometry' props`);

    function createScaledGeometryArrayFromXYProps (x, y, scales, markType) {
      const { scaleX, scaleY } = scales;

      const xNeedsScaling = x.constructor !== Function;
      const yNeedsScaling = y.constructor !== Function;

      const xValues = xNeedsScaling ? x : x(scales);
      const yValues = yNeedsScaling ? y : y(scales);

      const length = getNumberOfMarks(xValues, yValues, markType);

      const scaledGeometryArray = [];

      for (let i = 0; i < xValues.length; i++) {
        const scaledX = xNeedsScaling ? x[i].map(scaleX) : xValues[i];
        const scaledY = yNeedsScaling ? y[i].map(scaleY) : yValues[i];

        const scaledGeometry = createGeometryFromScaledProps(scaledX, scaledY, markType);
        scaledGeometryArray.push(scaledGeometry);
      }

      return { scaledGeometryArray, length }
    }

    function createCoordSysGeometryPolygon (
      geometryProps, sectionContext, coordinateTransformationContext, interpolate
    ) {
      const scaledGeometry = createScaledGeometry$2(geometryProps, sectionContext);
      const coordSysGeometry = createCoordSysGeometry(scaledGeometry, coordinateTransformationContext, interpolate);

      return coordSysGeometry
    }

    function createScaledGeometry$2 (geometryProps, sectionContext) {
      ensureValidCombination$2(geometryProps, 'Polygon');

      if (isDefined(geometryProps.geometry)) {
        if (geometryProps.geometry.constructor === Function) {
          return geometryProps.geometry(sectionContext)
        } else {
          return scaleGeometry(geometryProps.geometry, sectionContext)
        }
      }

      if (isUndefined(geometryProps.geometry)) {
        return createScaledGeometryFromXYProps(geometryProps.x, geometryProps.y, sectionContext, 'Polygon')
      }
    }

    function createCoordSysGeometryLine (geometryProps, sectionContext, coordinateTransformationContext) {
      const scaledGeometry = createScaledGeometry$3(geometryProps, sectionContext);
      const coordSysGeometry = createCoordSysGeometry(scaledGeometry, coordinateTransformationContext);

      return coordSysGeometry
    }

    function createScaledGeometry$3 (geometryProps, sectionContext) {
      ensureValidCombination$2(geometryProps, 'Line');
      if (isDefined(geometryProps.geometry)) {
        if (geometryProps.geometry.constructor === Function) {
          return geometryProps.geometry(sectionContext)
        } else {
          return scaleGeometry(geometryProps.geometry, sectionContext)
        }
      }

      if (isUndefined(geometryProps.geometry)) {
        return createScaledGeometryFromXYProps(geometryProps.x, geometryProps.y, sectionContext, 'Line')
      }
    }

    function createCoordSysGeometryArea (positioningProps, sectionContext, coordinateTransformationContext, interpolate) {
      // filter for allowed props; leave any undefined props in place
      const allowedProps =
        (({
          x1 = undefined,
          y1 = undefined,
          x2 = undefined,
          y2 = undefined,
          independentAxis = undefined
        }) => ({ x1, y1, x2, y2, independentAxis }))(positioningProps);

      const coordSysGeometry =
        createCoordSysGeometry(
          createScaledGeometry$4(
            scaleCoordinates$1(
              augmentProps(
                validateProps(allowedProps)),
              sectionContext)),
          coordinateTransformationContext,
          interpolate);

      return coordSysGeometry
    }

    function validateProps (allowedProps) {
      // validate only defined coordinate props
      const definedProps = {};
      for (const [key, value] of Object.entries(allowedProps)) {
        if (value !== undefined) {
          definedProps[key] = value;
        }
      }

      const definedKeys = Object.keys(definedProps);

      // reject if props do not include x1 and y1
      const containsx1y1 = ['x1', 'y1'].every(prop => definedKeys.includes(prop));
      if (!containsx1y1) { throw new Error('At least x1 and y1 must be provided') }

      // reject if at least one of x1 or y1 is not an array
      // assumes containsx1y1 check passes
      if (!(Array.isArray(definedProps.x1) || Array.isArray(definedProps.y1))) {
        throw new Error('At least x1 or y1 must be passed an array')
      }

      // reject if independentAxis does not align with x/y types
      const independentAxis = definedProps.independentAxis &&
            definedProps.independentAxis.toLowerCase();

      if (!independentAxis || independentAxis === 'x') {
        // check that x is the independent variable
        // reject if x1 is not given an array; x cannot be a constant and hence cannot be broadcasted
        if (!Array.isArray(definedProps.x1)) {
          throw new Error('x1 must be passed an array when independentAxis is "x" or undefined')
        }
        // reject if x1, y1 and x2 are provided but independentAxis is not y
        if (definedKeys.includes('x2')) {
          throw new Error('independentAxis must be "y" when x1, y1 and x2 are specified')
        }
      } else if (independentAxis === 'y') {
        // check that y is the independent variable
        // reject if y1 is not given an array; y cannot be a constant and hence cannot be broadcasted
        if (!Array.isArray(definedProps.y1)) {
          throw new Error('y1 must be passed an array when independentAxis is "y"')
        }
        // reject if x1, y1 and y2 are provided but independentAxis is not x
        if (definedKeys.includes('y2')) {
          throw new Error('independentAxis must be "x" when x1, y1 and y2 are specified')
        }
      } else {
        // reject if defined independentAxis is passed a value other than X or Y
        throw new Error('independentAxis must be passed "x" or "y" or left blank')
      }

      // reject if arrays given are not of equal length
      const arrayProps = Object.values(definedProps).filter(v => Array.isArray(v));

      const arrayLengths = Object.values(arrayProps).reduce((accum, elem) => {
        accum.push(elem.length);
        return accum
      }, []);

      const arrayLengthsEqual = arrayLengths.every((val, idx, arr) => val === arr[0]);
      if (!arrayLengthsEqual) { throw new Error('Arrays given must be of equal length') }

      return allowedProps
    }

    function augmentProps (allowedProps) {
      let { x1, y1, x2, y2, independentAxis } = allowedProps;
      independentAxis = independentAxis && independentAxis.toLowerCase();

      // undefined independentAxis defaults to x
      if (!independentAxis || independentAxis === 'x') {
        // if y1 is not an array, broadcast its value
        if (!Array.isArray(y1)) { y1 = Array(x1.length).fill(y1); }
        if (y2 === undefined) { y2 = Array(x1.length).fill(0); }
        // if all 4 props are provided, x2 is ignored
        return { coordinates: { x1: x1, y1: y1, y2: y2 }, independentAxis: 'x' }
      } else if (independentAxis === 'y') {
        // if x1 is not an array, broadcast its value
        if (!Array.isArray(x1)) { x1 = Array(y1.length).fill(x1); }
        if (x2 === undefined) { x2 = Array(y1.length).fill(0); }
        // if all 4 props are provided, y2 is ignored
        return { coordinates: { x1: x1, y1: y1, x2: x2 }, independentAxis: 'y' }
      }
    }

    const scaleMap = { x1: 'scaleX', y1: 'scaleY', x2: 'scaleX', y2: 'scaleY' };

    function scaleCoordinates$1 (augmentedProps, sectionContext) {
      const coordinateProps = augmentedProps.coordinates;

      const scaledProps = {};

      const propKeys = Object.keys(coordinateProps);

      for (const prop of propKeys) {
        const scale = sectionContext[scaleMap[prop]];
        const scaledValues = coordinateProps[prop].map(v => scale(v));
        scaledProps[prop] = scaledValues;
      }
      return scaledProps
    }

    function createScaledGeometry$4 (scaledProps) {
      // polygon outer ring is defined counterclockwise

      const propKeys = Object.keys(scaledProps);
      let bottomPoints, topPoints;

      if (propKeys.includes('y2')) { // x independent
        bottomPoints = scaledProps.y2.map((y2, i) => [scaledProps.x1[i], y2]);
        topPoints = scaledProps.y1.map((y1, i) => [scaledProps.x1[i], y1]).reverse();
      } else { // y independent
        bottomPoints = scaledProps.x2.map((x2, i) => [x2, scaledProps.y1[i]]);
        topPoints = scaledProps.x1.map((x1, i) => [x1, scaledProps.y1[i]]).reverse();
      }
      const origin = [bottomPoints[0]];
      const allPoints = [bottomPoints.concat(topPoints, origin)];

      const scaledGeometryArray = { type: 'Polygon', coordinates: allPoints };
      return scaledGeometryArray
    }

    function generateArrayOfLength (value, length) {
      return new Array(length).fill(value)
    }

    function getKeyArray (keyProp, length) {
      if (keyProp) {
        if (keyProp.constructor !== Array) throw new Error('key must be Array')
        if (keyProp.length !== length) throw new Error('key must be of same length as positioning props')

        return keyProp
      } else {
        return new Array(length).fill(0).map((_, i) => i)
      }
    }

    function createCoordSysGeometryObjectPoint (geometryProps, sectionContext, coordinateTransformationContext, keyProp) {
      const { scaledGeometryArray, length } = createScaledGeometryArray(geometryProps, sectionContext);
      const keyArray = getKeyArray(keyProp, length);
      const coordSysGeometryObject = createCoordSysGeometryObject(
        scaledGeometryArray, coordinateTransformationContext, keyArray
      );

      return coordSysGeometryObject
    }

    function createScaledGeometryArray (geometryProps, sectionContext) {
      ensureValidCombination$1(geometryProps);

      if (isDefined(geometryProps.geometry)) {
        return scaleGeometryProp$1(geometryProps.geometry, sectionContext)
      }

      if (isUndefined(geometryProps.geometry)) {
        return createScaledGeometryArrayFromCoordinates(
          geometryProps.x, geometryProps.y, sectionContext
        )
      }
    }

    function scaleGeometryProp$1 (geometry, sectionContext) {
      let scaledGeometryArray;

      if (geometry.constructor === Function) {
        scaledGeometryArray = geometry(sectionContext);
      } else {
        scaledGeometryArray = scaleGeometries(geometry, sectionContext);
      }

      const length = scaledGeometryArray.length;
      return { scaledGeometryArray, length }
    }

    function createScaledGeometryArrayFromCoordinates (x, y, sectionContext) {
      const xNeedsScaling = x.constructor !== Function;
      const yNeedsScaling = y.constructor !== Function;

      const xValue = x.constructor === Function ? x(sectionContext) : x;
      const yValue = y.constructor === Function ? y(sectionContext) : y;

      const length = getNumberOfMarks(xValue, yValue, 'Point');

      const xIsPrimitive = xValue.constructor !== Array;
      const yIsPrimitive = yValue.constructor !== Array;

      const scaledX = scaleCoordinate$1(xValue, sectionContext.scaleX, xNeedsScaling, xIsPrimitive, length);
      const scaledY = scaleCoordinate$1(yValue, sectionContext.scaleY, yNeedsScaling, yIsPrimitive, length);

      const scaledGeometryArray = createGeometryArrayFromScaledCoordinates(scaledX, scaledY, length);

      return { scaledGeometryArray, length }
    }

    function scaleCoordinate$1 (c, scale, needsScaling, isPrimitive, length) {
      let array;

      if (isPrimitive) array = generateArrayOfLength(c, length);
      if (!isPrimitive) array = c;

      if (needsScaling) return array.map(scale)
      if (!needsScaling) return array
    }

    function createGeometryArrayFromScaledCoordinates (scaledX, scaledY, length) {
      const geometryArray = [];

      for (let i = 0; i < length; i++) {
        geometryArray.push({
          type: 'Point',
          coordinates: [scaledX[i], scaledY[i]]
        });
      }

      return geometryArray
    }

    function createCoordSysGeometryObjectRectangle (
      coordinateProps, sectionContext, coordinateTransformationContext, keyProp, interpolate
    ) {
      const { scaledCoordinates, length } = scaleCoordinates$2(coordinateProps, sectionContext);
      const keyArray = getKeyArray(keyProp, length);
      const scaledGeometryArray = createScaledGeometryArray$1(scaledCoordinates, length);
      const coordSysGeometryObject = createCoordSysGeometryObject(
        scaledGeometryArray, coordinateTransformationContext, keyArray, interpolate
      );

      return coordSysGeometryObject
    }

    function scaleCoordinates$2 (coordinateProps, sectionContext) {
      ensureValidCombination(coordinateProps);

      const coordinatesThatNeedScaling = whichCoordinatesNeedScaling(coordinateProps);

      const nonMissingCoordinates = getMissingCoordinatesFromContext(coordinateProps, sectionContext);
      const coordinateValues = getCoordinateValues(nonMissingCoordinates, sectionContext);

      const length = getNRectangles(coordinateValues);

      const coordinatesThatArePrimitive = whichCoordinatesArePrimitive(coordinateValues);

      const scaledCoordinates = _scaleCoordinates(
        coordinateValues,
        sectionContext,
        coordinatesThatNeedScaling,
        coordinatesThatArePrimitive,
        length
      );

      return { scaledCoordinates, length }
    }

    const coordinateNames = ['x1', 'x2', 'y1', 'y2'];

    function whichCoordinatesNeedScaling (coordinates) {
      const coordinatesThatNeedScaling = {};

      for (const coordinateName of coordinateNames) {
        const coordinateValue = coordinates[coordinateName];
        coordinatesThatNeedScaling[coordinateName] = isDefined(coordinateValue) && coordinateValue.constructor !== Function;
      }

      return coordinatesThatNeedScaling
    }

    function getMissingCoordinatesFromContext (coordinates, sectionContext) {
      const nonMissingCoordinates = {};

      for (const coordinateName of coordinateNames) {
        const coordinateValue = coordinates[coordinateName];
        nonMissingCoordinates[coordinateName] = isUndefined(coordinateValue)
          ? getMissingCoordinateFromContext(coordinateName, sectionContext)
          : coordinateValue;
      }

      return nonMissingCoordinates
    }

    const coordMap = { x1: 'minX', x2: 'maxX', y1: 'minY', y2: 'maxY' };

    function getMissingCoordinateFromContext (coordinateName, sectionContext) {
      return sectionContext[coordMap[coordinateName]]
    }

    function getCoordinateValues (nonMissingCoordinates, sectionContext) {
      const coordinateValues = {};

      for (const coordinateName in nonMissingCoordinates) {
        const coordinateValue = nonMissingCoordinates[coordinateName];
        if (coordinateValue.constructor === Function) {
          coordinateValues[coordinateName] = coordinateValue(sectionContext);
        } else {
          coordinateValues[coordinateName] = coordinateValue;
        }
      }

      return coordinateValues
    }

    const invalidCoordinateError = new Error('RectangleLayer: invalid coordinate specification');

    function getNRectangles (coordinateValues) {
      let atLeastOneArray = false;
      let length;

      for (const coordinateName in coordinateValues) {
        const coordinateValue = coordinateValues[coordinateName];

        if (coordinateValue.constructor === Array) {
          atLeastOneArray = true;
          length = length || coordinateValue.length;

          if (length !== coordinateValue.length) throw invalidCoordinateError
        }
      }

      if (!atLeastOneArray) throw invalidCoordinateError

      return length
    }

    function whichCoordinatesArePrimitive (coordinateValues) {
      const coordinatesThatArePrimitive = {};

      for (const coordinateName in coordinateValues) {
        const coordinateValue = coordinateValues[coordinateName];

        coordinatesThatArePrimitive[coordinateName] = coordinateValue.constructor !== Array;
      }

      return coordinatesThatArePrimitive
    }

    function _scaleCoordinates (
      coordinateValues, scales, coordinatesThatNeedScaling, coordinatesThatArePrimitive, length
    ) {
      const scaledCoordinates = {};

      for (const coordinateName in coordinateValues) {
        const coordinateValue = coordinateValues[coordinateName];
        let array;
        const scale = coordinateName.startsWith('x') ? scales.scaleX : scales.scaleY;

        if (coordinatesThatArePrimitive[coordinateName]) array = generateArrayOfLength(coordinateValue, length);
        if (!coordinatesThatArePrimitive[coordinateName]) array = coordinateValue;

        scaledCoordinates[coordinateName] = coordinatesThatNeedScaling[coordinateName]
          ? array.map(scale)
          : array;
      }

      return scaledCoordinates
    }

    function createScaledGeometryArray$1 (scaledCoordinates, length) {
      const scaledGeometryArray = [];

      for (let i = 0; i < length; i++) {
        scaledGeometryArray.push(
          createScaledGeometry({
            x1: scaledCoordinates.x1[i],
            x2: scaledCoordinates.x2[i],
            y1: scaledCoordinates.y1[i],
            y2: scaledCoordinates.y2[i]
          })
        );
      }

      return scaledGeometryArray
    }

    function createCoordSysGeometryObjectPolygon (
      geometryProps, sectionContext, coordinateTransformationContext, keyProp, interpolate
    ) {
      const { scaledGeometryArray, length } = createScaledGeometryArray$2(geometryProps, sectionContext);
      const keyArray = getKeyArray(keyProp, length);
      const coordSysGeometryObject = createCoordSysGeometryObject(
        scaledGeometryArray, coordinateTransformationContext, keyArray, interpolate
      );

      return coordSysGeometryObject
    }

    function createScaledGeometryArray$2 (geometryProps, sectionContext) {
      ensureValidCombination$2(geometryProps);

      if (isDefined(geometryProps.geometry)) {
        if (geometryProps.geometry.constructor === Function) {
          return geometryProps.geometry(sectionContext)
        } else {
          return scaleGeometryProp$2(geometryProps.geometry, sectionContext)
        }
      }

      if (isUndefined(geometryProps.geometry)) {
        return createScaledGeometryArrayFromXYProps(
          geometryProps.x, geometryProps.y, sectionContext, 'Polygon'
        )
      }
    }

    function scaleGeometryProp$2 (geometry, scales) {
      const scaledGeometryArray = scaleGeometries(geometry, scales);
      const length = scaledGeometryArray.length;

      return { scaledGeometryArray, length }
    }

    function createCoordSysGeometryObjectLine (
      geometryProps, sectionContext, coordinateTransformationContext, keyProp, interpolate
    ) {
      const { scaledGeometryArray, length } = createScaledGeometryArray$3(geometryProps, sectionContext);
      const keyArray = getKeyArray(keyProp, length);
      const coordSysGeometryObject = createCoordSysGeometryObject(
        scaledGeometryArray, coordinateTransformationContext, keyArray, interpolate
      );

      return coordSysGeometryObject
    }

    function createScaledGeometryArray$3 (geometryProps, sectionContext) {
      ensureValidCombination$2(geometryProps);
      if (isDefined(geometryProps.geometry)) {
        if (geometryProps.geometry.constructor === Function) {
          return geometryProps.geometry(sectionContext)
        } else {
          return scaleGeometryProp$3(geometryProps.geometry, sectionContext)
        }
      }

      if (isUndefined(geometryProps.geometry)) {
        return createScaledGeometryArrayFromXYProps(
          geometryProps.x, geometryProps.y, sectionContext, 'Line'
        )
      }
    }

    function scaleGeometryProp$3 (geometry, scales) {
      const scaledGeometryArray = scaleGeometries(geometry, scales);
      const length = scaledGeometryArray.length;

      return { scaledGeometryArray, length }
    }

    function createCoordSysGeometryObjectArea (positioningProps, sectionContext, coordinateTransformationContext, keyProp, interpolate) {
      // filter for allowed props; leave any undefined props in place
      const allowedProps =
        (({
          x1 = undefined,
          y1 = undefined,
          x2 = undefined,
          y2 = undefined,
          independentAxis = undefined
        }) => ({ x1, y1, x2, y2, independentAxis }))(positioningProps);

      const { validatedProps, numAreas } = validateNumAreas(allowedProps);

      // pivot data for use with area mark methods
      const validatedPropArray = [...Array(numAreas).keys()].map(areaIndex => {
        return {
          x1: validatedProps.x1 && validatedProps.x1[areaIndex],
          y1: validatedProps.y1 && validatedProps.y1[areaIndex],
          x2: validatedProps.x2 && validatedProps.x2[areaIndex],
          y2: validatedProps.y2 && validatedProps.y2[areaIndex],
          independentAxis: validatedProps.independentAxis
        }
      });

      const scaledGeometryArray = validatedPropArray.map(area => {
        return createScaledGeometry$4(
          scaleCoordinates$1(
            augmentProps(
              validateProps(area)),
            sectionContext))
      });

      const keyArray = getKeyArray(keyProp, numAreas);

      const coordSysGeometryObject =
        createCoordSysGeometryObject(
          scaledGeometryArray,
          coordinateTransformationContext,
          keyArray,
          interpolate);

      return coordSysGeometryObject
    }

    function validateNumAreas (allowedProps) {
      const propsWithArray = Object.values(allowedProps).filter(v => Array.isArray(v));

      const numAreasAll = Object.values(propsWithArray).reduce((accum, elem) => {
        accum.push(elem.length);
        return accum
      }, []);

      const numAreasEqual = numAreasAll.every((val, idx, arr) => val === arr[0]);
      let numAreas;
      if (!numAreasEqual) {
        throw new Error('Number of areas declared per prop must be equal')
      } else { numAreas = numAreasAll[0]; }

      return { validatedProps: allowedProps, numAreas: numAreas }
    }

    const markCoordSysGeometryFuncs = new Proxy({
      Point: createCoordSysGeometryPoint,
      Rectangle: createCoordSysGeometryRectangle,
      Polygon: createCoordSysGeometryPolygon,
      Line: createCoordSysGeometryLine,
      Label: createCoordSysGeometryPoint,
      Area: createCoordSysGeometryArea
    }, {
      get: (obj, prop) => {
        if (prop in obj) {
          return obj[prop]
        } else {
          throw new Error(`Invalid Mark type: '${prop}'`)
        }
      }
    });

    const layerCoordSysGeometryFuncs = new Proxy({
      Point: createCoordSysGeometryObjectPoint,
      Rectangle: createCoordSysGeometryObjectRectangle,
      Polygon: createCoordSysGeometryObjectPolygon,
      Line: createCoordSysGeometryObjectLine,
      Label: createCoordSysGeometryObjectPoint,
      Area: createCoordSysGeometryObjectArea
    }, {
      get: (obj, prop) => {
        if (prop in obj) {
          return obj[prop]
        } else {
          throw new Error(`Invalid Layer type: '${prop}'`)
        }
      }
    });

    // https://stackoverflow.com/a/155678/7237112
    function representPointAsPolygon (point, { radius }) {
      const x = point.coordinates[0];
      const y = point.coordinates[1];

      const circumference = Math.PI * 2 * radius;
      const steps = Math.max(Math.ceil(circumference), 9);

      const polygon = {
        type: 'Polygon',
        coordinates: [[]]
      };

      for (let i = 0; i < steps; i++) {
        polygon.coordinates[0].push(
          [
            x + radius * Math.cos(Math.PI * i / steps * 2 - Math.PI / 2),
            y + radius * Math.sin(Math.PI * i / steps * 2 - Math.PI / 2)
          ]
        );
      }

      // close polygon
      polygon.coordinates[0].push(polygon.coordinates[0][0]);

      return polygon
    }

    function representPointsAsPolygons (points, { radiusObject }) {
      const polygons = {};

      for (const key in points) {
        polygons[key] = representPointAsPolygon(points[key], { radius: radiusObject[key] });
      }

      return polygons
    }

    function representLineAsPolygon (lineString, { strokeWidth }) {
      const lineCoordinates = lineString.coordinates;

      if (lineString.type === 'LineString') {
        const outerRing = createOuterRing(lineCoordinates, strokeWidth);

        return {
          type: 'Polygon',
          coordinates: [outerRing]
        }
      }

      if (lineString.type === 'MultiLineString') {
        const polygons = [];

        for (let i = 0; i < lineCoordinates.length; i++) {
          polygons.push(
            [createOuterRing(lineCoordinates[i], strokeWidth)]
          );
        }

        return {
          type: 'MultiPolygon',
          coordinates: polygons
        }
      }
    }

    function createOuterRing (lineCoordinates, strokeWidth) {
      const length = lineCoordinates.length;
      const lastIndex = length - 1;
      const distance = strokeWidth / 2;

      const coordinatesBottom = new Array(length);
      const coordinatesTop = new Array(length);

      for (let i = 0; i < length; i++) {
        if (i === 0) {
          const [bottomPoint, topPoint] = getCornerPointsStart(lineCoordinates, distance);
          coordinatesBottom[0] = bottomPoint;
          coordinatesTop[lastIndex] = topPoint;
        }

        if (i === lastIndex) {
          const [bottomPoint, topPoint] = getCornerPointsEnd(lineCoordinates, distance);
          coordinatesBottom[lastIndex] = bottomPoint;
          coordinatesTop[0] = topPoint;
        }

        if (i > 0 && i < lastIndex) {
          const [bottomPoint, topPoint] = getCornerPointsIndex(lineCoordinates, i, distance);
          coordinatesBottom[i] = bottomPoint;
          coordinatesTop[lastIndex - i] = topPoint;
        }
      }

      const outerRing = coordinatesBottom.concat(coordinatesTop);

      // Close ring if necessary
      if (ringIsNotClosed(outerRing)) {
        outerRing.push(outerRing[0]);
      }

      return outerRing
    }

    function representLinesAsPolygons (lines, { strokeWidthObject }) {
      const polygons = {};

      for (const key in lines) {
        polygons[key] = representLineAsPolygon(lines[key], { strokeWidth: strokeWidthObject[key] });
      }

      return polygons
    }

    function getCornerPointsStart (lineCoordinates, distance) {
      const segment = getNextSegment(0, lineCoordinates);
      const cornerPoint = segment[0];

      return getParallelPoints(segment, cornerPoint, distance)
    }

    function getCornerPointsEnd (lineCoordinates, distance) {
      const segment = getPreviousSegment(lineCoordinates.length - 1, lineCoordinates);
      const cornerPoint = segment[1];

      return getParallelPoints(segment, cornerPoint, distance)
    }

    function getCornerPointsIndex (lineCoordinates, index, distance) {
      const previousSegment = getPreviousSegment(index, lineCoordinates);
      const nextSegment = getNextSegment(index, lineCoordinates);

      const previousUnitVector = getUnitVector(previousSegment);
      const nextUnitVector = getUnitVector(nextSegment);

      if (previousUnitVector[0] === nextUnitVector[0] && previousUnitVector[1] === nextUnitVector[1]) {
        // unit vectors are the same, we can just use the existing line point

        const currentCornerPerpendicularPoints = getParallelPoints(
          previousSegment, previousSegment[1], distance
        );

        return currentCornerPerpendicularPoints
      } else {
        const previousCornerPerpendicularPoints = getParallelPoints(
          previousSegment, previousSegment[0], distance
        );
        const nextCornerPerpendicularPoints = getParallelPoints(
          nextSegment, nextSegment[1], distance
        );

        const bottomPoint = findIntersection(
          previousCornerPerpendicularPoints[0],
          previousUnitVector,
          nextCornerPerpendicularPoints[0],
          nextUnitVector
        );
        const topPoint = findIntersection(
          previousCornerPerpendicularPoints[1],
          previousUnitVector,
          nextCornerPerpendicularPoints[1],
          nextUnitVector
        );

        return [bottomPoint, topPoint]
      }
    }

    const getPreviousSegment = (i, coordinates) => [coordinates[i - 1], coordinates[i]];
    const getNextSegment = (i, coordinates) => [coordinates[i], coordinates[i + 1]];

    function getUnitVector (segment) {
      const [a, b] = segment;

      const magnitude = pointDistance(a, b);
      const dx = b[0] - a[0];
      const dy = b[1] - a[1];

      return [dx / magnitude, dy / magnitude]
    }

    const getNormalVector = vector => [-vector[1], vector[0]];

    function movePoint (point, unitVector, distance) {
      return [
        point[0] + unitVector[0] * distance,
        point[1] + unitVector[1] * distance
      ]
    }

    function getParallelPoints (segment, point, distance) {
      const unitVector = getUnitVector(segment);
      const normalVector = getNormalVector(unitVector);

      const bottomPoint = movePoint(point, normalVector, distance);
      const topPoint = movePoint(point, normalVector, -distance);

      return [bottomPoint, topPoint]
    }

    function findIntersection (point1, vector1, point2, vector2) {
      const lambda1 = findLambda(point1, vector1, point2, vector2);
      return [
        point1[0] + (vector1[0] * lambda1),
        point1[1] + (vector1[1] * lambda1)
      ]
    }

    function findLambda (p1, v1, p2, v2) {
      const deltaX = p1[0] - p2[0];
      const deltaY = p1[1] - p2[1];
      const v1x = v1[0];
      const v2x = v2[0];
      const v1y = v1[1];
      const v2y = v2[1];

      const lambda1 = ((v2x * deltaY) - (deltaX * v2y)) /
        ((v1x * v2y) - (v2x * v1y));
      return lambda1
    }

    function ringIsNotClosed (ring) {
      const first = ring[0];
      const last = ring[ring.length - 1];

      const closed = first[0] === last[0] && first[1] === last[1];

      return !closed
    }

    const markRepresentAsPolygonFuncs = new Proxy({
      Point: representPointAsPolygon,
      Line: representLineAsPolygon
    }, {
      get: (obj, prop) => {
        if (prop in obj) {
          return obj[prop]
        } else {
          return _ => _
        }
      }
    });

    const layerRepresentAsPolygonFuncs = new Proxy({
      Point: representPointsAsPolygons,
      Line: representLinesAsPolygons
    }, {
      get: (obj, prop) => {
        if (prop in obj) {
          return obj[prop]
        } else {
          return _ => _
        }
      }
    });

    function createDataNecessaryForIndexingMark (type, markId, geometryTypes, aesthetics) {
      const markData = { markId };
      let attributes;

      if (type === 'Point') {
        attributes = {
          pixelGeometry: geometryTypes.pixelGeometry,
          radius: aesthetics.radius
        };
      }

      if (type === 'Label') {
        attributes = {
          pixelGeometry: geometryTypes.pixelGeometry,
          radius: aesthetics.fontSize
        };
      }

      if (type === 'Rectangle') {
        attributes = { screenGeometry: geometryTypes.screenGeometry };
      }

      if (type === 'Polygon') {
        attributes = { screenGeometry: geometryTypes.screenGeometry };
      }

      if (type === 'Line') {
        attributes = {
          pixelGeometry: geometryTypes.pixelGeometry,
          strokeWidth: aesthetics.strokeWidth
        };
      }

      if (type === 'Area') {
        attributes = { screenGeometry: geometryTypes.screenGeometry };
      }

      markData.attributes = attributes;

      return markData
    }

    function createDataNecessaryForIndexingLayer (
      type, layerId, keyArray, geometryObjects, aestheticsObjects
    ) {
      const layerData = { layerId, keyArray };
      let layerAttributes;

      if (type === 'Point') {
        layerAttributes = {
          pixelGeometryObject: geometryObjects.pixelGeometryObject,
          radiusObject: aestheticsObjects.radiusObject
        };
      }

      if (type === 'Label') {
        layerAttributes = {
          pixelGeometryObject: geometryObjects.pixelGeometryObject,
          radiusObject: aestheticsObjects.fontSizeObject
        };
      }

      if (type === 'Rectangle') {
        layerAttributes = { screenGeometryObject: geometryObjects.screenGeometryObject };
      }

      if (type === 'Polygon') {
        layerAttributes = { screenGeometryObject: geometryObjects.screenGeometryObject };
      }

      if (type === 'Line') {
        layerAttributes = {
          pixelGeometryObject: geometryObjects.pixelGeometryObject,
          strokeWidthObject: aestheticsObjects.strokeWidthObject
        };
      }

      if (type === 'Area') {
        layerAttributes = { screenGeometryObject: geometryObjects.screenGeometryObject };
      }

      layerData.layerAttributes = layerAttributes;

      return layerData
    }

    function cubicOut(t) {
        const f = t - 1.0;
        return f * f * f + 1.0;
    }

    function is_date(obj) {
        return Object.prototype.toString.call(obj) === '[object Date]';
    }

    function get_interpolator(a, b) {
        if (a === b || a !== a)
            return () => a;
        const type = typeof a;
        if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
            throw new Error('Cannot interpolate values of different type');
        }
        if (Array.isArray(a)) {
            const arr = b.map((bi, i) => {
                return get_interpolator(a[i], bi);
            });
            return t => arr.map(fn => fn(t));
        }
        if (type === 'object') {
            if (!a || !b)
                throw new Error('Object cannot be null');
            if (is_date(a) && is_date(b)) {
                a = a.getTime();
                b = b.getTime();
                const delta = b - a;
                return t => new Date(a + t * delta);
            }
            const keys = Object.keys(b);
            const interpolators = {};
            keys.forEach(key => {
                interpolators[key] = get_interpolator(a[key], b[key]);
            });
            return t => {
                const result = {};
                keys.forEach(key => {
                    result[key] = interpolators[key](t);
                });
                return result;
            };
        }
        if (type === 'number') {
            const delta = b - a;
            return t => a + t * delta;
        }
        throw new Error(`Cannot interpolate ${type} values`);
    }
    function tweened(value, defaults = {}) {
        const store = writable(value);
        let task;
        let target_value = value;
        function set(new_value, opts) {
            if (value == null) {
                store.set(value = new_value);
                return Promise.resolve();
            }
            target_value = new_value;
            let previous_task = task;
            let started = false;
            let { delay = 0, duration = 400, easing = identity, interpolate = get_interpolator } = assign(assign({}, defaults), opts);
            const start = now() + delay;
            let fn;
            task = loop(now => {
                if (now < start)
                    return true;
                if (!started) {
                    fn = interpolate(value, new_value);
                    if (typeof duration === 'function')
                        duration = duration(value, new_value);
                    started = true;
                }
                if (previous_task) {
                    previous_task.abort();
                    previous_task = null;
                }
                const elapsed = now - start;
                if (elapsed > duration) {
                    store.set(value = new_value);
                    return false;
                }
                // @ts-ignore
                store.set(value = fn(easing(elapsed / duration)));
                return true;
            });
            return task.promise;
        }
        return {
            set,
            update: (fn, opts) => set(fn(target_value, value), opts),
            subscribe: store.subscribe
        };
    }

    /**
     * Returns either a Svelte store, or a Svelte 'tweened' store,
     * depending on whether the user specified transition options.
     * The way the tweened store is set up depends on the type of aesthetic,
     * and which options the user has chosen.
     *
     * @param {String} aestheticName The name of the aesthetic a store is created for.
     * @param {*} aestheticValue The initial value of the store.
     * @param {Number|Object} transitionOptions A number indicating the transtion duration, or an Object
     * with aesthetic names as keys, and Numbers OR Objects as values.
     * @returns {writable|tweened}
     */
    function createTransitionable (aestheticName, aestheticValue, transitionOptions) {
      if (isUndefined(transitionOptions) || isUndefined(aestheticValue)) {
        return writable(aestheticValue)
      }

      if (transitionOptions.constructor === Number) {
        const options = createOptionsFromDuration(aestheticName, transitionOptions);
        return tweened(aestheticValue, options)
      }

      if (transitionOptions.constructor === Object) {
        if (!(aestheticName in transitionOptions)) return writable(aestheticValue)

        const aestheticTransition = transitionOptions[aestheticName];

        if (aestheticTransition && aestheticTransition.constructor === Number) {
          const options = createOptionsFromDuration(aestheticName, aestheticTransition);
          return tweened(aestheticValue, options)
        }

        if (aestheticTransition && aestheticTransition.constructor === Object) {
          const options = createOptionsFromOptions(aestheticName, aestheticTransition);
          return tweened(aestheticValue, options)
        }
      }

      throw new Error(`Invalid transition for ${aestheticName}`)
    }

    function createOptionsFromDuration (aestheticName, duration) {
      if (aestheticName === 'geometry') {
        return { duration, easing: cubicOut, interpolate: transitionGeometry }
      } else {
        return { duration, easing: cubicOut, interpolate }
      }
    }

    function transitionsEqual (a, b) {
      if (a === undefined || b === undefined) return a === b

      if (a.constructor !== Object) return a === b

      return transitionObjectsEqual(a, b)
    }

    function transitionObjectsEqual (a, b) {
      if (b.constructor !== Object) return false

      if (numberOfKeys(a) !== numberOfKeys(b)) return false

      for (const aesthetic in a) {
        const aestheticA = a[aesthetic];
        const aestheticB = b[aesthetic];
        if (aestheticA.constructor !== Object) return aestheticA === aestheticB
        if (!aestheticTransitionObjectsEqual(aestheticA, aestheticB)) return false
      }

      return true
    }

    function aestheticTransitionObjectsEqual (a, b) {
      if (b.constructor !== Object) return false

      if (numberOfKeys(a) !== numberOfKeys(b)) return false

      for (const key in a) {
        if (a[key] !== b[key]) return false
      }

      return true
    }

    function numberOfKeys (obj) {
      return Object.keys(obj).length
    }

    function createOptionsFromOptions (aestheticName, transitionOptions) {
      if (aestheticName === 'geometry') {
        return Object.assign({ interpolate: transitionGeometry }, transitionOptions)
      } else {
        return Object.assign({ interpolate }, transitionOptions)
      }
    }

    /**
     * Like createTransitionable, returns either a Svelte store, or a Svelte 'tweened' store,
     * depending on whether the user specified transition options.
     * But instead of for a single Mark, the store is created for an entire layer.
     *
     * @param {String} aestheticName The name of the aesthetic a store is created for.
     * @param {*} aestheticValue The initial value of the store.
     * @param {Number|Object} transitionOptions A number indicating the transtion duration, or an Object
     * with aesthetic names as keys, and Numbers OR Objects as values.
     * @returns {writable|tweened}
     */
    function createTransitionableLayer (aestheticName, aestheticValue, transitionOptions) {
      if (isUndefined(transitionOptions) || isUndefined(aestheticValue)) {
        return writable(aestheticValue)
      }

      if (transitionOptions.constructor === Number) {
        const options = createOptionsFromDuration$1(aestheticName, transitionOptions);
        return tweened(aestheticValue, options)
      }

      if (transitionOptions.constructor === Object) {
        if (!(aestheticName in transitionOptions)) return writable(aestheticValue)

        const aestheticTransition = transitionOptions[aestheticName];

        if (aestheticTransition && aestheticTransition.constructor === Number) {
          const options = createOptionsFromDuration$1(aestheticName, aestheticTransition);
          return tweened(aestheticValue, options)
        }

        if (aestheticTransition && aestheticTransition.constructor === Object) {
          const options = createOptionsFromOptions$1(aestheticName, aestheticTransition);
          return tweened(aestheticValue, options)
        }
      }

      throw new Error(`Invalid transition for ${aestheticName}`)
    }

    function createOptionsFromDuration$1 (aestheticName, duration) {
      if (aestheticName === 'geometry') {
        return { duration, easing: cubicOut, interpolate: transitionGeometries }
      } else {
        return { duration, easing: cubicOut, interpolate: interpolateLayer }
      }
    }

    function createOptionsFromOptions$1 (aestheticName, transitionOptions) {
      if (aestheticName === 'geometry') {
        return Object.assign({ interpolate: transitionGeometries }, transitionOptions)
      } else {
        return Object.assign({ interpolate: interpolateLayer }, transitionOptions)
      }
    }

    function interpolateLayer (a, b) {
      const aWithoutObsoleteKeys = {};

      for (const key in a) {
        if (key in b) {
          aWithoutObsoleteKeys[key] = a[key];
        }
      }

      return interpolate(aWithoutObsoleteKeys, b)
    }

    const geoPathGenerator = geoPath();

    function generatePath (geometry) {
      return geoPathGenerator(geometry)
    }

    function textAnchorPoint (anchorPoint) {
    // For setting the anchor point on a SVG text element
      switch (anchorPoint) {
        case 'center':
          return { textAnchor: 'middle', dominantBaseline: 'middle' }
        case 'lb':
          return { textAnchor: 'start', dominantBaseline: 'alphabetic' }
        case 'lt':
          return { textAnchor: 'start', dominantBaseline: 'hanging' }
        case 'rt':
          return { textAnchor: 'end', dominantBaseline: 'hanging' }
        case 'rb':
          return { textAnchor: 'end', dominantBaseline: 'alphabetic' }
        case 'l':
          return { textAnchor: 'start', dominantBaseline: 'middle' }
        case 'r':
          return { textAnchor: 'end', dominantBaseline: 'middle' }
        case 'b':
          return { textAnchor: 'middle', dominantBaseline: 'alphabetic' }
        case 't':
          return { textAnchor: 'middle', dominantBaseline: 'hanging' }
        default: {
          return { textAnchor: 'middle', dominantBaseline: 'middle' }
        }
      }
    }

    /* src/components/Marks/Mark/Mark.svelte generated by Svelte v3.15.0 */
    const file$4 = "src/components/Marks/Mark/Mark.svelte";

    // (421:0) {#if $graphicContext.output() === 'svg'}
    function create_if_block$2(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let if_block3_anchor;
    	let if_block0 = ctx.renderPolygon && create_if_block_4(ctx);
    	let if_block1 = ctx.renderCircle && create_if_block_3(ctx);
    	let if_block2 = ctx.renderLine && create_if_block_2(ctx);
    	let if_block3 = ctx.renderLabel && create_if_block_1$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			if_block3_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, if_block3_anchor, anchor);
    		},
    		p: function update(changed, ctx) {
    			if (ctx.renderPolygon) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_4(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (ctx.renderCircle) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block_3(ctx);
    					if_block1.c();
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (ctx.renderLine) {
    				if (if_block2) {
    					if_block2.p(changed, ctx);
    				} else {
    					if_block2 = create_if_block_2(ctx);
    					if_block2.c();
    					if_block2.m(t2.parentNode, t2);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (ctx.renderLabel) {
    				if (if_block3) {
    					if_block3.p(changed, ctx);
    				} else {
    					if_block3 = create_if_block_1$2(ctx);
    					if_block3.c();
    					if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(if_block3_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(421:0) {#if $graphicContext.output() === 'svg'}",
    		ctx
    	});

    	return block;
    }

    // (423:2) {#if renderPolygon}
    function create_if_block_4(ctx) {
    	let path;
    	let path_class_value;
    	let path_d_value;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "class", path_class_value = ctx.type.toLowerCase());
    			attr_dev(path, "d", path_d_value = generatePath(ctx.$tr_screenGeometry));
    			attr_dev(path, "fill", ctx.$tr_fill);
    			attr_dev(path, "stroke", ctx.$tr_stroke);
    			attr_dev(path, "stroke-width", ctx.$tr_strokeWidth);
    			attr_dev(path, "fill-opacity", ctx.$tr_fillOpacity);
    			attr_dev(path, "stroke-opacity", ctx.$tr_strokeOpacity);
    			attr_dev(path, "opacity", ctx.$tr_opacity);
    			add_location(path, file$4, 424, 4, 12758);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		p: function update(changed, ctx) {
    			if (changed.type && path_class_value !== (path_class_value = ctx.type.toLowerCase())) {
    				attr_dev(path, "class", path_class_value);
    			}

    			if (changed.$tr_screenGeometry && path_d_value !== (path_d_value = generatePath(ctx.$tr_screenGeometry))) {
    				attr_dev(path, "d", path_d_value);
    			}

    			if (changed.$tr_fill) {
    				attr_dev(path, "fill", ctx.$tr_fill);
    			}

    			if (changed.$tr_stroke) {
    				attr_dev(path, "stroke", ctx.$tr_stroke);
    			}

    			if (changed.$tr_strokeWidth) {
    				attr_dev(path, "stroke-width", ctx.$tr_strokeWidth);
    			}

    			if (changed.$tr_fillOpacity) {
    				attr_dev(path, "fill-opacity", ctx.$tr_fillOpacity);
    			}

    			if (changed.$tr_strokeOpacity) {
    				attr_dev(path, "stroke-opacity", ctx.$tr_strokeOpacity);
    			}

    			if (changed.$tr_opacity) {
    				attr_dev(path, "opacity", ctx.$tr_opacity);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(423:2) {#if renderPolygon}",
    		ctx
    	});

    	return block;
    }

    // (438:2) {#if renderCircle}
    function create_if_block_3(ctx) {
    	let circle;
    	let circle_cx_value;
    	let circle_cy_value;

    	const block = {
    		c: function create() {
    			circle = svg_element("circle");
    			attr_dev(circle, "class", "point");
    			attr_dev(circle, "cx", circle_cx_value = ctx.$tr_screenGeometry.coordinates[0]);
    			attr_dev(circle, "cy", circle_cy_value = ctx.$tr_screenGeometry.coordinates[1]);
    			attr_dev(circle, "r", ctx.$tr_radius);
    			attr_dev(circle, "fill", ctx.$tr_fill);
    			attr_dev(circle, "stroke", ctx.$tr_stroke);
    			attr_dev(circle, "stroke-width", ctx.$tr_strokeWidth);
    			attr_dev(circle, "fill-opacity", ctx.$tr_fillOpacity);
    			attr_dev(circle, "stroke-opacity", ctx.$tr_strokeOpacity);
    			attr_dev(circle, "opacity", ctx.$tr_opacity);
    			add_location(circle, file$4, 439, 4, 13074);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, circle, anchor);
    		},
    		p: function update(changed, ctx) {
    			if (changed.$tr_screenGeometry && circle_cx_value !== (circle_cx_value = ctx.$tr_screenGeometry.coordinates[0])) {
    				attr_dev(circle, "cx", circle_cx_value);
    			}

    			if (changed.$tr_screenGeometry && circle_cy_value !== (circle_cy_value = ctx.$tr_screenGeometry.coordinates[1])) {
    				attr_dev(circle, "cy", circle_cy_value);
    			}

    			if (changed.$tr_radius) {
    				attr_dev(circle, "r", ctx.$tr_radius);
    			}

    			if (changed.$tr_fill) {
    				attr_dev(circle, "fill", ctx.$tr_fill);
    			}

    			if (changed.$tr_stroke) {
    				attr_dev(circle, "stroke", ctx.$tr_stroke);
    			}

    			if (changed.$tr_strokeWidth) {
    				attr_dev(circle, "stroke-width", ctx.$tr_strokeWidth);
    			}

    			if (changed.$tr_fillOpacity) {
    				attr_dev(circle, "fill-opacity", ctx.$tr_fillOpacity);
    			}

    			if (changed.$tr_strokeOpacity) {
    				attr_dev(circle, "stroke-opacity", ctx.$tr_strokeOpacity);
    			}

    			if (changed.$tr_opacity) {
    				attr_dev(circle, "opacity", ctx.$tr_opacity);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(circle);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(438:2) {#if renderCircle}",
    		ctx
    	});

    	return block;
    }

    // (455:2) {#if renderLine}
    function create_if_block_2(ctx) {
    	let path;
    	let path_d_value;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "class", "line");
    			attr_dev(path, "d", path_d_value = generatePath(ctx.$tr_screenGeometry));
    			attr_dev(path, "fill", "none");
    			attr_dev(path, "stroke-width", ctx.$tr_strokeWidth);
    			attr_dev(path, "stroke", ctx.$tr_stroke);
    			attr_dev(path, "opacity", ctx.$tr_opacity);
    			add_location(path, file$4, 456, 4, 13446);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		p: function update(changed, ctx) {
    			if (changed.$tr_screenGeometry && path_d_value !== (path_d_value = generatePath(ctx.$tr_screenGeometry))) {
    				attr_dev(path, "d", path_d_value);
    			}

    			if (changed.$tr_strokeWidth) {
    				attr_dev(path, "stroke-width", ctx.$tr_strokeWidth);
    			}

    			if (changed.$tr_stroke) {
    				attr_dev(path, "stroke", ctx.$tr_stroke);
    			}

    			if (changed.$tr_opacity) {
    				attr_dev(path, "opacity", ctx.$tr_opacity);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(455:2) {#if renderLine}",
    		ctx
    	});

    	return block;
    }

    // (468:2) {#if renderLabel}
    function create_if_block_1$2(ctx) {
    	let text_1;
    	let t_value = ctx.aesthetics.text + "";
    	let t;
    	let text_1_y_value;
    	let text_1_x_value;
    	let text_1_font_size_value;
    	let text_1_text_anchor_value;
    	let text_1_dominant_baseline_value;

    	const block = {
    		c: function create() {
    			text_1 = svg_element("text");
    			t = text(t_value);
    			attr_dev(text_1, "stroke-opacity", ctx.$tr_strokeOpacity);
    			attr_dev(text_1, "class", "label");
    			attr_dev(text_1, "y", text_1_y_value = ctx.$tr_screenGeometry.coordinates[1]);
    			attr_dev(text_1, "fill", ctx.$tr_fill);
    			attr_dev(text_1, "stroke", ctx.$tr_stroke);
    			attr_dev(text_1, "stroke-width", ctx.$tr_strokeWidth);
    			attr_dev(text_1, "fill-opacity", ctx.$tr_fillOpacity);
    			attr_dev(text_1, "x", text_1_x_value = ctx.$tr_screenGeometry.coordinates[0]);
    			attr_dev(text_1, "opacity", ctx.$tr_opacity);
    			attr_dev(text_1, "transform", ctx.rotateTransform);
    			attr_dev(text_1, "font-family", ctx.fontFamily);
    			attr_dev(text_1, "font-size", text_1_font_size_value = ctx.$tr_fontSize + "px");
    			attr_dev(text_1, "font-weight", ctx.$tr_fontWeight);
    			attr_dev(text_1, "text-anchor", text_1_text_anchor_value = ctx.parsedTextAnchorPoint.textAnchor);
    			attr_dev(text_1, "dominant-baseline", text_1_dominant_baseline_value = ctx.parsedTextAnchorPoint.dominantBaseline);
    			add_location(text_1, file$4, 469, 4, 13667);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, text_1, anchor);
    			append_dev(text_1, t);
    		},
    		p: function update(changed, ctx) {
    			if (changed.aesthetics && t_value !== (t_value = ctx.aesthetics.text + "")) set_data_dev(t, t_value);

    			if (changed.$tr_strokeOpacity) {
    				attr_dev(text_1, "stroke-opacity", ctx.$tr_strokeOpacity);
    			}

    			if (changed.$tr_screenGeometry && text_1_y_value !== (text_1_y_value = ctx.$tr_screenGeometry.coordinates[1])) {
    				attr_dev(text_1, "y", text_1_y_value);
    			}

    			if (changed.$tr_fill) {
    				attr_dev(text_1, "fill", ctx.$tr_fill);
    			}

    			if (changed.$tr_stroke) {
    				attr_dev(text_1, "stroke", ctx.$tr_stroke);
    			}

    			if (changed.$tr_strokeWidth) {
    				attr_dev(text_1, "stroke-width", ctx.$tr_strokeWidth);
    			}

    			if (changed.$tr_fillOpacity) {
    				attr_dev(text_1, "fill-opacity", ctx.$tr_fillOpacity);
    			}

    			if (changed.$tr_screenGeometry && text_1_x_value !== (text_1_x_value = ctx.$tr_screenGeometry.coordinates[0])) {
    				attr_dev(text_1, "x", text_1_x_value);
    			}

    			if (changed.$tr_opacity) {
    				attr_dev(text_1, "opacity", ctx.$tr_opacity);
    			}

    			if (changed.rotateTransform) {
    				attr_dev(text_1, "transform", ctx.rotateTransform);
    			}

    			if (changed.fontFamily) {
    				attr_dev(text_1, "font-family", ctx.fontFamily);
    			}

    			if (changed.$tr_fontSize && text_1_font_size_value !== (text_1_font_size_value = ctx.$tr_fontSize + "px")) {
    				attr_dev(text_1, "font-size", text_1_font_size_value);
    			}

    			if (changed.$tr_fontWeight) {
    				attr_dev(text_1, "font-weight", ctx.$tr_fontWeight);
    			}

    			if (changed.parsedTextAnchorPoint && text_1_text_anchor_value !== (text_1_text_anchor_value = ctx.parsedTextAnchorPoint.textAnchor)) {
    				attr_dev(text_1, "text-anchor", text_1_text_anchor_value);
    			}

    			if (changed.parsedTextAnchorPoint && text_1_dominant_baseline_value !== (text_1_dominant_baseline_value = ctx.parsedTextAnchorPoint.dominantBaseline)) {
    				attr_dev(text_1, "dominant-baseline", text_1_dominant_baseline_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(text_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(468:2) {#if renderLabel}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let show_if = ctx.$graphicContext.output() === "svg";
    	let if_block_anchor;
    	let if_block = show_if && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(changed, ctx) {
    			if (changed.$graphicContext) show_if = ctx.$graphicContext.output() === "svg";

    			if (show_if) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$2(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let idCounter$1 = 0;

    function getId$1() {
    	return "mark" + idCounter$1++;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let $sectionContext;
    	let $coordinateTransformationContext;
    	let $zoomContext;

    	let $tr_rotation,
    		$$unsubscribe_tr_rotation = noop,
    		$$subscribe_tr_rotation = () => ($$unsubscribe_tr_rotation(), $$unsubscribe_tr_rotation = subscribe(tr_rotation, $$value => $$invalidate("$tr_rotation", $tr_rotation = $$value)), tr_rotation);

    	let $tr_screenGeometry,
    		$$unsubscribe_tr_screenGeometry = noop,
    		$$subscribe_tr_screenGeometry = () => ($$unsubscribe_tr_screenGeometry(), $$unsubscribe_tr_screenGeometry = subscribe(tr_screenGeometry, $$value => $$invalidate("$tr_screenGeometry", $tr_screenGeometry = $$value)), tr_screenGeometry);

    	let $tr_radius,
    		$$unsubscribe_tr_radius = noop,
    		$$subscribe_tr_radius = () => ($$unsubscribe_tr_radius(), $$unsubscribe_tr_radius = subscribe(tr_radius, $$value => $$invalidate("$tr_radius", $tr_radius = $$value)), tr_radius);

    	let $tr_fill,
    		$$unsubscribe_tr_fill = noop,
    		$$subscribe_tr_fill = () => ($$unsubscribe_tr_fill(), $$unsubscribe_tr_fill = subscribe(tr_fill, $$value => $$invalidate("$tr_fill", $tr_fill = $$value)), tr_fill);

    	let $tr_stroke,
    		$$unsubscribe_tr_stroke = noop,
    		$$subscribe_tr_stroke = () => ($$unsubscribe_tr_stroke(), $$unsubscribe_tr_stroke = subscribe(tr_stroke, $$value => $$invalidate("$tr_stroke", $tr_stroke = $$value)), tr_stroke);

    	let $tr_strokeWidth,
    		$$unsubscribe_tr_strokeWidth = noop,
    		$$subscribe_tr_strokeWidth = () => ($$unsubscribe_tr_strokeWidth(), $$unsubscribe_tr_strokeWidth = subscribe(tr_strokeWidth, $$value => $$invalidate("$tr_strokeWidth", $tr_strokeWidth = $$value)), tr_strokeWidth);

    	let $tr_fillOpacity,
    		$$unsubscribe_tr_fillOpacity = noop,
    		$$subscribe_tr_fillOpacity = () => ($$unsubscribe_tr_fillOpacity(), $$unsubscribe_tr_fillOpacity = subscribe(tr_fillOpacity, $$value => $$invalidate("$tr_fillOpacity", $tr_fillOpacity = $$value)), tr_fillOpacity);

    	let $tr_strokeOpacity,
    		$$unsubscribe_tr_strokeOpacity = noop,
    		$$subscribe_tr_strokeOpacity = () => ($$unsubscribe_tr_strokeOpacity(), $$unsubscribe_tr_strokeOpacity = subscribe(tr_strokeOpacity, $$value => $$invalidate("$tr_strokeOpacity", $tr_strokeOpacity = $$value)), tr_strokeOpacity);

    	let $tr_opacity,
    		$$unsubscribe_tr_opacity = noop,
    		$$subscribe_tr_opacity = () => ($$unsubscribe_tr_opacity(), $$unsubscribe_tr_opacity = subscribe(tr_opacity, $$value => $$invalidate("$tr_opacity", $tr_opacity = $$value)), tr_opacity);

    	let $tr_fontSize,
    		$$unsubscribe_tr_fontSize = noop,
    		$$subscribe_tr_fontSize = () => ($$unsubscribe_tr_fontSize(), $$unsubscribe_tr_fontSize = subscribe(tr_fontSize, $$value => $$invalidate("$tr_fontSize", $tr_fontSize = $$value)), tr_fontSize);

    	let $tr_fontWeight,
    		$$unsubscribe_tr_fontWeight = noop,
    		$$subscribe_tr_fontWeight = () => ($$unsubscribe_tr_fontWeight(), $$unsubscribe_tr_fontWeight = subscribe(tr_fontWeight, $$value => $$invalidate("$tr_fontWeight", $tr_fontWeight = $$value)), tr_fontWeight);

    	let $interactionManagerContext;
    	let $graphicContext;
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_rotation());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_screenGeometry());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_radius());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_fill());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_stroke());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_strokeWidth());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_fillOpacity());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_strokeOpacity());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_opacity());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_fontSize());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_fontWeight());
    	const markId = getId$1();
    	let initPhase = true;
    	const initDone = () => !initPhase;
    	let { type } = $$props;
    	let { x } = $$props;
    	let { y } = $$props;
    	let { x1 } = $$props;
    	let { x2 } = $$props;
    	let { y1 } = $$props;
    	let { y2 } = $$props;
    	let { geometry } = $$props;
    	let { independentAxis } = $$props;
    	let { radius } = $$props;
    	let { fill } = $$props;
    	let { stroke } = $$props;
    	let { strokeWidth } = $$props;
    	let { strokeOpacity } = $$props;
    	let { fillOpacity } = $$props;
    	let { opacity } = $$props;
    	let { text } = $$props;
    	let { fontFamily } = $$props;
    	let { fontSize } = $$props;
    	let { fontWeight } = $$props;
    	let { rotation } = $$props;
    	let { anchorPoint } = $$props;
    	let { transition } = $$props;
    	let { onClick } = $$props;
    	let { onMousedown } = $$props;
    	let { onMouseup } = $$props;
    	let { onMouseover } = $$props;
    	let { onMouseout } = $$props;
    	let { onMousedrag } = $$props;
    	let { onSelect } = $$props;
    	let { onDeselect } = $$props;
    	let { interpolate = false } = $$props;
    	let { _asPolygon = true } = $$props;
    	let { zoomIdentity } = $$props;
    	let { blockReindexing = false } = $$props;

    	let aesthetics = validateAesthetics(type, {
    		x,
    		y,
    		x1,
    		x2,
    		y1,
    		y2,
    		geometry,
    		independentAxis,
    		radius,
    		fill,
    		stroke,
    		strokeWidth,
    		strokeOpacity,
    		fillOpacity,
    		opacity,
    		text,
    		fontFamily,
    		fontSize,
    		fontWeight,
    		rotation,
    		anchorPoint
    	});

    	let positioningAesthetics = {
    		x,
    		y,
    		x1,
    		x2,
    		y1,
    		y2,
    		geometry,
    		independentAxis
    	};

    	let createCoordSysGeometry = markCoordSysGeometryFuncs[type];
    	let representAsPolygon = markRepresentAsPolygonFuncs[type];
    	const graphicContext = subscribe$1();
    	validate_store(graphicContext, "graphicContext");
    	component_subscribe($$self, graphicContext, value => $$invalidate("$graphicContext", $graphicContext = value));
    	const sectionContext = subscribe$2();
    	validate_store(sectionContext, "sectionContext");
    	component_subscribe($$self, sectionContext, value => $$invalidate("$sectionContext", $sectionContext = value));
    	const coordinateTransformationContext = subscribe$5();
    	validate_store(coordinateTransformationContext, "coordinateTransformationContext");
    	component_subscribe($$self, coordinateTransformationContext, value => $$invalidate("$coordinateTransformationContext", $coordinateTransformationContext = value));
    	const interactionManagerContext = subscribe$4();
    	validate_store(interactionManagerContext, "interactionManagerContext");
    	component_subscribe($$self, interactionManagerContext, value => $$invalidate("$interactionManagerContext", $interactionManagerContext = value));
    	const zoomContext = subscribe$6();
    	validate_store(zoomContext, "zoomContext");
    	component_subscribe($$self, zoomContext, value => $$invalidate("$zoomContext", $zoomContext = value));
    	let coordSysGeometry;
    	let pixelGeometry;
    	let screenGeometry;
    	updateCoordSysGeometry();
    	updatePixelGeometry();
    	updateScreenGeometry();
    	let tr_screenGeometry = createTransitionable("geometry", screenGeometry, transition);
    	validate_store(tr_screenGeometry, "tr_screenGeometry");
    	$$subscribe_tr_screenGeometry();
    	let tr_radius = createTransitionable("radius", aesthetics.radius, transition);
    	validate_store(tr_radius, "tr_radius");
    	$$subscribe_tr_radius();
    	let tr_fill = createTransitionable("fill", aesthetics.fill, transition);
    	validate_store(tr_fill, "tr_fill");
    	$$subscribe_tr_fill();
    	let tr_stroke = createTransitionable("stroke", aesthetics.stroke, transition);
    	validate_store(tr_stroke, "tr_stroke");
    	$$subscribe_tr_stroke();
    	let tr_strokeWidth = createTransitionable("strokeWidth", aesthetics.strokeWidth, transition);
    	validate_store(tr_strokeWidth, "tr_strokeWidth");
    	$$subscribe_tr_strokeWidth();
    	let tr_fillOpacity = createTransitionable("fillOpacity", aesthetics.fillOpacity, transition);
    	validate_store(tr_fillOpacity, "tr_fillOpacity");
    	$$subscribe_tr_fillOpacity();
    	let tr_strokeOpacity = createTransitionable("strokeOpacity", aesthetics.strokeOpacity, transition);
    	validate_store(tr_strokeOpacity, "tr_strokeOpacity");
    	$$subscribe_tr_strokeOpacity();
    	let tr_opacity = createTransitionable("opacity", aesthetics.opacity, transition);
    	validate_store(tr_opacity, "tr_opacity");
    	$$subscribe_tr_opacity();
    	let tr_fontSize = createTransitionable("fontSize", aesthetics.fontSize, transition);
    	validate_store(tr_fontSize, "tr_fontSize");
    	$$subscribe_tr_fontSize();
    	let tr_fontWeight = createTransitionable("fontWeight", aesthetics.fontWeight, transition);
    	validate_store(tr_fontWeight, "tr_fontWeight");
    	$$subscribe_tr_fontWeight();
    	let tr_rotation = createTransitionable("rotation", aesthetics.rotation, transition);
    	validate_store(tr_rotation, "tr_rotation");
    	$$subscribe_tr_rotation();
    	let rotateTransform = `rotate(${$tr_rotation}, ${$tr_screenGeometry.coordinates[0]}, ${$tr_screenGeometry.coordinates[1]})`;
    	let parsedTextAnchorPoint = textAnchorPoint(aesthetics.anchorPoint);
    	let previousTransition;
    	let coordSysGeometryRecalculationNecessary = false;
    	let pixelGeometryRecalculationNecessary = false;
    	let screenGeometryRecalculationNecessary = false;
    	

    	beforeUpdate(() => {
    		if (!transitionsEqual(previousTransition, transition)) {
    			previousTransition = transition;
    			$$subscribe_tr_screenGeometry($$invalidate("tr_screenGeometry", tr_screenGeometry = createTransitionable("geometry", $tr_screenGeometry, transition)));
    			$$subscribe_tr_radius($$invalidate("tr_radius", tr_radius = createTransitionable("radius", $tr_radius, transition)));
    			$$subscribe_tr_fill($$invalidate("tr_fill", tr_fill = createTransitionable("fill", $tr_fill, transition)));
    			$$subscribe_tr_stroke($$invalidate("tr_stroke", tr_stroke = createTransitionable("stroke", $tr_stroke, transition)));
    			$$subscribe_tr_strokeWidth($$invalidate("tr_strokeWidth", tr_strokeWidth = createTransitionable("strokeWidth", $tr_strokeWidth, transition)));
    			$$subscribe_tr_fillOpacity($$invalidate("tr_fillOpacity", tr_fillOpacity = createTransitionable("fillOpacity", $tr_fillOpacity, transition)));
    			$$subscribe_tr_strokeOpacity($$invalidate("tr_strokeOpacity", tr_strokeOpacity = createTransitionable("strokeOpacity", $tr_strokeOpacity, transition)));
    			$$subscribe_tr_opacity($$invalidate("tr_opacity", tr_opacity = createTransitionable("opacity", $tr_opacity, transition)));
    			$$subscribe_tr_fontSize($$invalidate("tr_fontSize", tr_fontSize = createTransitionable("fontSize", $tr_fontSize, transition)));
    			$$subscribe_tr_fontWeight($$invalidate("tr_fontWeight", tr_fontWeight = createTransitionable("fontWeight", $tr_fontWeight, transition)));
    			$$subscribe_tr_rotation($$invalidate("tr_rotation", tr_rotation = createTransitionable("rotation", $tr_rotation, transition)));
    		}
    	});

    	afterUpdate(() => {
    		initPhase = false;
    	});

    	onMount(() => {
    		updateInteractionManagerIfNecessary();
    	});

    	onDestroy(() => {
    		removeMarkFromSpatialIndexIfNecessary();
    	});

    	function scheduleUpdateCoordSysGeometry() {
    		$$invalidate("coordSysGeometryRecalculationNecessary", coordSysGeometryRecalculationNecessary = true);
    		$$invalidate("pixelGeometryRecalculationNecessary", pixelGeometryRecalculationNecessary = true);
    		$$invalidate("screenGeometryRecalculationNecessary", screenGeometryRecalculationNecessary = true);
    	}

    	function updateCoordSysGeometry() {
    		coordSysGeometry = createCoordSysGeometry(positioningAesthetics, $sectionContext, $coordinateTransformationContext, interpolate);
    	}

    	function scheduleUpdatePixelGeometry() {
    		$$invalidate("pixelGeometryRecalculationNecessary", pixelGeometryRecalculationNecessary = true);
    		$$invalidate("screenGeometryRecalculationNecessary", screenGeometryRecalculationNecessary = true);
    	}

    	function updatePixelGeometry() {
    		const zoomTransformation = createZoomTransformation($zoomContext, zoomIdentity);

    		if (zoomTransformation) {
    			pixelGeometry = transformGeometry(coordSysGeometry, zoomTransformation);
    		} else {
    			pixelGeometry = coordSysGeometry;
    		}
    	}

    	function scheduleUpdateScreenGeometry() {
    		$$invalidate("screenGeometryRecalculationNecessary", screenGeometryRecalculationNecessary = true);
    	}

    	function updateScreenGeometry() {
    		if (_asPolygon) {
    			$$invalidate("screenGeometry", screenGeometry = representAsPolygon(pixelGeometry, aesthetics));
    		} else {
    			$$invalidate("screenGeometry", screenGeometry = pixelGeometry);
    		}
    	}

    	function updateInteractionManagerIfNecessary() {
    		if (initPhase || !(blockReindexing || $sectionContext.blockReindexing)) {
    			removeMarkFromSpatialIndexIfNecessary();

    			if (isInteractiveMouse) {
    				const markInterface = $interactionManagerContext.mouse().marks();
    				markInterface.loadMark(type, createDataNecessaryForIndexing());
    				if (onClick) markInterface.addMarkInteraction("click", markId, onClick);
    				if (onMousedown) markInterface.addMarkInteraction("mousedown", markId, onMousedown);
    				if (onMouseup) markInterface.addMarkInteraction("mouseup", markId, onMouseup);
    				if (onMouseout) markInterface.addMarkInteraction("mouseout", markId, onMouseout);
    				if (onMouseover) markInterface.addMarkInteraction("mouseover", markId, onMouseover);
    				if (onMousedrag) markInterface.addMarkInteraction("mousedrag", markId, onMousedrag);
    			}
    		}

    		removeMarkFromSelectIfNecessary();

    		if (isSelectable) {
    			const selectManager = $interactionManagerContext.select();
    			selectManager.loadMark(type, createDataNecessaryForIndexing(), { onSelect, onDeselect });
    		}
    	}

    	function removeMarkFromSpatialIndexIfNecessary() {
    		const markInterface = $interactionManagerContext.mouse().marks();

    		if (markInterface.markIsLoaded(markId)) {
    			markInterface.removeAllMarkInteractions(markId);
    			markInterface.removeMark(markId);
    		}
    	}

    	function removeMarkFromSelectIfNecessary() {
    		const selectManager = $interactionManagerContext.select();

    		if (selectManager.markIsLoaded(markId)) {
    			selectManager.removeMark(markId);
    		}
    	}

    	function createDataNecessaryForIndexing() {
    		return createDataNecessaryForIndexingMark(type, markId, { screenGeometry, pixelGeometry }, aesthetics);
    	}

    	const writable_props = [
    		"type",
    		"x",
    		"y",
    		"x1",
    		"x2",
    		"y1",
    		"y2",
    		"geometry",
    		"independentAxis",
    		"radius",
    		"fill",
    		"stroke",
    		"strokeWidth",
    		"strokeOpacity",
    		"fillOpacity",
    		"opacity",
    		"text",
    		"fontFamily",
    		"fontSize",
    		"fontWeight",
    		"rotation",
    		"anchorPoint",
    		"transition",
    		"onClick",
    		"onMousedown",
    		"onMouseup",
    		"onMouseover",
    		"onMouseout",
    		"onMousedrag",
    		"onSelect",
    		"onDeselect",
    		"interpolate",
    		"_asPolygon",
    		"zoomIdentity",
    		"blockReindexing"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Mark> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("type" in $$props) $$invalidate("type", type = $$props.type);
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("x1" in $$props) $$invalidate("x1", x1 = $$props.x1);
    		if ("x2" in $$props) $$invalidate("x2", x2 = $$props.x2);
    		if ("y1" in $$props) $$invalidate("y1", y1 = $$props.y1);
    		if ("y2" in $$props) $$invalidate("y2", y2 = $$props.y2);
    		if ("geometry" in $$props) $$invalidate("geometry", geometry = $$props.geometry);
    		if ("independentAxis" in $$props) $$invalidate("independentAxis", independentAxis = $$props.independentAxis);
    		if ("radius" in $$props) $$invalidate("radius", radius = $$props.radius);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("strokeOpacity" in $$props) $$invalidate("strokeOpacity", strokeOpacity = $$props.strokeOpacity);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("text" in $$props) $$invalidate("text", text = $$props.text);
    		if ("fontFamily" in $$props) $$invalidate("fontFamily", fontFamily = $$props.fontFamily);
    		if ("fontSize" in $$props) $$invalidate("fontSize", fontSize = $$props.fontSize);
    		if ("fontWeight" in $$props) $$invalidate("fontWeight", fontWeight = $$props.fontWeight);
    		if ("rotation" in $$props) $$invalidate("rotation", rotation = $$props.rotation);
    		if ("anchorPoint" in $$props) $$invalidate("anchorPoint", anchorPoint = $$props.anchorPoint);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("interpolate" in $$props) $$invalidate("interpolate", interpolate = $$props.interpolate);
    		if ("_asPolygon" in $$props) $$invalidate("_asPolygon", _asPolygon = $$props._asPolygon);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	$$self.$capture_state = () => {
    		return {
    			idCounter: idCounter$1,
    			initPhase,
    			type,
    			x,
    			y,
    			x1,
    			x2,
    			y1,
    			y2,
    			geometry,
    			independentAxis,
    			radius,
    			fill,
    			stroke,
    			strokeWidth,
    			strokeOpacity,
    			fillOpacity,
    			opacity,
    			text,
    			fontFamily,
    			fontSize,
    			fontWeight,
    			rotation,
    			anchorPoint,
    			transition,
    			onClick,
    			onMousedown,
    			onMouseup,
    			onMouseover,
    			onMouseout,
    			onMousedrag,
    			onSelect,
    			onDeselect,
    			interpolate,
    			_asPolygon,
    			zoomIdentity,
    			blockReindexing,
    			aesthetics,
    			positioningAesthetics,
    			createCoordSysGeometry,
    			representAsPolygon,
    			coordSysGeometry,
    			pixelGeometry,
    			screenGeometry,
    			tr_screenGeometry,
    			tr_radius,
    			tr_fill,
    			tr_stroke,
    			tr_strokeWidth,
    			tr_fillOpacity,
    			tr_strokeOpacity,
    			tr_opacity,
    			tr_fontSize,
    			tr_fontWeight,
    			tr_rotation,
    			rotateTransform,
    			parsedTextAnchorPoint,
    			previousTransition,
    			coordSysGeometryRecalculationNecessary,
    			pixelGeometryRecalculationNecessary,
    			screenGeometryRecalculationNecessary,
    			$sectionContext,
    			$coordinateTransformationContext,
    			$zoomContext,
    			$tr_rotation,
    			$tr_screenGeometry,
    			$tr_radius,
    			$tr_fill,
    			$tr_stroke,
    			$tr_strokeWidth,
    			$tr_fillOpacity,
    			$tr_strokeOpacity,
    			$tr_opacity,
    			$tr_fontSize,
    			$tr_fontWeight,
    			isInteractiveMouse,
    			isInteractiveTouch,
    			isSelectable,
    			$interactionManagerContext,
    			renderPolygon,
    			renderCircle,
    			renderLine,
    			renderLabel,
    			$graphicContext
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("initPhase" in $$props) initPhase = $$props.initPhase;
    		if ("type" in $$props) $$invalidate("type", type = $$props.type);
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("x1" in $$props) $$invalidate("x1", x1 = $$props.x1);
    		if ("x2" in $$props) $$invalidate("x2", x2 = $$props.x2);
    		if ("y1" in $$props) $$invalidate("y1", y1 = $$props.y1);
    		if ("y2" in $$props) $$invalidate("y2", y2 = $$props.y2);
    		if ("geometry" in $$props) $$invalidate("geometry", geometry = $$props.geometry);
    		if ("independentAxis" in $$props) $$invalidate("independentAxis", independentAxis = $$props.independentAxis);
    		if ("radius" in $$props) $$invalidate("radius", radius = $$props.radius);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("strokeOpacity" in $$props) $$invalidate("strokeOpacity", strokeOpacity = $$props.strokeOpacity);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("text" in $$props) $$invalidate("text", text = $$props.text);
    		if ("fontFamily" in $$props) $$invalidate("fontFamily", fontFamily = $$props.fontFamily);
    		if ("fontSize" in $$props) $$invalidate("fontSize", fontSize = $$props.fontSize);
    		if ("fontWeight" in $$props) $$invalidate("fontWeight", fontWeight = $$props.fontWeight);
    		if ("rotation" in $$props) $$invalidate("rotation", rotation = $$props.rotation);
    		if ("anchorPoint" in $$props) $$invalidate("anchorPoint", anchorPoint = $$props.anchorPoint);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("interpolate" in $$props) $$invalidate("interpolate", interpolate = $$props.interpolate);
    		if ("_asPolygon" in $$props) $$invalidate("_asPolygon", _asPolygon = $$props._asPolygon);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    		if ("aesthetics" in $$props) $$invalidate("aesthetics", aesthetics = $$props.aesthetics);
    		if ("positioningAesthetics" in $$props) $$invalidate("positioningAesthetics", positioningAesthetics = $$props.positioningAesthetics);
    		if ("createCoordSysGeometry" in $$props) createCoordSysGeometry = $$props.createCoordSysGeometry;
    		if ("representAsPolygon" in $$props) representAsPolygon = $$props.representAsPolygon;
    		if ("coordSysGeometry" in $$props) coordSysGeometry = $$props.coordSysGeometry;
    		if ("pixelGeometry" in $$props) pixelGeometry = $$props.pixelGeometry;
    		if ("screenGeometry" in $$props) $$invalidate("screenGeometry", screenGeometry = $$props.screenGeometry);
    		if ("tr_screenGeometry" in $$props) $$subscribe_tr_screenGeometry($$invalidate("tr_screenGeometry", tr_screenGeometry = $$props.tr_screenGeometry));
    		if ("tr_radius" in $$props) $$subscribe_tr_radius($$invalidate("tr_radius", tr_radius = $$props.tr_radius));
    		if ("tr_fill" in $$props) $$subscribe_tr_fill($$invalidate("tr_fill", tr_fill = $$props.tr_fill));
    		if ("tr_stroke" in $$props) $$subscribe_tr_stroke($$invalidate("tr_stroke", tr_stroke = $$props.tr_stroke));
    		if ("tr_strokeWidth" in $$props) $$subscribe_tr_strokeWidth($$invalidate("tr_strokeWidth", tr_strokeWidth = $$props.tr_strokeWidth));
    		if ("tr_fillOpacity" in $$props) $$subscribe_tr_fillOpacity($$invalidate("tr_fillOpacity", tr_fillOpacity = $$props.tr_fillOpacity));
    		if ("tr_strokeOpacity" in $$props) $$subscribe_tr_strokeOpacity($$invalidate("tr_strokeOpacity", tr_strokeOpacity = $$props.tr_strokeOpacity));
    		if ("tr_opacity" in $$props) $$subscribe_tr_opacity($$invalidate("tr_opacity", tr_opacity = $$props.tr_opacity));
    		if ("tr_fontSize" in $$props) $$subscribe_tr_fontSize($$invalidate("tr_fontSize", tr_fontSize = $$props.tr_fontSize));
    		if ("tr_fontWeight" in $$props) $$subscribe_tr_fontWeight($$invalidate("tr_fontWeight", tr_fontWeight = $$props.tr_fontWeight));
    		if ("tr_rotation" in $$props) $$subscribe_tr_rotation($$invalidate("tr_rotation", tr_rotation = $$props.tr_rotation));
    		if ("rotateTransform" in $$props) $$invalidate("rotateTransform", rotateTransform = $$props.rotateTransform);
    		if ("parsedTextAnchorPoint" in $$props) $$invalidate("parsedTextAnchorPoint", parsedTextAnchorPoint = $$props.parsedTextAnchorPoint);
    		if ("previousTransition" in $$props) previousTransition = $$props.previousTransition;
    		if ("coordSysGeometryRecalculationNecessary" in $$props) $$invalidate("coordSysGeometryRecalculationNecessary", coordSysGeometryRecalculationNecessary = $$props.coordSysGeometryRecalculationNecessary);
    		if ("pixelGeometryRecalculationNecessary" in $$props) $$invalidate("pixelGeometryRecalculationNecessary", pixelGeometryRecalculationNecessary = $$props.pixelGeometryRecalculationNecessary);
    		if ("screenGeometryRecalculationNecessary" in $$props) $$invalidate("screenGeometryRecalculationNecessary", screenGeometryRecalculationNecessary = $$props.screenGeometryRecalculationNecessary);
    		if ("$sectionContext" in $$props) sectionContext.set($sectionContext = $$props.$sectionContext);
    		if ("$coordinateTransformationContext" in $$props) coordinateTransformationContext.set($coordinateTransformationContext = $$props.$coordinateTransformationContext);
    		if ("$zoomContext" in $$props) zoomContext.set($zoomContext = $$props.$zoomContext);
    		if ("$tr_rotation" in $$props) tr_rotation.set($tr_rotation = $$props.$tr_rotation);
    		if ("$tr_screenGeometry" in $$props) tr_screenGeometry.set($tr_screenGeometry = $$props.$tr_screenGeometry);
    		if ("$tr_radius" in $$props) tr_radius.set($tr_radius = $$props.$tr_radius);
    		if ("$tr_fill" in $$props) tr_fill.set($tr_fill = $$props.$tr_fill);
    		if ("$tr_stroke" in $$props) tr_stroke.set($tr_stroke = $$props.$tr_stroke);
    		if ("$tr_strokeWidth" in $$props) tr_strokeWidth.set($tr_strokeWidth = $$props.$tr_strokeWidth);
    		if ("$tr_fillOpacity" in $$props) tr_fillOpacity.set($tr_fillOpacity = $$props.$tr_fillOpacity);
    		if ("$tr_strokeOpacity" in $$props) tr_strokeOpacity.set($tr_strokeOpacity = $$props.$tr_strokeOpacity);
    		if ("$tr_opacity" in $$props) tr_opacity.set($tr_opacity = $$props.$tr_opacity);
    		if ("$tr_fontSize" in $$props) tr_fontSize.set($tr_fontSize = $$props.$tr_fontSize);
    		if ("$tr_fontWeight" in $$props) tr_fontWeight.set($tr_fontWeight = $$props.$tr_fontWeight);
    		if ("isInteractiveMouse" in $$props) isInteractiveMouse = $$props.isInteractiveMouse;
    		if ("isInteractiveTouch" in $$props) isInteractiveTouch = $$props.isInteractiveTouch;
    		if ("isSelectable" in $$props) isSelectable = $$props.isSelectable;
    		if ("$interactionManagerContext" in $$props) interactionManagerContext.set($interactionManagerContext = $$props.$interactionManagerContext);
    		if ("renderPolygon" in $$props) $$invalidate("renderPolygon", renderPolygon = $$props.renderPolygon);
    		if ("renderCircle" in $$props) $$invalidate("renderCircle", renderCircle = $$props.renderCircle);
    		if ("renderLine" in $$props) $$invalidate("renderLine", renderLine = $$props.renderLine);
    		if ("renderLabel" in $$props) $$invalidate("renderLabel", renderLabel = $$props.renderLabel);
    		if ("$graphicContext" in $$props) graphicContext.set($graphicContext = $$props.$graphicContext);
    	};

    	let isInteractiveMouse;
    	let isInteractiveTouch;
    	let isSelectable;
    	let renderPolygon;
    	let renderCircle;
    	let renderLine;
    	let renderLabel;

    	$$self.$$.update = (changed = { type: 1, x: 1, y: 1, x1: 1, x2: 1, y1: 1, y2: 1, geometry: 1, independentAxis: 1, radius: 1, fill: 1, stroke: 1, strokeWidth: 1, strokeOpacity: 1, fillOpacity: 1, opacity: 1, text: 1, fontFamily: 1, fontSize: 1, fontWeight: 1, rotation: 1, anchorPoint: 1, positioningAesthetics: 1, $sectionContext: 1, $coordinateTransformationContext: 1, interpolate: 1, $zoomContext: 1, _asPolygon: 1, tr_radius: 1, aesthetics: 1, tr_strokeWidth: 1, tr_fill: 1, tr_stroke: 1, tr_fillOpacity: 1, tr_strokeOpacity: 1, tr_opacity: 1, tr_fontSize: 1, tr_fontWeight: 1, tr_rotation: 1, coordSysGeometryRecalculationNecessary: 1, pixelGeometryRecalculationNecessary: 1, screenGeometryRecalculationNecessary: 1, tr_screenGeometry: 1, screenGeometry: 1, $tr_rotation: 1, $tr_screenGeometry: 1, onClick: 1, onMousedown: 1, onMouseup: 1, onMouseover: 1, onMouseout: 1, onMousedrag: 1, onSelect: 1, onDeselect: 1 }) => {
    		if (changed.type || changed.x || changed.y || changed.x1 || changed.x2 || changed.y1 || changed.y2 || changed.geometry || changed.independentAxis || changed.radius || changed.fill || changed.stroke || changed.strokeWidth || changed.strokeOpacity || changed.fillOpacity || changed.opacity || changed.text || changed.fontFamily || changed.fontSize || changed.fontWeight || changed.rotation || changed.anchorPoint) {
    			 {
    				if (initDone()) {
    					$$invalidate("aesthetics", aesthetics = validateAesthetics(type, {
    						x,
    						y,
    						x1,
    						x2,
    						y1,
    						y2,
    						geometry,
    						independentAxis,
    						radius,
    						fill,
    						stroke,
    						strokeWidth,
    						strokeOpacity,
    						fillOpacity,
    						opacity,
    						text,
    						fontFamily,
    						fontSize,
    						fontWeight,
    						rotation,
    						anchorPoint
    					}));
    				}
    			}
    		}

    		if (changed.x || changed.y || changed.x1 || changed.x2 || changed.y1 || changed.y2 || changed.geometry || changed.independentAxis) {
    			 {
    				if (initDone()) {
    					$$invalidate("positioningAesthetics", positioningAesthetics = {
    						x,
    						y,
    						x1,
    						x2,
    						y1,
    						y2,
    						geometry,
    						independentAxis
    					});
    				}
    			}
    		}

    		if (changed.type) {
    			 {
    				if (initDone()) {
    					createCoordSysGeometry = markCoordSysGeometryFuncs[type];
    					representAsPolygon = markRepresentAsPolygonFuncs[type];
    				}
    			}
    		}

    		if (changed.positioningAesthetics || changed.$sectionContext || changed.$coordinateTransformationContext || changed.interpolate) {
    			 {
    				if (initDone()) {
    					scheduleUpdateCoordSysGeometry();
    				}
    			}
    		}

    		if (changed.$zoomContext) {
    			 {
    				if (initDone()) {
    					scheduleUpdatePixelGeometry();
    				}
    			}
    		}

    		if (changed._asPolygon || changed.tr_radius || changed.aesthetics || changed.tr_strokeWidth) {
    			 {
    				if (initDone()) {
    					if (!_asPolygon) {
    						tr_radius.set(aesthetics.radius);
    						tr_strokeWidth.set(aesthetics.strokeWidth);
    					}

    					if (_asPolygon) {
    						scheduleUpdateScreenGeometry();
    					}
    				}
    			}
    		}

    		if (changed.tr_fill || changed.aesthetics) {
    			 {
    				if (initDone()) tr_fill.set(aesthetics.fill);
    			}
    		}

    		if (changed.tr_stroke || changed.aesthetics) {
    			 {
    				if (initDone()) tr_stroke.set(aesthetics.stroke);
    			}
    		}

    		if (changed.tr_strokeWidth || changed.aesthetics) {
    			 {
    				if (initDone()) tr_strokeWidth.set(aesthetics.strokeWidth);
    			}
    		}

    		if (changed.tr_fillOpacity || changed.aesthetics) {
    			 {
    				if (initDone()) tr_fillOpacity.set(aesthetics.fillOpacity);
    			}
    		}

    		if (changed.tr_strokeOpacity || changed.aesthetics) {
    			 {
    				if (initDone()) tr_strokeOpacity.set(aesthetics.strokeOpacity);
    			}
    		}

    		if (changed.tr_opacity || changed.aesthetics) {
    			 {
    				if (initDone()) tr_opacity.set(aesthetics.opacity);
    			}
    		}

    		if (changed.tr_fontSize || changed.aesthetics) {
    			 {
    				if (initDone()) tr_fontSize.set(aesthetics.fontSize);
    			}
    		}

    		if (changed.tr_fontWeight || changed.aesthetics) {
    			 {
    				if (initDone()) tr_fontWeight.set(aesthetics.fontWeight);
    			}
    		}

    		if (changed.tr_rotation || changed.aesthetics) {
    			 {
    				if (initDone()) tr_rotation.set(aesthetics.rotation);
    			}
    		}

    		if (changed.coordSysGeometryRecalculationNecessary || changed.pixelGeometryRecalculationNecessary || changed.screenGeometryRecalculationNecessary || changed.tr_screenGeometry || changed.screenGeometry) {
    			 {
    				if (initDone()) {
    					if (coordSysGeometryRecalculationNecessary) updateCoordSysGeometry();
    					if (pixelGeometryRecalculationNecessary) updatePixelGeometry();

    					if (screenGeometryRecalculationNecessary) {
    						updateScreenGeometry();
    						tr_screenGeometry.set(screenGeometry);
    						updateInteractionManagerIfNecessary();
    					}

    					$$invalidate("coordSysGeometryRecalculationNecessary", coordSysGeometryRecalculationNecessary = false);
    					$$invalidate("pixelGeometryRecalculationNecessary", pixelGeometryRecalculationNecessary = false);
    					$$invalidate("screenGeometryRecalculationNecessary", screenGeometryRecalculationNecessary = false);
    				}
    			}
    		}

    		if (changed.$tr_rotation || changed.$tr_screenGeometry) {
    			 {
    				if (initDone()) $$invalidate("rotateTransform", rotateTransform = `rotate(${$tr_rotation}, ${$tr_screenGeometry.coordinates[0]}, ${$tr_screenGeometry.coordinates[1]})`);
    			}
    		}

    		if (changed.aesthetics) {
    			 {
    				if (initDone()) $$invalidate("parsedTextAnchorPoint", parsedTextAnchorPoint = textAnchorPoint(aesthetics.anchorPoint));
    			}
    		}

    		if (changed.onClick || changed.onMousedown || changed.onMouseup || changed.onMouseover || changed.onMouseout || changed.onMousedrag) {
    			 isInteractiveMouse = detectIt.hasMouse && (onClick !== undefined || onMousedown !== undefined || onMouseup !== undefined || onMouseover !== undefined || onMouseout !== undefined || onMousedrag !== undefined);
    		}

    		if (changed.onSelect || changed.onDeselect) {
    			 isSelectable = onSelect !== undefined || onDeselect !== undefined;
    		}

    		if (changed.type || changed._asPolygon) {
    			 $$invalidate("renderPolygon", renderPolygon = !["Point", "Line", "Label"].includes(type) || _asPolygon);
    		}

    		if (changed.type || changed._asPolygon) {
    			 $$invalidate("renderCircle", renderCircle = type === "Point" && !_asPolygon);
    		}

    		if (changed.type || changed._asPolygon) {
    			 $$invalidate("renderLine", renderLine = type === "Line" && !_asPolygon);
    		}

    		if (changed.type) {
    			 $$invalidate("renderLabel", renderLabel = type === "Label");
    		}
    	};

    	 isInteractiveTouch = detectIt.hasTouch;

    	return {
    		type,
    		x,
    		y,
    		x1,
    		x2,
    		y1,
    		y2,
    		geometry,
    		independentAxis,
    		radius,
    		fill,
    		stroke,
    		strokeWidth,
    		strokeOpacity,
    		fillOpacity,
    		opacity,
    		text,
    		fontFamily,
    		fontSize,
    		fontWeight,
    		rotation,
    		anchorPoint,
    		transition,
    		onClick,
    		onMousedown,
    		onMouseup,
    		onMouseover,
    		onMouseout,
    		onMousedrag,
    		onSelect,
    		onDeselect,
    		interpolate,
    		_asPolygon,
    		zoomIdentity,
    		blockReindexing,
    		aesthetics,
    		graphicContext,
    		sectionContext,
    		coordinateTransformationContext,
    		interactionManagerContext,
    		zoomContext,
    		tr_screenGeometry,
    		tr_radius,
    		tr_fill,
    		tr_stroke,
    		tr_strokeWidth,
    		tr_fillOpacity,
    		tr_strokeOpacity,
    		tr_opacity,
    		tr_fontSize,
    		tr_fontWeight,
    		tr_rotation,
    		rotateTransform,
    		parsedTextAnchorPoint,
    		$tr_screenGeometry,
    		$tr_radius,
    		$tr_fill,
    		$tr_stroke,
    		$tr_strokeWidth,
    		$tr_fillOpacity,
    		$tr_strokeOpacity,
    		$tr_opacity,
    		$tr_fontSize,
    		$tr_fontWeight,
    		renderPolygon,
    		renderCircle,
    		renderLine,
    		renderLabel,
    		$graphicContext
    	};
    }

    class Mark extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {
    			type: 0,
    			x: 0,
    			y: 0,
    			x1: 0,
    			x2: 0,
    			y1: 0,
    			y2: 0,
    			geometry: 0,
    			independentAxis: 0,
    			radius: 0,
    			fill: 0,
    			stroke: 0,
    			strokeWidth: 0,
    			strokeOpacity: 0,
    			fillOpacity: 0,
    			opacity: 0,
    			text: 0,
    			fontFamily: 0,
    			fontSize: 0,
    			fontWeight: 0,
    			rotation: 0,
    			anchorPoint: 0,
    			transition: 0,
    			onClick: 0,
    			onMousedown: 0,
    			onMouseup: 0,
    			onMouseover: 0,
    			onMouseout: 0,
    			onMousedrag: 0,
    			onSelect: 0,
    			onDeselect: 0,
    			interpolate: 0,
    			_asPolygon: 0,
    			zoomIdentity: 0,
    			blockReindexing: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Mark",
    			options,
    			id: create_fragment$6.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || ({});

    		if (ctx.type === undefined && !("type" in props)) {
    			console.warn("<Mark> was created without expected prop 'type'");
    		}

    		if (ctx.x === undefined && !("x" in props)) {
    			console.warn("<Mark> was created without expected prop 'x'");
    		}

    		if (ctx.y === undefined && !("y" in props)) {
    			console.warn("<Mark> was created without expected prop 'y'");
    		}

    		if (ctx.x1 === undefined && !("x1" in props)) {
    			console.warn("<Mark> was created without expected prop 'x1'");
    		}

    		if (ctx.x2 === undefined && !("x2" in props)) {
    			console.warn("<Mark> was created without expected prop 'x2'");
    		}

    		if (ctx.y1 === undefined && !("y1" in props)) {
    			console.warn("<Mark> was created without expected prop 'y1'");
    		}

    		if (ctx.y2 === undefined && !("y2" in props)) {
    			console.warn("<Mark> was created without expected prop 'y2'");
    		}

    		if (ctx.geometry === undefined && !("geometry" in props)) {
    			console.warn("<Mark> was created without expected prop 'geometry'");
    		}

    		if (ctx.independentAxis === undefined && !("independentAxis" in props)) {
    			console.warn("<Mark> was created without expected prop 'independentAxis'");
    		}

    		if (ctx.radius === undefined && !("radius" in props)) {
    			console.warn("<Mark> was created without expected prop 'radius'");
    		}

    		if (ctx.fill === undefined && !("fill" in props)) {
    			console.warn("<Mark> was created without expected prop 'fill'");
    		}

    		if (ctx.stroke === undefined && !("stroke" in props)) {
    			console.warn("<Mark> was created without expected prop 'stroke'");
    		}

    		if (ctx.strokeWidth === undefined && !("strokeWidth" in props)) {
    			console.warn("<Mark> was created without expected prop 'strokeWidth'");
    		}

    		if (ctx.strokeOpacity === undefined && !("strokeOpacity" in props)) {
    			console.warn("<Mark> was created without expected prop 'strokeOpacity'");
    		}

    		if (ctx.fillOpacity === undefined && !("fillOpacity" in props)) {
    			console.warn("<Mark> was created without expected prop 'fillOpacity'");
    		}

    		if (ctx.opacity === undefined && !("opacity" in props)) {
    			console.warn("<Mark> was created without expected prop 'opacity'");
    		}

    		if (ctx.text === undefined && !("text" in props)) {
    			console.warn("<Mark> was created without expected prop 'text'");
    		}

    		if (ctx.fontFamily === undefined && !("fontFamily" in props)) {
    			console.warn("<Mark> was created without expected prop 'fontFamily'");
    		}

    		if (ctx.fontSize === undefined && !("fontSize" in props)) {
    			console.warn("<Mark> was created without expected prop 'fontSize'");
    		}

    		if (ctx.fontWeight === undefined && !("fontWeight" in props)) {
    			console.warn("<Mark> was created without expected prop 'fontWeight'");
    		}

    		if (ctx.rotation === undefined && !("rotation" in props)) {
    			console.warn("<Mark> was created without expected prop 'rotation'");
    		}

    		if (ctx.anchorPoint === undefined && !("anchorPoint" in props)) {
    			console.warn("<Mark> was created without expected prop 'anchorPoint'");
    		}

    		if (ctx.transition === undefined && !("transition" in props)) {
    			console.warn("<Mark> was created without expected prop 'transition'");
    		}

    		if (ctx.onClick === undefined && !("onClick" in props)) {
    			console.warn("<Mark> was created without expected prop 'onClick'");
    		}

    		if (ctx.onMousedown === undefined && !("onMousedown" in props)) {
    			console.warn("<Mark> was created without expected prop 'onMousedown'");
    		}

    		if (ctx.onMouseup === undefined && !("onMouseup" in props)) {
    			console.warn("<Mark> was created without expected prop 'onMouseup'");
    		}

    		if (ctx.onMouseover === undefined && !("onMouseover" in props)) {
    			console.warn("<Mark> was created without expected prop 'onMouseover'");
    		}

    		if (ctx.onMouseout === undefined && !("onMouseout" in props)) {
    			console.warn("<Mark> was created without expected prop 'onMouseout'");
    		}

    		if (ctx.onMousedrag === undefined && !("onMousedrag" in props)) {
    			console.warn("<Mark> was created without expected prop 'onMousedrag'");
    		}

    		if (ctx.onSelect === undefined && !("onSelect" in props)) {
    			console.warn("<Mark> was created without expected prop 'onSelect'");
    		}

    		if (ctx.onDeselect === undefined && !("onDeselect" in props)) {
    			console.warn("<Mark> was created without expected prop 'onDeselect'");
    		}

    		if (ctx.zoomIdentity === undefined && !("zoomIdentity" in props)) {
    			console.warn("<Mark> was created without expected prop 'zoomIdentity'");
    		}
    	}

    	get type() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get x() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get x1() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x1(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get x2() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x2(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y1() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y1(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y2() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y2(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get geometry() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set geometry(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get independentAxis() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set independentAxis(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get radius() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radius(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fill() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fill(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stroke() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stroke(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeWidth() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeWidth(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeOpacity() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeOpacity(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillOpacity() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillOpacity(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opacity() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opacity(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fontFamily() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fontFamily(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fontSize() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fontSize(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fontWeight() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fontWeight(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rotation() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rotation(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get anchorPoint() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set anchorPoint(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transition() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transition(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClick() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClick(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedown() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedown(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseup() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseup(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseover() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseover(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseout() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseout(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedrag() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedrag(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSelect() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSelect(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onDeselect() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onDeselect(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get interpolate() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set interpolate(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get _asPolygon() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set _asPolygon(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zoomIdentity() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoomIdentity(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blockReindexing() {
    		throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blockReindexing(value) {
    		throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // There are three ways of setting the position of the axis, in order of precedence
    // 1. vjust with 'bottom', 'center' or 'top'
    //      hjust with 'left', 'center', 'right'
    // 1.5. vjust and/or hjust with a number (relative position within content of section)
    // 3. x, y props with positioning in data coords
    // The first two use 'smart defaults' based on the dimensions of the Graphic or Section
    // that the Title is contained in

    function isValid (x, y) {
      let validVariables = 0;

      for (const value in [x, y]) {
        if (checkValidType(value)) {
          validVariables += 1;
        }
      }

      if (validVariables < 2) {
        throw new Error('Couldn\'t construct legend because of invalid x, y inputs.')
      } else if (validVariables === 2 && x === undefined && y === undefined) {
        return false
      }

      return true

      // if (!isNaN(x) && !isNaN(y)) {
      //   return true
      // }

      // if (x !== undefined || y !== undefined) {
      //   throw new Error('Couldn\'t construct title because of invalid x, y inputs.')
      // }

      // return false
    }

    function checkValidType (value) {
      if (!isNaN(value) || {}.toString.call(value) === '[object Function]' || value === undefined) {
        return true
      }

      return false
    }

    function createTitleXCoord (hjust, range, x, offset, fontSize, padding) {
      if (x) {
        return x
      }

      const x1 = range[0];
      const x2 = range[1];
      const sectionWidth = Math.abs(x2 - x1);

      let justification;

      if (hjust === 'center' || hjust === 'centre') {
        justification = 0.5;
      }

      if (hjust === 'left') {
        justification = 0;
      }

      if (hjust === 'right') {
        justification = 1;
      }

      if (!isNaN(hjust)) {
        justification = hjust;
      }

      if (justification === undefined) {
        justification = 0.5;
      }

      if (!['left', 'center', 'right'].includes(hjust) && isNaN(hjust)) {
        throw Error('Please specify either `left`, `center`, `right` or a number from 0 to 1 for `hjust`')
      }

      return x1 + sectionWidth * justification + offset
    }

    function createTitleYCoord (vjust, range, y, offset, fontSize, padding) {
      if (y) {
        return y
      }

      const y1 = range[0];
      const y2 = range[1];
      const sectionHeight = Math.abs(y2 - y1);

      let justification;

      if (vjust === 'center') {
        justification = 0.5;
      }

      if (vjust === 'bottom') {
        justification = 1 - (fontSize / sectionHeight);
      }

      if (vjust === 'top') {
        justification = 0;
      }

      if (!isNaN(vjust)) {
        justification = vjust;
      }

      if (justification === undefined) {
        justification = 0.5;
      }

      if (!['center', 'bottom', 'top'].includes(vjust) && isNaN(vjust)) {
        throw Error('Please specify either `top`, `center`, `bottom` or a number for `vjust`')
      }

      return y1 + sectionHeight * justification + offset
    }

    /* src/components/Core/Title/Title.svelte generated by Svelte v3.15.0 */

    const { console: console_1$1 } = globals;

    function create_fragment$7(ctx) {
    	let t;
    	let current;

    	const mark0 = new Mark({
    			props: {
    				type: "Label",
    				x: ctx.func,
    				y: ctx.func_1,
    				geometry: ctx.geometry,
    				fill: ctx.titleFill,
    				stroke: ctx.titleStroke,
    				strokeWidth: ctx.titleStrokeWidth,
    				strokeOpacity: ctx.titleStrokeOpacity,
    				fillOpacity: ctx.titleFillOpacity,
    				opacity: ctx.titleOpacity,
    				text: ctx.title,
    				fontFamily: ctx.titleFontFamily,
    				fontSize: ctx.titleFontSize,
    				fontWeight: ctx.titleFontWeight,
    				rotation: ctx.titleRotation,
    				anchorPoint: ctx.titleAnchorPoint,
    				transition: ctx.transition,
    				onClick: ctx.onClick,
    				onMouseover: ctx.onMouseover,
    				onMouseout: ctx.onMouseout,
    				zoomIdentity: ctx.zoomIdentity,
    				_asPolygon: false
    			},
    			$$inline: true
    		});

    	const mark1 = new Mark({
    			props: {
    				type: "Label",
    				x: ctx.func_2,
    				y: ctx.func_3,
    				geometry: ctx.geometry,
    				fill: ctx.subtitleFill,
    				stroke: ctx.subtitleStroke,
    				strokeWidth: ctx.subtitleStrokeWidth,
    				strokeOpacity: ctx.subtitleStrokeOpacity,
    				fillOpacity: ctx.subtitleFillOpacity,
    				opacity: ctx.subtitleOpacity,
    				text: ctx.subtitle,
    				fontFamily: ctx.subtitleFontFamily,
    				fontSize: ctx.subtitleFontSize,
    				fontWeight: ctx.subtitleFontWeight,
    				rotation: ctx.subtitleRotation,
    				anchorPoint: ctx.subtitleAnchorPoint,
    				transition: ctx.transition,
    				onClick: ctx.onClick,
    				onMouseover: ctx.onMouseover,
    				onMouseout: ctx.onMouseout,
    				zoomIdentity: ctx.zoomIdentity,
    				_asPolygon: false
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mark0.$$.fragment);
    			t = space();
    			create_component(mark1.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(mark0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(mark1, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const mark0_changes = {};
    			if (changed.x) mark0_changes.x = ctx.func;
    			if (changed.y) mark0_changes.y = ctx.func_1;
    			if (changed.geometry) mark0_changes.geometry = ctx.geometry;
    			if (changed.titleFill) mark0_changes.fill = ctx.titleFill;
    			if (changed.titleStroke) mark0_changes.stroke = ctx.titleStroke;
    			if (changed.titleStrokeWidth) mark0_changes.strokeWidth = ctx.titleStrokeWidth;
    			if (changed.titleStrokeOpacity) mark0_changes.strokeOpacity = ctx.titleStrokeOpacity;
    			if (changed.titleFillOpacity) mark0_changes.fillOpacity = ctx.titleFillOpacity;
    			if (changed.titleOpacity) mark0_changes.opacity = ctx.titleOpacity;
    			if (changed.title) mark0_changes.text = ctx.title;
    			if (changed.titleFontFamily) mark0_changes.fontFamily = ctx.titleFontFamily;
    			if (changed.titleFontSize) mark0_changes.fontSize = ctx.titleFontSize;
    			if (changed.titleFontWeight) mark0_changes.fontWeight = ctx.titleFontWeight;
    			if (changed.titleRotation) mark0_changes.rotation = ctx.titleRotation;
    			if (changed.titleAnchorPoint) mark0_changes.anchorPoint = ctx.titleAnchorPoint;
    			if (changed.transition) mark0_changes.transition = ctx.transition;
    			if (changed.onClick) mark0_changes.onClick = ctx.onClick;
    			if (changed.onMouseover) mark0_changes.onMouseover = ctx.onMouseover;
    			if (changed.onMouseout) mark0_changes.onMouseout = ctx.onMouseout;
    			if (changed.zoomIdentity) mark0_changes.zoomIdentity = ctx.zoomIdentity;
    			mark0.$set(mark0_changes);
    			const mark1_changes = {};
    			if (changed.subtitleX) mark1_changes.x = ctx.func_2;
    			if (changed.subtitleY) mark1_changes.y = ctx.func_3;
    			if (changed.geometry) mark1_changes.geometry = ctx.geometry;
    			if (changed.subtitleFill) mark1_changes.fill = ctx.subtitleFill;
    			if (changed.subtitleStroke) mark1_changes.stroke = ctx.subtitleStroke;
    			if (changed.subtitleStrokeWidth) mark1_changes.strokeWidth = ctx.subtitleStrokeWidth;
    			if (changed.subtitleStrokeOpacity) mark1_changes.strokeOpacity = ctx.subtitleStrokeOpacity;
    			if (changed.subtitleFillOpacity) mark1_changes.fillOpacity = ctx.subtitleFillOpacity;
    			if (changed.subtitleOpacity) mark1_changes.opacity = ctx.subtitleOpacity;
    			if (changed.subtitle) mark1_changes.text = ctx.subtitle;
    			if (changed.subtitleFontFamily) mark1_changes.fontFamily = ctx.subtitleFontFamily;
    			if (changed.subtitleFontSize) mark1_changes.fontSize = ctx.subtitleFontSize;
    			if (changed.subtitleFontWeight) mark1_changes.fontWeight = ctx.subtitleFontWeight;
    			if (changed.subtitleRotation) mark1_changes.rotation = ctx.subtitleRotation;
    			if (changed.subtitleAnchorPoint) mark1_changes.anchorPoint = ctx.subtitleAnchorPoint;
    			if (changed.transition) mark1_changes.transition = ctx.transition;
    			if (changed.onClick) mark1_changes.onClick = ctx.onClick;
    			if (changed.onMouseover) mark1_changes.onMouseover = ctx.onMouseover;
    			if (changed.onMouseout) mark1_changes.onMouseout = ctx.onMouseout;
    			if (changed.zoomIdentity) mark1_changes.zoomIdentity = ctx.zoomIdentity;
    			mark1.$set(mark1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mark0.$$.fragment, local);
    			transition_in(mark1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mark0.$$.fragment, local);
    			transition_out(mark1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mark0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(mark1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let $sectionContext;
    	let { x } = $$props;
    	let { y } = $$props;
    	let { geometry } = $$props;
    	let { vjust = "top" } = $$props;
    	let { hjust = "center" } = $$props;
    	let { xOffset = 0 } = $$props;
    	let { yOffset = 10 } = $$props;
    	let { usePadding = false } = $$props;
    	let { title = "Title Text" } = $$props;
    	let { titleFill = "black" } = $$props;
    	let { titleStroke } = $$props;
    	let { titleStrokeWidth } = $$props;
    	let { titleStrokeOpacity } = $$props;
    	let { titleFillOpacity } = $$props;
    	let { titleOpacity = 1 } = $$props;
    	let { titleFontFamily } = $$props;
    	let { titleFontSize = 18 } = $$props;
    	let { titleFontWeight = "bold" } = $$props;
    	let { titleRotation = 0 } = $$props;
    	let { titleAnchorPoint = "center" } = $$props;
    	let { subtitle = "" } = $$props;
    	let { subtitleFill = "black" } = $$props;
    	let { subtitleStroke } = $$props;
    	let { subtitleStrokeWidth } = $$props;
    	let { subtitleStrokeOpacity } = $$props;
    	let { subtitleFillOpacity } = $$props;
    	let { subtitleOpacity = 1 } = $$props;
    	let { subtitleFontFamily } = $$props;
    	let { subtitleFontSize = 14 } = $$props;
    	let { subtitleFontWeight = "normal" } = $$props;
    	let { subtitleRotation = 0 } = $$props;
    	let { subtitleAnchorPoint = "center" } = $$props;
    	let { subtitleX } = $$props;
    	let { subtitleY } = $$props;
    	let { transition } = $$props;
    	let { onClick } = $$props;
    	let { onMouseover } = $$props;
    	let { onMouseout } = $$props;
    	let { zoomIdentity } = $$props;
    	const sectionContext = subscribe$2();
    	validate_store(sectionContext, "sectionContext");
    	component_subscribe($$self, sectionContext, value => $$invalidate("$sectionContext", $sectionContext = value));
    	const graphicContext = subscribe$1();
    	const zoomContext = subscribe$6();
    	let _padding;
    	let xRange = $sectionContext.scaleX.range();
    	let yRange = $sectionContext.scaleY.range();
    	let totalFontSize;

    	const writable_props = [
    		"x",
    		"y",
    		"geometry",
    		"vjust",
    		"hjust",
    		"xOffset",
    		"yOffset",
    		"usePadding",
    		"title",
    		"titleFill",
    		"titleStroke",
    		"titleStrokeWidth",
    		"titleStrokeOpacity",
    		"titleFillOpacity",
    		"titleOpacity",
    		"titleFontFamily",
    		"titleFontSize",
    		"titleFontWeight",
    		"titleRotation",
    		"titleAnchorPoint",
    		"subtitle",
    		"subtitleFill",
    		"subtitleStroke",
    		"subtitleStrokeWidth",
    		"subtitleStrokeOpacity",
    		"subtitleFillOpacity",
    		"subtitleOpacity",
    		"subtitleFontFamily",
    		"subtitleFontSize",
    		"subtitleFontWeight",
    		"subtitleRotation",
    		"subtitleAnchorPoint",
    		"subtitleX",
    		"subtitleY",
    		"transition",
    		"onClick",
    		"onMouseover",
    		"onMouseout",
    		"zoomIdentity"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<Title> was created with unknown prop '${key}'`);
    	});

    	const func = () => {
    		return x;
    	};

    	const func_1 = () => {
    		return y;
    	};

    	const func_2 = () => {
    		return subtitleX;
    	};

    	const func_3 = () => {
    		return subtitleY;
    	};

    	$$self.$set = $$props => {
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("geometry" in $$props) $$invalidate("geometry", geometry = $$props.geometry);
    		if ("vjust" in $$props) $$invalidate("vjust", vjust = $$props.vjust);
    		if ("hjust" in $$props) $$invalidate("hjust", hjust = $$props.hjust);
    		if ("xOffset" in $$props) $$invalidate("xOffset", xOffset = $$props.xOffset);
    		if ("yOffset" in $$props) $$invalidate("yOffset", yOffset = $$props.yOffset);
    		if ("usePadding" in $$props) $$invalidate("usePadding", usePadding = $$props.usePadding);
    		if ("title" in $$props) $$invalidate("title", title = $$props.title);
    		if ("titleFill" in $$props) $$invalidate("titleFill", titleFill = $$props.titleFill);
    		if ("titleStroke" in $$props) $$invalidate("titleStroke", titleStroke = $$props.titleStroke);
    		if ("titleStrokeWidth" in $$props) $$invalidate("titleStrokeWidth", titleStrokeWidth = $$props.titleStrokeWidth);
    		if ("titleStrokeOpacity" in $$props) $$invalidate("titleStrokeOpacity", titleStrokeOpacity = $$props.titleStrokeOpacity);
    		if ("titleFillOpacity" in $$props) $$invalidate("titleFillOpacity", titleFillOpacity = $$props.titleFillOpacity);
    		if ("titleOpacity" in $$props) $$invalidate("titleOpacity", titleOpacity = $$props.titleOpacity);
    		if ("titleFontFamily" in $$props) $$invalidate("titleFontFamily", titleFontFamily = $$props.titleFontFamily);
    		if ("titleFontSize" in $$props) $$invalidate("titleFontSize", titleFontSize = $$props.titleFontSize);
    		if ("titleFontWeight" in $$props) $$invalidate("titleFontWeight", titleFontWeight = $$props.titleFontWeight);
    		if ("titleRotation" in $$props) $$invalidate("titleRotation", titleRotation = $$props.titleRotation);
    		if ("titleAnchorPoint" in $$props) $$invalidate("titleAnchorPoint", titleAnchorPoint = $$props.titleAnchorPoint);
    		if ("subtitle" in $$props) $$invalidate("subtitle", subtitle = $$props.subtitle);
    		if ("subtitleFill" in $$props) $$invalidate("subtitleFill", subtitleFill = $$props.subtitleFill);
    		if ("subtitleStroke" in $$props) $$invalidate("subtitleStroke", subtitleStroke = $$props.subtitleStroke);
    		if ("subtitleStrokeWidth" in $$props) $$invalidate("subtitleStrokeWidth", subtitleStrokeWidth = $$props.subtitleStrokeWidth);
    		if ("subtitleStrokeOpacity" in $$props) $$invalidate("subtitleStrokeOpacity", subtitleStrokeOpacity = $$props.subtitleStrokeOpacity);
    		if ("subtitleFillOpacity" in $$props) $$invalidate("subtitleFillOpacity", subtitleFillOpacity = $$props.subtitleFillOpacity);
    		if ("subtitleOpacity" in $$props) $$invalidate("subtitleOpacity", subtitleOpacity = $$props.subtitleOpacity);
    		if ("subtitleFontFamily" in $$props) $$invalidate("subtitleFontFamily", subtitleFontFamily = $$props.subtitleFontFamily);
    		if ("subtitleFontSize" in $$props) $$invalidate("subtitleFontSize", subtitleFontSize = $$props.subtitleFontSize);
    		if ("subtitleFontWeight" in $$props) $$invalidate("subtitleFontWeight", subtitleFontWeight = $$props.subtitleFontWeight);
    		if ("subtitleRotation" in $$props) $$invalidate("subtitleRotation", subtitleRotation = $$props.subtitleRotation);
    		if ("subtitleAnchorPoint" in $$props) $$invalidate("subtitleAnchorPoint", subtitleAnchorPoint = $$props.subtitleAnchorPoint);
    		if ("subtitleX" in $$props) $$invalidate("subtitleX", subtitleX = $$props.subtitleX);
    		if ("subtitleY" in $$props) $$invalidate("subtitleY", subtitleY = $$props.subtitleY);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    	};

    	$$self.$capture_state = () => {
    		return {
    			x,
    			y,
    			geometry,
    			vjust,
    			hjust,
    			xOffset,
    			yOffset,
    			usePadding,
    			title,
    			titleFill,
    			titleStroke,
    			titleStrokeWidth,
    			titleStrokeOpacity,
    			titleFillOpacity,
    			titleOpacity,
    			titleFontFamily,
    			titleFontSize,
    			titleFontWeight,
    			titleRotation,
    			titleAnchorPoint,
    			subtitle,
    			subtitleFill,
    			subtitleStroke,
    			subtitleStrokeWidth,
    			subtitleStrokeOpacity,
    			subtitleFillOpacity,
    			subtitleOpacity,
    			subtitleFontFamily,
    			subtitleFontSize,
    			subtitleFontWeight,
    			subtitleRotation,
    			subtitleAnchorPoint,
    			subtitleX,
    			subtitleY,
    			transition,
    			onClick,
    			onMouseover,
    			onMouseout,
    			zoomIdentity,
    			_padding,
    			xRange,
    			yRange,
    			totalFontSize,
    			$sectionContext
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("geometry" in $$props) $$invalidate("geometry", geometry = $$props.geometry);
    		if ("vjust" in $$props) $$invalidate("vjust", vjust = $$props.vjust);
    		if ("hjust" in $$props) $$invalidate("hjust", hjust = $$props.hjust);
    		if ("xOffset" in $$props) $$invalidate("xOffset", xOffset = $$props.xOffset);
    		if ("yOffset" in $$props) $$invalidate("yOffset", yOffset = $$props.yOffset);
    		if ("usePadding" in $$props) $$invalidate("usePadding", usePadding = $$props.usePadding);
    		if ("title" in $$props) $$invalidate("title", title = $$props.title);
    		if ("titleFill" in $$props) $$invalidate("titleFill", titleFill = $$props.titleFill);
    		if ("titleStroke" in $$props) $$invalidate("titleStroke", titleStroke = $$props.titleStroke);
    		if ("titleStrokeWidth" in $$props) $$invalidate("titleStrokeWidth", titleStrokeWidth = $$props.titleStrokeWidth);
    		if ("titleStrokeOpacity" in $$props) $$invalidate("titleStrokeOpacity", titleStrokeOpacity = $$props.titleStrokeOpacity);
    		if ("titleFillOpacity" in $$props) $$invalidate("titleFillOpacity", titleFillOpacity = $$props.titleFillOpacity);
    		if ("titleOpacity" in $$props) $$invalidate("titleOpacity", titleOpacity = $$props.titleOpacity);
    		if ("titleFontFamily" in $$props) $$invalidate("titleFontFamily", titleFontFamily = $$props.titleFontFamily);
    		if ("titleFontSize" in $$props) $$invalidate("titleFontSize", titleFontSize = $$props.titleFontSize);
    		if ("titleFontWeight" in $$props) $$invalidate("titleFontWeight", titleFontWeight = $$props.titleFontWeight);
    		if ("titleRotation" in $$props) $$invalidate("titleRotation", titleRotation = $$props.titleRotation);
    		if ("titleAnchorPoint" in $$props) $$invalidate("titleAnchorPoint", titleAnchorPoint = $$props.titleAnchorPoint);
    		if ("subtitle" in $$props) $$invalidate("subtitle", subtitle = $$props.subtitle);
    		if ("subtitleFill" in $$props) $$invalidate("subtitleFill", subtitleFill = $$props.subtitleFill);
    		if ("subtitleStroke" in $$props) $$invalidate("subtitleStroke", subtitleStroke = $$props.subtitleStroke);
    		if ("subtitleStrokeWidth" in $$props) $$invalidate("subtitleStrokeWidth", subtitleStrokeWidth = $$props.subtitleStrokeWidth);
    		if ("subtitleStrokeOpacity" in $$props) $$invalidate("subtitleStrokeOpacity", subtitleStrokeOpacity = $$props.subtitleStrokeOpacity);
    		if ("subtitleFillOpacity" in $$props) $$invalidate("subtitleFillOpacity", subtitleFillOpacity = $$props.subtitleFillOpacity);
    		if ("subtitleOpacity" in $$props) $$invalidate("subtitleOpacity", subtitleOpacity = $$props.subtitleOpacity);
    		if ("subtitleFontFamily" in $$props) $$invalidate("subtitleFontFamily", subtitleFontFamily = $$props.subtitleFontFamily);
    		if ("subtitleFontSize" in $$props) $$invalidate("subtitleFontSize", subtitleFontSize = $$props.subtitleFontSize);
    		if ("subtitleFontWeight" in $$props) $$invalidate("subtitleFontWeight", subtitleFontWeight = $$props.subtitleFontWeight);
    		if ("subtitleRotation" in $$props) $$invalidate("subtitleRotation", subtitleRotation = $$props.subtitleRotation);
    		if ("subtitleAnchorPoint" in $$props) $$invalidate("subtitleAnchorPoint", subtitleAnchorPoint = $$props.subtitleAnchorPoint);
    		if ("subtitleX" in $$props) $$invalidate("subtitleX", subtitleX = $$props.subtitleX);
    		if ("subtitleY" in $$props) $$invalidate("subtitleY", subtitleY = $$props.subtitleY);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("_padding" in $$props) $$invalidate("_padding", _padding = $$props._padding);
    		if ("xRange" in $$props) $$invalidate("xRange", xRange = $$props.xRange);
    		if ("yRange" in $$props) $$invalidate("yRange", yRange = $$props.yRange);
    		if ("totalFontSize" in $$props) $$invalidate("totalFontSize", totalFontSize = $$props.totalFontSize);
    		if ("$sectionContext" in $$props) sectionContext.set($sectionContext = $$props.$sectionContext);
    	};

    	$$self.$$.update = (changed = { usePadding: 1, $sectionContext: 1, xRange: 1, _padding: 1, yRange: 1, subtitle: 1, titleFontSize: 1, subtitleFontSize: 1, x: 1, y: 1, hjust: 1, xOffset: 1, totalFontSize: 1, vjust: 1, yOffset: 1, subtitleX: 1, subtitleY: 1 }) => {
    		if (changed.usePadding || changed.$sectionContext || changed.xRange || changed._padding || changed.yRange) {
    			 {
    				if (usePadding === true) {
    					$$invalidate("_padding", _padding = $sectionContext.padding);
    					$$invalidate("xRange", xRange = removePadding(xRange, _padding.left, _padding.right));
    					$$invalidate("yRange", yRange = removePadding(yRange, _padding.top, _padding.bottom));
    				}
    			}
    		}

    		if (changed.subtitle || changed.titleFontSize || changed.subtitleFontSize || changed.x || changed.y || changed.xRange || changed.hjust || changed.xOffset || changed.totalFontSize || changed._padding || changed.yRange || changed.vjust || changed.yOffset || changed.$sectionContext || changed.subtitleX || changed.subtitleY) {
    			 {
    				$$invalidate("totalFontSize", totalFontSize = subtitle.length > 0
    				? titleFontSize + subtitleFontSize
    				: titleFontSize);

    				console.log(x, y);

    				if (!isValid(x, y)) {
    					if (sectionContext.flipX) xRange.reverse();
    					$$invalidate("x", x = createTitleXCoord(hjust, xRange, x, xOffset, totalFontSize, sectionContext.flipX));
    					if (sectionContext.flipY) yRange.reverse();
    					$$invalidate("y", y = createTitleYCoord(vjust, yRange, y, yOffset, totalFontSize, sectionContext.flipY));
    				} else {
    					let _x, _y;

    					if (({}).toString.call(x) === "[object Function]") {
    						_x = x();
    					} else {
    						_x = $sectionContext.scaleX(x);
    					}

    					if (({}).toString.call(y) === "[object Function]") {
    						_y = y();
    					} else {
    						_y = $sectionContext.scaleY(y);
    					}

    					$$invalidate("x", x = _x);
    					$$invalidate("y", y = _y);
    				}

    				if (subtitle.length > 0) {
    					if (!isValid(subtitleX, subtitleY)) {
    						const yRange = $sectionContext.scaleY.range();
    						$$invalidate("subtitleX", subtitleX = x);
    						$$invalidate("subtitleY", subtitleY = y + titleFontSize);
    					}
    				}
    			}
    		}
    	};

    	return {
    		x,
    		y,
    		geometry,
    		vjust,
    		hjust,
    		xOffset,
    		yOffset,
    		usePadding,
    		title,
    		titleFill,
    		titleStroke,
    		titleStrokeWidth,
    		titleStrokeOpacity,
    		titleFillOpacity,
    		titleOpacity,
    		titleFontFamily,
    		titleFontSize,
    		titleFontWeight,
    		titleRotation,
    		titleAnchorPoint,
    		subtitle,
    		subtitleFill,
    		subtitleStroke,
    		subtitleStrokeWidth,
    		subtitleStrokeOpacity,
    		subtitleFillOpacity,
    		subtitleOpacity,
    		subtitleFontFamily,
    		subtitleFontSize,
    		subtitleFontWeight,
    		subtitleRotation,
    		subtitleAnchorPoint,
    		subtitleX,
    		subtitleY,
    		transition,
    		onClick,
    		onMouseover,
    		onMouseout,
    		zoomIdentity,
    		sectionContext,
    		func,
    		func_1,
    		func_2,
    		func_3
    	};
    }

    class Title extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
    			x: 0,
    			y: 0,
    			geometry: 0,
    			vjust: 0,
    			hjust: 0,
    			xOffset: 0,
    			yOffset: 0,
    			usePadding: 0,
    			title: 0,
    			titleFill: 0,
    			titleStroke: 0,
    			titleStrokeWidth: 0,
    			titleStrokeOpacity: 0,
    			titleFillOpacity: 0,
    			titleOpacity: 0,
    			titleFontFamily: 0,
    			titleFontSize: 0,
    			titleFontWeight: 0,
    			titleRotation: 0,
    			titleAnchorPoint: 0,
    			subtitle: 0,
    			subtitleFill: 0,
    			subtitleStroke: 0,
    			subtitleStrokeWidth: 0,
    			subtitleStrokeOpacity: 0,
    			subtitleFillOpacity: 0,
    			subtitleOpacity: 0,
    			subtitleFontFamily: 0,
    			subtitleFontSize: 0,
    			subtitleFontWeight: 0,
    			subtitleRotation: 0,
    			subtitleAnchorPoint: 0,
    			subtitleX: 0,
    			subtitleY: 0,
    			transition: 0,
    			onClick: 0,
    			onMouseover: 0,
    			onMouseout: 0,
    			zoomIdentity: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Title",
    			options,
    			id: create_fragment$7.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || ({});

    		if (ctx.x === undefined && !("x" in props)) {
    			console_1$1.warn("<Title> was created without expected prop 'x'");
    		}

    		if (ctx.y === undefined && !("y" in props)) {
    			console_1$1.warn("<Title> was created without expected prop 'y'");
    		}

    		if (ctx.geometry === undefined && !("geometry" in props)) {
    			console_1$1.warn("<Title> was created without expected prop 'geometry'");
    		}

    		if (ctx.titleStroke === undefined && !("titleStroke" in props)) {
    			console_1$1.warn("<Title> was created without expected prop 'titleStroke'");
    		}

    		if (ctx.titleStrokeWidth === undefined && !("titleStrokeWidth" in props)) {
    			console_1$1.warn("<Title> was created without expected prop 'titleStrokeWidth'");
    		}

    		if (ctx.titleStrokeOpacity === undefined && !("titleStrokeOpacity" in props)) {
    			console_1$1.warn("<Title> was created without expected prop 'titleStrokeOpacity'");
    		}

    		if (ctx.titleFillOpacity === undefined && !("titleFillOpacity" in props)) {
    			console_1$1.warn("<Title> was created without expected prop 'titleFillOpacity'");
    		}

    		if (ctx.titleFontFamily === undefined && !("titleFontFamily" in props)) {
    			console_1$1.warn("<Title> was created without expected prop 'titleFontFamily'");
    		}

    		if (ctx.subtitleStroke === undefined && !("subtitleStroke" in props)) {
    			console_1$1.warn("<Title> was created without expected prop 'subtitleStroke'");
    		}

    		if (ctx.subtitleStrokeWidth === undefined && !("subtitleStrokeWidth" in props)) {
    			console_1$1.warn("<Title> was created without expected prop 'subtitleStrokeWidth'");
    		}

    		if (ctx.subtitleStrokeOpacity === undefined && !("subtitleStrokeOpacity" in props)) {
    			console_1$1.warn("<Title> was created without expected prop 'subtitleStrokeOpacity'");
    		}

    		if (ctx.subtitleFillOpacity === undefined && !("subtitleFillOpacity" in props)) {
    			console_1$1.warn("<Title> was created without expected prop 'subtitleFillOpacity'");
    		}

    		if (ctx.subtitleFontFamily === undefined && !("subtitleFontFamily" in props)) {
    			console_1$1.warn("<Title> was created without expected prop 'subtitleFontFamily'");
    		}

    		if (ctx.subtitleX === undefined && !("subtitleX" in props)) {
    			console_1$1.warn("<Title> was created without expected prop 'subtitleX'");
    		}

    		if (ctx.subtitleY === undefined && !("subtitleY" in props)) {
    			console_1$1.warn("<Title> was created without expected prop 'subtitleY'");
    		}

    		if (ctx.transition === undefined && !("transition" in props)) {
    			console_1$1.warn("<Title> was created without expected prop 'transition'");
    		}

    		if (ctx.onClick === undefined && !("onClick" in props)) {
    			console_1$1.warn("<Title> was created without expected prop 'onClick'");
    		}

    		if (ctx.onMouseover === undefined && !("onMouseover" in props)) {
    			console_1$1.warn("<Title> was created without expected prop 'onMouseover'");
    		}

    		if (ctx.onMouseout === undefined && !("onMouseout" in props)) {
    			console_1$1.warn("<Title> was created without expected prop 'onMouseout'");
    		}

    		if (ctx.zoomIdentity === undefined && !("zoomIdentity" in props)) {
    			console_1$1.warn("<Title> was created without expected prop 'zoomIdentity'");
    		}
    	}

    	get x() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get geometry() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set geometry(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get vjust() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set vjust(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hjust() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hjust(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xOffset() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xOffset(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get yOffset() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set yOffset(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get usePadding() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set usePadding(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleFill() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleFill(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleStroke() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleStroke(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleStrokeWidth() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleStrokeWidth(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleStrokeOpacity() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleStrokeOpacity(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleFillOpacity() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleFillOpacity(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleOpacity() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleOpacity(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleFontFamily() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleFontFamily(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleFontSize() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleFontSize(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleFontWeight() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleFontWeight(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleRotation() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleRotation(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleAnchorPoint() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleAnchorPoint(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subtitle() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitle(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subtitleFill() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitleFill(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subtitleStroke() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitleStroke(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subtitleStrokeWidth() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitleStrokeWidth(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subtitleStrokeOpacity() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitleStrokeOpacity(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subtitleFillOpacity() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitleFillOpacity(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subtitleOpacity() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitleOpacity(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subtitleFontFamily() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitleFontFamily(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subtitleFontSize() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitleFontSize(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subtitleFontWeight() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitleFontWeight(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subtitleRotation() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitleRotation(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subtitleAnchorPoint() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitleAnchorPoint(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subtitleX() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitleX(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subtitleY() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitleY(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transition() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transition(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClick() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClick(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseover() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseover(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseout() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseout(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zoomIdentity() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoomIdentity(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Marks/Point/Point.svelte generated by Svelte v3.15.0 */

    function create_fragment$8(ctx) {
    	let current;

    	const mark = new Mark({
    			props: {
    				type: "Point",
    				x: ctx.x,
    				y: ctx.y,
    				geometry: ctx.geometry,
    				radius: ctx.radius,
    				fill: ctx.fill,
    				stroke: ctx.stroke,
    				strokeWidth: ctx.strokeWidth,
    				strokeOpacity: ctx.strokeOpacity,
    				fillOpacity: ctx.fillOpacity,
    				opacity: ctx.opacity,
    				transition: ctx.transition,
    				onClick: ctx.onClick,
    				onMousedown: ctx.onMousedown,
    				onMouseup: ctx.onMouseup,
    				onMouseover: ctx.onMouseover,
    				onMouseout: ctx.onMouseout,
    				onMousedrag: ctx.onMousedrag,
    				onSelect: ctx.onSelect,
    				onDeselect: ctx.onDeselect,
    				zoomIdentity: ctx.zoomIdentity,
    				_asPolygon: false,
    				blockReindexing: ctx.blockReindexing
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mark.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(mark, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const mark_changes = {};
    			if (changed.x) mark_changes.x = ctx.x;
    			if (changed.y) mark_changes.y = ctx.y;
    			if (changed.geometry) mark_changes.geometry = ctx.geometry;
    			if (changed.radius) mark_changes.radius = ctx.radius;
    			if (changed.fill) mark_changes.fill = ctx.fill;
    			if (changed.stroke) mark_changes.stroke = ctx.stroke;
    			if (changed.strokeWidth) mark_changes.strokeWidth = ctx.strokeWidth;
    			if (changed.strokeOpacity) mark_changes.strokeOpacity = ctx.strokeOpacity;
    			if (changed.fillOpacity) mark_changes.fillOpacity = ctx.fillOpacity;
    			if (changed.opacity) mark_changes.opacity = ctx.opacity;
    			if (changed.transition) mark_changes.transition = ctx.transition;
    			if (changed.onClick) mark_changes.onClick = ctx.onClick;
    			if (changed.onMousedown) mark_changes.onMousedown = ctx.onMousedown;
    			if (changed.onMouseup) mark_changes.onMouseup = ctx.onMouseup;
    			if (changed.onMouseover) mark_changes.onMouseover = ctx.onMouseover;
    			if (changed.onMouseout) mark_changes.onMouseout = ctx.onMouseout;
    			if (changed.onMousedrag) mark_changes.onMousedrag = ctx.onMousedrag;
    			if (changed.onSelect) mark_changes.onSelect = ctx.onSelect;
    			if (changed.onDeselect) mark_changes.onDeselect = ctx.onDeselect;
    			if (changed.zoomIdentity) mark_changes.zoomIdentity = ctx.zoomIdentity;
    			if (changed.blockReindexing) mark_changes.blockReindexing = ctx.blockReindexing;
    			mark.$set(mark_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mark.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mark.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mark, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { x } = $$props;
    	let { y } = $$props;
    	let { geometry } = $$props;
    	let { radius } = $$props;
    	let { fill } = $$props;
    	let { stroke } = $$props;
    	let { strokeWidth } = $$props;
    	let { strokeOpacity } = $$props;
    	let { fillOpacity } = $$props;
    	let { opacity } = $$props;
    	let { transition } = $$props;
    	let { onClick } = $$props;
    	let { onMousedown } = $$props;
    	let { onMouseup } = $$props;
    	let { onMouseover } = $$props;
    	let { onMouseout } = $$props;
    	let { onMousedrag } = $$props;
    	let { onSelect } = $$props;
    	let { onDeselect } = $$props;
    	let { zoomIdentity } = $$props;
    	let { blockReindexing = false } = $$props;

    	const writable_props = [
    		"x",
    		"y",
    		"geometry",
    		"radius",
    		"fill",
    		"stroke",
    		"strokeWidth",
    		"strokeOpacity",
    		"fillOpacity",
    		"opacity",
    		"transition",
    		"onClick",
    		"onMousedown",
    		"onMouseup",
    		"onMouseover",
    		"onMouseout",
    		"onMousedrag",
    		"onSelect",
    		"onDeselect",
    		"zoomIdentity",
    		"blockReindexing"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Point> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("geometry" in $$props) $$invalidate("geometry", geometry = $$props.geometry);
    		if ("radius" in $$props) $$invalidate("radius", radius = $$props.radius);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("strokeOpacity" in $$props) $$invalidate("strokeOpacity", strokeOpacity = $$props.strokeOpacity);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	$$self.$capture_state = () => {
    		return {
    			x,
    			y,
    			geometry,
    			radius,
    			fill,
    			stroke,
    			strokeWidth,
    			strokeOpacity,
    			fillOpacity,
    			opacity,
    			transition,
    			onClick,
    			onMousedown,
    			onMouseup,
    			onMouseover,
    			onMouseout,
    			onMousedrag,
    			onSelect,
    			onDeselect,
    			zoomIdentity,
    			blockReindexing
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("geometry" in $$props) $$invalidate("geometry", geometry = $$props.geometry);
    		if ("radius" in $$props) $$invalidate("radius", radius = $$props.radius);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("strokeOpacity" in $$props) $$invalidate("strokeOpacity", strokeOpacity = $$props.strokeOpacity);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	return {
    		x,
    		y,
    		geometry,
    		radius,
    		fill,
    		stroke,
    		strokeWidth,
    		strokeOpacity,
    		fillOpacity,
    		opacity,
    		transition,
    		onClick,
    		onMousedown,
    		onMouseup,
    		onMouseover,
    		onMouseout,
    		onMousedrag,
    		onSelect,
    		onDeselect,
    		zoomIdentity,
    		blockReindexing
    	};
    }

    class Point extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {
    			x: 0,
    			y: 0,
    			geometry: 0,
    			radius: 0,
    			fill: 0,
    			stroke: 0,
    			strokeWidth: 0,
    			strokeOpacity: 0,
    			fillOpacity: 0,
    			opacity: 0,
    			transition: 0,
    			onClick: 0,
    			onMousedown: 0,
    			onMouseup: 0,
    			onMouseover: 0,
    			onMouseout: 0,
    			onMousedrag: 0,
    			onSelect: 0,
    			onDeselect: 0,
    			zoomIdentity: 0,
    			blockReindexing: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Point",
    			options,
    			id: create_fragment$8.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || ({});

    		if (ctx.x === undefined && !("x" in props)) {
    			console.warn("<Point> was created without expected prop 'x'");
    		}

    		if (ctx.y === undefined && !("y" in props)) {
    			console.warn("<Point> was created without expected prop 'y'");
    		}

    		if (ctx.geometry === undefined && !("geometry" in props)) {
    			console.warn("<Point> was created without expected prop 'geometry'");
    		}

    		if (ctx.radius === undefined && !("radius" in props)) {
    			console.warn("<Point> was created without expected prop 'radius'");
    		}

    		if (ctx.fill === undefined && !("fill" in props)) {
    			console.warn("<Point> was created without expected prop 'fill'");
    		}

    		if (ctx.stroke === undefined && !("stroke" in props)) {
    			console.warn("<Point> was created without expected prop 'stroke'");
    		}

    		if (ctx.strokeWidth === undefined && !("strokeWidth" in props)) {
    			console.warn("<Point> was created without expected prop 'strokeWidth'");
    		}

    		if (ctx.strokeOpacity === undefined && !("strokeOpacity" in props)) {
    			console.warn("<Point> was created without expected prop 'strokeOpacity'");
    		}

    		if (ctx.fillOpacity === undefined && !("fillOpacity" in props)) {
    			console.warn("<Point> was created without expected prop 'fillOpacity'");
    		}

    		if (ctx.opacity === undefined && !("opacity" in props)) {
    			console.warn("<Point> was created without expected prop 'opacity'");
    		}

    		if (ctx.transition === undefined && !("transition" in props)) {
    			console.warn("<Point> was created without expected prop 'transition'");
    		}

    		if (ctx.onClick === undefined && !("onClick" in props)) {
    			console.warn("<Point> was created without expected prop 'onClick'");
    		}

    		if (ctx.onMousedown === undefined && !("onMousedown" in props)) {
    			console.warn("<Point> was created without expected prop 'onMousedown'");
    		}

    		if (ctx.onMouseup === undefined && !("onMouseup" in props)) {
    			console.warn("<Point> was created without expected prop 'onMouseup'");
    		}

    		if (ctx.onMouseover === undefined && !("onMouseover" in props)) {
    			console.warn("<Point> was created without expected prop 'onMouseover'");
    		}

    		if (ctx.onMouseout === undefined && !("onMouseout" in props)) {
    			console.warn("<Point> was created without expected prop 'onMouseout'");
    		}

    		if (ctx.onMousedrag === undefined && !("onMousedrag" in props)) {
    			console.warn("<Point> was created without expected prop 'onMousedrag'");
    		}

    		if (ctx.onSelect === undefined && !("onSelect" in props)) {
    			console.warn("<Point> was created without expected prop 'onSelect'");
    		}

    		if (ctx.onDeselect === undefined && !("onDeselect" in props)) {
    			console.warn("<Point> was created without expected prop 'onDeselect'");
    		}

    		if (ctx.zoomIdentity === undefined && !("zoomIdentity" in props)) {
    			console.warn("<Point> was created without expected prop 'zoomIdentity'");
    		}
    	}

    	get x() {
    		throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x(value) {
    		throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y() {
    		throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y(value) {
    		throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get geometry() {
    		throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set geometry(value) {
    		throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get radius() {
    		throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radius(value) {
    		throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fill() {
    		throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fill(value) {
    		throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stroke() {
    		throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stroke(value) {
    		throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeWidth() {
    		throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeWidth(value) {
    		throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeOpacity() {
    		throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeOpacity(value) {
    		throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillOpacity() {
    		throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillOpacity(value) {
    		throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opacity() {
    		throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opacity(value) {
    		throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transition() {
    		throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transition(value) {
    		throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClick() {
    		throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClick(value) {
    		throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedown() {
    		throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedown(value) {
    		throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseup() {
    		throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseup(value) {
    		throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseover() {
    		throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseover(value) {
    		throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseout() {
    		throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseout(value) {
    		throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedrag() {
    		throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedrag(value) {
    		throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSelect() {
    		throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSelect(value) {
    		throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onDeselect() {
    		throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onDeselect(value) {
    		throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zoomIdentity() {
    		throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoomIdentity(value) {
    		throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blockReindexing() {
    		throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blockReindexing(value) {
    		throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Marks/Rectangle/Rectangle.svelte generated by Svelte v3.15.0 */

    function create_fragment$9(ctx) {
    	let current;

    	const mark = new Mark({
    			props: {
    				type: "Rectangle",
    				x1: ctx.x1,
    				x2: ctx.x2,
    				y1: ctx.y1,
    				y2: ctx.y2,
    				fill: ctx.fill,
    				stroke: ctx.stroke,
    				strokeWidth: ctx.strokeWidth,
    				strokeOpacity: ctx.strokeOpacity,
    				fillOpacity: ctx.fillOpacity,
    				opacity: ctx.opacity,
    				transition: ctx.transition,
    				onClick: ctx.onClick,
    				onMousedown: ctx.onMousedown,
    				onMouseup: ctx.onMouseup,
    				onMouseover: ctx.onMouseover,
    				onMouseout: ctx.onMouseout,
    				onMousedrag: ctx.onMousedrag,
    				onSelect: ctx.onSelect,
    				onDeselect: ctx.onDeselect,
    				zoomIdentity: ctx.zoomIdentity,
    				interpolate: ctx.interpolate,
    				blockReindexing: ctx.blockReindexing
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mark.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(mark, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const mark_changes = {};
    			if (changed.x1) mark_changes.x1 = ctx.x1;
    			if (changed.x2) mark_changes.x2 = ctx.x2;
    			if (changed.y1) mark_changes.y1 = ctx.y1;
    			if (changed.y2) mark_changes.y2 = ctx.y2;
    			if (changed.fill) mark_changes.fill = ctx.fill;
    			if (changed.stroke) mark_changes.stroke = ctx.stroke;
    			if (changed.strokeWidth) mark_changes.strokeWidth = ctx.strokeWidth;
    			if (changed.strokeOpacity) mark_changes.strokeOpacity = ctx.strokeOpacity;
    			if (changed.fillOpacity) mark_changes.fillOpacity = ctx.fillOpacity;
    			if (changed.opacity) mark_changes.opacity = ctx.opacity;
    			if (changed.transition) mark_changes.transition = ctx.transition;
    			if (changed.onClick) mark_changes.onClick = ctx.onClick;
    			if (changed.onMousedown) mark_changes.onMousedown = ctx.onMousedown;
    			if (changed.onMouseup) mark_changes.onMouseup = ctx.onMouseup;
    			if (changed.onMouseover) mark_changes.onMouseover = ctx.onMouseover;
    			if (changed.onMouseout) mark_changes.onMouseout = ctx.onMouseout;
    			if (changed.onMousedrag) mark_changes.onMousedrag = ctx.onMousedrag;
    			if (changed.onSelect) mark_changes.onSelect = ctx.onSelect;
    			if (changed.onDeselect) mark_changes.onDeselect = ctx.onDeselect;
    			if (changed.zoomIdentity) mark_changes.zoomIdentity = ctx.zoomIdentity;
    			if (changed.interpolate) mark_changes.interpolate = ctx.interpolate;
    			if (changed.blockReindexing) mark_changes.blockReindexing = ctx.blockReindexing;
    			mark.$set(mark_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mark.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mark.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mark, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { x1 } = $$props;
    	let { x2 } = $$props;
    	let { y1 } = $$props;
    	let { y2 } = $$props;
    	let { fill } = $$props;
    	let { stroke } = $$props;
    	let { strokeWidth } = $$props;
    	let { strokeOpacity } = $$props;
    	let { fillOpacity } = $$props;
    	let { opacity } = $$props;
    	let { transition } = $$props;
    	let { onClick } = $$props;
    	let { onMousedown } = $$props;
    	let { onMouseup } = $$props;
    	let { onMouseover } = $$props;
    	let { onMouseout } = $$props;
    	let { onMousedrag } = $$props;
    	let { onSelect } = $$props;
    	let { onDeselect } = $$props;
    	let { interpolate = true } = $$props;
    	let { zoomIdentity } = $$props;
    	let { blockReindexing = false } = $$props;

    	const writable_props = [
    		"x1",
    		"x2",
    		"y1",
    		"y2",
    		"fill",
    		"stroke",
    		"strokeWidth",
    		"strokeOpacity",
    		"fillOpacity",
    		"opacity",
    		"transition",
    		"onClick",
    		"onMousedown",
    		"onMouseup",
    		"onMouseover",
    		"onMouseout",
    		"onMousedrag",
    		"onSelect",
    		"onDeselect",
    		"interpolate",
    		"zoomIdentity",
    		"blockReindexing"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Rectangle> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("x1" in $$props) $$invalidate("x1", x1 = $$props.x1);
    		if ("x2" in $$props) $$invalidate("x2", x2 = $$props.x2);
    		if ("y1" in $$props) $$invalidate("y1", y1 = $$props.y1);
    		if ("y2" in $$props) $$invalidate("y2", y2 = $$props.y2);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("strokeOpacity" in $$props) $$invalidate("strokeOpacity", strokeOpacity = $$props.strokeOpacity);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("interpolate" in $$props) $$invalidate("interpolate", interpolate = $$props.interpolate);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	$$self.$capture_state = () => {
    		return {
    			x1,
    			x2,
    			y1,
    			y2,
    			fill,
    			stroke,
    			strokeWidth,
    			strokeOpacity,
    			fillOpacity,
    			opacity,
    			transition,
    			onClick,
    			onMousedown,
    			onMouseup,
    			onMouseover,
    			onMouseout,
    			onMousedrag,
    			onSelect,
    			onDeselect,
    			interpolate,
    			zoomIdentity,
    			blockReindexing
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("x1" in $$props) $$invalidate("x1", x1 = $$props.x1);
    		if ("x2" in $$props) $$invalidate("x2", x2 = $$props.x2);
    		if ("y1" in $$props) $$invalidate("y1", y1 = $$props.y1);
    		if ("y2" in $$props) $$invalidate("y2", y2 = $$props.y2);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("strokeOpacity" in $$props) $$invalidate("strokeOpacity", strokeOpacity = $$props.strokeOpacity);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("interpolate" in $$props) $$invalidate("interpolate", interpolate = $$props.interpolate);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	return {
    		x1,
    		x2,
    		y1,
    		y2,
    		fill,
    		stroke,
    		strokeWidth,
    		strokeOpacity,
    		fillOpacity,
    		opacity,
    		transition,
    		onClick,
    		onMousedown,
    		onMouseup,
    		onMouseover,
    		onMouseout,
    		onMousedrag,
    		onSelect,
    		onDeselect,
    		interpolate,
    		zoomIdentity,
    		blockReindexing
    	};
    }

    class Rectangle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {
    			x1: 0,
    			x2: 0,
    			y1: 0,
    			y2: 0,
    			fill: 0,
    			stroke: 0,
    			strokeWidth: 0,
    			strokeOpacity: 0,
    			fillOpacity: 0,
    			opacity: 0,
    			transition: 0,
    			onClick: 0,
    			onMousedown: 0,
    			onMouseup: 0,
    			onMouseover: 0,
    			onMouseout: 0,
    			onMousedrag: 0,
    			onSelect: 0,
    			onDeselect: 0,
    			interpolate: 0,
    			zoomIdentity: 0,
    			blockReindexing: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Rectangle",
    			options,
    			id: create_fragment$9.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || ({});

    		if (ctx.x1 === undefined && !("x1" in props)) {
    			console.warn("<Rectangle> was created without expected prop 'x1'");
    		}

    		if (ctx.x2 === undefined && !("x2" in props)) {
    			console.warn("<Rectangle> was created without expected prop 'x2'");
    		}

    		if (ctx.y1 === undefined && !("y1" in props)) {
    			console.warn("<Rectangle> was created without expected prop 'y1'");
    		}

    		if (ctx.y2 === undefined && !("y2" in props)) {
    			console.warn("<Rectangle> was created without expected prop 'y2'");
    		}

    		if (ctx.fill === undefined && !("fill" in props)) {
    			console.warn("<Rectangle> was created without expected prop 'fill'");
    		}

    		if (ctx.stroke === undefined && !("stroke" in props)) {
    			console.warn("<Rectangle> was created without expected prop 'stroke'");
    		}

    		if (ctx.strokeWidth === undefined && !("strokeWidth" in props)) {
    			console.warn("<Rectangle> was created without expected prop 'strokeWidth'");
    		}

    		if (ctx.strokeOpacity === undefined && !("strokeOpacity" in props)) {
    			console.warn("<Rectangle> was created without expected prop 'strokeOpacity'");
    		}

    		if (ctx.fillOpacity === undefined && !("fillOpacity" in props)) {
    			console.warn("<Rectangle> was created without expected prop 'fillOpacity'");
    		}

    		if (ctx.opacity === undefined && !("opacity" in props)) {
    			console.warn("<Rectangle> was created without expected prop 'opacity'");
    		}

    		if (ctx.transition === undefined && !("transition" in props)) {
    			console.warn("<Rectangle> was created without expected prop 'transition'");
    		}

    		if (ctx.onClick === undefined && !("onClick" in props)) {
    			console.warn("<Rectangle> was created without expected prop 'onClick'");
    		}

    		if (ctx.onMousedown === undefined && !("onMousedown" in props)) {
    			console.warn("<Rectangle> was created without expected prop 'onMousedown'");
    		}

    		if (ctx.onMouseup === undefined && !("onMouseup" in props)) {
    			console.warn("<Rectangle> was created without expected prop 'onMouseup'");
    		}

    		if (ctx.onMouseover === undefined && !("onMouseover" in props)) {
    			console.warn("<Rectangle> was created without expected prop 'onMouseover'");
    		}

    		if (ctx.onMouseout === undefined && !("onMouseout" in props)) {
    			console.warn("<Rectangle> was created without expected prop 'onMouseout'");
    		}

    		if (ctx.onMousedrag === undefined && !("onMousedrag" in props)) {
    			console.warn("<Rectangle> was created without expected prop 'onMousedrag'");
    		}

    		if (ctx.onSelect === undefined && !("onSelect" in props)) {
    			console.warn("<Rectangle> was created without expected prop 'onSelect'");
    		}

    		if (ctx.onDeselect === undefined && !("onDeselect" in props)) {
    			console.warn("<Rectangle> was created without expected prop 'onDeselect'");
    		}

    		if (ctx.zoomIdentity === undefined && !("zoomIdentity" in props)) {
    			console.warn("<Rectangle> was created without expected prop 'zoomIdentity'");
    		}
    	}

    	get x1() {
    		throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x1(value) {
    		throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get x2() {
    		throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x2(value) {
    		throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y1() {
    		throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y1(value) {
    		throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y2() {
    		throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y2(value) {
    		throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fill() {
    		throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fill(value) {
    		throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stroke() {
    		throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stroke(value) {
    		throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeWidth() {
    		throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeWidth(value) {
    		throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeOpacity() {
    		throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeOpacity(value) {
    		throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillOpacity() {
    		throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillOpacity(value) {
    		throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opacity() {
    		throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opacity(value) {
    		throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transition() {
    		throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transition(value) {
    		throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClick() {
    		throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClick(value) {
    		throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedown() {
    		throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedown(value) {
    		throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseup() {
    		throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseup(value) {
    		throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseover() {
    		throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseover(value) {
    		throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseout() {
    		throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseout(value) {
    		throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedrag() {
    		throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedrag(value) {
    		throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSelect() {
    		throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSelect(value) {
    		throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onDeselect() {
    		throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onDeselect(value) {
    		throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get interpolate() {
    		throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set interpolate(value) {
    		throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zoomIdentity() {
    		throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoomIdentity(value) {
    		throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blockReindexing() {
    		throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blockReindexing(value) {
    		throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Marks/Polygon/Polygon.svelte generated by Svelte v3.15.0 */

    function create_fragment$a(ctx) {
    	let current;

    	const mark = new Mark({
    			props: {
    				type: "Polygon",
    				x: ctx.x,
    				y: ctx.y,
    				geometry: ctx.geometry,
    				fill: ctx.fill,
    				stroke: ctx.stroke,
    				strokeWidth: ctx.strokeWidth,
    				strokeOpacity: ctx.strokeOpacity,
    				fillOpacity: ctx.fillOpacity,
    				opacity: ctx.opacity,
    				transition: ctx.transition,
    				onClick: ctx.onClick,
    				onMousedown: ctx.onMousedown,
    				onMouseup: ctx.onMouseup,
    				onMouseover: ctx.onMouseover,
    				onMouseout: ctx.onMouseout,
    				onMousedrag: ctx.onMousedrag,
    				onSelect: ctx.onSelect,
    				onDeselect: ctx.onDeselect,
    				interpolate: ctx.interpolate,
    				zoomIdentity: ctx.zoomIdentity,
    				blockReindexing: ctx.blockReindexing
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mark.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(mark, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const mark_changes = {};
    			if (changed.x) mark_changes.x = ctx.x;
    			if (changed.y) mark_changes.y = ctx.y;
    			if (changed.geometry) mark_changes.geometry = ctx.geometry;
    			if (changed.fill) mark_changes.fill = ctx.fill;
    			if (changed.stroke) mark_changes.stroke = ctx.stroke;
    			if (changed.strokeWidth) mark_changes.strokeWidth = ctx.strokeWidth;
    			if (changed.strokeOpacity) mark_changes.strokeOpacity = ctx.strokeOpacity;
    			if (changed.fillOpacity) mark_changes.fillOpacity = ctx.fillOpacity;
    			if (changed.opacity) mark_changes.opacity = ctx.opacity;
    			if (changed.transition) mark_changes.transition = ctx.transition;
    			if (changed.onClick) mark_changes.onClick = ctx.onClick;
    			if (changed.onMousedown) mark_changes.onMousedown = ctx.onMousedown;
    			if (changed.onMouseup) mark_changes.onMouseup = ctx.onMouseup;
    			if (changed.onMouseover) mark_changes.onMouseover = ctx.onMouseover;
    			if (changed.onMouseout) mark_changes.onMouseout = ctx.onMouseout;
    			if (changed.onMousedrag) mark_changes.onMousedrag = ctx.onMousedrag;
    			if (changed.onSelect) mark_changes.onSelect = ctx.onSelect;
    			if (changed.onDeselect) mark_changes.onDeselect = ctx.onDeselect;
    			if (changed.interpolate) mark_changes.interpolate = ctx.interpolate;
    			if (changed.zoomIdentity) mark_changes.zoomIdentity = ctx.zoomIdentity;
    			if (changed.blockReindexing) mark_changes.blockReindexing = ctx.blockReindexing;
    			mark.$set(mark_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mark.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mark.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mark, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { x } = $$props;
    	let { y } = $$props;
    	let { geometry } = $$props;
    	let { fill } = $$props;
    	let { stroke } = $$props;
    	let { strokeWidth } = $$props;
    	let { strokeOpacity } = $$props;
    	let { fillOpacity } = $$props;
    	let { opacity } = $$props;
    	let { transition } = $$props;
    	let { onClick } = $$props;
    	let { onMousedown } = $$props;
    	let { onMouseup } = $$props;
    	let { onMouseover } = $$props;
    	let { onMouseout } = $$props;
    	let { onMousedrag } = $$props;
    	let { onSelect } = $$props;
    	let { onDeselect } = $$props;
    	let { interpolate = false } = $$props;
    	let { zoomIdentity } = $$props;
    	let { blockReindexing = false } = $$props;

    	const writable_props = [
    		"x",
    		"y",
    		"geometry",
    		"fill",
    		"stroke",
    		"strokeWidth",
    		"strokeOpacity",
    		"fillOpacity",
    		"opacity",
    		"transition",
    		"onClick",
    		"onMousedown",
    		"onMouseup",
    		"onMouseover",
    		"onMouseout",
    		"onMousedrag",
    		"onSelect",
    		"onDeselect",
    		"interpolate",
    		"zoomIdentity",
    		"blockReindexing"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Polygon> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("geometry" in $$props) $$invalidate("geometry", geometry = $$props.geometry);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("strokeOpacity" in $$props) $$invalidate("strokeOpacity", strokeOpacity = $$props.strokeOpacity);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("interpolate" in $$props) $$invalidate("interpolate", interpolate = $$props.interpolate);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	$$self.$capture_state = () => {
    		return {
    			x,
    			y,
    			geometry,
    			fill,
    			stroke,
    			strokeWidth,
    			strokeOpacity,
    			fillOpacity,
    			opacity,
    			transition,
    			onClick,
    			onMousedown,
    			onMouseup,
    			onMouseover,
    			onMouseout,
    			onMousedrag,
    			onSelect,
    			onDeselect,
    			interpolate,
    			zoomIdentity,
    			blockReindexing
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("geometry" in $$props) $$invalidate("geometry", geometry = $$props.geometry);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("strokeOpacity" in $$props) $$invalidate("strokeOpacity", strokeOpacity = $$props.strokeOpacity);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("interpolate" in $$props) $$invalidate("interpolate", interpolate = $$props.interpolate);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	return {
    		x,
    		y,
    		geometry,
    		fill,
    		stroke,
    		strokeWidth,
    		strokeOpacity,
    		fillOpacity,
    		opacity,
    		transition,
    		onClick,
    		onMousedown,
    		onMouseup,
    		onMouseover,
    		onMouseout,
    		onMousedrag,
    		onSelect,
    		onDeselect,
    		interpolate,
    		zoomIdentity,
    		blockReindexing
    	};
    }

    class Polygon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {
    			x: 0,
    			y: 0,
    			geometry: 0,
    			fill: 0,
    			stroke: 0,
    			strokeWidth: 0,
    			strokeOpacity: 0,
    			fillOpacity: 0,
    			opacity: 0,
    			transition: 0,
    			onClick: 0,
    			onMousedown: 0,
    			onMouseup: 0,
    			onMouseover: 0,
    			onMouseout: 0,
    			onMousedrag: 0,
    			onSelect: 0,
    			onDeselect: 0,
    			interpolate: 0,
    			zoomIdentity: 0,
    			blockReindexing: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Polygon",
    			options,
    			id: create_fragment$a.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || ({});

    		if (ctx.x === undefined && !("x" in props)) {
    			console.warn("<Polygon> was created without expected prop 'x'");
    		}

    		if (ctx.y === undefined && !("y" in props)) {
    			console.warn("<Polygon> was created without expected prop 'y'");
    		}

    		if (ctx.geometry === undefined && !("geometry" in props)) {
    			console.warn("<Polygon> was created without expected prop 'geometry'");
    		}

    		if (ctx.fill === undefined && !("fill" in props)) {
    			console.warn("<Polygon> was created without expected prop 'fill'");
    		}

    		if (ctx.stroke === undefined && !("stroke" in props)) {
    			console.warn("<Polygon> was created without expected prop 'stroke'");
    		}

    		if (ctx.strokeWidth === undefined && !("strokeWidth" in props)) {
    			console.warn("<Polygon> was created without expected prop 'strokeWidth'");
    		}

    		if (ctx.strokeOpacity === undefined && !("strokeOpacity" in props)) {
    			console.warn("<Polygon> was created without expected prop 'strokeOpacity'");
    		}

    		if (ctx.fillOpacity === undefined && !("fillOpacity" in props)) {
    			console.warn("<Polygon> was created without expected prop 'fillOpacity'");
    		}

    		if (ctx.opacity === undefined && !("opacity" in props)) {
    			console.warn("<Polygon> was created without expected prop 'opacity'");
    		}

    		if (ctx.transition === undefined && !("transition" in props)) {
    			console.warn("<Polygon> was created without expected prop 'transition'");
    		}

    		if (ctx.onClick === undefined && !("onClick" in props)) {
    			console.warn("<Polygon> was created without expected prop 'onClick'");
    		}

    		if (ctx.onMousedown === undefined && !("onMousedown" in props)) {
    			console.warn("<Polygon> was created without expected prop 'onMousedown'");
    		}

    		if (ctx.onMouseup === undefined && !("onMouseup" in props)) {
    			console.warn("<Polygon> was created without expected prop 'onMouseup'");
    		}

    		if (ctx.onMouseover === undefined && !("onMouseover" in props)) {
    			console.warn("<Polygon> was created without expected prop 'onMouseover'");
    		}

    		if (ctx.onMouseout === undefined && !("onMouseout" in props)) {
    			console.warn("<Polygon> was created without expected prop 'onMouseout'");
    		}

    		if (ctx.onMousedrag === undefined && !("onMousedrag" in props)) {
    			console.warn("<Polygon> was created without expected prop 'onMousedrag'");
    		}

    		if (ctx.onSelect === undefined && !("onSelect" in props)) {
    			console.warn("<Polygon> was created without expected prop 'onSelect'");
    		}

    		if (ctx.onDeselect === undefined && !("onDeselect" in props)) {
    			console.warn("<Polygon> was created without expected prop 'onDeselect'");
    		}

    		if (ctx.zoomIdentity === undefined && !("zoomIdentity" in props)) {
    			console.warn("<Polygon> was created without expected prop 'zoomIdentity'");
    		}
    	}

    	get x() {
    		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x(value) {
    		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y() {
    		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y(value) {
    		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get geometry() {
    		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set geometry(value) {
    		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fill() {
    		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fill(value) {
    		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stroke() {
    		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stroke(value) {
    		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeWidth() {
    		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeWidth(value) {
    		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeOpacity() {
    		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeOpacity(value) {
    		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillOpacity() {
    		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillOpacity(value) {
    		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opacity() {
    		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opacity(value) {
    		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transition() {
    		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transition(value) {
    		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClick() {
    		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClick(value) {
    		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedown() {
    		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedown(value) {
    		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseup() {
    		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseup(value) {
    		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseover() {
    		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseover(value) {
    		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseout() {
    		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseout(value) {
    		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedrag() {
    		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedrag(value) {
    		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSelect() {
    		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSelect(value) {
    		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onDeselect() {
    		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onDeselect(value) {
    		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get interpolate() {
    		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set interpolate(value) {
    		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zoomIdentity() {
    		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoomIdentity(value) {
    		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blockReindexing() {
    		throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blockReindexing(value) {
    		throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Marks/Line/Line.svelte generated by Svelte v3.15.0 */

    function create_fragment$b(ctx) {
    	let current;

    	const mark = new Mark({
    			props: {
    				type: "Line",
    				x: ctx.x,
    				y: ctx.y,
    				geometry: ctx.geometry,
    				strokeWidth: ctx.strokeWidth,
    				stroke: ctx.stroke,
    				opacity: ctx.opacity,
    				transition: ctx.transition,
    				onClick: ctx.onClick,
    				onMousedown: ctx.onMousedown,
    				onMouseup: ctx.onMouseup,
    				onMouseover: ctx.onMouseover,
    				onMouseout: ctx.onMouseout,
    				onMousedrag: ctx.onMousedrag,
    				onSelect: ctx.onSelect,
    				onDeselect: ctx.onDeselect,
    				interpolate: ctx.interpolate,
    				zoomIdentity: ctx.zoomIdentity,
    				_asPolygon: false,
    				blockReindexing: ctx.blockReindexing
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mark.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(mark, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const mark_changes = {};
    			if (changed.x) mark_changes.x = ctx.x;
    			if (changed.y) mark_changes.y = ctx.y;
    			if (changed.geometry) mark_changes.geometry = ctx.geometry;
    			if (changed.strokeWidth) mark_changes.strokeWidth = ctx.strokeWidth;
    			if (changed.stroke) mark_changes.stroke = ctx.stroke;
    			if (changed.opacity) mark_changes.opacity = ctx.opacity;
    			if (changed.transition) mark_changes.transition = ctx.transition;
    			if (changed.onClick) mark_changes.onClick = ctx.onClick;
    			if (changed.onMousedown) mark_changes.onMousedown = ctx.onMousedown;
    			if (changed.onMouseup) mark_changes.onMouseup = ctx.onMouseup;
    			if (changed.onMouseover) mark_changes.onMouseover = ctx.onMouseover;
    			if (changed.onMouseout) mark_changes.onMouseout = ctx.onMouseout;
    			if (changed.onMousedrag) mark_changes.onMousedrag = ctx.onMousedrag;
    			if (changed.onSelect) mark_changes.onSelect = ctx.onSelect;
    			if (changed.onDeselect) mark_changes.onDeselect = ctx.onDeselect;
    			if (changed.interpolate) mark_changes.interpolate = ctx.interpolate;
    			if (changed.zoomIdentity) mark_changes.zoomIdentity = ctx.zoomIdentity;
    			if (changed.blockReindexing) mark_changes.blockReindexing = ctx.blockReindexing;
    			mark.$set(mark_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mark.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mark.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mark, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { x } = $$props;
    	let { y } = $$props;
    	let { geometry } = $$props;
    	let { strokeWidth } = $$props;
    	let { stroke } = $$props;
    	let { opacity } = $$props;
    	let { transition } = $$props;
    	let { onClick } = $$props;
    	let { onMousedown } = $$props;
    	let { onMouseup } = $$props;
    	let { onMouseover } = $$props;
    	let { onMouseout } = $$props;
    	let { onMousedrag } = $$props;
    	let { onSelect } = $$props;
    	let { onDeselect } = $$props;
    	let { interpolate = true } = $$props;
    	let { zoomIdentity } = $$props;
    	let { blockReindexing = false } = $$props;

    	const writable_props = [
    		"x",
    		"y",
    		"geometry",
    		"strokeWidth",
    		"stroke",
    		"opacity",
    		"transition",
    		"onClick",
    		"onMousedown",
    		"onMouseup",
    		"onMouseover",
    		"onMouseout",
    		"onMousedrag",
    		"onSelect",
    		"onDeselect",
    		"interpolate",
    		"zoomIdentity",
    		"blockReindexing"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Line> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("geometry" in $$props) $$invalidate("geometry", geometry = $$props.geometry);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("interpolate" in $$props) $$invalidate("interpolate", interpolate = $$props.interpolate);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	$$self.$capture_state = () => {
    		return {
    			x,
    			y,
    			geometry,
    			strokeWidth,
    			stroke,
    			opacity,
    			transition,
    			onClick,
    			onMousedown,
    			onMouseup,
    			onMouseover,
    			onMouseout,
    			onMousedrag,
    			onSelect,
    			onDeselect,
    			interpolate,
    			zoomIdentity,
    			blockReindexing
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("geometry" in $$props) $$invalidate("geometry", geometry = $$props.geometry);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("interpolate" in $$props) $$invalidate("interpolate", interpolate = $$props.interpolate);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	return {
    		x,
    		y,
    		geometry,
    		strokeWidth,
    		stroke,
    		opacity,
    		transition,
    		onClick,
    		onMousedown,
    		onMouseup,
    		onMouseover,
    		onMouseout,
    		onMousedrag,
    		onSelect,
    		onDeselect,
    		interpolate,
    		zoomIdentity,
    		blockReindexing
    	};
    }

    class Line extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {
    			x: 0,
    			y: 0,
    			geometry: 0,
    			strokeWidth: 0,
    			stroke: 0,
    			opacity: 0,
    			transition: 0,
    			onClick: 0,
    			onMousedown: 0,
    			onMouseup: 0,
    			onMouseover: 0,
    			onMouseout: 0,
    			onMousedrag: 0,
    			onSelect: 0,
    			onDeselect: 0,
    			interpolate: 0,
    			zoomIdentity: 0,
    			blockReindexing: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Line",
    			options,
    			id: create_fragment$b.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || ({});

    		if (ctx.x === undefined && !("x" in props)) {
    			console.warn("<Line> was created without expected prop 'x'");
    		}

    		if (ctx.y === undefined && !("y" in props)) {
    			console.warn("<Line> was created without expected prop 'y'");
    		}

    		if (ctx.geometry === undefined && !("geometry" in props)) {
    			console.warn("<Line> was created without expected prop 'geometry'");
    		}

    		if (ctx.strokeWidth === undefined && !("strokeWidth" in props)) {
    			console.warn("<Line> was created without expected prop 'strokeWidth'");
    		}

    		if (ctx.stroke === undefined && !("stroke" in props)) {
    			console.warn("<Line> was created without expected prop 'stroke'");
    		}

    		if (ctx.opacity === undefined && !("opacity" in props)) {
    			console.warn("<Line> was created without expected prop 'opacity'");
    		}

    		if (ctx.transition === undefined && !("transition" in props)) {
    			console.warn("<Line> was created without expected prop 'transition'");
    		}

    		if (ctx.onClick === undefined && !("onClick" in props)) {
    			console.warn("<Line> was created without expected prop 'onClick'");
    		}

    		if (ctx.onMousedown === undefined && !("onMousedown" in props)) {
    			console.warn("<Line> was created without expected prop 'onMousedown'");
    		}

    		if (ctx.onMouseup === undefined && !("onMouseup" in props)) {
    			console.warn("<Line> was created without expected prop 'onMouseup'");
    		}

    		if (ctx.onMouseover === undefined && !("onMouseover" in props)) {
    			console.warn("<Line> was created without expected prop 'onMouseover'");
    		}

    		if (ctx.onMouseout === undefined && !("onMouseout" in props)) {
    			console.warn("<Line> was created without expected prop 'onMouseout'");
    		}

    		if (ctx.onMousedrag === undefined && !("onMousedrag" in props)) {
    			console.warn("<Line> was created without expected prop 'onMousedrag'");
    		}

    		if (ctx.onSelect === undefined && !("onSelect" in props)) {
    			console.warn("<Line> was created without expected prop 'onSelect'");
    		}

    		if (ctx.onDeselect === undefined && !("onDeselect" in props)) {
    			console.warn("<Line> was created without expected prop 'onDeselect'");
    		}

    		if (ctx.zoomIdentity === undefined && !("zoomIdentity" in props)) {
    			console.warn("<Line> was created without expected prop 'zoomIdentity'");
    		}
    	}

    	get x() {
    		throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x(value) {
    		throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y() {
    		throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y(value) {
    		throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get geometry() {
    		throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set geometry(value) {
    		throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeWidth() {
    		throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeWidth(value) {
    		throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stroke() {
    		throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stroke(value) {
    		throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opacity() {
    		throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opacity(value) {
    		throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transition() {
    		throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transition(value) {
    		throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClick() {
    		throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClick(value) {
    		throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedown() {
    		throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedown(value) {
    		throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseup() {
    		throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseup(value) {
    		throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseover() {
    		throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseover(value) {
    		throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseout() {
    		throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseout(value) {
    		throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedrag() {
    		throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedrag(value) {
    		throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSelect() {
    		throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSelect(value) {
    		throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onDeselect() {
    		throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onDeselect(value) {
    		throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get interpolate() {
    		throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set interpolate(value) {
    		throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zoomIdentity() {
    		throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoomIdentity(value) {
    		throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blockReindexing() {
    		throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blockReindexing(value) {
    		throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Marks/Label/Label.svelte generated by Svelte v3.15.0 */

    function create_fragment$c(ctx) {
    	let current;

    	const mark = new Mark({
    			props: {
    				type: "Label",
    				x: ctx.x,
    				y: ctx.y,
    				geometry: ctx.geometry,
    				fill: ctx.fill,
    				stroke: ctx.stroke,
    				strokeWidth: ctx.strokeWidth,
    				strokeOpacity: ctx.strokeOpacity,
    				fillOpacity: ctx.fillOpacity,
    				opacity: ctx.opacity,
    				text: ctx.text,
    				fontFamily: ctx.fontFamily,
    				fontSize: ctx.fontSize,
    				fontWeight: ctx.fontWeight,
    				rotation: ctx.rotation,
    				anchorPoint: ctx.anchorPoint,
    				transition: ctx.transition,
    				onClick: ctx.onClick,
    				onMousedown: ctx.onMousedown,
    				onMouseup: ctx.onMouseup,
    				onMouseover: ctx.onMouseover,
    				onMouseout: ctx.onMouseout,
    				onMousedrag: ctx.onMousedrag,
    				onSelect: ctx.onSelect,
    				onDeselect: ctx.onDeselect,
    				zoomIdentity: ctx.zoomIdentity,
    				_asPolygon: false,
    				blockReindexing: ctx.blockReindexing
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mark.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(mark, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const mark_changes = {};
    			if (changed.x) mark_changes.x = ctx.x;
    			if (changed.y) mark_changes.y = ctx.y;
    			if (changed.geometry) mark_changes.geometry = ctx.geometry;
    			if (changed.fill) mark_changes.fill = ctx.fill;
    			if (changed.stroke) mark_changes.stroke = ctx.stroke;
    			if (changed.strokeWidth) mark_changes.strokeWidth = ctx.strokeWidth;
    			if (changed.strokeOpacity) mark_changes.strokeOpacity = ctx.strokeOpacity;
    			if (changed.fillOpacity) mark_changes.fillOpacity = ctx.fillOpacity;
    			if (changed.opacity) mark_changes.opacity = ctx.opacity;
    			if (changed.text) mark_changes.text = ctx.text;
    			if (changed.fontFamily) mark_changes.fontFamily = ctx.fontFamily;
    			if (changed.fontSize) mark_changes.fontSize = ctx.fontSize;
    			if (changed.fontWeight) mark_changes.fontWeight = ctx.fontWeight;
    			if (changed.rotation) mark_changes.rotation = ctx.rotation;
    			if (changed.anchorPoint) mark_changes.anchorPoint = ctx.anchorPoint;
    			if (changed.transition) mark_changes.transition = ctx.transition;
    			if (changed.onClick) mark_changes.onClick = ctx.onClick;
    			if (changed.onMousedown) mark_changes.onMousedown = ctx.onMousedown;
    			if (changed.onMouseup) mark_changes.onMouseup = ctx.onMouseup;
    			if (changed.onMouseover) mark_changes.onMouseover = ctx.onMouseover;
    			if (changed.onMouseout) mark_changes.onMouseout = ctx.onMouseout;
    			if (changed.onMousedrag) mark_changes.onMousedrag = ctx.onMousedrag;
    			if (changed.onSelect) mark_changes.onSelect = ctx.onSelect;
    			if (changed.onDeselect) mark_changes.onDeselect = ctx.onDeselect;
    			if (changed.zoomIdentity) mark_changes.zoomIdentity = ctx.zoomIdentity;
    			if (changed.blockReindexing) mark_changes.blockReindexing = ctx.blockReindexing;
    			mark.$set(mark_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mark.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mark.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mark, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { x } = $$props;
    	let { y } = $$props;
    	let { geometry } = $$props;
    	let { fill } = $$props;
    	let { stroke } = $$props;
    	let { strokeWidth } = $$props;
    	let { strokeOpacity } = $$props;
    	let { fillOpacity } = $$props;
    	let { opacity } = $$props;
    	let { text } = $$props;
    	let { fontFamily } = $$props;
    	let { fontSize } = $$props;
    	let { fontWeight } = $$props;
    	let { rotation } = $$props;
    	let { anchorPoint } = $$props;
    	let { transition } = $$props;
    	let { onClick } = $$props;
    	let { onMousedown } = $$props;
    	let { onMouseup } = $$props;
    	let { onMouseover } = $$props;
    	let { onMouseout } = $$props;
    	let { onMousedrag } = $$props;
    	let { onSelect } = $$props;
    	let { onDeselect } = $$props;
    	let { zoomIdentity } = $$props;
    	let { blockReindexing = false } = $$props;

    	const writable_props = [
    		"x",
    		"y",
    		"geometry",
    		"fill",
    		"stroke",
    		"strokeWidth",
    		"strokeOpacity",
    		"fillOpacity",
    		"opacity",
    		"text",
    		"fontFamily",
    		"fontSize",
    		"fontWeight",
    		"rotation",
    		"anchorPoint",
    		"transition",
    		"onClick",
    		"onMousedown",
    		"onMouseup",
    		"onMouseover",
    		"onMouseout",
    		"onMousedrag",
    		"onSelect",
    		"onDeselect",
    		"zoomIdentity",
    		"blockReindexing"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Label> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("geometry" in $$props) $$invalidate("geometry", geometry = $$props.geometry);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("strokeOpacity" in $$props) $$invalidate("strokeOpacity", strokeOpacity = $$props.strokeOpacity);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("text" in $$props) $$invalidate("text", text = $$props.text);
    		if ("fontFamily" in $$props) $$invalidate("fontFamily", fontFamily = $$props.fontFamily);
    		if ("fontSize" in $$props) $$invalidate("fontSize", fontSize = $$props.fontSize);
    		if ("fontWeight" in $$props) $$invalidate("fontWeight", fontWeight = $$props.fontWeight);
    		if ("rotation" in $$props) $$invalidate("rotation", rotation = $$props.rotation);
    		if ("anchorPoint" in $$props) $$invalidate("anchorPoint", anchorPoint = $$props.anchorPoint);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	$$self.$capture_state = () => {
    		return {
    			x,
    			y,
    			geometry,
    			fill,
    			stroke,
    			strokeWidth,
    			strokeOpacity,
    			fillOpacity,
    			opacity,
    			text,
    			fontFamily,
    			fontSize,
    			fontWeight,
    			rotation,
    			anchorPoint,
    			transition,
    			onClick,
    			onMousedown,
    			onMouseup,
    			onMouseover,
    			onMouseout,
    			onMousedrag,
    			onSelect,
    			onDeselect,
    			zoomIdentity,
    			blockReindexing
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("geometry" in $$props) $$invalidate("geometry", geometry = $$props.geometry);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("strokeOpacity" in $$props) $$invalidate("strokeOpacity", strokeOpacity = $$props.strokeOpacity);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("text" in $$props) $$invalidate("text", text = $$props.text);
    		if ("fontFamily" in $$props) $$invalidate("fontFamily", fontFamily = $$props.fontFamily);
    		if ("fontSize" in $$props) $$invalidate("fontSize", fontSize = $$props.fontSize);
    		if ("fontWeight" in $$props) $$invalidate("fontWeight", fontWeight = $$props.fontWeight);
    		if ("rotation" in $$props) $$invalidate("rotation", rotation = $$props.rotation);
    		if ("anchorPoint" in $$props) $$invalidate("anchorPoint", anchorPoint = $$props.anchorPoint);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	return {
    		x,
    		y,
    		geometry,
    		fill,
    		stroke,
    		strokeWidth,
    		strokeOpacity,
    		fillOpacity,
    		opacity,
    		text,
    		fontFamily,
    		fontSize,
    		fontWeight,
    		rotation,
    		anchorPoint,
    		transition,
    		onClick,
    		onMousedown,
    		onMouseup,
    		onMouseover,
    		onMouseout,
    		onMousedrag,
    		onSelect,
    		onDeselect,
    		zoomIdentity,
    		blockReindexing
    	};
    }

    class Label extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {
    			x: 0,
    			y: 0,
    			geometry: 0,
    			fill: 0,
    			stroke: 0,
    			strokeWidth: 0,
    			strokeOpacity: 0,
    			fillOpacity: 0,
    			opacity: 0,
    			text: 0,
    			fontFamily: 0,
    			fontSize: 0,
    			fontWeight: 0,
    			rotation: 0,
    			anchorPoint: 0,
    			transition: 0,
    			onClick: 0,
    			onMousedown: 0,
    			onMouseup: 0,
    			onMouseover: 0,
    			onMouseout: 0,
    			onMousedrag: 0,
    			onSelect: 0,
    			onDeselect: 0,
    			zoomIdentity: 0,
    			blockReindexing: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Label",
    			options,
    			id: create_fragment$c.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || ({});

    		if (ctx.x === undefined && !("x" in props)) {
    			console.warn("<Label> was created without expected prop 'x'");
    		}

    		if (ctx.y === undefined && !("y" in props)) {
    			console.warn("<Label> was created without expected prop 'y'");
    		}

    		if (ctx.geometry === undefined && !("geometry" in props)) {
    			console.warn("<Label> was created without expected prop 'geometry'");
    		}

    		if (ctx.fill === undefined && !("fill" in props)) {
    			console.warn("<Label> was created without expected prop 'fill'");
    		}

    		if (ctx.stroke === undefined && !("stroke" in props)) {
    			console.warn("<Label> was created without expected prop 'stroke'");
    		}

    		if (ctx.strokeWidth === undefined && !("strokeWidth" in props)) {
    			console.warn("<Label> was created without expected prop 'strokeWidth'");
    		}

    		if (ctx.strokeOpacity === undefined && !("strokeOpacity" in props)) {
    			console.warn("<Label> was created without expected prop 'strokeOpacity'");
    		}

    		if (ctx.fillOpacity === undefined && !("fillOpacity" in props)) {
    			console.warn("<Label> was created without expected prop 'fillOpacity'");
    		}

    		if (ctx.opacity === undefined && !("opacity" in props)) {
    			console.warn("<Label> was created without expected prop 'opacity'");
    		}

    		if (ctx.text === undefined && !("text" in props)) {
    			console.warn("<Label> was created without expected prop 'text'");
    		}

    		if (ctx.fontFamily === undefined && !("fontFamily" in props)) {
    			console.warn("<Label> was created without expected prop 'fontFamily'");
    		}

    		if (ctx.fontSize === undefined && !("fontSize" in props)) {
    			console.warn("<Label> was created without expected prop 'fontSize'");
    		}

    		if (ctx.fontWeight === undefined && !("fontWeight" in props)) {
    			console.warn("<Label> was created without expected prop 'fontWeight'");
    		}

    		if (ctx.rotation === undefined && !("rotation" in props)) {
    			console.warn("<Label> was created without expected prop 'rotation'");
    		}

    		if (ctx.anchorPoint === undefined && !("anchorPoint" in props)) {
    			console.warn("<Label> was created without expected prop 'anchorPoint'");
    		}

    		if (ctx.transition === undefined && !("transition" in props)) {
    			console.warn("<Label> was created without expected prop 'transition'");
    		}

    		if (ctx.onClick === undefined && !("onClick" in props)) {
    			console.warn("<Label> was created without expected prop 'onClick'");
    		}

    		if (ctx.onMousedown === undefined && !("onMousedown" in props)) {
    			console.warn("<Label> was created without expected prop 'onMousedown'");
    		}

    		if (ctx.onMouseup === undefined && !("onMouseup" in props)) {
    			console.warn("<Label> was created without expected prop 'onMouseup'");
    		}

    		if (ctx.onMouseover === undefined && !("onMouseover" in props)) {
    			console.warn("<Label> was created without expected prop 'onMouseover'");
    		}

    		if (ctx.onMouseout === undefined && !("onMouseout" in props)) {
    			console.warn("<Label> was created without expected prop 'onMouseout'");
    		}

    		if (ctx.onMousedrag === undefined && !("onMousedrag" in props)) {
    			console.warn("<Label> was created without expected prop 'onMousedrag'");
    		}

    		if (ctx.onSelect === undefined && !("onSelect" in props)) {
    			console.warn("<Label> was created without expected prop 'onSelect'");
    		}

    		if (ctx.onDeselect === undefined && !("onDeselect" in props)) {
    			console.warn("<Label> was created without expected prop 'onDeselect'");
    		}

    		if (ctx.zoomIdentity === undefined && !("zoomIdentity" in props)) {
    			console.warn("<Label> was created without expected prop 'zoomIdentity'");
    		}
    	}

    	get x() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get geometry() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set geometry(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fill() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fill(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stroke() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stroke(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeWidth() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeWidth(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeOpacity() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeOpacity(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillOpacity() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillOpacity(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opacity() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opacity(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fontFamily() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fontFamily(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fontSize() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fontSize(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fontWeight() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fontWeight(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rotation() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rotation(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get anchorPoint() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set anchorPoint(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transition() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transition(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClick() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClick(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedown() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedown(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseup() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseup(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseover() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseover(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseout() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseout(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedrag() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedrag(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSelect() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSelect(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onDeselect() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onDeselect(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zoomIdentity() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoomIdentity(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blockReindexing() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blockReindexing(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function createScreenGeometry ({ func, x }, sectionContext, coordinateTransformationContext, zoomContext) {
      ensureValidInput(func, x);

      const dataPoints = generateDataPoints(func, x, sectionContext);
      const geometry = {
        type: 'LineString',
        coordinates: dataPoints
      };

      const totalTransformation = createTotalTransformation(sectionContext, coordinateTransformationContext, zoomContext);

      if (geometryCompletelyOffScreen(geometry, totalTransformation, sectionContext)) {
        warn('FuncLine was completely out of Section window. Please check your Section scales and FuncLine props.');
        return {
          type: 'LineString',
          coordinates: [[0, 0], [0, 1]]
        }
      }

      return interpolateGeometry(geometry, totalTransformation)
    }

    function ensureValidInput (func, x) {
      if (func.constructor === Function && isUndefined(x)) return
      if (func.constructor === Function && isDefined(x)) {
        if (x.constructor === Array && x.length === 2 && x.every(d => d.constructor === Number)) {
          return
        }
      }

      throw new Error('FuncLine: invalid positioning props')
    }

    function generateDataPoints (func, x, sectionContext) {
      const domainX = x || getDomainX(sectionContext);
      return interpolatePointsFromFunc(func, domainX)
    }

    function getDomainX (sectionContext) {
      let domainX;

      if (isValidScale(sectionContext.scaleX)) {
        domainX = sectionContext.scaleX.domain();
      } else {
        domainX = sectionContext.rangeX;
      }

      return domainX
    }

    function isValidScale (scale) {
      if (scale && scale.constructor === Function && scale.name !== '') {
        if (scale.domain && scale.domain().every(d => d.constructor === Number)) {
          return true
        }

        throw new Error('FuncLine can only be used with functions that have numeric domains')
      } else {
        return false
      }
    }

    function interpolatePointsFromFunc (func, domainX, resolution = 100) {
      const points = [];

      const interpolator = interpolate(...domainX);

      for (let i = 0; i <= resolution; ++i) {
        const x = interpolator(i / resolution);
        const y = func(x);

        if (y.constructor === Number && !isNaN(y)) {
          points.push([x, y]);
        } else {
          throw new Error(`FuncLine: func is only allowed to return numbers. Received '${y}'`)
        }
      }

      return points
    }

    function createTotalTransformation (sectionContext, coordinateTransformationContext, zoomContext) {
      const { scaleX, scaleY } = sectionContext;

      const sectionTransformation = ([x, y]) => ([scaleX(x), scaleY(y)]);
      const coordinateTransformation = createCoordinateTransformation(coordinateTransformationContext);
      const zoomTransformation = createZoomTransformation$1(zoomContext);

      const totalTransformation = position => zoomTransformation(
        coordinateTransformation(
          sectionTransformation(position)
        )
      );

      return totalTransformation
    }

    function createCoordinateTransformation (coordinateTransformationContext) {
      if (coordinateTransformationContext) {
        return coordinateTransformationContext.transform.bind(coordinateTransformationContext)
      } else {
        return position => position
      }
    }

    function createZoomTransformation$1 (zoomContext) {
      if (zoomContext) {
        return zoomContext
      } else {
        return position => position
      }
    }

    function geometryCompletelyOffScreen (geometry, totalTransformation, sectionContext) {
      const transformedGeometry = transformGeometry(geometry, totalTransformation);

      for (let i = 0; i < transformedGeometry.coordinates.length; i++) {
        const point = transformedGeometry.coordinates[i];
        if (pointIsInRange(point, sectionContext)) return false
      }

      return true
    }

    function pointIsInRange (point, s) {
      return point[0] >= s.minX && point[0] <= s.maxX &&
        point[1] >= s.minY && point[1] <= s.maxY
    }

    /* src/components/Marks/FuncLine/FuncLine.svelte generated by Svelte v3.15.0 */

    const file$5 = "src/components/Marks/FuncLine/FuncLine.svelte";

    // (195:0) {#if $graphicContext.output() === 'svg'}
    function create_if_block$3(ctx) {
    	let path;
    	let path_d_value;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "class", "line");
    			attr_dev(path, "d", path_d_value = generatePath(ctx.$tr_screenGeometry));
    			attr_dev(path, "fill", "none");
    			attr_dev(path, "stroke-width", ctx.$tr_strokeWidth);
    			attr_dev(path, "stroke", ctx.$tr_stroke);
    			attr_dev(path, "opacity", ctx.$tr_opacity);
    			add_location(path, file$5, 196, 2, 6051);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		p: function update(changed, ctx) {
    			if (changed.$tr_screenGeometry && path_d_value !== (path_d_value = generatePath(ctx.$tr_screenGeometry))) {
    				attr_dev(path, "d", path_d_value);
    			}

    			if (changed.$tr_strokeWidth) {
    				attr_dev(path, "stroke-width", ctx.$tr_strokeWidth);
    			}

    			if (changed.$tr_stroke) {
    				attr_dev(path, "stroke", ctx.$tr_stroke);
    			}

    			if (changed.$tr_opacity) {
    				attr_dev(path, "opacity", ctx.$tr_opacity);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(195:0) {#if $graphicContext.output() === 'svg'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let show_if = ctx.$graphicContext.output() === "svg";
    	let if_block_anchor;
    	let if_block = show_if && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(changed, ctx) {
    			if (changed.$graphicContext) show_if = ctx.$graphicContext.output() === "svg";

    			if (show_if) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let idCounter$2 = 0;

    function getId$2() {
    	return "funcline" + idCounter$2++;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let $sectionContext;
    	let $coordinateTransformationContext;
    	let $zoomContext;

    	let $tr_screenGeometry,
    		$$unsubscribe_tr_screenGeometry = noop,
    		$$subscribe_tr_screenGeometry = () => ($$unsubscribe_tr_screenGeometry(), $$unsubscribe_tr_screenGeometry = subscribe(tr_screenGeometry, $$value => $$invalidate("$tr_screenGeometry", $tr_screenGeometry = $$value)), tr_screenGeometry);

    	let $tr_stroke,
    		$$unsubscribe_tr_stroke = noop,
    		$$subscribe_tr_stroke = () => ($$unsubscribe_tr_stroke(), $$unsubscribe_tr_stroke = subscribe(tr_stroke, $$value => $$invalidate("$tr_stroke", $tr_stroke = $$value)), tr_stroke);

    	let $tr_strokeWidth,
    		$$unsubscribe_tr_strokeWidth = noop,
    		$$subscribe_tr_strokeWidth = () => ($$unsubscribe_tr_strokeWidth(), $$unsubscribe_tr_strokeWidth = subscribe(tr_strokeWidth, $$value => $$invalidate("$tr_strokeWidth", $tr_strokeWidth = $$value)), tr_strokeWidth);

    	let $tr_opacity,
    		$$unsubscribe_tr_opacity = noop,
    		$$subscribe_tr_opacity = () => ($$unsubscribe_tr_opacity(), $$unsubscribe_tr_opacity = subscribe(tr_opacity, $$value => $$invalidate("$tr_opacity", $tr_opacity = $$value)), tr_opacity);

    	let $interactionManagerContext;
    	let $graphicContext;
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_screenGeometry());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_stroke());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_strokeWidth());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_opacity());
    	const markId = getId$2();
    	let initPhase = true;
    	const initDone = () => !initPhase;
    	let { func } = $$props;
    	let { x } = $$props;
    	let { strokeWidth = 1 } = $$props;
    	let { stroke = "black" } = $$props;
    	let { opacity = 1 } = $$props;
    	let { transition } = $$props;
    	let { onClick } = $$props;
    	let { onMousedown } = $$props;
    	let { onMouseup } = $$props;
    	let { onMouseover } = $$props;
    	let { onMouseout } = $$props;
    	let { onMousedrag } = $$props;
    	let { onSelect } = $$props;
    	let { onDeselect } = $$props;
    	let { zoomIdentity } = $$props;
    	let { blockReindexing = false } = $$props;
    	const graphicContext = subscribe$1();
    	validate_store(graphicContext, "graphicContext");
    	component_subscribe($$self, graphicContext, value => $$invalidate("$graphicContext", $graphicContext = value));
    	const sectionContext = subscribe$2();
    	validate_store(sectionContext, "sectionContext");
    	component_subscribe($$self, sectionContext, value => $$invalidate("$sectionContext", $sectionContext = value));
    	const coordinateTransformationContext = subscribe$5();
    	validate_store(coordinateTransformationContext, "coordinateTransformationContext");
    	component_subscribe($$self, coordinateTransformationContext, value => $$invalidate("$coordinateTransformationContext", $coordinateTransformationContext = value));
    	const interactionManagerContext = subscribe$4();
    	validate_store(interactionManagerContext, "interactionManagerContext");
    	component_subscribe($$self, interactionManagerContext, value => $$invalidate("$interactionManagerContext", $interactionManagerContext = value));
    	const zoomContext = subscribe$6();
    	validate_store(zoomContext, "zoomContext");
    	component_subscribe($$self, zoomContext, value => $$invalidate("$zoomContext", $zoomContext = value));
    	let screenGeometry = createScreenGeometry({ func, x }, $sectionContext, $coordinateTransformationContext, createZoomTransformation($zoomContext, zoomIdentity));
    	let tr_screenGeometry = createTransitionable("geometry", screenGeometry, transition);
    	validate_store(tr_screenGeometry, "tr_screenGeometry");
    	$$subscribe_tr_screenGeometry();
    	let tr_stroke = createTransitionable("stroke", stroke, transition);
    	validate_store(tr_stroke, "tr_stroke");
    	$$subscribe_tr_stroke();
    	let tr_strokeWidth = createTransitionable("strokeWidth", strokeWidth, transition);
    	validate_store(tr_strokeWidth, "tr_strokeWidth");
    	$$subscribe_tr_strokeWidth();
    	let tr_opacity = createTransitionable("opacity", opacity, transition);
    	validate_store(tr_opacity, "tr_opacity");
    	$$subscribe_tr_opacity();
    	let previousTransition;

    	beforeUpdate(() => {
    		if (!transitionsEqual(previousTransition, transition)) {
    			previousTransition = transition;
    			$$subscribe_tr_screenGeometry($$invalidate("tr_screenGeometry", tr_screenGeometry = createTransitionable("geometry", $tr_screenGeometry, transition)));
    			$$subscribe_tr_stroke($$invalidate("tr_stroke", tr_stroke = createTransitionable("stroke", $tr_stroke, transition)));
    			$$subscribe_tr_strokeWidth($$invalidate("tr_strokeWidth", tr_strokeWidth = createTransitionable("strokeWidth", $tr_strokeWidth, transition)));
    			$$subscribe_tr_opacity($$invalidate("tr_opacity", tr_opacity = createTransitionable("opacity", $tr_opacity, transition)));
    		}
    	});

    	afterUpdate(() => {
    		initPhase = false;
    	});

    	onMount(() => {
    		updateInteractionManagerIfNecessary();
    	});

    	onDestroy(() => {
    		removeMarkFromSpatialIndexIfNecessary();
    	});

    	function updateInteractionManagerIfNecessary() {
    		if (initPhase || !(blockReindexing || $sectionContext.blockReindexing)) {
    			removeMarkFromSpatialIndexIfNecessary();

    			if (isInteractiveMouse) {
    				const markInterface = $interactionManagerContext.mouse().marks();
    				markInterface.loadMark("Line", createDataNecessaryForIndexing());
    				if (onClick) markInterface.addMarkInteraction("click", markId, onClick);
    				if (onMousedown) markInterface.addMarkInteraction("mousedown", markId, onMousedown);
    				if (onMouseup) markInterface.addMarkInteraction("mouseoup", markId, onMouseup);
    				if (onMouseover) markInterface.addMarkInteraction("mouseover", markId, onMouseover);
    				if (onMouseout) markInterface.addMarkInteraction("mouseout", markId, onMouseout);
    				if (onMousedrag) markInterface.addMarkInteraction("mousedrag", markId, onMousedrag);
    			}
    		}

    		removeMarkFromSelectIfNecessary();

    		if (isSelectable) {
    			const selectManager = $interactionManagerContext.select();
    			selectManager.loadMark("Line", createDataNecessaryForIndexing(), { onSelect, onDeselect });
    		}
    	}

    	function removeMarkFromSpatialIndexIfNecessary() {
    		const markInterface = $interactionManagerContext.mouse().marks();

    		if (markInterface.markIsLoaded(markId)) {
    			markInterface.removeAllMarkInteractions(markId);
    			markInterface.removeMark(markId);
    		}
    	}

    	function removeMarkFromSelectIfNecessary() {
    		const selectManager = $interactionManagerContext.select();

    		if (selectManager.markIsLoaded(markId)) {
    			selectManager.removeMark(markId);
    		}
    	}

    	function createDataNecessaryForIndexing() {
    		return createDataNecessaryForIndexingMark("Line", markId, { pixelGeometry: screenGeometry }, { strokeWidth });
    	}

    	const writable_props = [
    		"func",
    		"x",
    		"strokeWidth",
    		"stroke",
    		"opacity",
    		"transition",
    		"onClick",
    		"onMousedown",
    		"onMouseup",
    		"onMouseover",
    		"onMouseout",
    		"onMousedrag",
    		"onSelect",
    		"onDeselect",
    		"zoomIdentity",
    		"blockReindexing"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FuncLine> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("func" in $$props) $$invalidate("func", func = $$props.func);
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	$$self.$capture_state = () => {
    		return {
    			idCounter: idCounter$2,
    			initPhase,
    			func,
    			x,
    			strokeWidth,
    			stroke,
    			opacity,
    			transition,
    			onClick,
    			onMousedown,
    			onMouseup,
    			onMouseover,
    			onMouseout,
    			onMousedrag,
    			onSelect,
    			onDeselect,
    			zoomIdentity,
    			blockReindexing,
    			screenGeometry,
    			tr_screenGeometry,
    			tr_stroke,
    			tr_strokeWidth,
    			tr_opacity,
    			previousTransition,
    			$sectionContext,
    			$coordinateTransformationContext,
    			$zoomContext,
    			$tr_screenGeometry,
    			$tr_stroke,
    			$tr_strokeWidth,
    			$tr_opacity,
    			isInteractiveMouse,
    			isInteractiveTouch,
    			isSelectable,
    			$interactionManagerContext,
    			$graphicContext
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("initPhase" in $$props) initPhase = $$props.initPhase;
    		if ("func" in $$props) $$invalidate("func", func = $$props.func);
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    		if ("screenGeometry" in $$props) $$invalidate("screenGeometry", screenGeometry = $$props.screenGeometry);
    		if ("tr_screenGeometry" in $$props) $$subscribe_tr_screenGeometry($$invalidate("tr_screenGeometry", tr_screenGeometry = $$props.tr_screenGeometry));
    		if ("tr_stroke" in $$props) $$subscribe_tr_stroke($$invalidate("tr_stroke", tr_stroke = $$props.tr_stroke));
    		if ("tr_strokeWidth" in $$props) $$subscribe_tr_strokeWidth($$invalidate("tr_strokeWidth", tr_strokeWidth = $$props.tr_strokeWidth));
    		if ("tr_opacity" in $$props) $$subscribe_tr_opacity($$invalidate("tr_opacity", tr_opacity = $$props.tr_opacity));
    		if ("previousTransition" in $$props) previousTransition = $$props.previousTransition;
    		if ("$sectionContext" in $$props) sectionContext.set($sectionContext = $$props.$sectionContext);
    		if ("$coordinateTransformationContext" in $$props) coordinateTransformationContext.set($coordinateTransformationContext = $$props.$coordinateTransformationContext);
    		if ("$zoomContext" in $$props) zoomContext.set($zoomContext = $$props.$zoomContext);
    		if ("$tr_screenGeometry" in $$props) tr_screenGeometry.set($tr_screenGeometry = $$props.$tr_screenGeometry);
    		if ("$tr_stroke" in $$props) tr_stroke.set($tr_stroke = $$props.$tr_stroke);
    		if ("$tr_strokeWidth" in $$props) tr_strokeWidth.set($tr_strokeWidth = $$props.$tr_strokeWidth);
    		if ("$tr_opacity" in $$props) tr_opacity.set($tr_opacity = $$props.$tr_opacity);
    		if ("isInteractiveMouse" in $$props) isInteractiveMouse = $$props.isInteractiveMouse;
    		if ("isInteractiveTouch" in $$props) isInteractiveTouch = $$props.isInteractiveTouch;
    		if ("isSelectable" in $$props) isSelectable = $$props.isSelectable;
    		if ("$interactionManagerContext" in $$props) interactionManagerContext.set($interactionManagerContext = $$props.$interactionManagerContext);
    		if ("$graphicContext" in $$props) graphicContext.set($graphicContext = $$props.$graphicContext);
    	};

    	let isInteractiveMouse;
    	let isInteractiveTouch;
    	let isSelectable;

    	$$self.$$.update = (changed = { func: 1, x: 1, $sectionContext: 1, $coordinateTransformationContext: 1, $zoomContext: 1, zoomIdentity: 1, tr_screenGeometry: 1, screenGeometry: 1, tr_stroke: 1, stroke: 1, tr_strokeWidth: 1, strokeWidth: 1, tr_opacity: 1, opacity: 1, onClick: 1, onMousedown: 1, onMouseup: 1, onMouseover: 1, onMouseout: 1, onMousedrag: 1, onSelect: 1, onDeselect: 1 }) => {
    		if (changed.func || changed.x || changed.$sectionContext || changed.$coordinateTransformationContext || changed.$zoomContext || changed.zoomIdentity || changed.tr_screenGeometry || changed.screenGeometry) {
    			 {
    				if (initDone()) {
    					$$invalidate("screenGeometry", screenGeometry = createScreenGeometry({ func, x }, $sectionContext, $coordinateTransformationContext, createZoomTransformation($zoomContext, zoomIdentity)));
    					tr_screenGeometry.set(screenGeometry);
    					updateInteractionManagerIfNecessary();
    				}
    			}
    		}

    		if (changed.tr_stroke || changed.stroke) {
    			 {
    				if (initDone()) tr_stroke.set(stroke);
    			}
    		}

    		if (changed.tr_strokeWidth || changed.strokeWidth) {
    			 {
    				if (initDone()) tr_strokeWidth.set(strokeWidth);
    			}
    		}

    		if (changed.tr_opacity || changed.opacity) {
    			 {
    				if (initDone()) tr_opacity.set(opacity);
    			}
    		}

    		if (changed.onClick || changed.onMousedown || changed.onMouseup || changed.onMouseover || changed.onMouseout || changed.onMousedrag) {
    			 isInteractiveMouse = detectIt.hasMouse && (onClick !== undefined || onMousedown !== undefined || onMouseup !== undefined || onMouseover !== undefined || onMouseout !== undefined || onMousedrag !== undefined);
    		}

    		if (changed.onSelect || changed.onDeselect) {
    			 isSelectable = onSelect !== undefined || onDeselect !== undefined;
    		}
    	};

    	 isInteractiveTouch = detectIt.hasTouch;

    	return {
    		func,
    		x,
    		strokeWidth,
    		stroke,
    		opacity,
    		transition,
    		onClick,
    		onMousedown,
    		onMouseup,
    		onMouseover,
    		onMouseout,
    		onMousedrag,
    		onSelect,
    		onDeselect,
    		zoomIdentity,
    		blockReindexing,
    		graphicContext,
    		sectionContext,
    		coordinateTransformationContext,
    		interactionManagerContext,
    		zoomContext,
    		tr_screenGeometry,
    		tr_stroke,
    		tr_strokeWidth,
    		tr_opacity,
    		$tr_screenGeometry,
    		$tr_stroke,
    		$tr_strokeWidth,
    		$tr_opacity,
    		$graphicContext
    	};
    }

    class FuncLine extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {
    			func: 0,
    			x: 0,
    			strokeWidth: 0,
    			stroke: 0,
    			opacity: 0,
    			transition: 0,
    			onClick: 0,
    			onMousedown: 0,
    			onMouseup: 0,
    			onMouseover: 0,
    			onMouseout: 0,
    			onMousedrag: 0,
    			onSelect: 0,
    			onDeselect: 0,
    			zoomIdentity: 0,
    			blockReindexing: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FuncLine",
    			options,
    			id: create_fragment$d.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || ({});

    		if (ctx.func === undefined && !("func" in props)) {
    			console.warn("<FuncLine> was created without expected prop 'func'");
    		}

    		if (ctx.x === undefined && !("x" in props)) {
    			console.warn("<FuncLine> was created without expected prop 'x'");
    		}

    		if (ctx.transition === undefined && !("transition" in props)) {
    			console.warn("<FuncLine> was created without expected prop 'transition'");
    		}

    		if (ctx.onClick === undefined && !("onClick" in props)) {
    			console.warn("<FuncLine> was created without expected prop 'onClick'");
    		}

    		if (ctx.onMousedown === undefined && !("onMousedown" in props)) {
    			console.warn("<FuncLine> was created without expected prop 'onMousedown'");
    		}

    		if (ctx.onMouseup === undefined && !("onMouseup" in props)) {
    			console.warn("<FuncLine> was created without expected prop 'onMouseup'");
    		}

    		if (ctx.onMouseover === undefined && !("onMouseover" in props)) {
    			console.warn("<FuncLine> was created without expected prop 'onMouseover'");
    		}

    		if (ctx.onMouseout === undefined && !("onMouseout" in props)) {
    			console.warn("<FuncLine> was created without expected prop 'onMouseout'");
    		}

    		if (ctx.onMousedrag === undefined && !("onMousedrag" in props)) {
    			console.warn("<FuncLine> was created without expected prop 'onMousedrag'");
    		}

    		if (ctx.onSelect === undefined && !("onSelect" in props)) {
    			console.warn("<FuncLine> was created without expected prop 'onSelect'");
    		}

    		if (ctx.onDeselect === undefined && !("onDeselect" in props)) {
    			console.warn("<FuncLine> was created without expected prop 'onDeselect'");
    		}

    		if (ctx.zoomIdentity === undefined && !("zoomIdentity" in props)) {
    			console.warn("<FuncLine> was created without expected prop 'zoomIdentity'");
    		}
    	}

    	get func() {
    		throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set func(value) {
    		throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get x() {
    		throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x(value) {
    		throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeWidth() {
    		throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeWidth(value) {
    		throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stroke() {
    		throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stroke(value) {
    		throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opacity() {
    		throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opacity(value) {
    		throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transition() {
    		throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transition(value) {
    		throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClick() {
    		throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClick(value) {
    		throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedown() {
    		throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedown(value) {
    		throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseup() {
    		throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseup(value) {
    		throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseover() {
    		throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseover(value) {
    		throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseout() {
    		throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseout(value) {
    		throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedrag() {
    		throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedrag(value) {
    		throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSelect() {
    		throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSelect(value) {
    		throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onDeselect() {
    		throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onDeselect(value) {
    		throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zoomIdentity() {
    		throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoomIdentity(value) {
    		throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blockReindexing() {
    		throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blockReindexing(value) {
    		throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Marks/Area/Area.svelte generated by Svelte v3.15.0 */

    function create_fragment$e(ctx) {
    	let current;

    	const mark = new Mark({
    			props: {
    				type: "Area",
    				x1: ctx.x1,
    				x2: ctx.x2,
    				y1: ctx.y1,
    				y2: ctx.y2,
    				independentAxis: ctx.independentAxis,
    				fill: ctx.fill,
    				stroke: ctx.stroke,
    				strokeWidth: ctx.strokeWidth,
    				strokeOpacity: ctx.strokeOpacity,
    				fillOpacity: ctx.fillOpacity,
    				opacity: ctx.opacity,
    				transition: ctx.transition,
    				onClick: ctx.onClick,
    				onMousedown: ctx.onMousedown,
    				onMouseup: ctx.onMouseup,
    				onMouseover: ctx.onMouseover,
    				onMouseout: ctx.onMouseout,
    				onMousedrag: ctx.onMousedrag,
    				onSelect: ctx.onSelect,
    				onDeselect: ctx.onDeselect,
    				interpolate: ctx.interpolate,
    				zoomIdentity: ctx.zoomIdentity,
    				blockReindexing: ctx.blockReindexing
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mark.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(mark, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const mark_changes = {};
    			if (changed.x1) mark_changes.x1 = ctx.x1;
    			if (changed.x2) mark_changes.x2 = ctx.x2;
    			if (changed.y1) mark_changes.y1 = ctx.y1;
    			if (changed.y2) mark_changes.y2 = ctx.y2;
    			if (changed.independentAxis) mark_changes.independentAxis = ctx.independentAxis;
    			if (changed.fill) mark_changes.fill = ctx.fill;
    			if (changed.stroke) mark_changes.stroke = ctx.stroke;
    			if (changed.strokeWidth) mark_changes.strokeWidth = ctx.strokeWidth;
    			if (changed.strokeOpacity) mark_changes.strokeOpacity = ctx.strokeOpacity;
    			if (changed.fillOpacity) mark_changes.fillOpacity = ctx.fillOpacity;
    			if (changed.opacity) mark_changes.opacity = ctx.opacity;
    			if (changed.transition) mark_changes.transition = ctx.transition;
    			if (changed.onClick) mark_changes.onClick = ctx.onClick;
    			if (changed.onMousedown) mark_changes.onMousedown = ctx.onMousedown;
    			if (changed.onMouseup) mark_changes.onMouseup = ctx.onMouseup;
    			if (changed.onMouseover) mark_changes.onMouseover = ctx.onMouseover;
    			if (changed.onMouseout) mark_changes.onMouseout = ctx.onMouseout;
    			if (changed.onMousedrag) mark_changes.onMousedrag = ctx.onMousedrag;
    			if (changed.onSelect) mark_changes.onSelect = ctx.onSelect;
    			if (changed.onDeselect) mark_changes.onDeselect = ctx.onDeselect;
    			if (changed.interpolate) mark_changes.interpolate = ctx.interpolate;
    			if (changed.zoomIdentity) mark_changes.zoomIdentity = ctx.zoomIdentity;
    			if (changed.blockReindexing) mark_changes.blockReindexing = ctx.blockReindexing;
    			mark.$set(mark_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mark.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mark.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mark, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { x1 } = $$props;
    	let { x2 } = $$props;
    	let { y1 } = $$props;
    	let { y2 } = $$props;
    	let { independentAxis } = $$props;
    	let { fill } = $$props;
    	let { stroke } = $$props;
    	let { strokeWidth } = $$props;
    	let { strokeOpacity } = $$props;
    	let { fillOpacity } = $$props;
    	let { opacity } = $$props;
    	let { transition } = $$props;
    	let { onClick } = $$props;
    	let { onMousedown } = $$props;
    	let { onMouseup } = $$props;
    	let { onMouseover } = $$props;
    	let { onMouseout } = $$props;
    	let { onMousedrag } = $$props;
    	let { onSelect } = $$props;
    	let { onDeselect } = $$props;
    	let { interpolate = true } = $$props;
    	let { zoomIdentity } = $$props;
    	let { blockReindexing = false } = $$props;

    	const writable_props = [
    		"x1",
    		"x2",
    		"y1",
    		"y2",
    		"independentAxis",
    		"fill",
    		"stroke",
    		"strokeWidth",
    		"strokeOpacity",
    		"fillOpacity",
    		"opacity",
    		"transition",
    		"onClick",
    		"onMousedown",
    		"onMouseup",
    		"onMouseover",
    		"onMouseout",
    		"onMousedrag",
    		"onSelect",
    		"onDeselect",
    		"interpolate",
    		"zoomIdentity",
    		"blockReindexing"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Area> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("x1" in $$props) $$invalidate("x1", x1 = $$props.x1);
    		if ("x2" in $$props) $$invalidate("x2", x2 = $$props.x2);
    		if ("y1" in $$props) $$invalidate("y1", y1 = $$props.y1);
    		if ("y2" in $$props) $$invalidate("y2", y2 = $$props.y2);
    		if ("independentAxis" in $$props) $$invalidate("independentAxis", independentAxis = $$props.independentAxis);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("strokeOpacity" in $$props) $$invalidate("strokeOpacity", strokeOpacity = $$props.strokeOpacity);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("interpolate" in $$props) $$invalidate("interpolate", interpolate = $$props.interpolate);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	$$self.$capture_state = () => {
    		return {
    			x1,
    			x2,
    			y1,
    			y2,
    			independentAxis,
    			fill,
    			stroke,
    			strokeWidth,
    			strokeOpacity,
    			fillOpacity,
    			opacity,
    			transition,
    			onClick,
    			onMousedown,
    			onMouseup,
    			onMouseover,
    			onMouseout,
    			onMousedrag,
    			onSelect,
    			onDeselect,
    			interpolate,
    			zoomIdentity,
    			blockReindexing
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("x1" in $$props) $$invalidate("x1", x1 = $$props.x1);
    		if ("x2" in $$props) $$invalidate("x2", x2 = $$props.x2);
    		if ("y1" in $$props) $$invalidate("y1", y1 = $$props.y1);
    		if ("y2" in $$props) $$invalidate("y2", y2 = $$props.y2);
    		if ("independentAxis" in $$props) $$invalidate("independentAxis", independentAxis = $$props.independentAxis);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("strokeOpacity" in $$props) $$invalidate("strokeOpacity", strokeOpacity = $$props.strokeOpacity);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("interpolate" in $$props) $$invalidate("interpolate", interpolate = $$props.interpolate);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	return {
    		x1,
    		x2,
    		y1,
    		y2,
    		independentAxis,
    		fill,
    		stroke,
    		strokeWidth,
    		strokeOpacity,
    		fillOpacity,
    		opacity,
    		transition,
    		onClick,
    		onMousedown,
    		onMouseup,
    		onMouseover,
    		onMouseout,
    		onMousedrag,
    		onSelect,
    		onDeselect,
    		interpolate,
    		zoomIdentity,
    		blockReindexing
    	};
    }

    class Area extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {
    			x1: 0,
    			x2: 0,
    			y1: 0,
    			y2: 0,
    			independentAxis: 0,
    			fill: 0,
    			stroke: 0,
    			strokeWidth: 0,
    			strokeOpacity: 0,
    			fillOpacity: 0,
    			opacity: 0,
    			transition: 0,
    			onClick: 0,
    			onMousedown: 0,
    			onMouseup: 0,
    			onMouseover: 0,
    			onMouseout: 0,
    			onMousedrag: 0,
    			onSelect: 0,
    			onDeselect: 0,
    			interpolate: 0,
    			zoomIdentity: 0,
    			blockReindexing: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Area",
    			options,
    			id: create_fragment$e.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || ({});

    		if (ctx.x1 === undefined && !("x1" in props)) {
    			console.warn("<Area> was created without expected prop 'x1'");
    		}

    		if (ctx.x2 === undefined && !("x2" in props)) {
    			console.warn("<Area> was created without expected prop 'x2'");
    		}

    		if (ctx.y1 === undefined && !("y1" in props)) {
    			console.warn("<Area> was created without expected prop 'y1'");
    		}

    		if (ctx.y2 === undefined && !("y2" in props)) {
    			console.warn("<Area> was created without expected prop 'y2'");
    		}

    		if (ctx.independentAxis === undefined && !("independentAxis" in props)) {
    			console.warn("<Area> was created without expected prop 'independentAxis'");
    		}

    		if (ctx.fill === undefined && !("fill" in props)) {
    			console.warn("<Area> was created without expected prop 'fill'");
    		}

    		if (ctx.stroke === undefined && !("stroke" in props)) {
    			console.warn("<Area> was created without expected prop 'stroke'");
    		}

    		if (ctx.strokeWidth === undefined && !("strokeWidth" in props)) {
    			console.warn("<Area> was created without expected prop 'strokeWidth'");
    		}

    		if (ctx.strokeOpacity === undefined && !("strokeOpacity" in props)) {
    			console.warn("<Area> was created without expected prop 'strokeOpacity'");
    		}

    		if (ctx.fillOpacity === undefined && !("fillOpacity" in props)) {
    			console.warn("<Area> was created without expected prop 'fillOpacity'");
    		}

    		if (ctx.opacity === undefined && !("opacity" in props)) {
    			console.warn("<Area> was created without expected prop 'opacity'");
    		}

    		if (ctx.transition === undefined && !("transition" in props)) {
    			console.warn("<Area> was created without expected prop 'transition'");
    		}

    		if (ctx.onClick === undefined && !("onClick" in props)) {
    			console.warn("<Area> was created without expected prop 'onClick'");
    		}

    		if (ctx.onMousedown === undefined && !("onMousedown" in props)) {
    			console.warn("<Area> was created without expected prop 'onMousedown'");
    		}

    		if (ctx.onMouseup === undefined && !("onMouseup" in props)) {
    			console.warn("<Area> was created without expected prop 'onMouseup'");
    		}

    		if (ctx.onMouseover === undefined && !("onMouseover" in props)) {
    			console.warn("<Area> was created without expected prop 'onMouseover'");
    		}

    		if (ctx.onMouseout === undefined && !("onMouseout" in props)) {
    			console.warn("<Area> was created without expected prop 'onMouseout'");
    		}

    		if (ctx.onMousedrag === undefined && !("onMousedrag" in props)) {
    			console.warn("<Area> was created without expected prop 'onMousedrag'");
    		}

    		if (ctx.onSelect === undefined && !("onSelect" in props)) {
    			console.warn("<Area> was created without expected prop 'onSelect'");
    		}

    		if (ctx.onDeselect === undefined && !("onDeselect" in props)) {
    			console.warn("<Area> was created without expected prop 'onDeselect'");
    		}

    		if (ctx.zoomIdentity === undefined && !("zoomIdentity" in props)) {
    			console.warn("<Area> was created without expected prop 'zoomIdentity'");
    		}
    	}

    	get x1() {
    		throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x1(value) {
    		throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get x2() {
    		throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x2(value) {
    		throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y1() {
    		throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y1(value) {
    		throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y2() {
    		throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y2(value) {
    		throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get independentAxis() {
    		throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set independentAxis(value) {
    		throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fill() {
    		throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fill(value) {
    		throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stroke() {
    		throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stroke(value) {
    		throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeWidth() {
    		throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeWidth(value) {
    		throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeOpacity() {
    		throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeOpacity(value) {
    		throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillOpacity() {
    		throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillOpacity(value) {
    		throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opacity() {
    		throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opacity(value) {
    		throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transition() {
    		throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transition(value) {
    		throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClick() {
    		throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClick(value) {
    		throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedown() {
    		throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedown(value) {
    		throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseup() {
    		throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseup(value) {
    		throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseover() {
    		throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseover(value) {
    		throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseout() {
    		throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseout(value) {
    		throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedrag() {
    		throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedrag(value) {
    		throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSelect() {
    		throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSelect(value) {
    		throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onDeselect() {
    		throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onDeselect(value) {
    		throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get interpolate() {
    		throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set interpolate(value) {
    		throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zoomIdentity() {
    		throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoomIdentity(value) {
    		throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blockReindexing() {
    		throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blockReindexing(value) {
    		throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * This function is only used when dealing with layers.
     * For layers, most 'aesthetic' props can be specified in two ways:
     *  - An Array of values is passed to the prop
     *  - A single value is passed to the prop
     * In both cases, we need to convert whatever was passed to an Object.
     * The keys will be whatever the user used as 'key' Array, and the values
     * are whatever the user used passed to the prop in question.
     * If the user passed an Array, the values of the Object correspond to the values in the Array.
     * If the user passed a single value, every value in the Object will be that value.
     * The object structure is necessary to do transitions later.
     *
     * @param {*} propValue Whatever was passed to the prop
     * @param {*} keyArray The array of indices to be used as keys
     * @returns {Object.<Number, *>} The 'prop Object'
     */
    function generatePropObject (propValue, keyArray) {
      const propObj = {};

      if (isDefined(propValue)) {
        if (propValue.constructor === Array) {
          for (let i = 0; i < keyArray.length; i++) {
            const key = keyArray[i];
            propObj[key] = propValue[i];
          }
        } else if (propValue.constructor === Function) {
          for (let i = 0; i < keyArray.length; i++) {
            const key = keyArray[i];
            propObj[key] = propValue(key, i);
          }
        } else {
          for (let i = 0; i < keyArray.length; i++) {
            const key = keyArray[i];
            propObj[key] = propValue;
          }
        }
      }

      return propObj
    }

    /* src/components/Marks/Mark/Layer.svelte generated by Svelte v3.15.0 */

    const { Object: Object_1 } = globals;
    const file$6 = "src/components/Marks/Mark/Layer.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = Object_1.create(ctx);
    	child_ctx.$key = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = Object_1.create(ctx);
    	child_ctx.$key = list[i];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = Object_1.create(ctx);
    	child_ctx.$key = list[i];
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = Object_1.create(ctx);
    	child_ctx.$key = list[i];
    	return child_ctx;
    }

    // (451:0) {#if $graphicContext.output() === 'svg'}
    function create_if_block_1$3(ctx) {
    	let t0;
    	let t1;
    	let if_block2_anchor;
    	let if_block0 = ctx.renderPolygon && create_if_block_4$1(ctx);
    	let if_block1 = ctx.renderCircle && create_if_block_3$1(ctx);
    	let if_block2 = ctx.renderLine && create_if_block_2$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    		},
    		p: function update(changed, ctx) {
    			if (ctx.renderPolygon) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_4$1(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (ctx.renderCircle) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block_3$1(ctx);
    					if_block1.c();
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (ctx.renderLine) {
    				if (if_block2) {
    					if_block2.p(changed, ctx);
    				} else {
    					if_block2 = create_if_block_2$1(ctx);
    					if_block2.c();
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(451:0) {#if $graphicContext.output() === 'svg'}",
    		ctx
    	});

    	return block;
    }

    // (453:2) {#if renderPolygon}
    function create_if_block_4$1(ctx) {
    	let g;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let g_class_value;
    	let each_value_3 = Object.keys(ctx.$tr_screenGeometryObject);
    	const get_key = ctx => ctx.$key;

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		let child_ctx = get_each_context_3(ctx, each_value_3, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_3(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			g = svg_element("g");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(g, "class", g_class_value = `${ctx.type.toLowerCase()}-layer`);
    			add_location(g, file$6, 453, 4, 15200);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(g, null);
    			}
    		},
    		p: function update(changed, ctx) {
    			const each_value_3 = Object.keys(ctx.$tr_screenGeometryObject);
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value_3, each_1_lookup, g, destroy_block, create_each_block_3, null, get_each_context_3);

    			if (changed.type && g_class_value !== (g_class_value = `${ctx.type.toLowerCase()}-layer`)) {
    				attr_dev(g, "class", g_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(453:2) {#if renderPolygon}",
    		ctx
    	});

    	return block;
    }

    // (455:6) {#each Object.keys($tr_screenGeometryObject) as $key ($key)}
    function create_each_block_3(key_2, ctx) {
    	let path;
    	let path_class_value;
    	let path_d_value;
    	let path_fill_value;
    	let path_stroke_value;
    	let path_stroke_width_value;
    	let path_fill_opacity_value;
    	let path_stroke_opacity_value;
    	let path_opacity_value;

    	const block = {
    		key: key_2,
    		first: null,
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "class", path_class_value = ctx.type.toLowerCase());
    			attr_dev(path, "d", path_d_value = generatePath(ctx.$tr_screenGeometryObject[ctx.$key]));
    			attr_dev(path, "fill", path_fill_value = ctx.$tr_fillObject[ctx.$key]);
    			attr_dev(path, "stroke", path_stroke_value = ctx.$tr_strokeObject[ctx.$key]);
    			attr_dev(path, "stroke-width", path_stroke_width_value = ctx.$tr_strokeWidthObject[ctx.$key]);
    			attr_dev(path, "fill-opacity", path_fill_opacity_value = ctx.$tr_fillOpacityObject[ctx.$key]);
    			attr_dev(path, "stroke-opacity", path_stroke_opacity_value = ctx.$tr_strokeOpacityObject[ctx.$key]);
    			attr_dev(path, "opacity", path_opacity_value = ctx.$tr_opacityObject[ctx.$key]);
    			add_location(path, file$6, 456, 8, 15318);
    			this.first = path;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		p: function update(changed, ctx) {
    			if (changed.type && path_class_value !== (path_class_value = ctx.type.toLowerCase())) {
    				attr_dev(path, "class", path_class_value);
    			}

    			if (changed.$tr_screenGeometryObject && path_d_value !== (path_d_value = generatePath(ctx.$tr_screenGeometryObject[ctx.$key]))) {
    				attr_dev(path, "d", path_d_value);
    			}

    			if ((changed.$tr_fillObject || changed.$tr_screenGeometryObject) && path_fill_value !== (path_fill_value = ctx.$tr_fillObject[ctx.$key])) {
    				attr_dev(path, "fill", path_fill_value);
    			}

    			if ((changed.$tr_strokeObject || changed.$tr_screenGeometryObject) && path_stroke_value !== (path_stroke_value = ctx.$tr_strokeObject[ctx.$key])) {
    				attr_dev(path, "stroke", path_stroke_value);
    			}

    			if ((changed.$tr_strokeWidthObject || changed.$tr_screenGeometryObject) && path_stroke_width_value !== (path_stroke_width_value = ctx.$tr_strokeWidthObject[ctx.$key])) {
    				attr_dev(path, "stroke-width", path_stroke_width_value);
    			}

    			if ((changed.$tr_fillOpacityObject || changed.$tr_screenGeometryObject) && path_fill_opacity_value !== (path_fill_opacity_value = ctx.$tr_fillOpacityObject[ctx.$key])) {
    				attr_dev(path, "fill-opacity", path_fill_opacity_value);
    			}

    			if ((changed.$tr_strokeOpacityObject || changed.$tr_screenGeometryObject) && path_stroke_opacity_value !== (path_stroke_opacity_value = ctx.$tr_strokeOpacityObject[ctx.$key])) {
    				attr_dev(path, "stroke-opacity", path_stroke_opacity_value);
    			}

    			if ((changed.$tr_opacityObject || changed.$tr_screenGeometryObject) && path_opacity_value !== (path_opacity_value = ctx.$tr_opacityObject[ctx.$key])) {
    				attr_dev(path, "opacity", path_opacity_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(455:6) {#each Object.keys($tr_screenGeometryObject) as $key ($key)}",
    		ctx
    	});

    	return block;
    }

    // (473:2) {#if renderCircle}
    function create_if_block_3$1(ctx) {
    	let g;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_value_2 = Object.keys(ctx.$tr_screenGeometryObject);
    	const get_key = ctx => ctx.$key;

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		let child_ctx = get_each_context_2(ctx, each_value_2, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_2(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			g = svg_element("g");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(g, "class", "point-layer");
    			add_location(g, file$6, 473, 4, 15777);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(g, null);
    			}
    		},
    		p: function update(changed, ctx) {
    			const each_value_2 = Object.keys(ctx.$tr_screenGeometryObject);
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value_2, each_1_lookup, g, destroy_block, create_each_block_2, null, get_each_context_2);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(473:2) {#if renderCircle}",
    		ctx
    	});

    	return block;
    }

    // (475:6) {#each Object.keys($tr_screenGeometryObject) as $key ($key)}
    function create_each_block_2(key_2, ctx) {
    	let circle;
    	let circle_cx_value;
    	let circle_cy_value;
    	let circle_r_value;
    	let circle_fill_value;
    	let circle_stroke_value;
    	let circle_stroke_width_value;
    	let circle_fill_opacity_value;
    	let circle_stroke_opacity_value;
    	let circle_opacity_value;

    	const block = {
    		key: key_2,
    		first: null,
    		c: function create() {
    			circle = svg_element("circle");
    			attr_dev(circle, "class", "point");
    			attr_dev(circle, "cx", circle_cx_value = ctx.$tr_screenGeometryObject[ctx.$key].coordinates[0]);
    			attr_dev(circle, "cy", circle_cy_value = ctx.$tr_screenGeometryObject[ctx.$key].coordinates[1]);
    			attr_dev(circle, "r", circle_r_value = ctx.$tr_radiusObject[ctx.$key]);
    			attr_dev(circle, "fill", circle_fill_value = ctx.$tr_fillObject[ctx.$key]);
    			attr_dev(circle, "stroke", circle_stroke_value = ctx.$tr_strokeObject[ctx.$key]);
    			attr_dev(circle, "stroke-width", circle_stroke_width_value = ctx.$tr_strokeWidthObject[ctx.$key]);
    			attr_dev(circle, "fill-opacity", circle_fill_opacity_value = ctx.$tr_fillOpacityObject[ctx.$key]);
    			attr_dev(circle, "stroke-opacity", circle_stroke_opacity_value = ctx.$tr_strokeOpacityObject[ctx.$key]);
    			attr_dev(circle, "opacity", circle_opacity_value = ctx.$tr_opacityObject[ctx.$key]);
    			add_location(circle, file$6, 476, 8, 15877);
    			this.first = circle;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, circle, anchor);
    		},
    		p: function update(changed, ctx) {
    			if (changed.$tr_screenGeometryObject && circle_cx_value !== (circle_cx_value = ctx.$tr_screenGeometryObject[ctx.$key].coordinates[0])) {
    				attr_dev(circle, "cx", circle_cx_value);
    			}

    			if (changed.$tr_screenGeometryObject && circle_cy_value !== (circle_cy_value = ctx.$tr_screenGeometryObject[ctx.$key].coordinates[1])) {
    				attr_dev(circle, "cy", circle_cy_value);
    			}

    			if ((changed.$tr_radiusObject || changed.$tr_screenGeometryObject) && circle_r_value !== (circle_r_value = ctx.$tr_radiusObject[ctx.$key])) {
    				attr_dev(circle, "r", circle_r_value);
    			}

    			if ((changed.$tr_fillObject || changed.$tr_screenGeometryObject) && circle_fill_value !== (circle_fill_value = ctx.$tr_fillObject[ctx.$key])) {
    				attr_dev(circle, "fill", circle_fill_value);
    			}

    			if ((changed.$tr_strokeObject || changed.$tr_screenGeometryObject) && circle_stroke_value !== (circle_stroke_value = ctx.$tr_strokeObject[ctx.$key])) {
    				attr_dev(circle, "stroke", circle_stroke_value);
    			}

    			if ((changed.$tr_strokeWidthObject || changed.$tr_screenGeometryObject) && circle_stroke_width_value !== (circle_stroke_width_value = ctx.$tr_strokeWidthObject[ctx.$key])) {
    				attr_dev(circle, "stroke-width", circle_stroke_width_value);
    			}

    			if ((changed.$tr_fillOpacityObject || changed.$tr_screenGeometryObject) && circle_fill_opacity_value !== (circle_fill_opacity_value = ctx.$tr_fillOpacityObject[ctx.$key])) {
    				attr_dev(circle, "fill-opacity", circle_fill_opacity_value);
    			}

    			if ((changed.$tr_strokeOpacityObject || changed.$tr_screenGeometryObject) && circle_stroke_opacity_value !== (circle_stroke_opacity_value = ctx.$tr_strokeOpacityObject[ctx.$key])) {
    				attr_dev(circle, "stroke-opacity", circle_stroke_opacity_value);
    			}

    			if ((changed.$tr_opacityObject || changed.$tr_screenGeometryObject) && circle_opacity_value !== (circle_opacity_value = ctx.$tr_opacityObject[ctx.$key])) {
    				attr_dev(circle, "opacity", circle_opacity_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(circle);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(475:6) {#each Object.keys($tr_screenGeometryObject) as $key ($key)}",
    		ctx
    	});

    	return block;
    }

    // (494:2) {#if renderLine}
    function create_if_block_2$1(ctx) {
    	let g;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_value_1 = Object.keys(ctx.$tr_screenGeometryObject);
    	const get_key = ctx => ctx.$key;

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			g = svg_element("g");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(g, "class", "line-layer");
    			add_location(g, file$6, 494, 4, 16422);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(g, null);
    			}
    		},
    		p: function update(changed, ctx) {
    			const each_value_1 = Object.keys(ctx.$tr_screenGeometryObject);
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value_1, each_1_lookup, g, destroy_block, create_each_block_1, null, get_each_context_1);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(494:2) {#if renderLine}",
    		ctx
    	});

    	return block;
    }

    // (496:6) {#each Object.keys($tr_screenGeometryObject) as $key ($key)}
    function create_each_block_1(key_2, ctx) {
    	let path;
    	let path_d_value;
    	let path_stroke_width_value;
    	let path_stroke_value;
    	let path_style_value;

    	const block = {
    		key: key_2,
    		first: null,
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "class", "line");
    			attr_dev(path, "d", path_d_value = generatePath(ctx.$tr_screenGeometryObject[ctx.$key]));
    			attr_dev(path, "fill", "none");
    			attr_dev(path, "stroke-width", path_stroke_width_value = ctx.$tr_strokeWidthObject[ctx.$key]);
    			attr_dev(path, "stroke", path_stroke_value = ctx.$tr_strokeObject[ctx.$key]);
    			attr_dev(path, "style", path_style_value = `opacity: ${ctx.$tr_opacityObject[ctx.$key]}`);
    			add_location(path, file$6, 497, 8, 16521);
    			this.first = path;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		p: function update(changed, ctx) {
    			if (changed.$tr_screenGeometryObject && path_d_value !== (path_d_value = generatePath(ctx.$tr_screenGeometryObject[ctx.$key]))) {
    				attr_dev(path, "d", path_d_value);
    			}

    			if ((changed.$tr_strokeWidthObject || changed.$tr_screenGeometryObject) && path_stroke_width_value !== (path_stroke_width_value = ctx.$tr_strokeWidthObject[ctx.$key])) {
    				attr_dev(path, "stroke-width", path_stroke_width_value);
    			}

    			if ((changed.$tr_strokeObject || changed.$tr_screenGeometryObject) && path_stroke_value !== (path_stroke_value = ctx.$tr_strokeObject[ctx.$key])) {
    				attr_dev(path, "stroke", path_stroke_value);
    			}

    			if ((changed.$tr_opacityObject || changed.$tr_screenGeometryObject) && path_style_value !== (path_style_value = `opacity: ${ctx.$tr_opacityObject[ctx.$key]}`)) {
    				attr_dev(path, "style", path_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(496:6) {#each Object.keys($tr_screenGeometryObject) as $key ($key)}",
    		ctx
    	});

    	return block;
    }

    // (513:0) {#if renderLabel}
    function create_if_block$4(ctx) {
    	let g;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_value = Object.keys(ctx.$tr_screenGeometryObject);
    	const get_key = ctx => ctx.$key;

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			g = svg_element("g");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(g, "class", "label-layer");
    			add_location(g, file$6, 513, 2, 16853);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(g, null);
    			}
    		},
    		p: function update(changed, ctx) {
    			const each_value = Object.keys(ctx.$tr_screenGeometryObject);
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, g, destroy_block, create_each_block, null, get_each_context);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(513:0) {#if renderLabel}",
    		ctx
    	});

    	return block;
    }

    // (515:4) {#each Object.keys($tr_screenGeometryObject) as $key ($key)}
    function create_each_block(key_2, ctx) {
    	let text_1;
    	let t_value = ctx.textObject[ctx.$key] + "";
    	let t;
    	let text_1_stroke_opacity_value;
    	let text_1_y_value;
    	let text_1_fill_value;
    	let text_1_stroke_value;
    	let text_1_stroke_width_value;
    	let text_1_fill_opacity_value;
    	let text_1_x_value;
    	let text_1_opacity_value;
    	let text_1_transform_value;
    	let text_1_font_family_value;
    	let text_1_font_size_value;
    	let text_1_font_weight_value;
    	let text_1_text_anchor_value;
    	let text_1_dominant_baseline_value;

    	const block = {
    		key: key_2,
    		first: null,
    		c: function create() {
    			text_1 = svg_element("text");
    			t = text(t_value);
    			attr_dev(text_1, "stroke-opacity", text_1_stroke_opacity_value = ctx.$tr_strokeOpacityObject[ctx.$key]);
    			attr_dev(text_1, "class", "label");
    			attr_dev(text_1, "y", text_1_y_value = ctx.$tr_screenGeometryObject[ctx.$key].coordinates[1]);
    			attr_dev(text_1, "fill", text_1_fill_value = ctx.$tr_fillObject[ctx.$key]);
    			attr_dev(text_1, "stroke", text_1_stroke_value = ctx.$tr_strokeObject[ctx.$key]);
    			attr_dev(text_1, "stroke-width", text_1_stroke_width_value = ctx.$tr_strokeWidthObject[ctx.$key]);
    			attr_dev(text_1, "fill-opacity", text_1_fill_opacity_value = ctx.$tr_fillOpacityObject[ctx.$key]);
    			attr_dev(text_1, "x", text_1_x_value = ctx.$tr_screenGeometryObject[ctx.$key].coordinates[0]);
    			attr_dev(text_1, "opacity", text_1_opacity_value = ctx.$tr_opacityObject[ctx.$key]);

    			attr_dev(text_1, "transform", text_1_transform_value = `
          rotate(${ctx.$tr_rotationObject[ctx.$key]}, 
          ${ctx.$tr_screenGeometryObject[ctx.$key].coordinates[0]}, 
          ${ctx.$tr_screenGeometryObject[ctx.$key].coordinates[1]})
        `);

    			attr_dev(text_1, "font-family", text_1_font_family_value = ctx.fontFamilyObject[ctx.$key]);
    			attr_dev(text_1, "font-size", text_1_font_size_value = ctx.$tr_fontSizeObject[ctx.$key] + "px");
    			attr_dev(text_1, "font-weight", text_1_font_weight_value = ctx.$tr_fontWeightObject[ctx.$key]);
    			attr_dev(text_1, "text-anchor", text_1_text_anchor_value = textAnchorPoint(ctx.anchorPointObject[ctx.$key]).textAnchor);
    			attr_dev(text_1, "dominant-baseline", text_1_dominant_baseline_value = textAnchorPoint(ctx.anchorPointObject[ctx.$key]).dominantBaseline);
    			add_location(text_1, file$6, 516, 6, 16949);
    			this.first = text_1;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, text_1, anchor);
    			append_dev(text_1, t);
    		},
    		p: function update(changed, ctx) {
    			if ((changed.textObject || changed.$tr_screenGeometryObject) && t_value !== (t_value = ctx.textObject[ctx.$key] + "")) set_data_dev(t, t_value);

    			if ((changed.$tr_strokeOpacityObject || changed.$tr_screenGeometryObject) && text_1_stroke_opacity_value !== (text_1_stroke_opacity_value = ctx.$tr_strokeOpacityObject[ctx.$key])) {
    				attr_dev(text_1, "stroke-opacity", text_1_stroke_opacity_value);
    			}

    			if (changed.$tr_screenGeometryObject && text_1_y_value !== (text_1_y_value = ctx.$tr_screenGeometryObject[ctx.$key].coordinates[1])) {
    				attr_dev(text_1, "y", text_1_y_value);
    			}

    			if ((changed.$tr_fillObject || changed.$tr_screenGeometryObject) && text_1_fill_value !== (text_1_fill_value = ctx.$tr_fillObject[ctx.$key])) {
    				attr_dev(text_1, "fill", text_1_fill_value);
    			}

    			if ((changed.$tr_strokeObject || changed.$tr_screenGeometryObject) && text_1_stroke_value !== (text_1_stroke_value = ctx.$tr_strokeObject[ctx.$key])) {
    				attr_dev(text_1, "stroke", text_1_stroke_value);
    			}

    			if ((changed.$tr_strokeWidthObject || changed.$tr_screenGeometryObject) && text_1_stroke_width_value !== (text_1_stroke_width_value = ctx.$tr_strokeWidthObject[ctx.$key])) {
    				attr_dev(text_1, "stroke-width", text_1_stroke_width_value);
    			}

    			if ((changed.$tr_fillOpacityObject || changed.$tr_screenGeometryObject) && text_1_fill_opacity_value !== (text_1_fill_opacity_value = ctx.$tr_fillOpacityObject[ctx.$key])) {
    				attr_dev(text_1, "fill-opacity", text_1_fill_opacity_value);
    			}

    			if (changed.$tr_screenGeometryObject && text_1_x_value !== (text_1_x_value = ctx.$tr_screenGeometryObject[ctx.$key].coordinates[0])) {
    				attr_dev(text_1, "x", text_1_x_value);
    			}

    			if ((changed.$tr_opacityObject || changed.$tr_screenGeometryObject) && text_1_opacity_value !== (text_1_opacity_value = ctx.$tr_opacityObject[ctx.$key])) {
    				attr_dev(text_1, "opacity", text_1_opacity_value);
    			}

    			if ((changed.$tr_rotationObject || changed.$tr_screenGeometryObject) && text_1_transform_value !== (text_1_transform_value = `
          rotate(${ctx.$tr_rotationObject[ctx.$key]}, 
          ${ctx.$tr_screenGeometryObject[ctx.$key].coordinates[0]}, 
          ${ctx.$tr_screenGeometryObject[ctx.$key].coordinates[1]})
        `)) {
    				attr_dev(text_1, "transform", text_1_transform_value);
    			}

    			if ((changed.fontFamilyObject || changed.$tr_screenGeometryObject) && text_1_font_family_value !== (text_1_font_family_value = ctx.fontFamilyObject[ctx.$key])) {
    				attr_dev(text_1, "font-family", text_1_font_family_value);
    			}

    			if ((changed.$tr_fontSizeObject || changed.$tr_screenGeometryObject) && text_1_font_size_value !== (text_1_font_size_value = ctx.$tr_fontSizeObject[ctx.$key] + "px")) {
    				attr_dev(text_1, "font-size", text_1_font_size_value);
    			}

    			if ((changed.$tr_fontWeightObject || changed.$tr_screenGeometryObject) && text_1_font_weight_value !== (text_1_font_weight_value = ctx.$tr_fontWeightObject[ctx.$key])) {
    				attr_dev(text_1, "font-weight", text_1_font_weight_value);
    			}

    			if ((changed.anchorPointObject || changed.$tr_screenGeometryObject) && text_1_text_anchor_value !== (text_1_text_anchor_value = textAnchorPoint(ctx.anchorPointObject[ctx.$key]).textAnchor)) {
    				attr_dev(text_1, "text-anchor", text_1_text_anchor_value);
    			}

    			if ((changed.anchorPointObject || changed.$tr_screenGeometryObject) && text_1_dominant_baseline_value !== (text_1_dominant_baseline_value = textAnchorPoint(ctx.anchorPointObject[ctx.$key]).dominantBaseline)) {
    				attr_dev(text_1, "dominant-baseline", text_1_dominant_baseline_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(text_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(515:4) {#each Object.keys($tr_screenGeometryObject) as $key ($key)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let show_if = ctx.$graphicContext.output() === "svg";
    	let t;
    	let if_block1_anchor;
    	let if_block0 = show_if && create_if_block_1$3(ctx);
    	let if_block1 = ctx.renderLabel && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(changed, ctx) {
    			if (changed.$graphicContext) show_if = ctx.$graphicContext.output() === "svg";

    			if (show_if) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_1$3(ctx);
    					if_block0.c();
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (ctx.renderLabel) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block$4(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let idCounter$3 = 0;

    function getId$3() {
    	return "layer" + idCounter$3++;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let $sectionContext;
    	let $coordinateTransformationContext;
    	let $zoomContext;

    	let $tr_screenGeometryObject,
    		$$unsubscribe_tr_screenGeometryObject = noop,
    		$$subscribe_tr_screenGeometryObject = () => ($$unsubscribe_tr_screenGeometryObject(), $$unsubscribe_tr_screenGeometryObject = subscribe(tr_screenGeometryObject, $$value => $$invalidate("$tr_screenGeometryObject", $tr_screenGeometryObject = $$value)), tr_screenGeometryObject);

    	let $tr_radiusObject,
    		$$unsubscribe_tr_radiusObject = noop,
    		$$subscribe_tr_radiusObject = () => ($$unsubscribe_tr_radiusObject(), $$unsubscribe_tr_radiusObject = subscribe(tr_radiusObject, $$value => $$invalidate("$tr_radiusObject", $tr_radiusObject = $$value)), tr_radiusObject);

    	let $tr_fillObject,
    		$$unsubscribe_tr_fillObject = noop,
    		$$subscribe_tr_fillObject = () => ($$unsubscribe_tr_fillObject(), $$unsubscribe_tr_fillObject = subscribe(tr_fillObject, $$value => $$invalidate("$tr_fillObject", $tr_fillObject = $$value)), tr_fillObject);

    	let $tr_strokeObject,
    		$$unsubscribe_tr_strokeObject = noop,
    		$$subscribe_tr_strokeObject = () => ($$unsubscribe_tr_strokeObject(), $$unsubscribe_tr_strokeObject = subscribe(tr_strokeObject, $$value => $$invalidate("$tr_strokeObject", $tr_strokeObject = $$value)), tr_strokeObject);

    	let $tr_strokeWidthObject,
    		$$unsubscribe_tr_strokeWidthObject = noop,
    		$$subscribe_tr_strokeWidthObject = () => ($$unsubscribe_tr_strokeWidthObject(), $$unsubscribe_tr_strokeWidthObject = subscribe(tr_strokeWidthObject, $$value => $$invalidate("$tr_strokeWidthObject", $tr_strokeWidthObject = $$value)), tr_strokeWidthObject);

    	let $tr_strokeOpacityObject,
    		$$unsubscribe_tr_strokeOpacityObject = noop,
    		$$subscribe_tr_strokeOpacityObject = () => ($$unsubscribe_tr_strokeOpacityObject(), $$unsubscribe_tr_strokeOpacityObject = subscribe(tr_strokeOpacityObject, $$value => $$invalidate("$tr_strokeOpacityObject", $tr_strokeOpacityObject = $$value)), tr_strokeOpacityObject);

    	let $tr_fillOpacityObject,
    		$$unsubscribe_tr_fillOpacityObject = noop,
    		$$subscribe_tr_fillOpacityObject = () => ($$unsubscribe_tr_fillOpacityObject(), $$unsubscribe_tr_fillOpacityObject = subscribe(tr_fillOpacityObject, $$value => $$invalidate("$tr_fillOpacityObject", $tr_fillOpacityObject = $$value)), tr_fillOpacityObject);

    	let $tr_opacityObject,
    		$$unsubscribe_tr_opacityObject = noop,
    		$$subscribe_tr_opacityObject = () => ($$unsubscribe_tr_opacityObject(), $$unsubscribe_tr_opacityObject = subscribe(tr_opacityObject, $$value => $$invalidate("$tr_opacityObject", $tr_opacityObject = $$value)), tr_opacityObject);

    	let $tr_fontSizeObject,
    		$$unsubscribe_tr_fontSizeObject = noop,
    		$$subscribe_tr_fontSizeObject = () => ($$unsubscribe_tr_fontSizeObject(), $$unsubscribe_tr_fontSizeObject = subscribe(tr_fontSizeObject, $$value => $$invalidate("$tr_fontSizeObject", $tr_fontSizeObject = $$value)), tr_fontSizeObject);

    	let $tr_fontWeightObject,
    		$$unsubscribe_tr_fontWeightObject = noop,
    		$$subscribe_tr_fontWeightObject = () => ($$unsubscribe_tr_fontWeightObject(), $$unsubscribe_tr_fontWeightObject = subscribe(tr_fontWeightObject, $$value => $$invalidate("$tr_fontWeightObject", $tr_fontWeightObject = $$value)), tr_fontWeightObject);

    	let $tr_rotationObject,
    		$$unsubscribe_tr_rotationObject = noop,
    		$$subscribe_tr_rotationObject = () => ($$unsubscribe_tr_rotationObject(), $$unsubscribe_tr_rotationObject = subscribe(tr_rotationObject, $$value => $$invalidate("$tr_rotationObject", $tr_rotationObject = $$value)), tr_rotationObject);

    	let $interactionManagerContext;
    	let $graphicContext;
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_screenGeometryObject());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_radiusObject());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_fillObject());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_strokeObject());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_strokeWidthObject());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_strokeOpacityObject());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_fillOpacityObject());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_opacityObject());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_fontSizeObject());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_fontWeightObject());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_tr_rotationObject());
    	const layerId = getId$3();
    	let initPhase = true;
    	const initDone = () => !initPhase;
    	let { type } = $$props;
    	let { x } = $$props;
    	let { y } = $$props;
    	let { x1 } = $$props;
    	let { x2 } = $$props;
    	let { y1 } = $$props;
    	let { y2 } = $$props;
    	let { geometry } = $$props;
    	let { independentAxis } = $$props;
    	let { radius } = $$props;
    	let { fill } = $$props;
    	let { stroke } = $$props;
    	let { strokeWidth } = $$props;
    	let { strokeOpacity } = $$props;
    	let { fillOpacity } = $$props;
    	let { opacity } = $$props;
    	let { text } = $$props;
    	let { fontFamily } = $$props;
    	let { fontSize } = $$props;
    	let { fontWeight } = $$props;
    	let { rotation } = $$props;
    	let { anchorPoint } = $$props;
    	let { transition } = $$props;
    	let { onClick } = $$props;
    	let { onMousedown } = $$props;
    	let { onMouseup } = $$props;
    	let { onMouseover } = $$props;
    	let { onMouseout } = $$props;
    	let { onMousedrag } = $$props;
    	let { onSelect } = $$props;
    	let { onDeselect } = $$props;
    	let { key } = $$props;
    	let { interpolate } = $$props;
    	let { _asPolygon = true } = $$props;
    	let { zoomIdentity } = $$props;
    	let { blockReindexing = false } = $$props;

    	let aesthetics = validateAesthetics(type, {
    		x,
    		y,
    		x1,
    		x2,
    		y1,
    		y2,
    		geometry,
    		independentAxis,
    		radius,
    		fill,
    		stroke,
    		strokeWidth,
    		strokeOpacity,
    		fillOpacity,
    		opacity,
    		text,
    		fontFamily,
    		fontSize,
    		fontWeight,
    		rotation,
    		anchorPoint
    	});

    	let positioningAesthetics = {
    		x,
    		y,
    		x1,
    		x2,
    		y1,
    		y2,
    		geometry,
    		independentAxis
    	};

    	let createCoordSysGeometryObject = layerCoordSysGeometryFuncs[type];
    	let representAsPolygonObject = layerRepresentAsPolygonFuncs[type];
    	const graphicContext = subscribe$1();
    	validate_store(graphicContext, "graphicContext");
    	component_subscribe($$self, graphicContext, value => $$invalidate("$graphicContext", $graphicContext = value));
    	const sectionContext = subscribe$2();
    	validate_store(sectionContext, "sectionContext");
    	component_subscribe($$self, sectionContext, value => $$invalidate("$sectionContext", $sectionContext = value));
    	const coordinateTransformationContext = subscribe$5();
    	validate_store(coordinateTransformationContext, "coordinateTransformationContext");
    	component_subscribe($$self, coordinateTransformationContext, value => $$invalidate("$coordinateTransformationContext", $coordinateTransformationContext = value));
    	const interactionManagerContext = subscribe$4();
    	validate_store(interactionManagerContext, "interactionManagerContext");
    	component_subscribe($$self, interactionManagerContext, value => $$invalidate("$interactionManagerContext", $interactionManagerContext = value));
    	const zoomContext = subscribe$6();
    	validate_store(zoomContext, "zoomContext");
    	component_subscribe($$self, zoomContext, value => $$invalidate("$zoomContext", $zoomContext = value));
    	let coordSysGeometryObject;
    	let pixelGeometryObject;
    	let screenGeometryObject;
    	updateCoordSysGeometryObject();
    	updatePixelGeometryObject();
    	let keyArray = Object.keys(coordSysGeometryObject);
    	let radiusObject = generatePropObject(aesthetics.radius, keyArray);
    	const fillObject = generatePropObject(aesthetics.fill, keyArray);
    	const strokeObject = generatePropObject(aesthetics.stroke, keyArray);
    	let strokeWidthObject = generatePropObject(aesthetics.strokeWidth, keyArray);
    	const strokeOpacityObject = generatePropObject(aesthetics.strokeOpacity, keyArray);
    	const fillOpacityObject = generatePropObject(aesthetics.fillOpacity, keyArray);
    	const opacityObject = generatePropObject(aesthetics.opacity, keyArray);
    	let textObject = generatePropObject(aesthetics.text, keyArray);
    	let fontFamilyObject = generatePropObject(aesthetics.fontFamily, keyArray);
    	const fontSizeObject = generatePropObject(aesthetics.fontSize, keyArray);
    	const fontWeightObject = generatePropObject(aesthetics.fontWeight, keyArray);
    	const rotationObject = generatePropObject(aesthetics.rotation, keyArray);
    	let anchorPointObject = generatePropObject(aesthetics.anchorPoint, keyArray);
    	updateScreenGeometryObject();
    	let tr_screenGeometryObject = createTransitionableLayer("geometry", screenGeometryObject, transition);
    	validate_store(tr_screenGeometryObject, "tr_screenGeometryObject");
    	$$subscribe_tr_screenGeometryObject();
    	let tr_radiusObject = createTransitionableLayer("radius", radiusObject, transition);
    	validate_store(tr_radiusObject, "tr_radiusObject");
    	$$subscribe_tr_radiusObject();
    	let tr_fillObject = createTransitionableLayer("fill", fillObject, transition);
    	validate_store(tr_fillObject, "tr_fillObject");
    	$$subscribe_tr_fillObject();
    	let tr_strokeObject = createTransitionableLayer("stroke", strokeObject, transition);
    	validate_store(tr_strokeObject, "tr_strokeObject");
    	$$subscribe_tr_strokeObject();
    	let tr_strokeWidthObject = createTransitionableLayer("strokeWidth", strokeWidthObject, transition);
    	validate_store(tr_strokeWidthObject, "tr_strokeWidthObject");
    	$$subscribe_tr_strokeWidthObject();
    	let tr_strokeOpacityObject = createTransitionableLayer("strokeOpacity", strokeOpacityObject, transition);
    	validate_store(tr_strokeOpacityObject, "tr_strokeOpacityObject");
    	$$subscribe_tr_strokeOpacityObject();
    	let tr_fillOpacityObject = createTransitionableLayer("fillOpacity", fillOpacityObject, transition);
    	validate_store(tr_fillOpacityObject, "tr_fillOpacityObject");
    	$$subscribe_tr_fillOpacityObject();
    	let tr_opacityObject = createTransitionableLayer("opacity", opacityObject, transition);
    	validate_store(tr_opacityObject, "tr_opacityObject");
    	$$subscribe_tr_opacityObject();
    	let tr_fontSizeObject = createTransitionableLayer("fontSize", fontSizeObject, transition);
    	validate_store(tr_fontSizeObject, "tr_fontSizeObject");
    	$$subscribe_tr_fontSizeObject();
    	let tr_fontWeightObject = createTransitionableLayer("fontWeight", fontWeightObject, transition);
    	validate_store(tr_fontWeightObject, "tr_fontWeightObject");
    	$$subscribe_tr_fontWeightObject();
    	let tr_rotationObject = createTransitionableLayer("rotation", rotationObject, transition);
    	validate_store(tr_rotationObject, "tr_rotationObject");
    	$$subscribe_tr_rotationObject();
    	let previousTransition;
    	let coordSysGeometryObjectRecalculationNecessary = false;
    	let pixelGeometryObjectRecalculationNecessary = false;
    	let screenGeometryObjectRecalculationNecessary = false;

    	beforeUpdate(() => {
    		if (!transitionsEqual(previousTransition, transition) && initDone()) {
    			$$subscribe_tr_screenGeometryObject($$invalidate("tr_screenGeometryObject", tr_screenGeometryObject = createTransitionableLayer("geometry", $tr_screenGeometryObject, transition)));
    			$$subscribe_tr_radiusObject($$invalidate("tr_radiusObject", tr_radiusObject = createTransitionableLayer("radius", $tr_radiusObject, transition)));
    			$$subscribe_tr_fillObject($$invalidate("tr_fillObject", tr_fillObject = createTransitionableLayer("fill", $tr_fillObject, transition)));
    			$$subscribe_tr_strokeObject($$invalidate("tr_strokeObject", tr_strokeObject = createTransitionableLayer("stroke", $tr_strokeObject, transition)));
    			$$subscribe_tr_strokeWidthObject($$invalidate("tr_strokeWidthObject", tr_strokeWidthObject = createTransitionableLayer("strokeWidth", $tr_strokeWidthObject, transition)));
    			$$subscribe_tr_strokeOpacityObject($$invalidate("tr_strokeOpacityObject", tr_strokeOpacityObject = createTransitionableLayer("strokeOpacity", $tr_strokeOpacityObject, transition)));
    			$$subscribe_tr_fillOpacityObject($$invalidate("tr_fillOpacityObject", tr_fillOpacityObject = createTransitionableLayer("fillOpacity", $tr_fillOpacityObject, transition)));
    			$$subscribe_tr_opacityObject($$invalidate("tr_opacityObject", tr_opacityObject = createTransitionableLayer("opacity", $tr_opacityObject, transition)));
    			$$subscribe_tr_fontSizeObject($$invalidate("tr_fontSizeObject", tr_fontSizeObject = createTransitionableLayer("fontSize", $tr_fontSizeObject, transition)));
    			$$subscribe_tr_fontWeightObject($$invalidate("tr_fontWeightObject", tr_fontWeightObject = createTransitionableLayer("fontWeight", $tr_fontWeightObject, transition)));
    			$$subscribe_tr_rotationObject($$invalidate("tr_rotationObject", tr_rotationObject = createTransitionableLayer("rotation", $tr_rotationObject, transition)));
    		}

    		previousTransition = transition;
    	});

    	afterUpdate(() => {
    		initPhase = false;
    	});

    	onMount(() => {
    		updateInteractionManagerIfNecessary();
    	});

    	onDestroy(() => {
    		removeLayerFromSpatialIndexIfNecessary();
    	});

    	function scheduleUpdateCoordSysGeometryObject() {
    		$$invalidate("coordSysGeometryObjectRecalculationNecessary", coordSysGeometryObjectRecalculationNecessary = true);
    		$$invalidate("pixelGeometryObjectRecalculationNecessary", pixelGeometryObjectRecalculationNecessary = true);
    		$$invalidate("screenGeometryObjectRecalculationNecessary", screenGeometryObjectRecalculationNecessary = true);
    	}

    	function updateCoordSysGeometryObject() {
    		$$invalidate("coordSysGeometryObject", coordSysGeometryObject = createCoordSysGeometryObject(positioningAesthetics, $sectionContext, $coordinateTransformationContext, key, interpolate));
    	}

    	function scheduleUpdatePixelGeometryObject() {
    		$$invalidate("pixelGeometryObjectRecalculationNecessary", pixelGeometryObjectRecalculationNecessary = true);
    		$$invalidate("screenGeometryObjectRecalculationNecessary", screenGeometryObjectRecalculationNecessary = true);
    	}

    	function updatePixelGeometryObject() {
    		const zoomTransformation = createZoomTransformation($zoomContext, zoomIdentity);

    		if (zoomTransformation) {
    			pixelGeometryObject = transformGeometries(coordSysGeometryObject, zoomTransformation);
    		} else {
    			pixelGeometryObject = coordSysGeometryObject;
    		}
    	}

    	function updateScreenGeometryObject() {
    		if (_asPolygon) {
    			screenGeometryObject = representAsPolygonObject(pixelGeometryObject, { radiusObject, strokeWidthObject });
    		} else {
    			screenGeometryObject = pixelGeometryObject;
    		}
    	}

    	function updateScreenGeometryObjectTransitionable() {
    		tr_screenGeometryObject.set(screenGeometryObject);
    	}

    	function updateRadiusAndStrokeWidth() {
    		radiusObject = generatePropObject(aesthetics.radius, keyArray);
    		strokeWidthObject = generatePropObject(aesthetics.strokeWidth, keyArray);
    	}

    	function updateInteractionManagerIfNecessary() {
    		if (initPhase || !(blockReindexing || $sectionContext.blockReindexing)) {
    			removeLayerFromSpatialIndexIfNecessary();

    			if (isInteractiveMouse) {
    				const markInterface = $interactionManagerContext.mouse().marks();
    				markInterface.loadLayer(type, createDataNecessaryForIndexing());
    				if (onClick) markInterface.addLayerInteraction("click", layerId, onClick);
    				if (onMousedown) markInterface.addLayerInteraction("mousedown", layerId, onMousedown);
    				if (onMouseup) markInterface.addLayerInteraction("mouseup", layerId, onMouseup);
    				if (onMouseout) markInterface.addLayerInteraction("mouseout", layerId, onMouseout);
    				if (onMouseover) markInterface.addLayerInteraction("mouseover", layerId, onMouseover);
    				if (onMousedrag) markInterface.addLayerInteraction("mousedrag", layerId, onMousedrag);
    			}
    		}

    		removeLayerFromSelectIfNecessary();

    		if (isSelectable) {
    			const selectManager = $interactionManagerContext.select();
    			selectManager.loadLayer(type, createDataNecessaryForIndexing(), { onSelect, onDeselect });
    		}
    	}

    	function removeLayerFromSpatialIndexIfNecessary() {
    		const markInterface = $interactionManagerContext.mouse().marks();

    		if (markInterface.layerIsLoaded(layerId)) {
    			markInterface.removeAllLayerInteractions(layerId);
    			markInterface.removeLayer(layerId);
    		}
    	}

    	function removeLayerFromSelectIfNecessary() {
    		const selectManager = $interactionManagerContext.select();

    		if (selectManager.layerIsLoaded(layerId)) {
    			selectManager.removeLayer(layerId);
    		}
    	}

    	function createDataNecessaryForIndexing() {
    		return createDataNecessaryForIndexingLayer(
    			type,
    			layerId,
    			keyArray,
    			{
    				pixelGeometryObject,
    				screenGeometryObject
    			},
    			{ radiusObject, strokeWidthObject }
    		);
    	}

    	const writable_props = [
    		"type",
    		"x",
    		"y",
    		"x1",
    		"x2",
    		"y1",
    		"y2",
    		"geometry",
    		"independentAxis",
    		"radius",
    		"fill",
    		"stroke",
    		"strokeWidth",
    		"strokeOpacity",
    		"fillOpacity",
    		"opacity",
    		"text",
    		"fontFamily",
    		"fontSize",
    		"fontWeight",
    		"rotation",
    		"anchorPoint",
    		"transition",
    		"onClick",
    		"onMousedown",
    		"onMouseup",
    		"onMouseover",
    		"onMouseout",
    		"onMousedrag",
    		"onSelect",
    		"onDeselect",
    		"key",
    		"interpolate",
    		"_asPolygon",
    		"zoomIdentity",
    		"blockReindexing"
    	];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Layer> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("type" in $$props) $$invalidate("type", type = $$props.type);
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("x1" in $$props) $$invalidate("x1", x1 = $$props.x1);
    		if ("x2" in $$props) $$invalidate("x2", x2 = $$props.x2);
    		if ("y1" in $$props) $$invalidate("y1", y1 = $$props.y1);
    		if ("y2" in $$props) $$invalidate("y2", y2 = $$props.y2);
    		if ("geometry" in $$props) $$invalidate("geometry", geometry = $$props.geometry);
    		if ("independentAxis" in $$props) $$invalidate("independentAxis", independentAxis = $$props.independentAxis);
    		if ("radius" in $$props) $$invalidate("radius", radius = $$props.radius);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("strokeOpacity" in $$props) $$invalidate("strokeOpacity", strokeOpacity = $$props.strokeOpacity);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("text" in $$props) $$invalidate("text", text = $$props.text);
    		if ("fontFamily" in $$props) $$invalidate("fontFamily", fontFamily = $$props.fontFamily);
    		if ("fontSize" in $$props) $$invalidate("fontSize", fontSize = $$props.fontSize);
    		if ("fontWeight" in $$props) $$invalidate("fontWeight", fontWeight = $$props.fontWeight);
    		if ("rotation" in $$props) $$invalidate("rotation", rotation = $$props.rotation);
    		if ("anchorPoint" in $$props) $$invalidate("anchorPoint", anchorPoint = $$props.anchorPoint);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("key" in $$props) $$invalidate("key", key = $$props.key);
    		if ("interpolate" in $$props) $$invalidate("interpolate", interpolate = $$props.interpolate);
    		if ("_asPolygon" in $$props) $$invalidate("_asPolygon", _asPolygon = $$props._asPolygon);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	$$self.$capture_state = () => {
    		return {
    			idCounter: idCounter$3,
    			initPhase,
    			type,
    			x,
    			y,
    			x1,
    			x2,
    			y1,
    			y2,
    			geometry,
    			independentAxis,
    			radius,
    			fill,
    			stroke,
    			strokeWidth,
    			strokeOpacity,
    			fillOpacity,
    			opacity,
    			text,
    			fontFamily,
    			fontSize,
    			fontWeight,
    			rotation,
    			anchorPoint,
    			transition,
    			onClick,
    			onMousedown,
    			onMouseup,
    			onMouseover,
    			onMouseout,
    			onMousedrag,
    			onSelect,
    			onDeselect,
    			key,
    			interpolate,
    			_asPolygon,
    			zoomIdentity,
    			blockReindexing,
    			aesthetics,
    			positioningAesthetics,
    			createCoordSysGeometryObject,
    			representAsPolygonObject,
    			coordSysGeometryObject,
    			pixelGeometryObject,
    			screenGeometryObject,
    			keyArray,
    			radiusObject,
    			strokeWidthObject,
    			textObject,
    			fontFamilyObject,
    			anchorPointObject,
    			tr_screenGeometryObject,
    			tr_radiusObject,
    			tr_fillObject,
    			tr_strokeObject,
    			tr_strokeWidthObject,
    			tr_strokeOpacityObject,
    			tr_fillOpacityObject,
    			tr_opacityObject,
    			tr_fontSizeObject,
    			tr_fontWeightObject,
    			tr_rotationObject,
    			previousTransition,
    			coordSysGeometryObjectRecalculationNecessary,
    			pixelGeometryObjectRecalculationNecessary,
    			screenGeometryObjectRecalculationNecessary,
    			$sectionContext,
    			$coordinateTransformationContext,
    			$zoomContext,
    			$tr_screenGeometryObject,
    			$tr_radiusObject,
    			$tr_fillObject,
    			$tr_strokeObject,
    			$tr_strokeWidthObject,
    			$tr_strokeOpacityObject,
    			$tr_fillOpacityObject,
    			$tr_opacityObject,
    			$tr_fontSizeObject,
    			$tr_fontWeightObject,
    			$tr_rotationObject,
    			isInteractiveMouse,
    			isInteractiveTouch,
    			isSelectable,
    			$interactionManagerContext,
    			renderPolygon,
    			renderCircle,
    			renderLine,
    			renderLabel,
    			$graphicContext
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("initPhase" in $$props) initPhase = $$props.initPhase;
    		if ("type" in $$props) $$invalidate("type", type = $$props.type);
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("x1" in $$props) $$invalidate("x1", x1 = $$props.x1);
    		if ("x2" in $$props) $$invalidate("x2", x2 = $$props.x2);
    		if ("y1" in $$props) $$invalidate("y1", y1 = $$props.y1);
    		if ("y2" in $$props) $$invalidate("y2", y2 = $$props.y2);
    		if ("geometry" in $$props) $$invalidate("geometry", geometry = $$props.geometry);
    		if ("independentAxis" in $$props) $$invalidate("independentAxis", independentAxis = $$props.independentAxis);
    		if ("radius" in $$props) $$invalidate("radius", radius = $$props.radius);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("strokeOpacity" in $$props) $$invalidate("strokeOpacity", strokeOpacity = $$props.strokeOpacity);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("text" in $$props) $$invalidate("text", text = $$props.text);
    		if ("fontFamily" in $$props) $$invalidate("fontFamily", fontFamily = $$props.fontFamily);
    		if ("fontSize" in $$props) $$invalidate("fontSize", fontSize = $$props.fontSize);
    		if ("fontWeight" in $$props) $$invalidate("fontWeight", fontWeight = $$props.fontWeight);
    		if ("rotation" in $$props) $$invalidate("rotation", rotation = $$props.rotation);
    		if ("anchorPoint" in $$props) $$invalidate("anchorPoint", anchorPoint = $$props.anchorPoint);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("key" in $$props) $$invalidate("key", key = $$props.key);
    		if ("interpolate" in $$props) $$invalidate("interpolate", interpolate = $$props.interpolate);
    		if ("_asPolygon" in $$props) $$invalidate("_asPolygon", _asPolygon = $$props._asPolygon);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    		if ("aesthetics" in $$props) $$invalidate("aesthetics", aesthetics = $$props.aesthetics);
    		if ("positioningAesthetics" in $$props) $$invalidate("positioningAesthetics", positioningAesthetics = $$props.positioningAesthetics);
    		if ("createCoordSysGeometryObject" in $$props) createCoordSysGeometryObject = $$props.createCoordSysGeometryObject;
    		if ("representAsPolygonObject" in $$props) representAsPolygonObject = $$props.representAsPolygonObject;
    		if ("coordSysGeometryObject" in $$props) $$invalidate("coordSysGeometryObject", coordSysGeometryObject = $$props.coordSysGeometryObject);
    		if ("pixelGeometryObject" in $$props) pixelGeometryObject = $$props.pixelGeometryObject;
    		if ("screenGeometryObject" in $$props) screenGeometryObject = $$props.screenGeometryObject;
    		if ("keyArray" in $$props) $$invalidate("keyArray", keyArray = $$props.keyArray);
    		if ("radiusObject" in $$props) radiusObject = $$props.radiusObject;
    		if ("strokeWidthObject" in $$props) strokeWidthObject = $$props.strokeWidthObject;
    		if ("textObject" in $$props) $$invalidate("textObject", textObject = $$props.textObject);
    		if ("fontFamilyObject" in $$props) $$invalidate("fontFamilyObject", fontFamilyObject = $$props.fontFamilyObject);
    		if ("anchorPointObject" in $$props) $$invalidate("anchorPointObject", anchorPointObject = $$props.anchorPointObject);
    		if ("tr_screenGeometryObject" in $$props) $$subscribe_tr_screenGeometryObject($$invalidate("tr_screenGeometryObject", tr_screenGeometryObject = $$props.tr_screenGeometryObject));
    		if ("tr_radiusObject" in $$props) $$subscribe_tr_radiusObject($$invalidate("tr_radiusObject", tr_radiusObject = $$props.tr_radiusObject));
    		if ("tr_fillObject" in $$props) $$subscribe_tr_fillObject($$invalidate("tr_fillObject", tr_fillObject = $$props.tr_fillObject));
    		if ("tr_strokeObject" in $$props) $$subscribe_tr_strokeObject($$invalidate("tr_strokeObject", tr_strokeObject = $$props.tr_strokeObject));
    		if ("tr_strokeWidthObject" in $$props) $$subscribe_tr_strokeWidthObject($$invalidate("tr_strokeWidthObject", tr_strokeWidthObject = $$props.tr_strokeWidthObject));
    		if ("tr_strokeOpacityObject" in $$props) $$subscribe_tr_strokeOpacityObject($$invalidate("tr_strokeOpacityObject", tr_strokeOpacityObject = $$props.tr_strokeOpacityObject));
    		if ("tr_fillOpacityObject" in $$props) $$subscribe_tr_fillOpacityObject($$invalidate("tr_fillOpacityObject", tr_fillOpacityObject = $$props.tr_fillOpacityObject));
    		if ("tr_opacityObject" in $$props) $$subscribe_tr_opacityObject($$invalidate("tr_opacityObject", tr_opacityObject = $$props.tr_opacityObject));
    		if ("tr_fontSizeObject" in $$props) $$subscribe_tr_fontSizeObject($$invalidate("tr_fontSizeObject", tr_fontSizeObject = $$props.tr_fontSizeObject));
    		if ("tr_fontWeightObject" in $$props) $$subscribe_tr_fontWeightObject($$invalidate("tr_fontWeightObject", tr_fontWeightObject = $$props.tr_fontWeightObject));
    		if ("tr_rotationObject" in $$props) $$subscribe_tr_rotationObject($$invalidate("tr_rotationObject", tr_rotationObject = $$props.tr_rotationObject));
    		if ("previousTransition" in $$props) previousTransition = $$props.previousTransition;
    		if ("coordSysGeometryObjectRecalculationNecessary" in $$props) $$invalidate("coordSysGeometryObjectRecalculationNecessary", coordSysGeometryObjectRecalculationNecessary = $$props.coordSysGeometryObjectRecalculationNecessary);
    		if ("pixelGeometryObjectRecalculationNecessary" in $$props) $$invalidate("pixelGeometryObjectRecalculationNecessary", pixelGeometryObjectRecalculationNecessary = $$props.pixelGeometryObjectRecalculationNecessary);
    		if ("screenGeometryObjectRecalculationNecessary" in $$props) $$invalidate("screenGeometryObjectRecalculationNecessary", screenGeometryObjectRecalculationNecessary = $$props.screenGeometryObjectRecalculationNecessary);
    		if ("$sectionContext" in $$props) sectionContext.set($sectionContext = $$props.$sectionContext);
    		if ("$coordinateTransformationContext" in $$props) coordinateTransformationContext.set($coordinateTransformationContext = $$props.$coordinateTransformationContext);
    		if ("$zoomContext" in $$props) zoomContext.set($zoomContext = $$props.$zoomContext);
    		if ("$tr_screenGeometryObject" in $$props) tr_screenGeometryObject.set($tr_screenGeometryObject = $$props.$tr_screenGeometryObject);
    		if ("$tr_radiusObject" in $$props) tr_radiusObject.set($tr_radiusObject = $$props.$tr_radiusObject);
    		if ("$tr_fillObject" in $$props) tr_fillObject.set($tr_fillObject = $$props.$tr_fillObject);
    		if ("$tr_strokeObject" in $$props) tr_strokeObject.set($tr_strokeObject = $$props.$tr_strokeObject);
    		if ("$tr_strokeWidthObject" in $$props) tr_strokeWidthObject.set($tr_strokeWidthObject = $$props.$tr_strokeWidthObject);
    		if ("$tr_strokeOpacityObject" in $$props) tr_strokeOpacityObject.set($tr_strokeOpacityObject = $$props.$tr_strokeOpacityObject);
    		if ("$tr_fillOpacityObject" in $$props) tr_fillOpacityObject.set($tr_fillOpacityObject = $$props.$tr_fillOpacityObject);
    		if ("$tr_opacityObject" in $$props) tr_opacityObject.set($tr_opacityObject = $$props.$tr_opacityObject);
    		if ("$tr_fontSizeObject" in $$props) tr_fontSizeObject.set($tr_fontSizeObject = $$props.$tr_fontSizeObject);
    		if ("$tr_fontWeightObject" in $$props) tr_fontWeightObject.set($tr_fontWeightObject = $$props.$tr_fontWeightObject);
    		if ("$tr_rotationObject" in $$props) tr_rotationObject.set($tr_rotationObject = $$props.$tr_rotationObject);
    		if ("isInteractiveMouse" in $$props) isInteractiveMouse = $$props.isInteractiveMouse;
    		if ("isInteractiveTouch" in $$props) isInteractiveTouch = $$props.isInteractiveTouch;
    		if ("isSelectable" in $$props) isSelectable = $$props.isSelectable;
    		if ("$interactionManagerContext" in $$props) interactionManagerContext.set($interactionManagerContext = $$props.$interactionManagerContext);
    		if ("renderPolygon" in $$props) $$invalidate("renderPolygon", renderPolygon = $$props.renderPolygon);
    		if ("renderCircle" in $$props) $$invalidate("renderCircle", renderCircle = $$props.renderCircle);
    		if ("renderLine" in $$props) $$invalidate("renderLine", renderLine = $$props.renderLine);
    		if ("renderLabel" in $$props) $$invalidate("renderLabel", renderLabel = $$props.renderLabel);
    		if ("$graphicContext" in $$props) graphicContext.set($graphicContext = $$props.$graphicContext);
    	};

    	let isInteractiveMouse;
    	let isInteractiveTouch;
    	let isSelectable;
    	let renderPolygon;
    	let renderCircle;
    	let renderLine;
    	let renderLabel;

    	$$self.$$.update = (changed = { type: 1, x: 1, y: 1, x1: 1, x2: 1, y1: 1, y2: 1, geometry: 1, independentAxis: 1, radius: 1, fill: 1, stroke: 1, strokeWidth: 1, strokeOpacity: 1, fillOpacity: 1, opacity: 1, text: 1, fontFamily: 1, fontSize: 1, fontWeight: 1, rotation: 1, anchorPoint: 1, positioningAesthetics: 1, $sectionContext: 1, $coordinateTransformationContext: 1, key: 1, interpolate: 1, $zoomContext: 1, coordSysGeometryObjectRecalculationNecessary: 1, coordSysGeometryObject: 1, _asPolygon: 1, pixelGeometryObjectRecalculationNecessary: 1, screenGeometryObjectRecalculationNecessary: 1, tr_radiusObject: 1, aesthetics: 1, keyArray: 1, tr_strokeWidthObject: 1, tr_fillObject: 1, tr_strokeObject: 1, tr_strokeOpacityObject: 1, tr_fillOpacityObject: 1, tr_opacityObject: 1, tr_fontSizeObject: 1, tr_fontWeightObject: 1, tr_rotationObject: 1, onClick: 1, onMousedown: 1, onMouseup: 1, onMouseover: 1, onMouseout: 1, onMousedrag: 1, onSelect: 1, onDeselect: 1 }) => {
    		if (changed.type || changed.x || changed.y || changed.x1 || changed.x2 || changed.y1 || changed.y2 || changed.geometry || changed.independentAxis || changed.radius || changed.fill || changed.stroke || changed.strokeWidth || changed.strokeOpacity || changed.fillOpacity || changed.opacity || changed.text || changed.fontFamily || changed.fontSize || changed.fontWeight || changed.rotation || changed.anchorPoint) {
    			 {
    				if (initDone()) {
    					$$invalidate("aesthetics", aesthetics = validateAesthetics(type, {
    						x,
    						y,
    						x1,
    						x2,
    						y1,
    						y2,
    						geometry,
    						independentAxis,
    						radius,
    						fill,
    						stroke,
    						strokeWidth,
    						strokeOpacity,
    						fillOpacity,
    						opacity,
    						text,
    						fontFamily,
    						fontSize,
    						fontWeight,
    						rotation,
    						anchorPoint
    					}));
    				}
    			}
    		}

    		if (changed.x || changed.y || changed.x1 || changed.x2 || changed.y1 || changed.y2 || changed.geometry || changed.independentAxis) {
    			 {
    				if (initDone()) {
    					$$invalidate("positioningAesthetics", positioningAesthetics = {
    						x,
    						y,
    						x1,
    						x2,
    						y1,
    						y2,
    						geometry,
    						independentAxis
    					});
    				}
    			}
    		}

    		if (changed.type) {
    			 {
    				if (initDone()) {
    					createCoordSysGeometryObject = layerCoordSysGeometryFuncs[type];
    					representAsPolygonObject = layerRepresentAsPolygonFuncs[type];
    				}
    			}
    		}

    		if (changed.positioningAesthetics || changed.$sectionContext || changed.$coordinateTransformationContext || changed.key || changed.interpolate) {
    			 {
    				if (initDone()) {
    					scheduleUpdateCoordSysGeometryObject();
    				}
    			}
    		}

    		if (changed.$zoomContext) {
    			 {
    				if (initDone()) {
    					scheduleUpdatePixelGeometryObject();
    				}
    			}
    		}

    		if (changed.coordSysGeometryObjectRecalculationNecessary || changed.coordSysGeometryObject || changed._asPolygon || changed.pixelGeometryObjectRecalculationNecessary || changed.screenGeometryObjectRecalculationNecessary) {
    			 {
    				tick().then(() => {
    					if (coordSysGeometryObjectRecalculationNecessary) {
    						updateCoordSysGeometryObject();
    						$$invalidate("keyArray", keyArray = Object.keys(coordSysGeometryObject));

    						if (_asPolygon) {
    							updateRadiusAndStrokeWidth();
    						}
    					}

    					if (pixelGeometryObjectRecalculationNecessary) updatePixelGeometryObject();

    					if (screenGeometryObjectRecalculationNecessary) {
    						updateScreenGeometryObject();
    						updateScreenGeometryObjectTransitionable();
    						updateInteractionManagerIfNecessary();
    					}

    					$$invalidate("coordSysGeometryObjectRecalculationNecessary", coordSysGeometryObjectRecalculationNecessary = false);
    					$$invalidate("pixelGeometryObjectRecalculationNecessary", pixelGeometryObjectRecalculationNecessary = false);
    					$$invalidate("screenGeometryObjectRecalculationNecessary", screenGeometryObjectRecalculationNecessary = false);
    				});
    			}
    		}

    		if (changed._asPolygon || changed.tr_radiusObject || changed.aesthetics || changed.keyArray || changed.tr_strokeWidthObject) {
    			 {
    				if (initDone()) {
    					if (!_asPolygon) {
    						tr_radiusObject.set(generatePropObject(aesthetics.radius, keyArray));
    						tr_strokeWidthObject.set(generatePropObject(aesthetics.strokeWidth, keyArray));
    					}
    				}
    			}
    		}

    		if (changed.tr_fillObject || changed.aesthetics || changed.keyArray) {
    			 {
    				if (initDone()) tr_fillObject.set(generatePropObject(aesthetics.fill, keyArray));
    			}
    		}

    		if (changed.tr_strokeObject || changed.aesthetics || changed.keyArray) {
    			 {
    				if (initDone()) tr_strokeObject.set(generatePropObject(aesthetics.stroke, keyArray));
    			}
    		}

    		if (changed.tr_strokeOpacityObject || changed.aesthetics || changed.keyArray) {
    			 {
    				if (initDone()) tr_strokeOpacityObject.set(generatePropObject(aesthetics.strokeOpacity, keyArray));
    			}
    		}

    		if (changed.tr_fillOpacityObject || changed.aesthetics || changed.keyArray) {
    			 {
    				if (initDone()) tr_fillOpacityObject.set(generatePropObject(aesthetics.fillOpacity, keyArray));
    			}
    		}

    		if (changed.tr_opacityObject || changed.aesthetics || changed.keyArray) {
    			 {
    				if (initDone()) tr_opacityObject.set(generatePropObject(aesthetics.opacity, keyArray));
    			}
    		}

    		if (changed.tr_fontSizeObject || changed.aesthetics || changed.keyArray) {
    			 {
    				if (initDone()) tr_fontSizeObject.set(generatePropObject(aesthetics.fontSize, keyArray));
    			}
    		}

    		if (changed.tr_fontWeightObject || changed.aesthetics || changed.keyArray) {
    			 {
    				if (initDone()) tr_fontWeightObject.set(generatePropObject(aesthetics.fontWeight, keyArray));
    			}
    		}

    		if (changed.tr_rotationObject || changed.aesthetics || changed.keyArray) {
    			 {
    				if (initDone()) tr_rotationObject.set(generatePropObject(aesthetics.rotation, keyArray));
    			}
    		}

    		if (changed.aesthetics || changed.keyArray) {
    			 {
    				if (initDone()) $$invalidate("textObject", textObject = generatePropObject(aesthetics.text, keyArray));
    			}
    		}

    		if (changed.aesthetics || changed.keyArray) {
    			 {
    				if (initDone()) $$invalidate("fontFamilyObject", fontFamilyObject = generatePropObject(aesthetics.fontFamily, keyArray));
    			}
    		}

    		if (changed.aesthetics || changed.keyArray) {
    			 {
    				if (initDone()) $$invalidate("anchorPointObject", anchorPointObject = generatePropObject(aesthetics.anchorPoint, keyArray));
    			}
    		}

    		if (changed.onClick || changed.onMousedown || changed.onMouseup || changed.onMouseover || changed.onMouseout || changed.onMousedrag) {
    			 isInteractiveMouse = detectIt.hasMouse && (onClick !== undefined || onMousedown !== undefined || onMouseup !== undefined || onMouseover !== undefined || onMouseout !== undefined || onMousedrag !== undefined);
    		}

    		if (changed.onSelect || changed.onDeselect) {
    			 isSelectable = onSelect !== undefined || onDeselect !== undefined;
    		}

    		if (changed.type || changed._asPolygon) {
    			 $$invalidate("renderPolygon", renderPolygon = !["Point", "Line", "Label"].includes(type) || _asPolygon);
    		}

    		if (changed.type || changed._asPolygon) {
    			 $$invalidate("renderCircle", renderCircle = type === "Point" && !_asPolygon);
    		}

    		if (changed.type || changed._asPolygon) {
    			 $$invalidate("renderLine", renderLine = type === "Line" && !_asPolygon);
    		}

    		if (changed.type) {
    			 $$invalidate("renderLabel", renderLabel = type === "Label");
    		}
    	};

    	 isInteractiveTouch = detectIt.hasTouch;

    	return {
    		type,
    		x,
    		y,
    		x1,
    		x2,
    		y1,
    		y2,
    		geometry,
    		independentAxis,
    		radius,
    		fill,
    		stroke,
    		strokeWidth,
    		strokeOpacity,
    		fillOpacity,
    		opacity,
    		text,
    		fontFamily,
    		fontSize,
    		fontWeight,
    		rotation,
    		anchorPoint,
    		transition,
    		onClick,
    		onMousedown,
    		onMouseup,
    		onMouseover,
    		onMouseout,
    		onMousedrag,
    		onSelect,
    		onDeselect,
    		key,
    		interpolate,
    		_asPolygon,
    		zoomIdentity,
    		blockReindexing,
    		graphicContext,
    		sectionContext,
    		coordinateTransformationContext,
    		interactionManagerContext,
    		zoomContext,
    		textObject,
    		fontFamilyObject,
    		anchorPointObject,
    		tr_screenGeometryObject,
    		tr_radiusObject,
    		tr_fillObject,
    		tr_strokeObject,
    		tr_strokeWidthObject,
    		tr_strokeOpacityObject,
    		tr_fillOpacityObject,
    		tr_opacityObject,
    		tr_fontSizeObject,
    		tr_fontWeightObject,
    		tr_rotationObject,
    		$tr_screenGeometryObject,
    		$tr_radiusObject,
    		$tr_fillObject,
    		$tr_strokeObject,
    		$tr_strokeWidthObject,
    		$tr_strokeOpacityObject,
    		$tr_fillOpacityObject,
    		$tr_opacityObject,
    		$tr_fontSizeObject,
    		$tr_fontWeightObject,
    		$tr_rotationObject,
    		renderPolygon,
    		renderCircle,
    		renderLine,
    		renderLabel,
    		$graphicContext
    	};
    }

    class Layer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {
    			type: 0,
    			x: 0,
    			y: 0,
    			x1: 0,
    			x2: 0,
    			y1: 0,
    			y2: 0,
    			geometry: 0,
    			independentAxis: 0,
    			radius: 0,
    			fill: 0,
    			stroke: 0,
    			strokeWidth: 0,
    			strokeOpacity: 0,
    			fillOpacity: 0,
    			opacity: 0,
    			text: 0,
    			fontFamily: 0,
    			fontSize: 0,
    			fontWeight: 0,
    			rotation: 0,
    			anchorPoint: 0,
    			transition: 0,
    			onClick: 0,
    			onMousedown: 0,
    			onMouseup: 0,
    			onMouseover: 0,
    			onMouseout: 0,
    			onMousedrag: 0,
    			onSelect: 0,
    			onDeselect: 0,
    			key: 0,
    			interpolate: 0,
    			_asPolygon: 0,
    			zoomIdentity: 0,
    			blockReindexing: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Layer",
    			options,
    			id: create_fragment$f.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || ({});

    		if (ctx.type === undefined && !("type" in props)) {
    			console.warn("<Layer> was created without expected prop 'type'");
    		}

    		if (ctx.x === undefined && !("x" in props)) {
    			console.warn("<Layer> was created without expected prop 'x'");
    		}

    		if (ctx.y === undefined && !("y" in props)) {
    			console.warn("<Layer> was created without expected prop 'y'");
    		}

    		if (ctx.x1 === undefined && !("x1" in props)) {
    			console.warn("<Layer> was created without expected prop 'x1'");
    		}

    		if (ctx.x2 === undefined && !("x2" in props)) {
    			console.warn("<Layer> was created without expected prop 'x2'");
    		}

    		if (ctx.y1 === undefined && !("y1" in props)) {
    			console.warn("<Layer> was created without expected prop 'y1'");
    		}

    		if (ctx.y2 === undefined && !("y2" in props)) {
    			console.warn("<Layer> was created without expected prop 'y2'");
    		}

    		if (ctx.geometry === undefined && !("geometry" in props)) {
    			console.warn("<Layer> was created without expected prop 'geometry'");
    		}

    		if (ctx.independentAxis === undefined && !("independentAxis" in props)) {
    			console.warn("<Layer> was created without expected prop 'independentAxis'");
    		}

    		if (ctx.radius === undefined && !("radius" in props)) {
    			console.warn("<Layer> was created without expected prop 'radius'");
    		}

    		if (ctx.fill === undefined && !("fill" in props)) {
    			console.warn("<Layer> was created without expected prop 'fill'");
    		}

    		if (ctx.stroke === undefined && !("stroke" in props)) {
    			console.warn("<Layer> was created without expected prop 'stroke'");
    		}

    		if (ctx.strokeWidth === undefined && !("strokeWidth" in props)) {
    			console.warn("<Layer> was created without expected prop 'strokeWidth'");
    		}

    		if (ctx.strokeOpacity === undefined && !("strokeOpacity" in props)) {
    			console.warn("<Layer> was created without expected prop 'strokeOpacity'");
    		}

    		if (ctx.fillOpacity === undefined && !("fillOpacity" in props)) {
    			console.warn("<Layer> was created without expected prop 'fillOpacity'");
    		}

    		if (ctx.opacity === undefined && !("opacity" in props)) {
    			console.warn("<Layer> was created without expected prop 'opacity'");
    		}

    		if (ctx.text === undefined && !("text" in props)) {
    			console.warn("<Layer> was created without expected prop 'text'");
    		}

    		if (ctx.fontFamily === undefined && !("fontFamily" in props)) {
    			console.warn("<Layer> was created without expected prop 'fontFamily'");
    		}

    		if (ctx.fontSize === undefined && !("fontSize" in props)) {
    			console.warn("<Layer> was created without expected prop 'fontSize'");
    		}

    		if (ctx.fontWeight === undefined && !("fontWeight" in props)) {
    			console.warn("<Layer> was created without expected prop 'fontWeight'");
    		}

    		if (ctx.rotation === undefined && !("rotation" in props)) {
    			console.warn("<Layer> was created without expected prop 'rotation'");
    		}

    		if (ctx.anchorPoint === undefined && !("anchorPoint" in props)) {
    			console.warn("<Layer> was created without expected prop 'anchorPoint'");
    		}

    		if (ctx.transition === undefined && !("transition" in props)) {
    			console.warn("<Layer> was created without expected prop 'transition'");
    		}

    		if (ctx.onClick === undefined && !("onClick" in props)) {
    			console.warn("<Layer> was created without expected prop 'onClick'");
    		}

    		if (ctx.onMousedown === undefined && !("onMousedown" in props)) {
    			console.warn("<Layer> was created without expected prop 'onMousedown'");
    		}

    		if (ctx.onMouseup === undefined && !("onMouseup" in props)) {
    			console.warn("<Layer> was created without expected prop 'onMouseup'");
    		}

    		if (ctx.onMouseover === undefined && !("onMouseover" in props)) {
    			console.warn("<Layer> was created without expected prop 'onMouseover'");
    		}

    		if (ctx.onMouseout === undefined && !("onMouseout" in props)) {
    			console.warn("<Layer> was created without expected prop 'onMouseout'");
    		}

    		if (ctx.onMousedrag === undefined && !("onMousedrag" in props)) {
    			console.warn("<Layer> was created without expected prop 'onMousedrag'");
    		}

    		if (ctx.onSelect === undefined && !("onSelect" in props)) {
    			console.warn("<Layer> was created without expected prop 'onSelect'");
    		}

    		if (ctx.onDeselect === undefined && !("onDeselect" in props)) {
    			console.warn("<Layer> was created without expected prop 'onDeselect'");
    		}

    		if (ctx.key === undefined && !("key" in props)) {
    			console.warn("<Layer> was created without expected prop 'key'");
    		}

    		if (ctx.interpolate === undefined && !("interpolate" in props)) {
    			console.warn("<Layer> was created without expected prop 'interpolate'");
    		}

    		if (ctx.zoomIdentity === undefined && !("zoomIdentity" in props)) {
    			console.warn("<Layer> was created without expected prop 'zoomIdentity'");
    		}
    	}

    	get type() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get x() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get x1() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x1(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get x2() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x2(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y1() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y1(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y2() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y2(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get geometry() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set geometry(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get independentAxis() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set independentAxis(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get radius() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radius(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fill() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fill(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stroke() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stroke(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeWidth() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeWidth(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeOpacity() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeOpacity(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillOpacity() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillOpacity(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opacity() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opacity(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fontFamily() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fontFamily(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fontSize() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fontSize(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fontWeight() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fontWeight(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rotation() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rotation(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get anchorPoint() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set anchorPoint(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transition() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transition(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClick() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClick(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedown() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedown(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseup() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseup(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseover() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseover(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseout() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseout(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedrag() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedrag(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSelect() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSelect(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onDeselect() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onDeselect(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get key() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get interpolate() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set interpolate(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get _asPolygon() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set _asPolygon(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zoomIdentity() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoomIdentity(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blockReindexing() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blockReindexing(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Marks/Point/PointLayer.svelte generated by Svelte v3.15.0 */

    function create_fragment$g(ctx) {
    	let current;

    	const layer = new Layer({
    			props: {
    				type: "Point",
    				x: ctx.x,
    				y: ctx.y,
    				geometry: ctx.geometry,
    				radius: ctx.radius,
    				fill: ctx.fill,
    				stroke: ctx.stroke,
    				strokeWidth: ctx.strokeWidth,
    				strokeOpacity: ctx.strokeOpacity,
    				fillOpacity: ctx.fillOpacity,
    				opacity: ctx.opacity,
    				transition: ctx.transition,
    				onClick: ctx.onClick,
    				onMousedown: ctx.onMousedown,
    				onMouseup: ctx.onMouseup,
    				onMouseover: ctx.onMouseover,
    				onMouseout: ctx.onMouseout,
    				onMousedrag: ctx.onMousedrag,
    				onSelect: ctx.onSelect,
    				onDeselect: ctx.onDeselect,
    				key: ctx.key,
    				zoomIdentity: ctx.zoomIdentity,
    				_asPolygon: false,
    				blockReindexing: ctx.blockReindexing
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(layer.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(layer, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const layer_changes = {};
    			if (changed.x) layer_changes.x = ctx.x;
    			if (changed.y) layer_changes.y = ctx.y;
    			if (changed.geometry) layer_changes.geometry = ctx.geometry;
    			if (changed.radius) layer_changes.radius = ctx.radius;
    			if (changed.fill) layer_changes.fill = ctx.fill;
    			if (changed.stroke) layer_changes.stroke = ctx.stroke;
    			if (changed.strokeWidth) layer_changes.strokeWidth = ctx.strokeWidth;
    			if (changed.strokeOpacity) layer_changes.strokeOpacity = ctx.strokeOpacity;
    			if (changed.fillOpacity) layer_changes.fillOpacity = ctx.fillOpacity;
    			if (changed.opacity) layer_changes.opacity = ctx.opacity;
    			if (changed.transition) layer_changes.transition = ctx.transition;
    			if (changed.onClick) layer_changes.onClick = ctx.onClick;
    			if (changed.onMousedown) layer_changes.onMousedown = ctx.onMousedown;
    			if (changed.onMouseup) layer_changes.onMouseup = ctx.onMouseup;
    			if (changed.onMouseover) layer_changes.onMouseover = ctx.onMouseover;
    			if (changed.onMouseout) layer_changes.onMouseout = ctx.onMouseout;
    			if (changed.onMousedrag) layer_changes.onMousedrag = ctx.onMousedrag;
    			if (changed.onSelect) layer_changes.onSelect = ctx.onSelect;
    			if (changed.onDeselect) layer_changes.onDeselect = ctx.onDeselect;
    			if (changed.key) layer_changes.key = ctx.key;
    			if (changed.zoomIdentity) layer_changes.zoomIdentity = ctx.zoomIdentity;
    			if (changed.blockReindexing) layer_changes.blockReindexing = ctx.blockReindexing;
    			layer.$set(layer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(layer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(layer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(layer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { x } = $$props;
    	let { y } = $$props;
    	let { geometry } = $$props;
    	let { radius } = $$props;
    	let { fill } = $$props;
    	let { stroke } = $$props;
    	let { strokeWidth } = $$props;
    	let { strokeOpacity } = $$props;
    	let { fillOpacity } = $$props;
    	let { opacity } = $$props;
    	let { transition } = $$props;
    	let { onClick } = $$props;
    	let { onMousedown } = $$props;
    	let { onMouseup } = $$props;
    	let { onMouseover } = $$props;
    	let { onMouseout } = $$props;
    	let { onMousedrag } = $$props;
    	let { onSelect } = $$props;
    	let { onDeselect } = $$props;
    	let { key } = $$props;
    	let { zoomIdentity } = $$props;
    	let { blockReindexing = false } = $$props;

    	const writable_props = [
    		"x",
    		"y",
    		"geometry",
    		"radius",
    		"fill",
    		"stroke",
    		"strokeWidth",
    		"strokeOpacity",
    		"fillOpacity",
    		"opacity",
    		"transition",
    		"onClick",
    		"onMousedown",
    		"onMouseup",
    		"onMouseover",
    		"onMouseout",
    		"onMousedrag",
    		"onSelect",
    		"onDeselect",
    		"key",
    		"zoomIdentity",
    		"blockReindexing"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PointLayer> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("geometry" in $$props) $$invalidate("geometry", geometry = $$props.geometry);
    		if ("radius" in $$props) $$invalidate("radius", radius = $$props.radius);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("strokeOpacity" in $$props) $$invalidate("strokeOpacity", strokeOpacity = $$props.strokeOpacity);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("key" in $$props) $$invalidate("key", key = $$props.key);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	$$self.$capture_state = () => {
    		return {
    			x,
    			y,
    			geometry,
    			radius,
    			fill,
    			stroke,
    			strokeWidth,
    			strokeOpacity,
    			fillOpacity,
    			opacity,
    			transition,
    			onClick,
    			onMousedown,
    			onMouseup,
    			onMouseover,
    			onMouseout,
    			onMousedrag,
    			onSelect,
    			onDeselect,
    			key,
    			zoomIdentity,
    			blockReindexing
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("geometry" in $$props) $$invalidate("geometry", geometry = $$props.geometry);
    		if ("radius" in $$props) $$invalidate("radius", radius = $$props.radius);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("strokeOpacity" in $$props) $$invalidate("strokeOpacity", strokeOpacity = $$props.strokeOpacity);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("key" in $$props) $$invalidate("key", key = $$props.key);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	return {
    		x,
    		y,
    		geometry,
    		radius,
    		fill,
    		stroke,
    		strokeWidth,
    		strokeOpacity,
    		fillOpacity,
    		opacity,
    		transition,
    		onClick,
    		onMousedown,
    		onMouseup,
    		onMouseover,
    		onMouseout,
    		onMousedrag,
    		onSelect,
    		onDeselect,
    		key,
    		zoomIdentity,
    		blockReindexing
    	};
    }

    class PointLayer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {
    			x: 0,
    			y: 0,
    			geometry: 0,
    			radius: 0,
    			fill: 0,
    			stroke: 0,
    			strokeWidth: 0,
    			strokeOpacity: 0,
    			fillOpacity: 0,
    			opacity: 0,
    			transition: 0,
    			onClick: 0,
    			onMousedown: 0,
    			onMouseup: 0,
    			onMouseover: 0,
    			onMouseout: 0,
    			onMousedrag: 0,
    			onSelect: 0,
    			onDeselect: 0,
    			key: 0,
    			zoomIdentity: 0,
    			blockReindexing: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PointLayer",
    			options,
    			id: create_fragment$g.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || ({});

    		if (ctx.x === undefined && !("x" in props)) {
    			console.warn("<PointLayer> was created without expected prop 'x'");
    		}

    		if (ctx.y === undefined && !("y" in props)) {
    			console.warn("<PointLayer> was created without expected prop 'y'");
    		}

    		if (ctx.geometry === undefined && !("geometry" in props)) {
    			console.warn("<PointLayer> was created without expected prop 'geometry'");
    		}

    		if (ctx.radius === undefined && !("radius" in props)) {
    			console.warn("<PointLayer> was created without expected prop 'radius'");
    		}

    		if (ctx.fill === undefined && !("fill" in props)) {
    			console.warn("<PointLayer> was created without expected prop 'fill'");
    		}

    		if (ctx.stroke === undefined && !("stroke" in props)) {
    			console.warn("<PointLayer> was created without expected prop 'stroke'");
    		}

    		if (ctx.strokeWidth === undefined && !("strokeWidth" in props)) {
    			console.warn("<PointLayer> was created without expected prop 'strokeWidth'");
    		}

    		if (ctx.strokeOpacity === undefined && !("strokeOpacity" in props)) {
    			console.warn("<PointLayer> was created without expected prop 'strokeOpacity'");
    		}

    		if (ctx.fillOpacity === undefined && !("fillOpacity" in props)) {
    			console.warn("<PointLayer> was created without expected prop 'fillOpacity'");
    		}

    		if (ctx.opacity === undefined && !("opacity" in props)) {
    			console.warn("<PointLayer> was created without expected prop 'opacity'");
    		}

    		if (ctx.transition === undefined && !("transition" in props)) {
    			console.warn("<PointLayer> was created without expected prop 'transition'");
    		}

    		if (ctx.onClick === undefined && !("onClick" in props)) {
    			console.warn("<PointLayer> was created without expected prop 'onClick'");
    		}

    		if (ctx.onMousedown === undefined && !("onMousedown" in props)) {
    			console.warn("<PointLayer> was created without expected prop 'onMousedown'");
    		}

    		if (ctx.onMouseup === undefined && !("onMouseup" in props)) {
    			console.warn("<PointLayer> was created without expected prop 'onMouseup'");
    		}

    		if (ctx.onMouseover === undefined && !("onMouseover" in props)) {
    			console.warn("<PointLayer> was created without expected prop 'onMouseover'");
    		}

    		if (ctx.onMouseout === undefined && !("onMouseout" in props)) {
    			console.warn("<PointLayer> was created without expected prop 'onMouseout'");
    		}

    		if (ctx.onMousedrag === undefined && !("onMousedrag" in props)) {
    			console.warn("<PointLayer> was created without expected prop 'onMousedrag'");
    		}

    		if (ctx.onSelect === undefined && !("onSelect" in props)) {
    			console.warn("<PointLayer> was created without expected prop 'onSelect'");
    		}

    		if (ctx.onDeselect === undefined && !("onDeselect" in props)) {
    			console.warn("<PointLayer> was created without expected prop 'onDeselect'");
    		}

    		if (ctx.key === undefined && !("key" in props)) {
    			console.warn("<PointLayer> was created without expected prop 'key'");
    		}

    		if (ctx.zoomIdentity === undefined && !("zoomIdentity" in props)) {
    			console.warn("<PointLayer> was created without expected prop 'zoomIdentity'");
    		}
    	}

    	get x() {
    		throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x(value) {
    		throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y() {
    		throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y(value) {
    		throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get geometry() {
    		throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set geometry(value) {
    		throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get radius() {
    		throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radius(value) {
    		throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fill() {
    		throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fill(value) {
    		throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stroke() {
    		throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stroke(value) {
    		throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeWidth() {
    		throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeWidth(value) {
    		throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeOpacity() {
    		throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeOpacity(value) {
    		throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillOpacity() {
    		throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillOpacity(value) {
    		throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opacity() {
    		throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opacity(value) {
    		throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transition() {
    		throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transition(value) {
    		throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClick() {
    		throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClick(value) {
    		throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedown() {
    		throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedown(value) {
    		throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseup() {
    		throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseup(value) {
    		throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseover() {
    		throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseover(value) {
    		throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseout() {
    		throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseout(value) {
    		throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedrag() {
    		throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedrag(value) {
    		throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSelect() {
    		throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSelect(value) {
    		throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onDeselect() {
    		throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onDeselect(value) {
    		throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get key() {
    		throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zoomIdentity() {
    		throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoomIdentity(value) {
    		throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blockReindexing() {
    		throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blockReindexing(value) {
    		throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Marks/Rectangle/RectangleLayer.svelte generated by Svelte v3.15.0 */

    function create_fragment$h(ctx) {
    	let current;

    	const layer = new Layer({
    			props: {
    				type: "Rectangle",
    				x1: ctx.x1,
    				x2: ctx.x2,
    				y1: ctx.y1,
    				y2: ctx.y2,
    				fill: ctx.fill,
    				stroke: ctx.stroke,
    				strokeWidth: ctx.strokeWidth,
    				strokeOpacity: ctx.strokeOpacity,
    				fillOpacity: ctx.fillOpacity,
    				opacity: ctx.opacity,
    				transition: ctx.transition,
    				onClick: ctx.onClick,
    				onMousedown: ctx.onMousedown,
    				onMouseup: ctx.onMouseup,
    				onMouseover: ctx.onMouseover,
    				onMouseout: ctx.onMouseout,
    				onMousedrag: ctx.onMousedrag,
    				onSelect: ctx.onSelect,
    				onDeselect: ctx.onDeselect,
    				key: ctx.key,
    				zoomIdentity: ctx.zoomIdentity,
    				interpolate: ctx.interpolate,
    				blockReindexing: ctx.blockReindexing
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(layer.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(layer, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const layer_changes = {};
    			if (changed.x1) layer_changes.x1 = ctx.x1;
    			if (changed.x2) layer_changes.x2 = ctx.x2;
    			if (changed.y1) layer_changes.y1 = ctx.y1;
    			if (changed.y2) layer_changes.y2 = ctx.y2;
    			if (changed.fill) layer_changes.fill = ctx.fill;
    			if (changed.stroke) layer_changes.stroke = ctx.stroke;
    			if (changed.strokeWidth) layer_changes.strokeWidth = ctx.strokeWidth;
    			if (changed.strokeOpacity) layer_changes.strokeOpacity = ctx.strokeOpacity;
    			if (changed.fillOpacity) layer_changes.fillOpacity = ctx.fillOpacity;
    			if (changed.opacity) layer_changes.opacity = ctx.opacity;
    			if (changed.transition) layer_changes.transition = ctx.transition;
    			if (changed.onClick) layer_changes.onClick = ctx.onClick;
    			if (changed.onMousedown) layer_changes.onMousedown = ctx.onMousedown;
    			if (changed.onMouseup) layer_changes.onMouseup = ctx.onMouseup;
    			if (changed.onMouseover) layer_changes.onMouseover = ctx.onMouseover;
    			if (changed.onMouseout) layer_changes.onMouseout = ctx.onMouseout;
    			if (changed.onMousedrag) layer_changes.onMousedrag = ctx.onMousedrag;
    			if (changed.onSelect) layer_changes.onSelect = ctx.onSelect;
    			if (changed.onDeselect) layer_changes.onDeselect = ctx.onDeselect;
    			if (changed.key) layer_changes.key = ctx.key;
    			if (changed.zoomIdentity) layer_changes.zoomIdentity = ctx.zoomIdentity;
    			if (changed.interpolate) layer_changes.interpolate = ctx.interpolate;
    			if (changed.blockReindexing) layer_changes.blockReindexing = ctx.blockReindexing;
    			layer.$set(layer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(layer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(layer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(layer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { x1 } = $$props;
    	let { x2 } = $$props;
    	let { y1 } = $$props;
    	let { y2 } = $$props;
    	let { fill } = $$props;
    	let { stroke } = $$props;
    	let { strokeWidth } = $$props;
    	let { strokeOpacity } = $$props;
    	let { fillOpacity } = $$props;
    	let { opacity } = $$props;
    	let { transition } = $$props;
    	let { onClick } = $$props;
    	let { onMousedown } = $$props;
    	let { onMouseup } = $$props;
    	let { onMouseover } = $$props;
    	let { onMouseout } = $$props;
    	let { onMousedrag } = $$props;
    	let { onSelect } = $$props;
    	let { onDeselect } = $$props;
    	let { key } = $$props;
    	let { interpolate = true } = $$props;
    	let { zoomIdentity } = $$props;
    	let { blockReindexing = false } = $$props;

    	const writable_props = [
    		"x1",
    		"x2",
    		"y1",
    		"y2",
    		"fill",
    		"stroke",
    		"strokeWidth",
    		"strokeOpacity",
    		"fillOpacity",
    		"opacity",
    		"transition",
    		"onClick",
    		"onMousedown",
    		"onMouseup",
    		"onMouseover",
    		"onMouseout",
    		"onMousedrag",
    		"onSelect",
    		"onDeselect",
    		"key",
    		"interpolate",
    		"zoomIdentity",
    		"blockReindexing"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<RectangleLayer> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("x1" in $$props) $$invalidate("x1", x1 = $$props.x1);
    		if ("x2" in $$props) $$invalidate("x2", x2 = $$props.x2);
    		if ("y1" in $$props) $$invalidate("y1", y1 = $$props.y1);
    		if ("y2" in $$props) $$invalidate("y2", y2 = $$props.y2);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("strokeOpacity" in $$props) $$invalidate("strokeOpacity", strokeOpacity = $$props.strokeOpacity);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("key" in $$props) $$invalidate("key", key = $$props.key);
    		if ("interpolate" in $$props) $$invalidate("interpolate", interpolate = $$props.interpolate);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	$$self.$capture_state = () => {
    		return {
    			x1,
    			x2,
    			y1,
    			y2,
    			fill,
    			stroke,
    			strokeWidth,
    			strokeOpacity,
    			fillOpacity,
    			opacity,
    			transition,
    			onClick,
    			onMousedown,
    			onMouseup,
    			onMouseover,
    			onMouseout,
    			onMousedrag,
    			onSelect,
    			onDeselect,
    			key,
    			interpolate,
    			zoomIdentity,
    			blockReindexing
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("x1" in $$props) $$invalidate("x1", x1 = $$props.x1);
    		if ("x2" in $$props) $$invalidate("x2", x2 = $$props.x2);
    		if ("y1" in $$props) $$invalidate("y1", y1 = $$props.y1);
    		if ("y2" in $$props) $$invalidate("y2", y2 = $$props.y2);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("strokeOpacity" in $$props) $$invalidate("strokeOpacity", strokeOpacity = $$props.strokeOpacity);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("key" in $$props) $$invalidate("key", key = $$props.key);
    		if ("interpolate" in $$props) $$invalidate("interpolate", interpolate = $$props.interpolate);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	return {
    		x1,
    		x2,
    		y1,
    		y2,
    		fill,
    		stroke,
    		strokeWidth,
    		strokeOpacity,
    		fillOpacity,
    		opacity,
    		transition,
    		onClick,
    		onMousedown,
    		onMouseup,
    		onMouseover,
    		onMouseout,
    		onMousedrag,
    		onSelect,
    		onDeselect,
    		key,
    		interpolate,
    		zoomIdentity,
    		blockReindexing
    	};
    }

    class RectangleLayer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {
    			x1: 0,
    			x2: 0,
    			y1: 0,
    			y2: 0,
    			fill: 0,
    			stroke: 0,
    			strokeWidth: 0,
    			strokeOpacity: 0,
    			fillOpacity: 0,
    			opacity: 0,
    			transition: 0,
    			onClick: 0,
    			onMousedown: 0,
    			onMouseup: 0,
    			onMouseover: 0,
    			onMouseout: 0,
    			onMousedrag: 0,
    			onSelect: 0,
    			onDeselect: 0,
    			key: 0,
    			interpolate: 0,
    			zoomIdentity: 0,
    			blockReindexing: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RectangleLayer",
    			options,
    			id: create_fragment$h.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || ({});

    		if (ctx.x1 === undefined && !("x1" in props)) {
    			console.warn("<RectangleLayer> was created without expected prop 'x1'");
    		}

    		if (ctx.x2 === undefined && !("x2" in props)) {
    			console.warn("<RectangleLayer> was created without expected prop 'x2'");
    		}

    		if (ctx.y1 === undefined && !("y1" in props)) {
    			console.warn("<RectangleLayer> was created without expected prop 'y1'");
    		}

    		if (ctx.y2 === undefined && !("y2" in props)) {
    			console.warn("<RectangleLayer> was created without expected prop 'y2'");
    		}

    		if (ctx.fill === undefined && !("fill" in props)) {
    			console.warn("<RectangleLayer> was created without expected prop 'fill'");
    		}

    		if (ctx.stroke === undefined && !("stroke" in props)) {
    			console.warn("<RectangleLayer> was created without expected prop 'stroke'");
    		}

    		if (ctx.strokeWidth === undefined && !("strokeWidth" in props)) {
    			console.warn("<RectangleLayer> was created without expected prop 'strokeWidth'");
    		}

    		if (ctx.strokeOpacity === undefined && !("strokeOpacity" in props)) {
    			console.warn("<RectangleLayer> was created without expected prop 'strokeOpacity'");
    		}

    		if (ctx.fillOpacity === undefined && !("fillOpacity" in props)) {
    			console.warn("<RectangleLayer> was created without expected prop 'fillOpacity'");
    		}

    		if (ctx.opacity === undefined && !("opacity" in props)) {
    			console.warn("<RectangleLayer> was created without expected prop 'opacity'");
    		}

    		if (ctx.transition === undefined && !("transition" in props)) {
    			console.warn("<RectangleLayer> was created without expected prop 'transition'");
    		}

    		if (ctx.onClick === undefined && !("onClick" in props)) {
    			console.warn("<RectangleLayer> was created without expected prop 'onClick'");
    		}

    		if (ctx.onMousedown === undefined && !("onMousedown" in props)) {
    			console.warn("<RectangleLayer> was created without expected prop 'onMousedown'");
    		}

    		if (ctx.onMouseup === undefined && !("onMouseup" in props)) {
    			console.warn("<RectangleLayer> was created without expected prop 'onMouseup'");
    		}

    		if (ctx.onMouseover === undefined && !("onMouseover" in props)) {
    			console.warn("<RectangleLayer> was created without expected prop 'onMouseover'");
    		}

    		if (ctx.onMouseout === undefined && !("onMouseout" in props)) {
    			console.warn("<RectangleLayer> was created without expected prop 'onMouseout'");
    		}

    		if (ctx.onMousedrag === undefined && !("onMousedrag" in props)) {
    			console.warn("<RectangleLayer> was created without expected prop 'onMousedrag'");
    		}

    		if (ctx.onSelect === undefined && !("onSelect" in props)) {
    			console.warn("<RectangleLayer> was created without expected prop 'onSelect'");
    		}

    		if (ctx.onDeselect === undefined && !("onDeselect" in props)) {
    			console.warn("<RectangleLayer> was created without expected prop 'onDeselect'");
    		}

    		if (ctx.key === undefined && !("key" in props)) {
    			console.warn("<RectangleLayer> was created without expected prop 'key'");
    		}

    		if (ctx.zoomIdentity === undefined && !("zoomIdentity" in props)) {
    			console.warn("<RectangleLayer> was created without expected prop 'zoomIdentity'");
    		}
    	}

    	get x1() {
    		throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x1(value) {
    		throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get x2() {
    		throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x2(value) {
    		throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y1() {
    		throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y1(value) {
    		throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y2() {
    		throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y2(value) {
    		throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fill() {
    		throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fill(value) {
    		throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stroke() {
    		throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stroke(value) {
    		throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeWidth() {
    		throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeWidth(value) {
    		throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeOpacity() {
    		throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeOpacity(value) {
    		throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillOpacity() {
    		throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillOpacity(value) {
    		throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opacity() {
    		throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opacity(value) {
    		throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transition() {
    		throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transition(value) {
    		throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClick() {
    		throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClick(value) {
    		throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedown() {
    		throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedown(value) {
    		throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseup() {
    		throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseup(value) {
    		throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseover() {
    		throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseover(value) {
    		throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseout() {
    		throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseout(value) {
    		throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedrag() {
    		throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedrag(value) {
    		throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSelect() {
    		throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSelect(value) {
    		throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onDeselect() {
    		throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onDeselect(value) {
    		throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get key() {
    		throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get interpolate() {
    		throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set interpolate(value) {
    		throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zoomIdentity() {
    		throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoomIdentity(value) {
    		throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blockReindexing() {
    		throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blockReindexing(value) {
    		throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Marks/Polygon/PolygonLayer.svelte generated by Svelte v3.15.0 */

    function create_fragment$i(ctx) {
    	let current;

    	const layer = new Layer({
    			props: {
    				type: "Polygon",
    				x: ctx.x,
    				y: ctx.y,
    				geometry: ctx.geometry,
    				fill: ctx.fill,
    				stroke: ctx.stroke,
    				strokeWidth: ctx.strokeWidth,
    				strokeOpacity: ctx.strokeOpacity,
    				fillOpacity: ctx.fillOpacity,
    				opacity: ctx.opacity,
    				transition: ctx.transition,
    				onClick: ctx.onClick,
    				onMousedown: ctx.onMousedown,
    				onMouseup: ctx.onMouseup,
    				onMouseover: ctx.onMouseover,
    				onMouseout: ctx.onMouseout,
    				onMousedrag: ctx.onMousedrag,
    				onSelect: ctx.onSelect,
    				onDeselect: ctx.onDeselect,
    				key: ctx.key,
    				zoomIdentity: ctx.zoomIdentity,
    				interpolate: ctx.interpolate,
    				blockReindexing: ctx.blockReindexing
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(layer.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(layer, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const layer_changes = {};
    			if (changed.x) layer_changes.x = ctx.x;
    			if (changed.y) layer_changes.y = ctx.y;
    			if (changed.geometry) layer_changes.geometry = ctx.geometry;
    			if (changed.fill) layer_changes.fill = ctx.fill;
    			if (changed.stroke) layer_changes.stroke = ctx.stroke;
    			if (changed.strokeWidth) layer_changes.strokeWidth = ctx.strokeWidth;
    			if (changed.strokeOpacity) layer_changes.strokeOpacity = ctx.strokeOpacity;
    			if (changed.fillOpacity) layer_changes.fillOpacity = ctx.fillOpacity;
    			if (changed.opacity) layer_changes.opacity = ctx.opacity;
    			if (changed.transition) layer_changes.transition = ctx.transition;
    			if (changed.onClick) layer_changes.onClick = ctx.onClick;
    			if (changed.onMousedown) layer_changes.onMousedown = ctx.onMousedown;
    			if (changed.onMouseup) layer_changes.onMouseup = ctx.onMouseup;
    			if (changed.onMouseover) layer_changes.onMouseover = ctx.onMouseover;
    			if (changed.onMouseout) layer_changes.onMouseout = ctx.onMouseout;
    			if (changed.onMousedrag) layer_changes.onMousedrag = ctx.onMousedrag;
    			if (changed.onSelect) layer_changes.onSelect = ctx.onSelect;
    			if (changed.onDeselect) layer_changes.onDeselect = ctx.onDeselect;
    			if (changed.key) layer_changes.key = ctx.key;
    			if (changed.zoomIdentity) layer_changes.zoomIdentity = ctx.zoomIdentity;
    			if (changed.interpolate) layer_changes.interpolate = ctx.interpolate;
    			if (changed.blockReindexing) layer_changes.blockReindexing = ctx.blockReindexing;
    			layer.$set(layer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(layer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(layer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(layer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { x } = $$props;
    	let { y } = $$props;
    	let { geometry } = $$props;
    	let { fill } = $$props;
    	let { stroke } = $$props;
    	let { strokeWidth } = $$props;
    	let { strokeOpacity } = $$props;
    	let { fillOpacity } = $$props;
    	let { opacity } = $$props;
    	let { transition } = $$props;
    	let { onClick } = $$props;
    	let { onMousedown } = $$props;
    	let { onMouseup } = $$props;
    	let { onMouseover } = $$props;
    	let { onMouseout } = $$props;
    	let { onMousedrag } = $$props;
    	let { onSelect } = $$props;
    	let { onDeselect } = $$props;
    	let { interpolate = false } = $$props;
    	let { key } = $$props;
    	let { zoomIdentity } = $$props;
    	let { blockReindexing = false } = $$props;

    	const writable_props = [
    		"x",
    		"y",
    		"geometry",
    		"fill",
    		"stroke",
    		"strokeWidth",
    		"strokeOpacity",
    		"fillOpacity",
    		"opacity",
    		"transition",
    		"onClick",
    		"onMousedown",
    		"onMouseup",
    		"onMouseover",
    		"onMouseout",
    		"onMousedrag",
    		"onSelect",
    		"onDeselect",
    		"interpolate",
    		"key",
    		"zoomIdentity",
    		"blockReindexing"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PolygonLayer> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("geometry" in $$props) $$invalidate("geometry", geometry = $$props.geometry);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("strokeOpacity" in $$props) $$invalidate("strokeOpacity", strokeOpacity = $$props.strokeOpacity);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("interpolate" in $$props) $$invalidate("interpolate", interpolate = $$props.interpolate);
    		if ("key" in $$props) $$invalidate("key", key = $$props.key);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	$$self.$capture_state = () => {
    		return {
    			x,
    			y,
    			geometry,
    			fill,
    			stroke,
    			strokeWidth,
    			strokeOpacity,
    			fillOpacity,
    			opacity,
    			transition,
    			onClick,
    			onMousedown,
    			onMouseup,
    			onMouseover,
    			onMouseout,
    			onMousedrag,
    			onSelect,
    			onDeselect,
    			interpolate,
    			key,
    			zoomIdentity,
    			blockReindexing
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("geometry" in $$props) $$invalidate("geometry", geometry = $$props.geometry);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("strokeOpacity" in $$props) $$invalidate("strokeOpacity", strokeOpacity = $$props.strokeOpacity);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("interpolate" in $$props) $$invalidate("interpolate", interpolate = $$props.interpolate);
    		if ("key" in $$props) $$invalidate("key", key = $$props.key);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	return {
    		x,
    		y,
    		geometry,
    		fill,
    		stroke,
    		strokeWidth,
    		strokeOpacity,
    		fillOpacity,
    		opacity,
    		transition,
    		onClick,
    		onMousedown,
    		onMouseup,
    		onMouseover,
    		onMouseout,
    		onMousedrag,
    		onSelect,
    		onDeselect,
    		interpolate,
    		key,
    		zoomIdentity,
    		blockReindexing
    	};
    }

    class PolygonLayer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {
    			x: 0,
    			y: 0,
    			geometry: 0,
    			fill: 0,
    			stroke: 0,
    			strokeWidth: 0,
    			strokeOpacity: 0,
    			fillOpacity: 0,
    			opacity: 0,
    			transition: 0,
    			onClick: 0,
    			onMousedown: 0,
    			onMouseup: 0,
    			onMouseover: 0,
    			onMouseout: 0,
    			onMousedrag: 0,
    			onSelect: 0,
    			onDeselect: 0,
    			interpolate: 0,
    			key: 0,
    			zoomIdentity: 0,
    			blockReindexing: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PolygonLayer",
    			options,
    			id: create_fragment$i.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || ({});

    		if (ctx.x === undefined && !("x" in props)) {
    			console.warn("<PolygonLayer> was created without expected prop 'x'");
    		}

    		if (ctx.y === undefined && !("y" in props)) {
    			console.warn("<PolygonLayer> was created without expected prop 'y'");
    		}

    		if (ctx.geometry === undefined && !("geometry" in props)) {
    			console.warn("<PolygonLayer> was created without expected prop 'geometry'");
    		}

    		if (ctx.fill === undefined && !("fill" in props)) {
    			console.warn("<PolygonLayer> was created without expected prop 'fill'");
    		}

    		if (ctx.stroke === undefined && !("stroke" in props)) {
    			console.warn("<PolygonLayer> was created without expected prop 'stroke'");
    		}

    		if (ctx.strokeWidth === undefined && !("strokeWidth" in props)) {
    			console.warn("<PolygonLayer> was created without expected prop 'strokeWidth'");
    		}

    		if (ctx.strokeOpacity === undefined && !("strokeOpacity" in props)) {
    			console.warn("<PolygonLayer> was created without expected prop 'strokeOpacity'");
    		}

    		if (ctx.fillOpacity === undefined && !("fillOpacity" in props)) {
    			console.warn("<PolygonLayer> was created without expected prop 'fillOpacity'");
    		}

    		if (ctx.opacity === undefined && !("opacity" in props)) {
    			console.warn("<PolygonLayer> was created without expected prop 'opacity'");
    		}

    		if (ctx.transition === undefined && !("transition" in props)) {
    			console.warn("<PolygonLayer> was created without expected prop 'transition'");
    		}

    		if (ctx.onClick === undefined && !("onClick" in props)) {
    			console.warn("<PolygonLayer> was created without expected prop 'onClick'");
    		}

    		if (ctx.onMousedown === undefined && !("onMousedown" in props)) {
    			console.warn("<PolygonLayer> was created without expected prop 'onMousedown'");
    		}

    		if (ctx.onMouseup === undefined && !("onMouseup" in props)) {
    			console.warn("<PolygonLayer> was created without expected prop 'onMouseup'");
    		}

    		if (ctx.onMouseover === undefined && !("onMouseover" in props)) {
    			console.warn("<PolygonLayer> was created without expected prop 'onMouseover'");
    		}

    		if (ctx.onMouseout === undefined && !("onMouseout" in props)) {
    			console.warn("<PolygonLayer> was created without expected prop 'onMouseout'");
    		}

    		if (ctx.onMousedrag === undefined && !("onMousedrag" in props)) {
    			console.warn("<PolygonLayer> was created without expected prop 'onMousedrag'");
    		}

    		if (ctx.onSelect === undefined && !("onSelect" in props)) {
    			console.warn("<PolygonLayer> was created without expected prop 'onSelect'");
    		}

    		if (ctx.onDeselect === undefined && !("onDeselect" in props)) {
    			console.warn("<PolygonLayer> was created without expected prop 'onDeselect'");
    		}

    		if (ctx.key === undefined && !("key" in props)) {
    			console.warn("<PolygonLayer> was created without expected prop 'key'");
    		}

    		if (ctx.zoomIdentity === undefined && !("zoomIdentity" in props)) {
    			console.warn("<PolygonLayer> was created without expected prop 'zoomIdentity'");
    		}
    	}

    	get x() {
    		throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x(value) {
    		throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y() {
    		throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y(value) {
    		throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get geometry() {
    		throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set geometry(value) {
    		throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fill() {
    		throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fill(value) {
    		throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stroke() {
    		throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stroke(value) {
    		throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeWidth() {
    		throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeWidth(value) {
    		throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeOpacity() {
    		throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeOpacity(value) {
    		throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillOpacity() {
    		throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillOpacity(value) {
    		throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opacity() {
    		throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opacity(value) {
    		throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transition() {
    		throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transition(value) {
    		throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClick() {
    		throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClick(value) {
    		throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedown() {
    		throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedown(value) {
    		throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseup() {
    		throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseup(value) {
    		throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseover() {
    		throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseover(value) {
    		throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseout() {
    		throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseout(value) {
    		throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedrag() {
    		throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedrag(value) {
    		throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSelect() {
    		throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSelect(value) {
    		throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onDeselect() {
    		throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onDeselect(value) {
    		throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get interpolate() {
    		throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set interpolate(value) {
    		throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get key() {
    		throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zoomIdentity() {
    		throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoomIdentity(value) {
    		throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blockReindexing() {
    		throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blockReindexing(value) {
    		throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Marks/Line/LineLayer.svelte generated by Svelte v3.15.0 */

    function create_fragment$j(ctx) {
    	let current;

    	const layer = new Layer({
    			props: {
    				type: "Line",
    				x: ctx.x,
    				y: ctx.y,
    				geometry: ctx.geometry,
    				strokeWidth: ctx.strokeWidth,
    				stroke: ctx.stroke,
    				opacity: ctx.opacity,
    				transition: ctx.transition,
    				onClick: ctx.onClick,
    				onMousedown: ctx.onMousedown,
    				onMouseup: ctx.onMouseup,
    				onMouseover: ctx.onMouseover,
    				onMouseout: ctx.onMouseout,
    				onMousedrag: ctx.onMousedrag,
    				onSelect: ctx.onSelect,
    				onDeselect: ctx.onDeselect,
    				interpolate: ctx.interpolate,
    				zoomIdentity: ctx.zoomIdentity,
    				key: ctx.key,
    				_asPolygon: false,
    				blockReindexing: ctx.blockReindexing
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(layer.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(layer, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const layer_changes = {};
    			if (changed.x) layer_changes.x = ctx.x;
    			if (changed.y) layer_changes.y = ctx.y;
    			if (changed.geometry) layer_changes.geometry = ctx.geometry;
    			if (changed.strokeWidth) layer_changes.strokeWidth = ctx.strokeWidth;
    			if (changed.stroke) layer_changes.stroke = ctx.stroke;
    			if (changed.opacity) layer_changes.opacity = ctx.opacity;
    			if (changed.transition) layer_changes.transition = ctx.transition;
    			if (changed.onClick) layer_changes.onClick = ctx.onClick;
    			if (changed.onMousedown) layer_changes.onMousedown = ctx.onMousedown;
    			if (changed.onMouseup) layer_changes.onMouseup = ctx.onMouseup;
    			if (changed.onMouseover) layer_changes.onMouseover = ctx.onMouseover;
    			if (changed.onMouseout) layer_changes.onMouseout = ctx.onMouseout;
    			if (changed.onMousedrag) layer_changes.onMousedrag = ctx.onMousedrag;
    			if (changed.onSelect) layer_changes.onSelect = ctx.onSelect;
    			if (changed.onDeselect) layer_changes.onDeselect = ctx.onDeselect;
    			if (changed.interpolate) layer_changes.interpolate = ctx.interpolate;
    			if (changed.zoomIdentity) layer_changes.zoomIdentity = ctx.zoomIdentity;
    			if (changed.key) layer_changes.key = ctx.key;
    			if (changed.blockReindexing) layer_changes.blockReindexing = ctx.blockReindexing;
    			layer.$set(layer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(layer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(layer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(layer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { x } = $$props;
    	let { y } = $$props;
    	let { geometry } = $$props;
    	let { strokeWidth } = $$props;
    	let { stroke } = $$props;
    	let { opacity } = $$props;
    	let { transition } = $$props;
    	let { onClick } = $$props;
    	let { onMousedown } = $$props;
    	let { onMouseup } = $$props;
    	let { onMouseover } = $$props;
    	let { onMouseout } = $$props;
    	let { onMousedrag } = $$props;
    	let { onSelect } = $$props;
    	let { onDeselect } = $$props;
    	let { key } = $$props;
    	let { interpolate = true } = $$props;
    	let { zoomIdentity } = $$props;
    	let { blockReindexing = false } = $$props;

    	const writable_props = [
    		"x",
    		"y",
    		"geometry",
    		"strokeWidth",
    		"stroke",
    		"opacity",
    		"transition",
    		"onClick",
    		"onMousedown",
    		"onMouseup",
    		"onMouseover",
    		"onMouseout",
    		"onMousedrag",
    		"onSelect",
    		"onDeselect",
    		"key",
    		"interpolate",
    		"zoomIdentity",
    		"blockReindexing"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LineLayer> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("geometry" in $$props) $$invalidate("geometry", geometry = $$props.geometry);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("key" in $$props) $$invalidate("key", key = $$props.key);
    		if ("interpolate" in $$props) $$invalidate("interpolate", interpolate = $$props.interpolate);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	$$self.$capture_state = () => {
    		return {
    			x,
    			y,
    			geometry,
    			strokeWidth,
    			stroke,
    			opacity,
    			transition,
    			onClick,
    			onMousedown,
    			onMouseup,
    			onMouseover,
    			onMouseout,
    			onMousedrag,
    			onSelect,
    			onDeselect,
    			key,
    			interpolate,
    			zoomIdentity,
    			blockReindexing
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("geometry" in $$props) $$invalidate("geometry", geometry = $$props.geometry);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("key" in $$props) $$invalidate("key", key = $$props.key);
    		if ("interpolate" in $$props) $$invalidate("interpolate", interpolate = $$props.interpolate);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	return {
    		x,
    		y,
    		geometry,
    		strokeWidth,
    		stroke,
    		opacity,
    		transition,
    		onClick,
    		onMousedown,
    		onMouseup,
    		onMouseover,
    		onMouseout,
    		onMousedrag,
    		onSelect,
    		onDeselect,
    		key,
    		interpolate,
    		zoomIdentity,
    		blockReindexing
    	};
    }

    class LineLayer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {
    			x: 0,
    			y: 0,
    			geometry: 0,
    			strokeWidth: 0,
    			stroke: 0,
    			opacity: 0,
    			transition: 0,
    			onClick: 0,
    			onMousedown: 0,
    			onMouseup: 0,
    			onMouseover: 0,
    			onMouseout: 0,
    			onMousedrag: 0,
    			onSelect: 0,
    			onDeselect: 0,
    			key: 0,
    			interpolate: 0,
    			zoomIdentity: 0,
    			blockReindexing: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LineLayer",
    			options,
    			id: create_fragment$j.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || ({});

    		if (ctx.x === undefined && !("x" in props)) {
    			console.warn("<LineLayer> was created without expected prop 'x'");
    		}

    		if (ctx.y === undefined && !("y" in props)) {
    			console.warn("<LineLayer> was created without expected prop 'y'");
    		}

    		if (ctx.geometry === undefined && !("geometry" in props)) {
    			console.warn("<LineLayer> was created without expected prop 'geometry'");
    		}

    		if (ctx.strokeWidth === undefined && !("strokeWidth" in props)) {
    			console.warn("<LineLayer> was created without expected prop 'strokeWidth'");
    		}

    		if (ctx.stroke === undefined && !("stroke" in props)) {
    			console.warn("<LineLayer> was created without expected prop 'stroke'");
    		}

    		if (ctx.opacity === undefined && !("opacity" in props)) {
    			console.warn("<LineLayer> was created without expected prop 'opacity'");
    		}

    		if (ctx.transition === undefined && !("transition" in props)) {
    			console.warn("<LineLayer> was created without expected prop 'transition'");
    		}

    		if (ctx.onClick === undefined && !("onClick" in props)) {
    			console.warn("<LineLayer> was created without expected prop 'onClick'");
    		}

    		if (ctx.onMousedown === undefined && !("onMousedown" in props)) {
    			console.warn("<LineLayer> was created without expected prop 'onMousedown'");
    		}

    		if (ctx.onMouseup === undefined && !("onMouseup" in props)) {
    			console.warn("<LineLayer> was created without expected prop 'onMouseup'");
    		}

    		if (ctx.onMouseover === undefined && !("onMouseover" in props)) {
    			console.warn("<LineLayer> was created without expected prop 'onMouseover'");
    		}

    		if (ctx.onMouseout === undefined && !("onMouseout" in props)) {
    			console.warn("<LineLayer> was created without expected prop 'onMouseout'");
    		}

    		if (ctx.onMousedrag === undefined && !("onMousedrag" in props)) {
    			console.warn("<LineLayer> was created without expected prop 'onMousedrag'");
    		}

    		if (ctx.onSelect === undefined && !("onSelect" in props)) {
    			console.warn("<LineLayer> was created without expected prop 'onSelect'");
    		}

    		if (ctx.onDeselect === undefined && !("onDeselect" in props)) {
    			console.warn("<LineLayer> was created without expected prop 'onDeselect'");
    		}

    		if (ctx.key === undefined && !("key" in props)) {
    			console.warn("<LineLayer> was created without expected prop 'key'");
    		}

    		if (ctx.zoomIdentity === undefined && !("zoomIdentity" in props)) {
    			console.warn("<LineLayer> was created without expected prop 'zoomIdentity'");
    		}
    	}

    	get x() {
    		throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x(value) {
    		throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y() {
    		throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y(value) {
    		throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get geometry() {
    		throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set geometry(value) {
    		throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeWidth() {
    		throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeWidth(value) {
    		throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stroke() {
    		throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stroke(value) {
    		throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opacity() {
    		throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opacity(value) {
    		throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transition() {
    		throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transition(value) {
    		throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClick() {
    		throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClick(value) {
    		throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedown() {
    		throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedown(value) {
    		throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseup() {
    		throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseup(value) {
    		throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseover() {
    		throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseover(value) {
    		throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseout() {
    		throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseout(value) {
    		throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedrag() {
    		throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedrag(value) {
    		throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSelect() {
    		throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSelect(value) {
    		throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onDeselect() {
    		throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onDeselect(value) {
    		throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get key() {
    		throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get interpolate() {
    		throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set interpolate(value) {
    		throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zoomIdentity() {
    		throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoomIdentity(value) {
    		throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blockReindexing() {
    		throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blockReindexing(value) {
    		throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Marks/Label/LabelLayer.svelte generated by Svelte v3.15.0 */

    function create_fragment$k(ctx) {
    	let current;

    	const layer = new Layer({
    			props: {
    				type: "Label",
    				x: ctx.x,
    				y: ctx.y,
    				geometry: ctx.geometry,
    				fill: ctx.fill,
    				stroke: ctx.stroke,
    				strokeWidth: ctx.strokeWidth,
    				strokeOpacity: ctx.strokeOpacity,
    				fillOpacity: ctx.fillOpacity,
    				opacity: ctx.opacity,
    				text: ctx.text,
    				fontFamily: ctx.fontFamily,
    				fontSize: ctx.fontSize,
    				fontWeight: ctx.fontWeight,
    				rotation: ctx.rotation,
    				anchorPoint: ctx.anchorPoint,
    				transition: ctx.transition,
    				onClick: ctx.onClick,
    				onMousedown: ctx.onMousedown,
    				onMouseup: ctx.onMouseup,
    				onMouseover: ctx.onMouseover,
    				onMouseout: ctx.onMouseout,
    				onMousedrag: ctx.onMousedrag,
    				onSelect: ctx.onSelect,
    				onDeselect: ctx.onDeselect,
    				key: ctx.key,
    				zoomIdentity: ctx.zoomIdentity,
    				_asPolygon: false,
    				blockReindexing: ctx.blockReindexing
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(layer.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(layer, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const layer_changes = {};
    			if (changed.x) layer_changes.x = ctx.x;
    			if (changed.y) layer_changes.y = ctx.y;
    			if (changed.geometry) layer_changes.geometry = ctx.geometry;
    			if (changed.fill) layer_changes.fill = ctx.fill;
    			if (changed.stroke) layer_changes.stroke = ctx.stroke;
    			if (changed.strokeWidth) layer_changes.strokeWidth = ctx.strokeWidth;
    			if (changed.strokeOpacity) layer_changes.strokeOpacity = ctx.strokeOpacity;
    			if (changed.fillOpacity) layer_changes.fillOpacity = ctx.fillOpacity;
    			if (changed.opacity) layer_changes.opacity = ctx.opacity;
    			if (changed.text) layer_changes.text = ctx.text;
    			if (changed.fontFamily) layer_changes.fontFamily = ctx.fontFamily;
    			if (changed.fontSize) layer_changes.fontSize = ctx.fontSize;
    			if (changed.fontWeight) layer_changes.fontWeight = ctx.fontWeight;
    			if (changed.rotation) layer_changes.rotation = ctx.rotation;
    			if (changed.anchorPoint) layer_changes.anchorPoint = ctx.anchorPoint;
    			if (changed.transition) layer_changes.transition = ctx.transition;
    			if (changed.onClick) layer_changes.onClick = ctx.onClick;
    			if (changed.onMousedown) layer_changes.onMousedown = ctx.onMousedown;
    			if (changed.onMouseup) layer_changes.onMouseup = ctx.onMouseup;
    			if (changed.onMouseover) layer_changes.onMouseover = ctx.onMouseover;
    			if (changed.onMouseout) layer_changes.onMouseout = ctx.onMouseout;
    			if (changed.onMousedrag) layer_changes.onMousedrag = ctx.onMousedrag;
    			if (changed.onSelect) layer_changes.onSelect = ctx.onSelect;
    			if (changed.onDeselect) layer_changes.onDeselect = ctx.onDeselect;
    			if (changed.key) layer_changes.key = ctx.key;
    			if (changed.zoomIdentity) layer_changes.zoomIdentity = ctx.zoomIdentity;
    			if (changed.blockReindexing) layer_changes.blockReindexing = ctx.blockReindexing;
    			layer.$set(layer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(layer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(layer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(layer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let { x } = $$props;
    	let { y } = $$props;
    	let { geometry } = $$props;
    	let { fill } = $$props;
    	let { stroke } = $$props;
    	let { strokeWidth } = $$props;
    	let { strokeOpacity } = $$props;
    	let { fillOpacity } = $$props;
    	let { opacity } = $$props;
    	let { text } = $$props;
    	let { fontFamily } = $$props;
    	let { fontSize } = $$props;
    	let { fontWeight } = $$props;
    	let { rotation } = $$props;
    	let { anchorPoint } = $$props;
    	let { transition } = $$props;
    	let { onClick } = $$props;
    	let { onMousedown } = $$props;
    	let { onMouseup } = $$props;
    	let { onMouseover } = $$props;
    	let { onMouseout } = $$props;
    	let { onMousedrag } = $$props;
    	let { onSelect } = $$props;
    	let { onDeselect } = $$props;
    	let { key } = $$props;
    	let { zoomIdentity } = $$props;
    	let { blockReindexing = false } = $$props;

    	const writable_props = [
    		"x",
    		"y",
    		"geometry",
    		"fill",
    		"stroke",
    		"strokeWidth",
    		"strokeOpacity",
    		"fillOpacity",
    		"opacity",
    		"text",
    		"fontFamily",
    		"fontSize",
    		"fontWeight",
    		"rotation",
    		"anchorPoint",
    		"transition",
    		"onClick",
    		"onMousedown",
    		"onMouseup",
    		"onMouseover",
    		"onMouseout",
    		"onMousedrag",
    		"onSelect",
    		"onDeselect",
    		"key",
    		"zoomIdentity",
    		"blockReindexing"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LabelLayer> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("geometry" in $$props) $$invalidate("geometry", geometry = $$props.geometry);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("strokeOpacity" in $$props) $$invalidate("strokeOpacity", strokeOpacity = $$props.strokeOpacity);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("text" in $$props) $$invalidate("text", text = $$props.text);
    		if ("fontFamily" in $$props) $$invalidate("fontFamily", fontFamily = $$props.fontFamily);
    		if ("fontSize" in $$props) $$invalidate("fontSize", fontSize = $$props.fontSize);
    		if ("fontWeight" in $$props) $$invalidate("fontWeight", fontWeight = $$props.fontWeight);
    		if ("rotation" in $$props) $$invalidate("rotation", rotation = $$props.rotation);
    		if ("anchorPoint" in $$props) $$invalidate("anchorPoint", anchorPoint = $$props.anchorPoint);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("key" in $$props) $$invalidate("key", key = $$props.key);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	$$self.$capture_state = () => {
    		return {
    			x,
    			y,
    			geometry,
    			fill,
    			stroke,
    			strokeWidth,
    			strokeOpacity,
    			fillOpacity,
    			opacity,
    			text,
    			fontFamily,
    			fontSize,
    			fontWeight,
    			rotation,
    			anchorPoint,
    			transition,
    			onClick,
    			onMousedown,
    			onMouseup,
    			onMouseover,
    			onMouseout,
    			onMousedrag,
    			onSelect,
    			onDeselect,
    			key,
    			zoomIdentity,
    			blockReindexing
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("geometry" in $$props) $$invalidate("geometry", geometry = $$props.geometry);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("strokeOpacity" in $$props) $$invalidate("strokeOpacity", strokeOpacity = $$props.strokeOpacity);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("opacity" in $$props) $$invalidate("opacity", opacity = $$props.opacity);
    		if ("text" in $$props) $$invalidate("text", text = $$props.text);
    		if ("fontFamily" in $$props) $$invalidate("fontFamily", fontFamily = $$props.fontFamily);
    		if ("fontSize" in $$props) $$invalidate("fontSize", fontSize = $$props.fontSize);
    		if ("fontWeight" in $$props) $$invalidate("fontWeight", fontWeight = $$props.fontWeight);
    		if ("rotation" in $$props) $$invalidate("rotation", rotation = $$props.rotation);
    		if ("anchorPoint" in $$props) $$invalidate("anchorPoint", anchorPoint = $$props.anchorPoint);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("onClick" in $$props) $$invalidate("onClick", onClick = $$props.onClick);
    		if ("onMousedown" in $$props) $$invalidate("onMousedown", onMousedown = $$props.onMousedown);
    		if ("onMouseup" in $$props) $$invalidate("onMouseup", onMouseup = $$props.onMouseup);
    		if ("onMouseover" in $$props) $$invalidate("onMouseover", onMouseover = $$props.onMouseover);
    		if ("onMouseout" in $$props) $$invalidate("onMouseout", onMouseout = $$props.onMouseout);
    		if ("onMousedrag" in $$props) $$invalidate("onMousedrag", onMousedrag = $$props.onMousedrag);
    		if ("onSelect" in $$props) $$invalidate("onSelect", onSelect = $$props.onSelect);
    		if ("onDeselect" in $$props) $$invalidate("onDeselect", onDeselect = $$props.onDeselect);
    		if ("key" in $$props) $$invalidate("key", key = $$props.key);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	return {
    		x,
    		y,
    		geometry,
    		fill,
    		stroke,
    		strokeWidth,
    		strokeOpacity,
    		fillOpacity,
    		opacity,
    		text,
    		fontFamily,
    		fontSize,
    		fontWeight,
    		rotation,
    		anchorPoint,
    		transition,
    		onClick,
    		onMousedown,
    		onMouseup,
    		onMouseover,
    		onMouseout,
    		onMousedrag,
    		onSelect,
    		onDeselect,
    		key,
    		zoomIdentity,
    		blockReindexing
    	};
    }

    class LabelLayer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {
    			x: 0,
    			y: 0,
    			geometry: 0,
    			fill: 0,
    			stroke: 0,
    			strokeWidth: 0,
    			strokeOpacity: 0,
    			fillOpacity: 0,
    			opacity: 0,
    			text: 0,
    			fontFamily: 0,
    			fontSize: 0,
    			fontWeight: 0,
    			rotation: 0,
    			anchorPoint: 0,
    			transition: 0,
    			onClick: 0,
    			onMousedown: 0,
    			onMouseup: 0,
    			onMouseover: 0,
    			onMouseout: 0,
    			onMousedrag: 0,
    			onSelect: 0,
    			onDeselect: 0,
    			key: 0,
    			zoomIdentity: 0,
    			blockReindexing: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LabelLayer",
    			options,
    			id: create_fragment$k.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || ({});

    		if (ctx.x === undefined && !("x" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'x'");
    		}

    		if (ctx.y === undefined && !("y" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'y'");
    		}

    		if (ctx.geometry === undefined && !("geometry" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'geometry'");
    		}

    		if (ctx.fill === undefined && !("fill" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'fill'");
    		}

    		if (ctx.stroke === undefined && !("stroke" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'stroke'");
    		}

    		if (ctx.strokeWidth === undefined && !("strokeWidth" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'strokeWidth'");
    		}

    		if (ctx.strokeOpacity === undefined && !("strokeOpacity" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'strokeOpacity'");
    		}

    		if (ctx.fillOpacity === undefined && !("fillOpacity" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'fillOpacity'");
    		}

    		if (ctx.opacity === undefined && !("opacity" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'opacity'");
    		}

    		if (ctx.text === undefined && !("text" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'text'");
    		}

    		if (ctx.fontFamily === undefined && !("fontFamily" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'fontFamily'");
    		}

    		if (ctx.fontSize === undefined && !("fontSize" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'fontSize'");
    		}

    		if (ctx.fontWeight === undefined && !("fontWeight" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'fontWeight'");
    		}

    		if (ctx.rotation === undefined && !("rotation" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'rotation'");
    		}

    		if (ctx.anchorPoint === undefined && !("anchorPoint" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'anchorPoint'");
    		}

    		if (ctx.transition === undefined && !("transition" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'transition'");
    		}

    		if (ctx.onClick === undefined && !("onClick" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'onClick'");
    		}

    		if (ctx.onMousedown === undefined && !("onMousedown" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'onMousedown'");
    		}

    		if (ctx.onMouseup === undefined && !("onMouseup" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'onMouseup'");
    		}

    		if (ctx.onMouseover === undefined && !("onMouseover" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'onMouseover'");
    		}

    		if (ctx.onMouseout === undefined && !("onMouseout" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'onMouseout'");
    		}

    		if (ctx.onMousedrag === undefined && !("onMousedrag" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'onMousedrag'");
    		}

    		if (ctx.onSelect === undefined && !("onSelect" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'onSelect'");
    		}

    		if (ctx.onDeselect === undefined && !("onDeselect" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'onDeselect'");
    		}

    		if (ctx.key === undefined && !("key" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'key'");
    		}

    		if (ctx.zoomIdentity === undefined && !("zoomIdentity" in props)) {
    			console.warn("<LabelLayer> was created without expected prop 'zoomIdentity'");
    		}
    	}

    	get x() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get geometry() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set geometry(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fill() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fill(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stroke() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stroke(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeWidth() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeWidth(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeOpacity() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeOpacity(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillOpacity() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillOpacity(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opacity() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opacity(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fontFamily() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fontFamily(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fontSize() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fontSize(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fontWeight() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fontWeight(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rotation() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rotation(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get anchorPoint() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set anchorPoint(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transition() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transition(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClick() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClick(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedown() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedown(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseup() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseup(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseover() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseover(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseout() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseout(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMousedrag() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMousedrag(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSelect() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSelect(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onDeselect() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onDeselect(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get key() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zoomIdentity() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoomIdentity(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blockReindexing() {
    		throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blockReindexing(value) {
    		throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function createXAxisCoords (vjust, y, offset, scaleX, scaleY, sectionContext) {
      // there are three ways of setting the position of the axis, in order of precedence
      // 1. vjust with 'bottom', 'center' or 'top'
      // 2. vjust with a number (relative position within content of section
      // 3. y prop with either a single number (positioning in data coords)
      //    or a function that returns an array of 2 numbers (in pixel coords)
      const xRange = scaleX.range();
      const yRange = scaleY.range();
      if (sectionContext.flipX) xRange.reverse();
      if (!sectionContext.flipY) yRange.reverse();
      const x1 = xRange[0];
      const x2 = xRange[1];
      const y1 = yRange[0];
      const y2 = yRange[1];
      const xCoords = () => {
        return [x1, x2]
      };

      let yCoords;

      if (vjust === 'bottom') {
        yCoords = () => {
          return [y1 + offset, y1 + offset]
        };
      }
      if (vjust === 'center' || vjust === 'centre') {
        const yCoord = (y2 - y1) * 0.5 + y1;
        yCoords = () => {
          return [yCoord + offset, yCoord + offset]
        };
      }
      if (vjust === 'top') {
        yCoords = () => {
          return [y2 - offset, y2 - offset]
        };
      }
      if (!isNaN(vjust)) {
        const yCoord = (y2 - y1) * vjust + y1;
        yCoords = () => {
          return [yCoord, yCoord]
        };
      }
      if (!isNaN(y)) {
        yCoords = () => [scaleY(y), scaleY(y)];
      }
      if (typeof y === 'function') {
        yCoords = y;
      }
      if (yCoords === undefined) {
        // we still haven't set yCoords
        // which means we don't have a y prop and a non-valid vjust prop
        // probably should throw warning
        yCoords = () => {
          return [y1 + offset, y1 + offset]
        };
      }
      return { xCoords, yCoords }
    }

    function createTitleXCoord$1 (hjust, axisXCoords, x, scaleX, scaleY, offset, axisHeight, flip, fontSize, sectionContext) {
      if (x) {
        return () => x
      }
      const xRange = scaleX.range();
      if (sectionContext.flipX) xRange.reverse();
      const x1 = xRange[0];
      const x2 = xRange[1];
      let justification;

      if (hjust === 'axis') {
        return () => axisXCoords()[0]
      }
      if (hjust === 'center' || hjust === 'centre') {
        justification = 0.5;
      }
      if (hjust === 'left') {
        justification = 0;
      }
      if (hjust === 'right') {
        justification = 1;
      }
      if (!isNaN(hjust)) {
        justification = hjust;
      }
      if (justification === undefined) {
        justification = 0.5;
      }
      return () => x1 + Math.abs(x1 - x2) * justification + offset
    }

    function createTitleYCoord$1 (vjust, axisYCoords, y, scaleX, scaleY, offset, height, flip, fontSize, sectionContext) {
      const yRange = scaleY.range();
      if (!sectionContext.flipY) yRange.reverse();
      const y1 = yRange[0];
      const y2 = yRange[1];
      if (y) {
        return () => y
      }
      let heightOffset;
      if (offset === 'axis') {
        heightOffset = height + 1;
        if (flip) heightOffset = -heightOffset - fontSize;
      } else {
        heightOffset = offset;
      }
      let justification;

      if (vjust === 'axis') {
        return () => axisYCoords()[0] + heightOffset
      }

      if (vjust === 'center' || vjust === 'centre') {
        justification = 0.5;
      }
      if (vjust === 'bottom') {
        justification = 0;
      }
      if (vjust === 'top') {
        justification = 1;
      }
      if (!isNaN(vjust)) {
        justification = vjust;
      }
      if (justification === undefined) {
        justification = 0.5;
      }
      return () => y1 - Math.abs(y1 - y2) * justification + heightOffset
    }

    function createXTickGeoms (tickPositions, yCoords, scale, baseLineWidth, tickSize, flip) {
      const x = [];
      const y = [];

      const yStart = yCoords()[0] - baseLineWidth / 2;

      let offset = baseLineWidth + tickSize;
      if (flip) offset = -offset;

      const bandOffset = scale.bandwidth ? scale.bandwidth() / 2 : 0;

      for (let index = 0; index < tickPositions.length; index++) {
        const tick = scale(tickPositions[index]) + bandOffset;
        x.push([tick, tick]);
        y.push([yStart, yStart + offset]);
      }
      return { tickXCoords: () => x, tickYCoords: () => y }
    }

    function createXLabelGeoms (tickPositions, yCoords, scale, baseLineWidth, tickSize, labelOffset, flip) {
      const x = [];
      const y = [];

      const yStart = yCoords()[0];

      let offset = baseLineWidth + tickSize + labelOffset;
      if (flip) offset = -offset;

      const bandOffset = scale.bandwidth ? scale.bandwidth() / 2 : 0;

      for (let index = 0; index < tickPositions.length; index++) {
        const tick = scale(tickPositions[index]) + bandOffset;
        x.push(tick);
        y.push(yStart + offset);
      }
      return { tickLabelXCoords: () => x, tickLabelYCoords: () => y }
    }

    function getTickPositions (tickValuesArray, scale, tickCount, tickExtra) {
      let tickPositions;

      if (Array.isArray(tickValuesArray) && tickValuesArray.length > 0) {
        tickPositions = tickValuesArray;
      } else if ('ticks' in scale) {
        tickPositions = scale.ticks(tickCount);
      } else if ('domain' in scale) {
        tickPositions = scale.domain();
      } else {
        throw new Error(`Couldn't construct axis. Please provide 'tickValues' or a scale with
      either a 'ticks' or a 'domain' method.`)
      }

      if (tickExtra && 'domain' in scale && tickPositions[0] !== scale.domain()[0]) {
        tickPositions.unshift(scale.domain()[0]);
      }

      return tickPositions
    }

    function getFormat (labelFormat, scale, numberOfTicks) {
      if (labelFormat) return labelFormat
      if ('tickFormat' in scale) return scale.tickFormat(numberOfTicks)

      return x => x
    }

    /* src/components/Guides/Axes/XAxis.svelte generated by Svelte v3.15.0 */
    const file$7 = "src/components/Guides/Axes/XAxis.svelte";

    // (112:2) {#if baseLine}
    function create_if_block_2$2(ctx) {
    	let current;

    	const line = new Line({
    			props: {
    				x: ctx.xCoords,
    				y: ctx.yCoords,
    				strokeWidth: ctx.baseLineWidth,
    				opacity: ctx.baseLineOpacity,
    				stroke: ctx.baseLineColor,
    				zoomIdentity: ctx.zoomIdentity
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(line.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(line, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const line_changes = {};
    			if (changed.xCoords) line_changes.x = ctx.xCoords;
    			if (changed.yCoords) line_changes.y = ctx.yCoords;
    			if (changed.baseLineWidth) line_changes.strokeWidth = ctx.baseLineWidth;
    			if (changed.baseLineOpacity) line_changes.opacity = ctx.baseLineOpacity;
    			if (changed.baseLineColor) line_changes.stroke = ctx.baseLineColor;
    			if (changed.zoomIdentity) line_changes.zoomIdentity = ctx.zoomIdentity;
    			line.$set(line_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(line.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(line.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(line, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(112:2) {#if baseLine}",
    		ctx
    	});

    	return block;
    }

    // (119:2) {#if ticks}
    function create_if_block_1$4(ctx) {
    	let current;

    	const linelayer = new LineLayer({
    			props: {
    				x: ctx.tickXCoords,
    				y: ctx.tickYCoords,
    				strokeWidth: ctx.tickWidth,
    				opacity: ctx.tickOpacity,
    				stroke: ctx.tickColor,
    				transition: ctx.transition,
    				zoomIdentity: ctx.zoomIdentity
    			},
    			$$inline: true
    		});

    	const labellayer = new LabelLayer({
    			props: {
    				x: ctx.tickLabelXCoords,
    				y: ctx.tickLabelYCoords,
    				text: ctx.tickLabelText,
    				anchorPoint: ctx.labelAnchorPoint,
    				rotation: ctx.labelRotate,
    				fontFamily: ctx.labelFont,
    				fontSize: ctx.labelFontSize,
    				fontWeight: ctx.labelFontWeight,
    				opacity: ctx.labelOpacity,
    				fill: ctx.labelColor,
    				transition: ctx.transition,
    				zoomIdentity: ctx.zoomIdentity
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(linelayer.$$.fragment);
    			create_component(labellayer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(linelayer, target, anchor);
    			mount_component(labellayer, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const linelayer_changes = {};
    			if (changed.tickXCoords) linelayer_changes.x = ctx.tickXCoords;
    			if (changed.tickYCoords) linelayer_changes.y = ctx.tickYCoords;
    			if (changed.tickWidth) linelayer_changes.strokeWidth = ctx.tickWidth;
    			if (changed.tickOpacity) linelayer_changes.opacity = ctx.tickOpacity;
    			if (changed.tickColor) linelayer_changes.stroke = ctx.tickColor;
    			if (changed.transition) linelayer_changes.transition = ctx.transition;
    			if (changed.zoomIdentity) linelayer_changes.zoomIdentity = ctx.zoomIdentity;
    			linelayer.$set(linelayer_changes);
    			const labellayer_changes = {};
    			if (changed.tickLabelXCoords) labellayer_changes.x = ctx.tickLabelXCoords;
    			if (changed.tickLabelYCoords) labellayer_changes.y = ctx.tickLabelYCoords;
    			if (changed.tickLabelText) labellayer_changes.text = ctx.tickLabelText;
    			if (changed.labelAnchorPoint) labellayer_changes.anchorPoint = ctx.labelAnchorPoint;
    			if (changed.labelRotate) labellayer_changes.rotation = ctx.labelRotate;
    			if (changed.labelFont) labellayer_changes.fontFamily = ctx.labelFont;
    			if (changed.labelFontSize) labellayer_changes.fontSize = ctx.labelFontSize;
    			if (changed.labelFontWeight) labellayer_changes.fontWeight = ctx.labelFontWeight;
    			if (changed.labelOpacity) labellayer_changes.opacity = ctx.labelOpacity;
    			if (changed.labelColor) labellayer_changes.fill = ctx.labelColor;
    			if (changed.transition) labellayer_changes.transition = ctx.transition;
    			if (changed.zoomIdentity) labellayer_changes.zoomIdentity = ctx.zoomIdentity;
    			labellayer.$set(labellayer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(linelayer.$$.fragment, local);
    			transition_in(labellayer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(linelayer.$$.fragment, local);
    			transition_out(labellayer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(linelayer, detaching);
    			destroy_component(labellayer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(119:2) {#if ticks}",
    		ctx
    	});

    	return block;
    }

    // (132:2) {#if title.length > 0}
    function create_if_block$5(ctx) {
    	let current;

    	const label = new Label({
    			props: {
    				x: ctx.titleXCoord,
    				y: ctx.titleYCoord,
    				text: ctx.title,
    				anchorPoint: ctx.titleAnchorPoint,
    				rotation: ctx.titleRotation,
    				fontFamily: ctx.titleFont,
    				fontSize: ctx.titleFontSize,
    				fontWeight: ctx.titleFontWeight,
    				opacity: ctx.titleOpacity,
    				fill: ctx.titleColor,
    				zoomIdentity: ctx.zoomIdentity
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(label.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(label, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const label_changes = {};
    			if (changed.titleXCoord) label_changes.x = ctx.titleXCoord;
    			if (changed.titleYCoord) label_changes.y = ctx.titleYCoord;
    			if (changed.title) label_changes.text = ctx.title;
    			if (changed.titleAnchorPoint) label_changes.anchorPoint = ctx.titleAnchorPoint;
    			if (changed.titleRotation) label_changes.rotation = ctx.titleRotation;
    			if (changed.titleFont) label_changes.fontFamily = ctx.titleFont;
    			if (changed.titleFontSize) label_changes.fontSize = ctx.titleFontSize;
    			if (changed.titleFontWeight) label_changes.fontWeight = ctx.titleFontWeight;
    			if (changed.titleOpacity) label_changes.opacity = ctx.titleOpacity;
    			if (changed.titleColor) label_changes.fill = ctx.titleColor;
    			if (changed.zoomIdentity) label_changes.zoomIdentity = ctx.zoomIdentity;
    			label.$set(label_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(label, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(132:2) {#if title.length > 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let g;
    	let if_block0_anchor;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = ctx.baseLine && create_if_block_2$2(ctx);
    	let if_block1 = ctx.ticks && create_if_block_1$4(ctx);
    	let if_block2 = ctx.title.length > 0 && create_if_block$5(ctx);

    	const block = {
    		c: function create() {
    			g = svg_element("g");
    			if (if_block0) if_block0.c();
    			if_block0_anchor = empty();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    			if (if_block2) if_block2.c();
    			attr_dev(g, "class", "x-axis");
    			add_location(g, file$7, 109, 0, 3496);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);
    			if (if_block0) if_block0.m(g, null);
    			append_dev(g, if_block0_anchor);
    			if (if_block1) if_block1.m(g, null);
    			append_dev(g, if_block1_anchor);
    			if (if_block2) if_block2.m(g, null);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (ctx.baseLine) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    					transition_in(if_block0, 1);
    				} else {
    					if_block0 = create_if_block_2$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(g, if_block0_anchor);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (ctx.ticks) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    					transition_in(if_block1, 1);
    				} else {
    					if_block1 = create_if_block_1$4(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(g, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (ctx.title.length > 0) {
    				if (if_block2) {
    					if_block2.p(changed, ctx);
    					transition_in(if_block2, 1);
    				} else {
    					if_block2 = create_if_block$5(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(g, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let $sectionContext;
    	let { scale } = $$props;
    	let { flip = false } = $$props;
    	let { baseLine = true } = $$props;
    	let { baseLineColor = "black" } = $$props;
    	let { baseLineOpacity = 1 } = $$props;
    	let { baseLineWidth = 1 } = $$props;
    	let { vjust = "bottom" } = $$props;
    	let { y } = $$props;
    	let { yOffset = 0 } = $$props;
    	let { hjust } = $$props;
    	let { x } = $$props;
    	let { xOffset = 0 } = $$props;
    	let { ticks = true } = $$props;
    	let { tickCount = 10 } = $$props;
    	let { tickExtra = false } = $$props;
    	let { tickValues } = $$props;
    	let { tickSize = 5 } = $$props;
    	let { tickWidth = 0.5 } = $$props;
    	let { tickColor = "black" } = $$props;
    	let { tickOpacity = 1 } = $$props;
    	let { labelFormat } = $$props;
    	let { labelOffset = 2 } = $$props;
    	let { labelRotate = 0 } = $$props;
    	let { labelFont = "Helvetica" } = $$props;
    	let { labelFontSize = 10 } = $$props;
    	let { labelFontWeight = "normal" } = $$props;
    	let { labelOpacity = 1 } = $$props;
    	let { labelColor = "black" } = $$props;
    	let { titleHjust = "center" } = $$props;
    	let { titleXOffset = 0 } = $$props;
    	let { titleX } = $$props;
    	let { titleVjust = "axis" } = $$props;
    	let { titleYOffset = "axis" } = $$props;
    	let { titleY } = $$props;
    	let { title = "" } = $$props;
    	let { titleColor = "black" } = $$props;
    	let { titleFont = "Helvetica" } = $$props;
    	let { titleFontSize = "12" } = $$props;
    	let { titleFontWeight = "normal" } = $$props;
    	let { titleOpacity = 1 } = $$props;
    	let { titleRotation = 0 } = $$props;
    	let { titleAnchorPoint = "t" } = $$props;
    	let { transition } = $$props;
    	let { zoomIdentity } = $$props;
    	const sectionContext = subscribe$2();
    	validate_store(sectionContext, "sectionContext");
    	component_subscribe($$self, sectionContext, value => $$invalidate("$sectionContext", $sectionContext = value));
    	const graphicContext = subscribe$1();
    	const zoomContext = subscribe$6();
    	let xCoords;
    	let yCoords;
    	let tickPositions;
    	let tickXCoords;
    	let tickYCoords;
    	let tickLabelXCoords;
    	let tickLabelYCoords;
    	let format;
    	let tickLabelText;
    	let titleXCoord;
    	let titleYCoord;
    	let axisHeight;
    	let labelAnchorPoint = "t";
    	let scaleX;

    	const writable_props = [
    		"scale",
    		"flip",
    		"baseLine",
    		"baseLineColor",
    		"baseLineOpacity",
    		"baseLineWidth",
    		"vjust",
    		"y",
    		"yOffset",
    		"hjust",
    		"x",
    		"xOffset",
    		"ticks",
    		"tickCount",
    		"tickExtra",
    		"tickValues",
    		"tickSize",
    		"tickWidth",
    		"tickColor",
    		"tickOpacity",
    		"labelFormat",
    		"labelOffset",
    		"labelRotate",
    		"labelFont",
    		"labelFontSize",
    		"labelFontWeight",
    		"labelOpacity",
    		"labelColor",
    		"titleHjust",
    		"titleXOffset",
    		"titleX",
    		"titleVjust",
    		"titleYOffset",
    		"titleY",
    		"title",
    		"titleColor",
    		"titleFont",
    		"titleFontSize",
    		"titleFontWeight",
    		"titleOpacity",
    		"titleRotation",
    		"titleAnchorPoint",
    		"transition",
    		"zoomIdentity"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<XAxis> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("scale" in $$props) $$invalidate("scale", scale = $$props.scale);
    		if ("flip" in $$props) $$invalidate("flip", flip = $$props.flip);
    		if ("baseLine" in $$props) $$invalidate("baseLine", baseLine = $$props.baseLine);
    		if ("baseLineColor" in $$props) $$invalidate("baseLineColor", baseLineColor = $$props.baseLineColor);
    		if ("baseLineOpacity" in $$props) $$invalidate("baseLineOpacity", baseLineOpacity = $$props.baseLineOpacity);
    		if ("baseLineWidth" in $$props) $$invalidate("baseLineWidth", baseLineWidth = $$props.baseLineWidth);
    		if ("vjust" in $$props) $$invalidate("vjust", vjust = $$props.vjust);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("yOffset" in $$props) $$invalidate("yOffset", yOffset = $$props.yOffset);
    		if ("hjust" in $$props) $$invalidate("hjust", hjust = $$props.hjust);
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("xOffset" in $$props) $$invalidate("xOffset", xOffset = $$props.xOffset);
    		if ("ticks" in $$props) $$invalidate("ticks", ticks = $$props.ticks);
    		if ("tickCount" in $$props) $$invalidate("tickCount", tickCount = $$props.tickCount);
    		if ("tickExtra" in $$props) $$invalidate("tickExtra", tickExtra = $$props.tickExtra);
    		if ("tickValues" in $$props) $$invalidate("tickValues", tickValues = $$props.tickValues);
    		if ("tickSize" in $$props) $$invalidate("tickSize", tickSize = $$props.tickSize);
    		if ("tickWidth" in $$props) $$invalidate("tickWidth", tickWidth = $$props.tickWidth);
    		if ("tickColor" in $$props) $$invalidate("tickColor", tickColor = $$props.tickColor);
    		if ("tickOpacity" in $$props) $$invalidate("tickOpacity", tickOpacity = $$props.tickOpacity);
    		if ("labelFormat" in $$props) $$invalidate("labelFormat", labelFormat = $$props.labelFormat);
    		if ("labelOffset" in $$props) $$invalidate("labelOffset", labelOffset = $$props.labelOffset);
    		if ("labelRotate" in $$props) $$invalidate("labelRotate", labelRotate = $$props.labelRotate);
    		if ("labelFont" in $$props) $$invalidate("labelFont", labelFont = $$props.labelFont);
    		if ("labelFontSize" in $$props) $$invalidate("labelFontSize", labelFontSize = $$props.labelFontSize);
    		if ("labelFontWeight" in $$props) $$invalidate("labelFontWeight", labelFontWeight = $$props.labelFontWeight);
    		if ("labelOpacity" in $$props) $$invalidate("labelOpacity", labelOpacity = $$props.labelOpacity);
    		if ("labelColor" in $$props) $$invalidate("labelColor", labelColor = $$props.labelColor);
    		if ("titleHjust" in $$props) $$invalidate("titleHjust", titleHjust = $$props.titleHjust);
    		if ("titleXOffset" in $$props) $$invalidate("titleXOffset", titleXOffset = $$props.titleXOffset);
    		if ("titleX" in $$props) $$invalidate("titleX", titleX = $$props.titleX);
    		if ("titleVjust" in $$props) $$invalidate("titleVjust", titleVjust = $$props.titleVjust);
    		if ("titleYOffset" in $$props) $$invalidate("titleYOffset", titleYOffset = $$props.titleYOffset);
    		if ("titleY" in $$props) $$invalidate("titleY", titleY = $$props.titleY);
    		if ("title" in $$props) $$invalidate("title", title = $$props.title);
    		if ("titleColor" in $$props) $$invalidate("titleColor", titleColor = $$props.titleColor);
    		if ("titleFont" in $$props) $$invalidate("titleFont", titleFont = $$props.titleFont);
    		if ("titleFontSize" in $$props) $$invalidate("titleFontSize", titleFontSize = $$props.titleFontSize);
    		if ("titleFontWeight" in $$props) $$invalidate("titleFontWeight", titleFontWeight = $$props.titleFontWeight);
    		if ("titleOpacity" in $$props) $$invalidate("titleOpacity", titleOpacity = $$props.titleOpacity);
    		if ("titleRotation" in $$props) $$invalidate("titleRotation", titleRotation = $$props.titleRotation);
    		if ("titleAnchorPoint" in $$props) $$invalidate("titleAnchorPoint", titleAnchorPoint = $$props.titleAnchorPoint);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    	};

    	$$self.$capture_state = () => {
    		return {
    			scale,
    			flip,
    			baseLine,
    			baseLineColor,
    			baseLineOpacity,
    			baseLineWidth,
    			vjust,
    			y,
    			yOffset,
    			hjust,
    			x,
    			xOffset,
    			ticks,
    			tickCount,
    			tickExtra,
    			tickValues,
    			tickSize,
    			tickWidth,
    			tickColor,
    			tickOpacity,
    			labelFormat,
    			labelOffset,
    			labelRotate,
    			labelFont,
    			labelFontSize,
    			labelFontWeight,
    			labelOpacity,
    			labelColor,
    			titleHjust,
    			titleXOffset,
    			titleX,
    			titleVjust,
    			titleYOffset,
    			titleY,
    			title,
    			titleColor,
    			titleFont,
    			titleFontSize,
    			titleFontWeight,
    			titleOpacity,
    			titleRotation,
    			titleAnchorPoint,
    			transition,
    			zoomIdentity,
    			xCoords,
    			yCoords,
    			tickPositions,
    			tickXCoords,
    			tickYCoords,
    			tickLabelXCoords,
    			tickLabelYCoords,
    			format,
    			tickLabelText,
    			titleXCoord,
    			titleYCoord,
    			axisHeight,
    			labelAnchorPoint,
    			scaleX,
    			$sectionContext
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("scale" in $$props) $$invalidate("scale", scale = $$props.scale);
    		if ("flip" in $$props) $$invalidate("flip", flip = $$props.flip);
    		if ("baseLine" in $$props) $$invalidate("baseLine", baseLine = $$props.baseLine);
    		if ("baseLineColor" in $$props) $$invalidate("baseLineColor", baseLineColor = $$props.baseLineColor);
    		if ("baseLineOpacity" in $$props) $$invalidate("baseLineOpacity", baseLineOpacity = $$props.baseLineOpacity);
    		if ("baseLineWidth" in $$props) $$invalidate("baseLineWidth", baseLineWidth = $$props.baseLineWidth);
    		if ("vjust" in $$props) $$invalidate("vjust", vjust = $$props.vjust);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("yOffset" in $$props) $$invalidate("yOffset", yOffset = $$props.yOffset);
    		if ("hjust" in $$props) $$invalidate("hjust", hjust = $$props.hjust);
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("xOffset" in $$props) $$invalidate("xOffset", xOffset = $$props.xOffset);
    		if ("ticks" in $$props) $$invalidate("ticks", ticks = $$props.ticks);
    		if ("tickCount" in $$props) $$invalidate("tickCount", tickCount = $$props.tickCount);
    		if ("tickExtra" in $$props) $$invalidate("tickExtra", tickExtra = $$props.tickExtra);
    		if ("tickValues" in $$props) $$invalidate("tickValues", tickValues = $$props.tickValues);
    		if ("tickSize" in $$props) $$invalidate("tickSize", tickSize = $$props.tickSize);
    		if ("tickWidth" in $$props) $$invalidate("tickWidth", tickWidth = $$props.tickWidth);
    		if ("tickColor" in $$props) $$invalidate("tickColor", tickColor = $$props.tickColor);
    		if ("tickOpacity" in $$props) $$invalidate("tickOpacity", tickOpacity = $$props.tickOpacity);
    		if ("labelFormat" in $$props) $$invalidate("labelFormat", labelFormat = $$props.labelFormat);
    		if ("labelOffset" in $$props) $$invalidate("labelOffset", labelOffset = $$props.labelOffset);
    		if ("labelRotate" in $$props) $$invalidate("labelRotate", labelRotate = $$props.labelRotate);
    		if ("labelFont" in $$props) $$invalidate("labelFont", labelFont = $$props.labelFont);
    		if ("labelFontSize" in $$props) $$invalidate("labelFontSize", labelFontSize = $$props.labelFontSize);
    		if ("labelFontWeight" in $$props) $$invalidate("labelFontWeight", labelFontWeight = $$props.labelFontWeight);
    		if ("labelOpacity" in $$props) $$invalidate("labelOpacity", labelOpacity = $$props.labelOpacity);
    		if ("labelColor" in $$props) $$invalidate("labelColor", labelColor = $$props.labelColor);
    		if ("titleHjust" in $$props) $$invalidate("titleHjust", titleHjust = $$props.titleHjust);
    		if ("titleXOffset" in $$props) $$invalidate("titleXOffset", titleXOffset = $$props.titleXOffset);
    		if ("titleX" in $$props) $$invalidate("titleX", titleX = $$props.titleX);
    		if ("titleVjust" in $$props) $$invalidate("titleVjust", titleVjust = $$props.titleVjust);
    		if ("titleYOffset" in $$props) $$invalidate("titleYOffset", titleYOffset = $$props.titleYOffset);
    		if ("titleY" in $$props) $$invalidate("titleY", titleY = $$props.titleY);
    		if ("title" in $$props) $$invalidate("title", title = $$props.title);
    		if ("titleColor" in $$props) $$invalidate("titleColor", titleColor = $$props.titleColor);
    		if ("titleFont" in $$props) $$invalidate("titleFont", titleFont = $$props.titleFont);
    		if ("titleFontSize" in $$props) $$invalidate("titleFontSize", titleFontSize = $$props.titleFontSize);
    		if ("titleFontWeight" in $$props) $$invalidate("titleFontWeight", titleFontWeight = $$props.titleFontWeight);
    		if ("titleOpacity" in $$props) $$invalidate("titleOpacity", titleOpacity = $$props.titleOpacity);
    		if ("titleRotation" in $$props) $$invalidate("titleRotation", titleRotation = $$props.titleRotation);
    		if ("titleAnchorPoint" in $$props) $$invalidate("titleAnchorPoint", titleAnchorPoint = $$props.titleAnchorPoint);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("xCoords" in $$props) $$invalidate("xCoords", xCoords = $$props.xCoords);
    		if ("yCoords" in $$props) $$invalidate("yCoords", yCoords = $$props.yCoords);
    		if ("tickPositions" in $$props) $$invalidate("tickPositions", tickPositions = $$props.tickPositions);
    		if ("tickXCoords" in $$props) $$invalidate("tickXCoords", tickXCoords = $$props.tickXCoords);
    		if ("tickYCoords" in $$props) $$invalidate("tickYCoords", tickYCoords = $$props.tickYCoords);
    		if ("tickLabelXCoords" in $$props) $$invalidate("tickLabelXCoords", tickLabelXCoords = $$props.tickLabelXCoords);
    		if ("tickLabelYCoords" in $$props) $$invalidate("tickLabelYCoords", tickLabelYCoords = $$props.tickLabelYCoords);
    		if ("format" in $$props) $$invalidate("format", format = $$props.format);
    		if ("tickLabelText" in $$props) $$invalidate("tickLabelText", tickLabelText = $$props.tickLabelText);
    		if ("titleXCoord" in $$props) $$invalidate("titleXCoord", titleXCoord = $$props.titleXCoord);
    		if ("titleYCoord" in $$props) $$invalidate("titleYCoord", titleYCoord = $$props.titleYCoord);
    		if ("axisHeight" in $$props) $$invalidate("axisHeight", axisHeight = $$props.axisHeight);
    		if ("labelAnchorPoint" in $$props) $$invalidate("labelAnchorPoint", labelAnchorPoint = $$props.labelAnchorPoint);
    		if ("scaleX" in $$props) $$invalidate("scaleX", scaleX = $$props.scaleX);
    		if ("$sectionContext" in $$props) sectionContext.set($sectionContext = $$props.$sectionContext);
    	};

    	$$self.$$.update = (changed = { scale: 1, $sectionContext: 1, vjust: 1, y: 1, yOffset: 1, scaleX: 1, tickValues: 1, tickCount: 1, tickExtra: 1, tickPositions: 1, yCoords: 1, baseLineWidth: 1, tickSize: 1, flip: 1, labelOffset: 1, labelFormat: 1, format: 1, labelFontSize: 1, title: 1, titleHjust: 1, xCoords: 1, titleX: 1, titleXOffset: 1, axisHeight: 1, titleFontSize: 1, titleVjust: 1, titleY: 1, titleYOffset: 1 }) => {
    		if (changed.scale || changed.$sectionContext || changed.vjust || changed.y || changed.yOffset || changed.scaleX) {
    			 {
    				$$invalidate("scaleX", scaleX = typeof scale === "undefined"
    				? $sectionContext.scaleX
    				: scale);

    				$$invalidate("xCoords", { xCoords, yCoords } = createXAxisCoords(vjust, y, yOffset, scaleX, $sectionContext.scaleY, $sectionContext), xCoords, (((((($$invalidate("yCoords", yCoords), $$invalidate("scale", scale)), $$invalidate("$sectionContext", $sectionContext)), $$invalidate("vjust", vjust)), $$invalidate("y", y)), $$invalidate("yOffset", yOffset)), $$invalidate("scaleX", scaleX)));
    			}
    		}

    		if (changed.tickValues || changed.scaleX || changed.tickCount || changed.tickExtra || changed.tickPositions || changed.yCoords || changed.baseLineWidth || changed.tickSize || changed.flip || changed.labelOffset || changed.labelFormat || changed.format || changed.labelFontSize) {
    			 {
    				$$invalidate("tickPositions", tickPositions = getTickPositions(tickValues, scaleX, tickCount, tickExtra));
    				$$invalidate("tickXCoords", { tickXCoords, tickYCoords } = createXTickGeoms(tickPositions, yCoords, scaleX, baseLineWidth, tickSize, flip), tickXCoords, (((((((((((((((((($$invalidate("tickYCoords", tickYCoords), $$invalidate("tickValues", tickValues)), $$invalidate("scaleX", scaleX)), $$invalidate("tickCount", tickCount)), $$invalidate("tickExtra", tickExtra)), $$invalidate("tickPositions", tickPositions)), $$invalidate("yCoords", yCoords)), $$invalidate("baseLineWidth", baseLineWidth)), $$invalidate("tickSize", tickSize)), $$invalidate("flip", flip)), $$invalidate("labelOffset", labelOffset)), $$invalidate("labelFormat", labelFormat)), $$invalidate("format", format)), $$invalidate("labelFontSize", labelFontSize)), $$invalidate("scale", scale)), $$invalidate("$sectionContext", $sectionContext)), $$invalidate("vjust", vjust)), $$invalidate("y", y)), $$invalidate("yOffset", yOffset)));
    				$$invalidate("tickLabelXCoords", { tickLabelXCoords, tickLabelYCoords } = createXLabelGeoms(tickPositions, yCoords, scaleX, baseLineWidth, tickSize, labelOffset, flip), tickLabelXCoords, (((((((((((((((((($$invalidate("tickLabelYCoords", tickLabelYCoords), $$invalidate("tickValues", tickValues)), $$invalidate("scaleX", scaleX)), $$invalidate("tickCount", tickCount)), $$invalidate("tickExtra", tickExtra)), $$invalidate("tickPositions", tickPositions)), $$invalidate("yCoords", yCoords)), $$invalidate("baseLineWidth", baseLineWidth)), $$invalidate("tickSize", tickSize)), $$invalidate("flip", flip)), $$invalidate("labelOffset", labelOffset)), $$invalidate("labelFormat", labelFormat)), $$invalidate("format", format)), $$invalidate("labelFontSize", labelFontSize)), $$invalidate("scale", scale)), $$invalidate("$sectionContext", $sectionContext)), $$invalidate("vjust", vjust)), $$invalidate("y", y)), $$invalidate("yOffset", yOffset)));
    				$$invalidate("format", format = getFormat(labelFormat, scaleX, tickPositions.length));
    				$$invalidate("tickLabelText", tickLabelText = tickPositions.map(format));
    				$$invalidate("axisHeight", axisHeight = baseLineWidth + tickSize + labelOffset + labelFontSize);
    				$$invalidate("labelAnchorPoint", labelAnchorPoint = flip ? "b" : "t");
    			}
    		}

    		if (changed.title || changed.titleHjust || changed.xCoords || changed.titleX || changed.scaleX || changed.$sectionContext || changed.titleXOffset || changed.axisHeight || changed.flip || changed.titleFontSize || changed.titleVjust || changed.yCoords || changed.titleY || changed.titleYOffset) {
    			 {
    				if (title.length > 0) {
    					$$invalidate("titleXCoord", titleXCoord = createTitleXCoord$1(titleHjust, xCoords, titleX, scaleX, $sectionContext.scaleY, titleXOffset, axisHeight, flip, titleFontSize, $sectionContext));
    					$$invalidate("titleYCoord", titleYCoord = createTitleYCoord$1(titleVjust, yCoords, titleY, scaleX, $sectionContext.scaleY, titleYOffset, axisHeight, flip, titleFontSize, $sectionContext));
    				}
    			}
    		}
    	};

    	return {
    		scale,
    		flip,
    		baseLine,
    		baseLineColor,
    		baseLineOpacity,
    		baseLineWidth,
    		vjust,
    		y,
    		yOffset,
    		hjust,
    		x,
    		xOffset,
    		ticks,
    		tickCount,
    		tickExtra,
    		tickValues,
    		tickSize,
    		tickWidth,
    		tickColor,
    		tickOpacity,
    		labelFormat,
    		labelOffset,
    		labelRotate,
    		labelFont,
    		labelFontSize,
    		labelFontWeight,
    		labelOpacity,
    		labelColor,
    		titleHjust,
    		titleXOffset,
    		titleX,
    		titleVjust,
    		titleYOffset,
    		titleY,
    		title,
    		titleColor,
    		titleFont,
    		titleFontSize,
    		titleFontWeight,
    		titleOpacity,
    		titleRotation,
    		titleAnchorPoint,
    		transition,
    		zoomIdentity,
    		sectionContext,
    		xCoords,
    		yCoords,
    		tickXCoords,
    		tickYCoords,
    		tickLabelXCoords,
    		tickLabelYCoords,
    		tickLabelText,
    		titleXCoord,
    		titleYCoord,
    		labelAnchorPoint
    	};
    }

    class XAxis extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$l, create_fragment$l, safe_not_equal, {
    			scale: 0,
    			flip: 0,
    			baseLine: 0,
    			baseLineColor: 0,
    			baseLineOpacity: 0,
    			baseLineWidth: 0,
    			vjust: 0,
    			y: 0,
    			yOffset: 0,
    			hjust: 0,
    			x: 0,
    			xOffset: 0,
    			ticks: 0,
    			tickCount: 0,
    			tickExtra: 0,
    			tickValues: 0,
    			tickSize: 0,
    			tickWidth: 0,
    			tickColor: 0,
    			tickOpacity: 0,
    			labelFormat: 0,
    			labelOffset: 0,
    			labelRotate: 0,
    			labelFont: 0,
    			labelFontSize: 0,
    			labelFontWeight: 0,
    			labelOpacity: 0,
    			labelColor: 0,
    			titleHjust: 0,
    			titleXOffset: 0,
    			titleX: 0,
    			titleVjust: 0,
    			titleYOffset: 0,
    			titleY: 0,
    			title: 0,
    			titleColor: 0,
    			titleFont: 0,
    			titleFontSize: 0,
    			titleFontWeight: 0,
    			titleOpacity: 0,
    			titleRotation: 0,
    			titleAnchorPoint: 0,
    			transition: 0,
    			zoomIdentity: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "XAxis",
    			options,
    			id: create_fragment$l.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || ({});

    		if (ctx.scale === undefined && !("scale" in props)) {
    			console.warn("<XAxis> was created without expected prop 'scale'");
    		}

    		if (ctx.y === undefined && !("y" in props)) {
    			console.warn("<XAxis> was created without expected prop 'y'");
    		}

    		if (ctx.hjust === undefined && !("hjust" in props)) {
    			console.warn("<XAxis> was created without expected prop 'hjust'");
    		}

    		if (ctx.x === undefined && !("x" in props)) {
    			console.warn("<XAxis> was created without expected prop 'x'");
    		}

    		if (ctx.tickValues === undefined && !("tickValues" in props)) {
    			console.warn("<XAxis> was created without expected prop 'tickValues'");
    		}

    		if (ctx.labelFormat === undefined && !("labelFormat" in props)) {
    			console.warn("<XAxis> was created without expected prop 'labelFormat'");
    		}

    		if (ctx.titleX === undefined && !("titleX" in props)) {
    			console.warn("<XAxis> was created without expected prop 'titleX'");
    		}

    		if (ctx.titleY === undefined && !("titleY" in props)) {
    			console.warn("<XAxis> was created without expected prop 'titleY'");
    		}

    		if (ctx.transition === undefined && !("transition" in props)) {
    			console.warn("<XAxis> was created without expected prop 'transition'");
    		}

    		if (ctx.zoomIdentity === undefined && !("zoomIdentity" in props)) {
    			console.warn("<XAxis> was created without expected prop 'zoomIdentity'");
    		}
    	}

    	get scale() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scale(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flip() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flip(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get baseLine() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set baseLine(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get baseLineColor() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set baseLineColor(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get baseLineOpacity() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set baseLineOpacity(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get baseLineWidth() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set baseLineWidth(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get vjust() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set vjust(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get yOffset() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set yOffset(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hjust() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hjust(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get x() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xOffset() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xOffset(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ticks() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ticks(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tickCount() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tickCount(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tickExtra() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tickExtra(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tickValues() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tickValues(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tickSize() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tickSize(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tickWidth() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tickWidth(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tickColor() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tickColor(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tickOpacity() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tickOpacity(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelFormat() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelFormat(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelOffset() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelOffset(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelRotate() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelRotate(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelFont() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelFont(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelFontSize() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelFontSize(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelFontWeight() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelFontWeight(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelOpacity() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelOpacity(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelColor() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelColor(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleHjust() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleHjust(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleXOffset() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleXOffset(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleX() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleX(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleVjust() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleVjust(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleYOffset() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleYOffset(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleY() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleY(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleColor() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleColor(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleFont() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleFont(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleFontSize() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleFontSize(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleFontWeight() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleFontWeight(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleOpacity() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleOpacity(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleRotation() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleRotation(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleAnchorPoint() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleAnchorPoint(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transition() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transition(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zoomIdentity() {
    		throw new Error("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoomIdentity(value) {
    		throw new Error("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function createYAxisCoords (hjust, x, offset, scaleX, scaleY, sectionContext) {
      // there are three ways of setting the position of the axis, in order of precedence
      // 1. vjust with 'bottom', 'center' or 'top'
      // 2. vjust with a number (relative position within content of section
      // 3. y prop with either a single number (positioning in data coords)
      //    or a function that returns an array of 2 numbers (in pixel coords)
      const xRange = scaleX.range();
      const yRange = scaleY.range();
      if (sectionContext.flipX) xRange.reverse();
      if (!sectionContext.flipY) yRange.reverse();
      const x1 = xRange[0];
      const x2 = xRange[1];
      const y1 = yRange[0];
      const y2 = yRange[1];
      const yCoords = () => {
        return [y1, y2]
      };
      let xCoords;

      if (hjust === 'left') {
        xCoords = () => {
          return [x1 - offset, x1 - offset]
        };
      }
      if (hjust === 'center' || hjust === 'centre') {
        const xCoord = (x2 - x1) * 0.5 + x1;
        xCoords = () => {
          return [xCoord + offset, xCoord + offset]
        };
      }
      if (hjust === 'right') {
        xCoords = () => {
          return [x2 + offset, x2 + offset]
        };
      }
      if (!isNaN(hjust)) {
        const xCoord = (x2 - x1) * hjust + x1;
        xCoords = () => {
          return [xCoord, xCoord]
        };
      }
      if (!isNaN(x)) {
        xCoords = () => [scaleX(x), scaleX(x)];
      }
      if (typeof x === 'function') {
        xCoords = x;
      }
      if (xCoords === undefined) {
        // we still haven't set yCoords
        // which means we don't have a y prop and a non-valid vjust prop
        // probably should throw warning
        xCoords = () => {
          return [x1 + offset, x1 + offset]
        };
      }
      return { xCoords, yCoords }
    }

    function createTitleXCoord$2 (hjust, axisXCoords, x, scaleX, scaleY, offset, width, flip, fontSize, sectionContext) {
      if (x) {
        return () => x
      }
      const xRange = scaleX.range();
      if (sectionContext.flipX) xRange.reverse();
      const x1 = xRange[0];
      const x2 = xRange[1];
      let justification;
      let widthOffset;
      if (offset === 'axis') {
        widthOffset = width * 1.65;
        if (flip) widthOffset = -widthOffset - fontSize;
      } else {
        widthOffset = offset;
      }

      if (hjust === 'axis') {
        return () => axisXCoords()[0] - widthOffset
      }
      if (hjust === 'center' || hjust === 'centre') {
        justification = 0.5;
      }
      if (hjust === 'left') {
        justification = 0;
      }
      if (hjust === 'right') {
        justification = 1;
      }
      if (!isNaN(hjust)) {
        justification = hjust;
      }
      if (justification === undefined) {
        justification = 0.5;
      }
      return () => x1 + Math.abs(x1 - x2) * justification - widthOffset
    }

    function createTitleYCoord$2 (vjust, axisYCoords, y, scaleX, scaleY, offset, width, flip, fontSize, sectionContext) {
      if (y) {
        return () => y
      }
      const yRange = scaleY.range();
      if (!sectionContext.flipY) yRange.reverse();
      const y1 = yRange[0];
      const y2 = yRange[1];
      let justification;

      if (vjust === 'axis') {
        return () => axisYCoords()[0]
      }

      if (vjust === 'center' || vjust === 'centre') {
        justification = 0.5;
      }
      if (vjust === 'bottom') {
        justification = 0;
      }
      if (vjust === 'top') {
        justification = 1;
      }
      if (!isNaN(vjust)) {
        justification = vjust;
      }
      if (justification === undefined) {
        justification = 0.5;
      }
      return () => y1 - Math.abs(y1 - y2) * justification + offset
    }

    function createYTickGeoms (tickPositions, xCoords, scale, baseLineWidth, tickSize, flip) {
      const x = [];
      const y = [];

      const xStart = xCoords()[0] - baseLineWidth / 2;

      let offset = baseLineWidth + tickSize;
      if (!flip) offset = -offset;

      const bandOffset = scale.bandwidth ? scale.bandwidth() / 2 : 0;

      for (let index = 0; index < tickPositions.length; index++) {
        const tick = scale(tickPositions[index]) + bandOffset;
        x.push([xStart, xStart + offset]);
        y.push([tick, tick]);
      }
      return { tickXCoords: () => x, tickYCoords: () => y }
    }

    function createYLabelGeoms (tickPositions, xCoords, scale, baseLineWidth, tickSize, labelOffset, flip) {
      const x = [];
      const y = [];

      const xStart = xCoords()[0];

      let offset = baseLineWidth + tickSize + labelOffset;
      if (!flip) offset = -offset;

      const bandOffset = scale.bandwidth ? scale.bandwidth() / 2 : 0;

      for (let index = 0; index < tickPositions.length; index++) {
        const tick = scale(tickPositions[index]) + bandOffset;
        x.push(xStart + offset);
        y.push(tick);
      }
      return { tickLabelXCoords: () => x, tickLabelYCoords: () => y }
    }

    /* src/components/Guides/Axes/YAxis.svelte generated by Svelte v3.15.0 */
    const file$8 = "src/components/Guides/Axes/YAxis.svelte";

    // (110:2) {#if baseLine}
    function create_if_block_2$3(ctx) {
    	let current;

    	const line = new Line({
    			props: {
    				x: ctx.xCoords,
    				y: ctx.yCoords,
    				strokeWidth: ctx.baseLineWidth,
    				opacity: ctx.baseLineOpacity,
    				stroke: ctx.baseLineColor,
    				zoomIdentity: ctx.zoomIdentity
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(line.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(line, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const line_changes = {};
    			if (changed.xCoords) line_changes.x = ctx.xCoords;
    			if (changed.yCoords) line_changes.y = ctx.yCoords;
    			if (changed.baseLineWidth) line_changes.strokeWidth = ctx.baseLineWidth;
    			if (changed.baseLineOpacity) line_changes.opacity = ctx.baseLineOpacity;
    			if (changed.baseLineColor) line_changes.stroke = ctx.baseLineColor;
    			if (changed.zoomIdentity) line_changes.zoomIdentity = ctx.zoomIdentity;
    			line.$set(line_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(line.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(line.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(line, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(110:2) {#if baseLine}",
    		ctx
    	});

    	return block;
    }

    // (117:2) {#if ticks}
    function create_if_block_1$5(ctx) {
    	let current;

    	const linelayer = new LineLayer({
    			props: {
    				x: ctx.tickXCoords,
    				y: ctx.tickYCoords,
    				strokeWidth: ctx.tickWidth,
    				opacity: ctx.tickOpacity,
    				stroke: ctx.tickColor,
    				transition: ctx.transition,
    				zoomIdentity: ctx.zoomIdentity
    			},
    			$$inline: true
    		});

    	const labellayer = new LabelLayer({
    			props: {
    				x: ctx.tickLabelXCoords,
    				y: ctx.tickLabelYCoords,
    				text: ctx.tickLabelText,
    				anchorPoint: ctx.labelAnchorPoint,
    				rotation: ctx.labelRotate,
    				fontFamily: ctx.labelFont,
    				fontSize: ctx.labelFontSize,
    				fontWeight: ctx.labelFontWeight,
    				opacity: ctx.labelOpacity,
    				fill: ctx.labelColor,
    				transition: ctx.transition,
    				zoomIdentity: ctx.zoomIdentity
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(linelayer.$$.fragment);
    			create_component(labellayer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(linelayer, target, anchor);
    			mount_component(labellayer, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const linelayer_changes = {};
    			if (changed.tickXCoords) linelayer_changes.x = ctx.tickXCoords;
    			if (changed.tickYCoords) linelayer_changes.y = ctx.tickYCoords;
    			if (changed.tickWidth) linelayer_changes.strokeWidth = ctx.tickWidth;
    			if (changed.tickOpacity) linelayer_changes.opacity = ctx.tickOpacity;
    			if (changed.tickColor) linelayer_changes.stroke = ctx.tickColor;
    			if (changed.transition) linelayer_changes.transition = ctx.transition;
    			if (changed.zoomIdentity) linelayer_changes.zoomIdentity = ctx.zoomIdentity;
    			linelayer.$set(linelayer_changes);
    			const labellayer_changes = {};
    			if (changed.tickLabelXCoords) labellayer_changes.x = ctx.tickLabelXCoords;
    			if (changed.tickLabelYCoords) labellayer_changes.y = ctx.tickLabelYCoords;
    			if (changed.tickLabelText) labellayer_changes.text = ctx.tickLabelText;
    			if (changed.labelAnchorPoint) labellayer_changes.anchorPoint = ctx.labelAnchorPoint;
    			if (changed.labelRotate) labellayer_changes.rotation = ctx.labelRotate;
    			if (changed.labelFont) labellayer_changes.fontFamily = ctx.labelFont;
    			if (changed.labelFontSize) labellayer_changes.fontSize = ctx.labelFontSize;
    			if (changed.labelFontWeight) labellayer_changes.fontWeight = ctx.labelFontWeight;
    			if (changed.labelOpacity) labellayer_changes.opacity = ctx.labelOpacity;
    			if (changed.labelColor) labellayer_changes.fill = ctx.labelColor;
    			if (changed.transition) labellayer_changes.transition = ctx.transition;
    			if (changed.zoomIdentity) labellayer_changes.zoomIdentity = ctx.zoomIdentity;
    			labellayer.$set(labellayer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(linelayer.$$.fragment, local);
    			transition_in(labellayer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(linelayer.$$.fragment, local);
    			transition_out(labellayer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(linelayer, detaching);
    			destroy_component(labellayer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(117:2) {#if ticks}",
    		ctx
    	});

    	return block;
    }

    // (130:2) {#if title.length > 0}
    function create_if_block$6(ctx) {
    	let current;

    	const label = new Label({
    			props: {
    				x: ctx.titleXCoord,
    				y: ctx.titleYCoord,
    				text: ctx.title,
    				anchorPoint: ctx.titleAnchorPoint,
    				rotation: ctx.titleRotation,
    				fontFamily: ctx.titleFont,
    				fontSize: ctx.titleFontSize,
    				fontWeight: ctx.titleFontWeight,
    				opacity: ctx.titleOpacity,
    				fill: ctx.titleColor,
    				zoomIdentity: ctx.zoomIdentity
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(label.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(label, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const label_changes = {};
    			if (changed.titleXCoord) label_changes.x = ctx.titleXCoord;
    			if (changed.titleYCoord) label_changes.y = ctx.titleYCoord;
    			if (changed.title) label_changes.text = ctx.title;
    			if (changed.titleAnchorPoint) label_changes.anchorPoint = ctx.titleAnchorPoint;
    			if (changed.titleRotation) label_changes.rotation = ctx.titleRotation;
    			if (changed.titleFont) label_changes.fontFamily = ctx.titleFont;
    			if (changed.titleFontSize) label_changes.fontSize = ctx.titleFontSize;
    			if (changed.titleFontWeight) label_changes.fontWeight = ctx.titleFontWeight;
    			if (changed.titleOpacity) label_changes.opacity = ctx.titleOpacity;
    			if (changed.titleColor) label_changes.fill = ctx.titleColor;
    			if (changed.zoomIdentity) label_changes.zoomIdentity = ctx.zoomIdentity;
    			label.$set(label_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(label, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(130:2) {#if title.length > 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let g;
    	let if_block0_anchor;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = ctx.baseLine && create_if_block_2$3(ctx);
    	let if_block1 = ctx.ticks && create_if_block_1$5(ctx);
    	let if_block2 = ctx.title.length > 0 && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			g = svg_element("g");
    			if (if_block0) if_block0.c();
    			if_block0_anchor = empty();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    			if (if_block2) if_block2.c();
    			attr_dev(g, "class", "y-axis");
    			add_location(g, file$8, 107, 0, 3362);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);
    			if (if_block0) if_block0.m(g, null);
    			append_dev(g, if_block0_anchor);
    			if (if_block1) if_block1.m(g, null);
    			append_dev(g, if_block1_anchor);
    			if (if_block2) if_block2.m(g, null);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (ctx.baseLine) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    					transition_in(if_block0, 1);
    				} else {
    					if_block0 = create_if_block_2$3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(g, if_block0_anchor);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (ctx.ticks) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    					transition_in(if_block1, 1);
    				} else {
    					if_block1 = create_if_block_1$5(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(g, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (ctx.title.length > 0) {
    				if (if_block2) {
    					if_block2.p(changed, ctx);
    					transition_in(if_block2, 1);
    				} else {
    					if_block2 = create_if_block$6(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(g, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let $sectionContext;
    	let { scale } = $$props;
    	let { flip = false } = $$props;
    	let { baseLine = true } = $$props;
    	let { baseLineColor = "black" } = $$props;
    	let { baseLineOpacity = 1 } = $$props;
    	let { baseLineWidth = 1 } = $$props;
    	let { vjust } = $$props;
    	let { y } = $$props;
    	let { yOffset } = $$props;
    	let { hjust = "left" } = $$props;
    	let { x } = $$props;
    	let { xOffset = 0 } = $$props;
    	let { ticks = true } = $$props;
    	let { tickCount = 10 } = $$props;
    	let { tickExtra = false } = $$props;
    	let { tickValues } = $$props;
    	let { tickSize = 5 } = $$props;
    	let { tickWidth = 0.5 } = $$props;
    	let { tickColor = "black" } = $$props;
    	let { tickOpacity = 1 } = $$props;
    	let { labelFormat } = $$props;
    	let { labelOffset = 2 } = $$props;
    	let { labelRotate = 0 } = $$props;
    	let { labelFont = "Helvetica" } = $$props;
    	let { labelFontSize = 10 } = $$props;
    	let { labelFontWeight = "normal" } = $$props;
    	let { labelOpacity = 1 } = $$props;
    	let { labelColor = "black" } = $$props;
    	let { titleHjust = "axis" } = $$props;
    	let { titleXOffset = "axis" } = $$props;
    	let { titleX } = $$props;
    	let { titleVjust = "center" } = $$props;
    	let { titleYOffset = 0 } = $$props;
    	let { titleY } = $$props;
    	let { title = "" } = $$props;
    	let { titleColor = "black" } = $$props;
    	let { titleFont = "Helvetica" } = $$props;
    	let { titleFontSize = "12" } = $$props;
    	let { titleFontWeight = "normal" } = $$props;
    	let { titleOpacity = 1 } = $$props;
    	let { titleRotation = -90 } = $$props;
    	let { titleAnchorPoint = "center" } = $$props;
    	let { transition } = $$props;
    	let { zoomIdentity } = $$props;
    	const sectionContext = subscribe$2();
    	validate_store(sectionContext, "sectionContext");
    	component_subscribe($$self, sectionContext, value => $$invalidate("$sectionContext", $sectionContext = value));
    	const graphicContext = subscribe$1();
    	let xCoords;
    	let yCoords;
    	let tickPositions;
    	let tickXCoords;
    	let tickYCoords;
    	let tickLabelXCoords;
    	let tickLabelYCoords;
    	let format;
    	let tickLabelText;
    	let titleXCoord;
    	let titleYCoord;
    	let axisWidth;
    	let labelAnchorPoint = "r";
    	let scaleY;

    	const writable_props = [
    		"scale",
    		"flip",
    		"baseLine",
    		"baseLineColor",
    		"baseLineOpacity",
    		"baseLineWidth",
    		"vjust",
    		"y",
    		"yOffset",
    		"hjust",
    		"x",
    		"xOffset",
    		"ticks",
    		"tickCount",
    		"tickExtra",
    		"tickValues",
    		"tickSize",
    		"tickWidth",
    		"tickColor",
    		"tickOpacity",
    		"labelFormat",
    		"labelOffset",
    		"labelRotate",
    		"labelFont",
    		"labelFontSize",
    		"labelFontWeight",
    		"labelOpacity",
    		"labelColor",
    		"titleHjust",
    		"titleXOffset",
    		"titleX",
    		"titleVjust",
    		"titleYOffset",
    		"titleY",
    		"title",
    		"titleColor",
    		"titleFont",
    		"titleFontSize",
    		"titleFontWeight",
    		"titleOpacity",
    		"titleRotation",
    		"titleAnchorPoint",
    		"transition",
    		"zoomIdentity"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<YAxis> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("scale" in $$props) $$invalidate("scale", scale = $$props.scale);
    		if ("flip" in $$props) $$invalidate("flip", flip = $$props.flip);
    		if ("baseLine" in $$props) $$invalidate("baseLine", baseLine = $$props.baseLine);
    		if ("baseLineColor" in $$props) $$invalidate("baseLineColor", baseLineColor = $$props.baseLineColor);
    		if ("baseLineOpacity" in $$props) $$invalidate("baseLineOpacity", baseLineOpacity = $$props.baseLineOpacity);
    		if ("baseLineWidth" in $$props) $$invalidate("baseLineWidth", baseLineWidth = $$props.baseLineWidth);
    		if ("vjust" in $$props) $$invalidate("vjust", vjust = $$props.vjust);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("yOffset" in $$props) $$invalidate("yOffset", yOffset = $$props.yOffset);
    		if ("hjust" in $$props) $$invalidate("hjust", hjust = $$props.hjust);
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("xOffset" in $$props) $$invalidate("xOffset", xOffset = $$props.xOffset);
    		if ("ticks" in $$props) $$invalidate("ticks", ticks = $$props.ticks);
    		if ("tickCount" in $$props) $$invalidate("tickCount", tickCount = $$props.tickCount);
    		if ("tickExtra" in $$props) $$invalidate("tickExtra", tickExtra = $$props.tickExtra);
    		if ("tickValues" in $$props) $$invalidate("tickValues", tickValues = $$props.tickValues);
    		if ("tickSize" in $$props) $$invalidate("tickSize", tickSize = $$props.tickSize);
    		if ("tickWidth" in $$props) $$invalidate("tickWidth", tickWidth = $$props.tickWidth);
    		if ("tickColor" in $$props) $$invalidate("tickColor", tickColor = $$props.tickColor);
    		if ("tickOpacity" in $$props) $$invalidate("tickOpacity", tickOpacity = $$props.tickOpacity);
    		if ("labelFormat" in $$props) $$invalidate("labelFormat", labelFormat = $$props.labelFormat);
    		if ("labelOffset" in $$props) $$invalidate("labelOffset", labelOffset = $$props.labelOffset);
    		if ("labelRotate" in $$props) $$invalidate("labelRotate", labelRotate = $$props.labelRotate);
    		if ("labelFont" in $$props) $$invalidate("labelFont", labelFont = $$props.labelFont);
    		if ("labelFontSize" in $$props) $$invalidate("labelFontSize", labelFontSize = $$props.labelFontSize);
    		if ("labelFontWeight" in $$props) $$invalidate("labelFontWeight", labelFontWeight = $$props.labelFontWeight);
    		if ("labelOpacity" in $$props) $$invalidate("labelOpacity", labelOpacity = $$props.labelOpacity);
    		if ("labelColor" in $$props) $$invalidate("labelColor", labelColor = $$props.labelColor);
    		if ("titleHjust" in $$props) $$invalidate("titleHjust", titleHjust = $$props.titleHjust);
    		if ("titleXOffset" in $$props) $$invalidate("titleXOffset", titleXOffset = $$props.titleXOffset);
    		if ("titleX" in $$props) $$invalidate("titleX", titleX = $$props.titleX);
    		if ("titleVjust" in $$props) $$invalidate("titleVjust", titleVjust = $$props.titleVjust);
    		if ("titleYOffset" in $$props) $$invalidate("titleYOffset", titleYOffset = $$props.titleYOffset);
    		if ("titleY" in $$props) $$invalidate("titleY", titleY = $$props.titleY);
    		if ("title" in $$props) $$invalidate("title", title = $$props.title);
    		if ("titleColor" in $$props) $$invalidate("titleColor", titleColor = $$props.titleColor);
    		if ("titleFont" in $$props) $$invalidate("titleFont", titleFont = $$props.titleFont);
    		if ("titleFontSize" in $$props) $$invalidate("titleFontSize", titleFontSize = $$props.titleFontSize);
    		if ("titleFontWeight" in $$props) $$invalidate("titleFontWeight", titleFontWeight = $$props.titleFontWeight);
    		if ("titleOpacity" in $$props) $$invalidate("titleOpacity", titleOpacity = $$props.titleOpacity);
    		if ("titleRotation" in $$props) $$invalidate("titleRotation", titleRotation = $$props.titleRotation);
    		if ("titleAnchorPoint" in $$props) $$invalidate("titleAnchorPoint", titleAnchorPoint = $$props.titleAnchorPoint);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    	};

    	$$self.$capture_state = () => {
    		return {
    			scale,
    			flip,
    			baseLine,
    			baseLineColor,
    			baseLineOpacity,
    			baseLineWidth,
    			vjust,
    			y,
    			yOffset,
    			hjust,
    			x,
    			xOffset,
    			ticks,
    			tickCount,
    			tickExtra,
    			tickValues,
    			tickSize,
    			tickWidth,
    			tickColor,
    			tickOpacity,
    			labelFormat,
    			labelOffset,
    			labelRotate,
    			labelFont,
    			labelFontSize,
    			labelFontWeight,
    			labelOpacity,
    			labelColor,
    			titleHjust,
    			titleXOffset,
    			titleX,
    			titleVjust,
    			titleYOffset,
    			titleY,
    			title,
    			titleColor,
    			titleFont,
    			titleFontSize,
    			titleFontWeight,
    			titleOpacity,
    			titleRotation,
    			titleAnchorPoint,
    			transition,
    			zoomIdentity,
    			xCoords,
    			yCoords,
    			tickPositions,
    			tickXCoords,
    			tickYCoords,
    			tickLabelXCoords,
    			tickLabelYCoords,
    			format,
    			tickLabelText,
    			titleXCoord,
    			titleYCoord,
    			axisWidth,
    			labelAnchorPoint,
    			scaleY,
    			$sectionContext
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("scale" in $$props) $$invalidate("scale", scale = $$props.scale);
    		if ("flip" in $$props) $$invalidate("flip", flip = $$props.flip);
    		if ("baseLine" in $$props) $$invalidate("baseLine", baseLine = $$props.baseLine);
    		if ("baseLineColor" in $$props) $$invalidate("baseLineColor", baseLineColor = $$props.baseLineColor);
    		if ("baseLineOpacity" in $$props) $$invalidate("baseLineOpacity", baseLineOpacity = $$props.baseLineOpacity);
    		if ("baseLineWidth" in $$props) $$invalidate("baseLineWidth", baseLineWidth = $$props.baseLineWidth);
    		if ("vjust" in $$props) $$invalidate("vjust", vjust = $$props.vjust);
    		if ("y" in $$props) $$invalidate("y", y = $$props.y);
    		if ("yOffset" in $$props) $$invalidate("yOffset", yOffset = $$props.yOffset);
    		if ("hjust" in $$props) $$invalidate("hjust", hjust = $$props.hjust);
    		if ("x" in $$props) $$invalidate("x", x = $$props.x);
    		if ("xOffset" in $$props) $$invalidate("xOffset", xOffset = $$props.xOffset);
    		if ("ticks" in $$props) $$invalidate("ticks", ticks = $$props.ticks);
    		if ("tickCount" in $$props) $$invalidate("tickCount", tickCount = $$props.tickCount);
    		if ("tickExtra" in $$props) $$invalidate("tickExtra", tickExtra = $$props.tickExtra);
    		if ("tickValues" in $$props) $$invalidate("tickValues", tickValues = $$props.tickValues);
    		if ("tickSize" in $$props) $$invalidate("tickSize", tickSize = $$props.tickSize);
    		if ("tickWidth" in $$props) $$invalidate("tickWidth", tickWidth = $$props.tickWidth);
    		if ("tickColor" in $$props) $$invalidate("tickColor", tickColor = $$props.tickColor);
    		if ("tickOpacity" in $$props) $$invalidate("tickOpacity", tickOpacity = $$props.tickOpacity);
    		if ("labelFormat" in $$props) $$invalidate("labelFormat", labelFormat = $$props.labelFormat);
    		if ("labelOffset" in $$props) $$invalidate("labelOffset", labelOffset = $$props.labelOffset);
    		if ("labelRotate" in $$props) $$invalidate("labelRotate", labelRotate = $$props.labelRotate);
    		if ("labelFont" in $$props) $$invalidate("labelFont", labelFont = $$props.labelFont);
    		if ("labelFontSize" in $$props) $$invalidate("labelFontSize", labelFontSize = $$props.labelFontSize);
    		if ("labelFontWeight" in $$props) $$invalidate("labelFontWeight", labelFontWeight = $$props.labelFontWeight);
    		if ("labelOpacity" in $$props) $$invalidate("labelOpacity", labelOpacity = $$props.labelOpacity);
    		if ("labelColor" in $$props) $$invalidate("labelColor", labelColor = $$props.labelColor);
    		if ("titleHjust" in $$props) $$invalidate("titleHjust", titleHjust = $$props.titleHjust);
    		if ("titleXOffset" in $$props) $$invalidate("titleXOffset", titleXOffset = $$props.titleXOffset);
    		if ("titleX" in $$props) $$invalidate("titleX", titleX = $$props.titleX);
    		if ("titleVjust" in $$props) $$invalidate("titleVjust", titleVjust = $$props.titleVjust);
    		if ("titleYOffset" in $$props) $$invalidate("titleYOffset", titleYOffset = $$props.titleYOffset);
    		if ("titleY" in $$props) $$invalidate("titleY", titleY = $$props.titleY);
    		if ("title" in $$props) $$invalidate("title", title = $$props.title);
    		if ("titleColor" in $$props) $$invalidate("titleColor", titleColor = $$props.titleColor);
    		if ("titleFont" in $$props) $$invalidate("titleFont", titleFont = $$props.titleFont);
    		if ("titleFontSize" in $$props) $$invalidate("titleFontSize", titleFontSize = $$props.titleFontSize);
    		if ("titleFontWeight" in $$props) $$invalidate("titleFontWeight", titleFontWeight = $$props.titleFontWeight);
    		if ("titleOpacity" in $$props) $$invalidate("titleOpacity", titleOpacity = $$props.titleOpacity);
    		if ("titleRotation" in $$props) $$invalidate("titleRotation", titleRotation = $$props.titleRotation);
    		if ("titleAnchorPoint" in $$props) $$invalidate("titleAnchorPoint", titleAnchorPoint = $$props.titleAnchorPoint);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("xCoords" in $$props) $$invalidate("xCoords", xCoords = $$props.xCoords);
    		if ("yCoords" in $$props) $$invalidate("yCoords", yCoords = $$props.yCoords);
    		if ("tickPositions" in $$props) $$invalidate("tickPositions", tickPositions = $$props.tickPositions);
    		if ("tickXCoords" in $$props) $$invalidate("tickXCoords", tickXCoords = $$props.tickXCoords);
    		if ("tickYCoords" in $$props) $$invalidate("tickYCoords", tickYCoords = $$props.tickYCoords);
    		if ("tickLabelXCoords" in $$props) $$invalidate("tickLabelXCoords", tickLabelXCoords = $$props.tickLabelXCoords);
    		if ("tickLabelYCoords" in $$props) $$invalidate("tickLabelYCoords", tickLabelYCoords = $$props.tickLabelYCoords);
    		if ("format" in $$props) $$invalidate("format", format = $$props.format);
    		if ("tickLabelText" in $$props) $$invalidate("tickLabelText", tickLabelText = $$props.tickLabelText);
    		if ("titleXCoord" in $$props) $$invalidate("titleXCoord", titleXCoord = $$props.titleXCoord);
    		if ("titleYCoord" in $$props) $$invalidate("titleYCoord", titleYCoord = $$props.titleYCoord);
    		if ("axisWidth" in $$props) $$invalidate("axisWidth", axisWidth = $$props.axisWidth);
    		if ("labelAnchorPoint" in $$props) $$invalidate("labelAnchorPoint", labelAnchorPoint = $$props.labelAnchorPoint);
    		if ("scaleY" in $$props) $$invalidate("scaleY", scaleY = $$props.scaleY);
    		if ("$sectionContext" in $$props) sectionContext.set($sectionContext = $$props.$sectionContext);
    	};

    	$$self.$$.update = (changed = { scale: 1, $sectionContext: 1, hjust: 1, x: 1, xOffset: 1, scaleY: 1, tickValues: 1, tickCount: 1, tickExtra: 1, tickPositions: 1, xCoords: 1, baseLineWidth: 1, tickSize: 1, flip: 1, labelOffset: 1, labelFormat: 1, format: 1, labelFontSize: 1, title: 1, titleHjust: 1, titleX: 1, titleXOffset: 1, axisWidth: 1, titleFontSize: 1, titleVjust: 1, yCoords: 1, titleY: 1, titleYOffset: 1 }) => {
    		if (changed.scale || changed.$sectionContext || changed.hjust || changed.x || changed.xOffset || changed.scaleY) {
    			 {
    				$$invalidate("scaleY", scaleY = typeof scale === "undefined"
    				? $sectionContext.scaleY
    				: scale);

    				$$invalidate("xCoords", { xCoords, yCoords } = createYAxisCoords(hjust, x, xOffset, $sectionContext.scaleX, scaleY, $sectionContext), xCoords, (((((($$invalidate("yCoords", yCoords), $$invalidate("scale", scale)), $$invalidate("$sectionContext", $sectionContext)), $$invalidate("hjust", hjust)), $$invalidate("x", x)), $$invalidate("xOffset", xOffset)), $$invalidate("scaleY", scaleY)));
    			}
    		}

    		if (changed.tickValues || changed.scaleY || changed.tickCount || changed.tickExtra || changed.tickPositions || changed.xCoords || changed.baseLineWidth || changed.tickSize || changed.flip || changed.labelOffset || changed.labelFormat || changed.format || changed.labelFontSize) {
    			 {
    				$$invalidate("tickPositions", tickPositions = getTickPositions(tickValues, scaleY, tickCount, tickExtra));
    				$$invalidate("tickXCoords", { tickXCoords, tickYCoords } = createYTickGeoms(tickPositions, xCoords, scaleY, baseLineWidth, tickSize, flip), tickXCoords, (((((((((((((((((($$invalidate("tickYCoords", tickYCoords), $$invalidate("tickValues", tickValues)), $$invalidate("scaleY", scaleY)), $$invalidate("tickCount", tickCount)), $$invalidate("tickExtra", tickExtra)), $$invalidate("tickPositions", tickPositions)), $$invalidate("xCoords", xCoords)), $$invalidate("baseLineWidth", baseLineWidth)), $$invalidate("tickSize", tickSize)), $$invalidate("flip", flip)), $$invalidate("labelOffset", labelOffset)), $$invalidate("labelFormat", labelFormat)), $$invalidate("format", format)), $$invalidate("labelFontSize", labelFontSize)), $$invalidate("scale", scale)), $$invalidate("$sectionContext", $sectionContext)), $$invalidate("hjust", hjust)), $$invalidate("x", x)), $$invalidate("xOffset", xOffset)));
    				$$invalidate("tickLabelXCoords", { tickLabelXCoords, tickLabelYCoords } = createYLabelGeoms(tickPositions, xCoords, scaleY, baseLineWidth, tickSize, labelOffset, flip), tickLabelXCoords, (((((((((((((((((($$invalidate("tickLabelYCoords", tickLabelYCoords), $$invalidate("tickValues", tickValues)), $$invalidate("scaleY", scaleY)), $$invalidate("tickCount", tickCount)), $$invalidate("tickExtra", tickExtra)), $$invalidate("tickPositions", tickPositions)), $$invalidate("xCoords", xCoords)), $$invalidate("baseLineWidth", baseLineWidth)), $$invalidate("tickSize", tickSize)), $$invalidate("flip", flip)), $$invalidate("labelOffset", labelOffset)), $$invalidate("labelFormat", labelFormat)), $$invalidate("format", format)), $$invalidate("labelFontSize", labelFontSize)), $$invalidate("scale", scale)), $$invalidate("$sectionContext", $sectionContext)), $$invalidate("hjust", hjust)), $$invalidate("x", x)), $$invalidate("xOffset", xOffset)));
    				$$invalidate("format", format = getFormat(labelFormat, scaleY, tickPositions.length));
    				$$invalidate("tickLabelText", tickLabelText = tickPositions.map(format));
    				$$invalidate("axisWidth", axisWidth = baseLineWidth + tickSize + labelOffset + labelFontSize);
    				$$invalidate("labelAnchorPoint", labelAnchorPoint = flip ? "l" : "r");
    			}
    		}

    		if (changed.title || changed.titleHjust || changed.xCoords || changed.titleX || changed.$sectionContext || changed.scaleY || changed.titleXOffset || changed.axisWidth || changed.flip || changed.titleFontSize || changed.titleVjust || changed.yCoords || changed.titleY || changed.titleYOffset) {
    			 {
    				if (title.length > 0) {
    					$$invalidate("titleXCoord", titleXCoord = createTitleXCoord$2(titleHjust, xCoords, titleX, $sectionContext.scaleX, scaleY, titleXOffset, axisWidth, flip, titleFontSize, $sectionContext));
    					$$invalidate("titleYCoord", titleYCoord = createTitleYCoord$2(titleVjust, yCoords, titleY, $sectionContext.scaleX, scaleY, titleYOffset, axisWidth, flip, titleFontSize, $sectionContext));
    				}
    			}
    		}
    	};

    	return {
    		scale,
    		flip,
    		baseLine,
    		baseLineColor,
    		baseLineOpacity,
    		baseLineWidth,
    		vjust,
    		y,
    		yOffset,
    		hjust,
    		x,
    		xOffset,
    		ticks,
    		tickCount,
    		tickExtra,
    		tickValues,
    		tickSize,
    		tickWidth,
    		tickColor,
    		tickOpacity,
    		labelFormat,
    		labelOffset,
    		labelRotate,
    		labelFont,
    		labelFontSize,
    		labelFontWeight,
    		labelOpacity,
    		labelColor,
    		titleHjust,
    		titleXOffset,
    		titleX,
    		titleVjust,
    		titleYOffset,
    		titleY,
    		title,
    		titleColor,
    		titleFont,
    		titleFontSize,
    		titleFontWeight,
    		titleOpacity,
    		titleRotation,
    		titleAnchorPoint,
    		transition,
    		zoomIdentity,
    		sectionContext,
    		xCoords,
    		yCoords,
    		tickXCoords,
    		tickYCoords,
    		tickLabelXCoords,
    		tickLabelYCoords,
    		tickLabelText,
    		titleXCoord,
    		titleYCoord,
    		labelAnchorPoint
    	};
    }

    class YAxis extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$m, create_fragment$m, safe_not_equal, {
    			scale: 0,
    			flip: 0,
    			baseLine: 0,
    			baseLineColor: 0,
    			baseLineOpacity: 0,
    			baseLineWidth: 0,
    			vjust: 0,
    			y: 0,
    			yOffset: 0,
    			hjust: 0,
    			x: 0,
    			xOffset: 0,
    			ticks: 0,
    			tickCount: 0,
    			tickExtra: 0,
    			tickValues: 0,
    			tickSize: 0,
    			tickWidth: 0,
    			tickColor: 0,
    			tickOpacity: 0,
    			labelFormat: 0,
    			labelOffset: 0,
    			labelRotate: 0,
    			labelFont: 0,
    			labelFontSize: 0,
    			labelFontWeight: 0,
    			labelOpacity: 0,
    			labelColor: 0,
    			titleHjust: 0,
    			titleXOffset: 0,
    			titleX: 0,
    			titleVjust: 0,
    			titleYOffset: 0,
    			titleY: 0,
    			title: 0,
    			titleColor: 0,
    			titleFont: 0,
    			titleFontSize: 0,
    			titleFontWeight: 0,
    			titleOpacity: 0,
    			titleRotation: 0,
    			titleAnchorPoint: 0,
    			transition: 0,
    			zoomIdentity: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "YAxis",
    			options,
    			id: create_fragment$m.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || ({});

    		if (ctx.scale === undefined && !("scale" in props)) {
    			console.warn("<YAxis> was created without expected prop 'scale'");
    		}

    		if (ctx.vjust === undefined && !("vjust" in props)) {
    			console.warn("<YAxis> was created without expected prop 'vjust'");
    		}

    		if (ctx.y === undefined && !("y" in props)) {
    			console.warn("<YAxis> was created without expected prop 'y'");
    		}

    		if (ctx.yOffset === undefined && !("yOffset" in props)) {
    			console.warn("<YAxis> was created without expected prop 'yOffset'");
    		}

    		if (ctx.x === undefined && !("x" in props)) {
    			console.warn("<YAxis> was created without expected prop 'x'");
    		}

    		if (ctx.tickValues === undefined && !("tickValues" in props)) {
    			console.warn("<YAxis> was created without expected prop 'tickValues'");
    		}

    		if (ctx.labelFormat === undefined && !("labelFormat" in props)) {
    			console.warn("<YAxis> was created without expected prop 'labelFormat'");
    		}

    		if (ctx.titleX === undefined && !("titleX" in props)) {
    			console.warn("<YAxis> was created without expected prop 'titleX'");
    		}

    		if (ctx.titleY === undefined && !("titleY" in props)) {
    			console.warn("<YAxis> was created without expected prop 'titleY'");
    		}

    		if (ctx.transition === undefined && !("transition" in props)) {
    			console.warn("<YAxis> was created without expected prop 'transition'");
    		}

    		if (ctx.zoomIdentity === undefined && !("zoomIdentity" in props)) {
    			console.warn("<YAxis> was created without expected prop 'zoomIdentity'");
    		}
    	}

    	get scale() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scale(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flip() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flip(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get baseLine() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set baseLine(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get baseLineColor() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set baseLineColor(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get baseLineOpacity() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set baseLineOpacity(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get baseLineWidth() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set baseLineWidth(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get vjust() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set vjust(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get yOffset() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set yOffset(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hjust() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hjust(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get x() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xOffset() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xOffset(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ticks() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ticks(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tickCount() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tickCount(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tickExtra() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tickExtra(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tickValues() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tickValues(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tickSize() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tickSize(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tickWidth() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tickWidth(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tickColor() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tickColor(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tickOpacity() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tickOpacity(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelFormat() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelFormat(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelOffset() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelOffset(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelRotate() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelRotate(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelFont() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelFont(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelFontSize() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelFontSize(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelFontWeight() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelFontWeight(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelOpacity() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelOpacity(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelColor() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelColor(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleHjust() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleHjust(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleXOffset() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleXOffset(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleX() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleX(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleVjust() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleVjust(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleYOffset() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleYOffset(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleY() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleY(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleColor() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleColor(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleFont() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleFont(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleFontSize() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleFontSize(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleFontWeight() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleFontWeight(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleOpacity() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleOpacity(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleRotation() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleRotation(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleAnchorPoint() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleAnchorPoint(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transition() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transition(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zoomIdentity() {
    		throw new Error("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoomIdentity(value) {
    		throw new Error("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function createGeoScales (bbox) {
      const domainX = bbox.x;
      const domainY = bbox.y;

      let rangeX;
      let rangeY;

      const scaleX = linear$1().domain(domainX);
      const scaleY = linear$1().domain(domainY);

      const setRangeX = range => {
        rangeX = range;
        updateRanges();
        return scaleX
      };

      const setRangeY = range => {
        rangeY = range;
        updateRanges();
        return scaleY
      };

      function updateRanges () {
        if (rangeX && rangeY) {
          const rangeDeltaX = Math.abs(rangeX[1] - rangeX[0]);
          const rangeDeltaY = Math.abs(rangeY[1] - rangeY[0]);

          const midX = (rangeX[0] + rangeX[1]) / 2;
          const midY = (rangeY[0] + rangeY[1]) / 2;

          const scalingFactorX = rangeDeltaX / (domainX[1] - domainX[0]);
          const scalingFactorY = rangeDeltaY / (domainY[1] - domainY[0]);

          if (scalingFactorX < scalingFactorY) {
            const fromMidY = (domainY[1] - domainY[0]) / 2 * scalingFactorX;
            const newRangeY = [midY - fromMidY, midY + fromMidY];

            if (rangeY[0] > rangeY[1]) newRangeY.reverse();

            scaleX.range(rangeX);
            scaleY.range(newRangeY);
          }

          if (scalingFactorX >= scalingFactorY) {
            const fromMidX = (domainX[1] - domainX[0]) / 2 * scalingFactorY;
            const newRangeX = [midX - fromMidX, midX + fromMidX];

            scaleX.range(newRangeX);
            scaleY.range(rangeY);
          }
        }
      }

      const dummyScaleObject = {
        scaleX: { range: setRangeX, copy: function () { return this } },
        scaleY: { range: setRangeY, copy: function () { return this } }
      };

      return dummyScaleObject
    }

    function createPanHandler (zoomIdentity, options) {
      const dimension = options.dimension || 'both';
      const setZoomIdentity = options.setZoomIdentity || emptyFunc;
      const setBlockReindexing = options.setBlockReindexing || emptyFunc;

      let panning = false;
      let previousCoordinates;

      const start = function (event) {
        setBlockReindexing(true);
        panning = true;
        previousCoordinates = event.screenCoordinates;
      };

      const handler = function (event) {
        if (!panning) return

        const currentCoordinates = event.screenCoordinates;
        const delta = calculateDelta(previousCoordinates, currentCoordinates);
        previousCoordinates = currentCoordinates;

        const extentX = options.extentX;
        const extentY = options.extentY;

        // stops panning if past extents X and Y
        const tempX = zoomIdentity.x - delta.x;
        const tempY = zoomIdentity.y - delta.y;

        if (tempX <= extentX[1] && tempX >= extentX[0]) {
          zoomIdentity.x -= delta.x;
        }

        if (tempY <= extentY[1] && tempY >= extentY[0]) {
          zoomIdentity.y -= delta.y;
        }

        if (dimension === 'x') zoomIdentity.y = 0;
        if (dimension === 'y') zoomIdentity.x = 0;

        setZoomIdentity(zoomIdentity);
      };

      const end = function (event) {
        setBlockReindexing(false);
        panning = false;
      };

      // Resets zoomId to original zoomId (x, y, k)
      const reset = function () {
        zoomIdentity.x = 0;
        zoomIdentity.y = 0;

        setZoomIdentity(zoomIdentity);
      };

      return {
        handlers: {
          onMousedown: start,
          onMousemove: handler,
          onMouseup: end
        },

        reset
      }
    }

    function calculateDelta (previousCoordinates, currentCoordinates) {
      return {
        x: previousCoordinates.x - currentCoordinates.x,
        y: previousCoordinates.y - currentCoordinates.y
      }
    }

    const emptyFunc = () => {};

    // export default function createZoomHandler (zoomId, minZoom, maxZoom, extents, step, centerPt) {
    function createZoomHandler (
      zoomIdentity,
      {
        setZoomIdentity = () => {},
        minZoom, maxZoom,
        extentX, extentY,
        step, center: centerPt,
        dimension = 'both'
      }
    ) {
      const zoom = function (event) {
        // Calculate new zoom factor based on step
        const delta = event.wheelDelta * step;
        const tempK = zoomIdentity.kx - delta;

        // Offsetting only takes effect when k is within range to prevent jitter
        if (tempK >= minZoom && tempK <= maxZoom) {
          if (dimension === 'both') {
            zoomIdentity.kx -= delta;
            zoomIdentity.ky -= delta;
          }

          if (dimension === 'x') {
            zoomIdentity.kx -= delta;
            zoomIdentity.ky = 1;
          }

          if (dimension === 'y') {
            zoomIdentity.kx = 1;
            zoomIdentity.ky -= delta;
          }

          // stops zooming if past extents X and Y
          const offsetX = -(event.screenCoordinates.x * delta);
          const offsetY = -(event.screenCoordinates.y * delta);

          const tempX = zoomIdentity.x - offsetX;
          const tempY = zoomIdentity.y - offsetY;

          // Make sure the viewport stays on the cursor area when zooming in/out
          if ((tempX <= extentX[1] && tempX >= extentX[0]) && (tempY <= extentY[1] && tempY >= extentY[0])) {
            zoomIdentity.x -= dimension !== 'y' ? offsetX : 0;
            zoomIdentity.y -= dimension !== 'x' ? offsetY : 0;
          } else {
            zoomIdentity.x += dimension !== 'y' ? offsetX : 0;
            zoomIdentity.y += dimension !== 'x' ? offsetY : 0;
          }
        }

        setZoomIdentity(zoomIdentity);
      };

      const reset = function () {
        zoomIdentity.x = 0;
        zoomIdentity.y = 0;
        zoomIdentity.kx = 1;
        zoomIdentity.ky = 1;

        setZoomIdentity(zoomIdentity);
      };

      // Brings viewport back to specified center point
      const center = function () {
        zoomIdentity.x = centerPt.x;
        zoomIdentity.y = centerPt.y;

        setZoomIdentity(zoomIdentity);
      };

      return {
        handlers: {
          onWheel: zoom
        },

        reset,
        center
      }
    }

    // There are three ways of setting the position of the axis, in order of precedence
    // 1. vjust with 'bottom', 'center' or 'top'
    // 2. vjust with a number (relative position within content of section)
    // 3. x1, x2, y1, y2 props with positioning in data coords

    function createPosYCoords (vjust, yRange, orient, height, offset, titleFontSize, flip) {
      let y1;
      let y2;
      const y1Range = yRange[0];
      const y2Range = yRange[1];
      const heightRatio = orient === 'vertical' ? 0.3 : 0.1;
      const addTitleSize = titleFontSize;
      height = (height === 0 || height === undefined) ? (y2Range - y1Range) * heightRatio : height;

      // if (parentPadding !== undefined) {
      //   y1Range = !flip ? y1Range - parentPadding.top : y1Range - parentPadding.bottom
      //   y2Range = !flip ? y2Range + parentPadding.bottom : y2Range + parentPadding.top
      // }

      if (vjust === 'top') {
        y1 = y1Range + offset + addTitleSize;
        y2 = y1Range + height + offset + addTitleSize;
      }
      if (vjust === 'center' || vjust === 'centre') {
        const yCoord = (y2Range - y1Range) * 0.5 + y1Range;
        y1 = yCoord - height / 2 + offset + addTitleSize;
        y2 = yCoord + height / 2 + offset + addTitleSize;
      }

      if (vjust === 'bottom') {
        y1 = y2Range - height + offset - addTitleSize;
        y2 = y2Range + offset - addTitleSize;
      }

      if (!isNaN(vjust) && (vjust <= 1 && vjust >= -1)) {
        const yCoord = (y2Range - y1Range) * vjust + y1Range;
        y1 = yCoord + offset - addTitleSize;
        y2 = yCoord + height + offset - addTitleSize;
      }

      if (!['top', 'bottom', 'center'].includes(vjust) && y1 === undefined) {
        throw Error('Please specify either `top`, `center`, `bottom` or a number in the range [-1, 1] for `vjust`')
      }

      return { y1, y2, height }
    }

    function createPosXCoords (hjust, xRange, orient, width, offset, labelFontSize, flip) {
      let x1;
      let x2;
      const x1Range = xRange[0];
      const x2Range = xRange[1];
      const widthRatio = orient === 'vertical' ? 0.1 : 0.3;
      width = width === 0 ? (x2Range - x1Range) * widthRatio : width;

      // if (parentPadding !== undefined) {
      //   x1Range = !flip ? x1Range - parentPadding.top : x1Range - parentPadding.bottom
      //   x2Range = !flip ? x2Range + parentPadding.bottom : x2Range + parentPadding.top
      // }

      if (hjust === 'left') {
        x1 = x1Range + offset + labelFontSize * 1.05;
        x2 = x1Range + width + offset + labelFontSize * 1.05;
      }

      if (hjust === 'center' || hjust === 'centre') {
        const xCoord = (x2Range - x1Range) * 0.5 + x1Range;
        x1 = xCoord - width / 2 + offset;
        x2 = xCoord + width / 2 + offset;
      }

      if (hjust === 'right') {
        x1 = x2Range - width + offset - labelFontSize * 1.05;
        x2 = x2Range + offset - labelFontSize * 1.05;
      }

      if (!isNaN(hjust)) {
        const xCoord = (x2Range - x1Range) * hjust + x1Range;
        x1 = xCoord - labelFontSize * 1.05;
        x2 = xCoord + width - labelFontSize * 1.05;
      }

      if (!['left', 'center', 'right'].includes(hjust) && x1 === undefined) {
        throw Error('Please specify either `left`, `center`, `right` or a number from 0 to 1 for `vjust`')
      }

      return { x1, x2, width }
    }

    function createTitleXCoord$3 (hjust, xCoords, x, offset, addTitleSize, addLabelSize, orient, padding) {
      if (x) {
        return () => x
      }

      const x1 = xCoords.x1;
      const x2 = xCoords.x2;
      let justification;

      if (hjust === 'center' || hjust === 'centre') {
        justification = 0.5;
      }
      if (hjust === 'left') {
        justification = 0;
      }
      if (hjust === 'right') {
        justification = 1;
      }

      if (!isNaN(hjust)) {
        justification = hjust;
      }
      if (justification === undefined) {
        justification = 0.5;
      }

      if (!['left', 'center', 'right'].includes(hjust) && isNaN(hjust)) {
        throw Error('Please specify either `left`, `center`, `right` or a number from 0 to 1 for `hjust`')
      }

      return x1 + Math.abs(x1 - x2) * justification + padding + offset
    }

    function createTitleYCoord$3 (vjust, yCoords, y, offset, addTitleSize, addLabelSize, orient, padding) {
      if (y) {
        return () => y
      }

      const y1 = yCoords.y1;
      const y2 = yCoords.y2;
      let justification;
      let addFontSize;

      if (vjust === 'center') {
        justification = 0.5;
        addFontSize = 0;
      }
      if (vjust === 'bottom') {
        justification = 1;
        addFontSize = addTitleSize / 2;
      }
      if (vjust === 'top') {
        justification = 0;
        addFontSize = -addTitleSize / 2;
      }

      if (!isNaN(vjust)) {
        justification = vjust;
        addFontSize = 0;
      }

      if (justification === undefined) {
        justification = 0.5;
        addFontSize = 0;
      }

      if (!['center', 'bottom', 'top'].includes(vjust) && isNaN(vjust)) {
        throw Error('Please specify either `top`, `center`, `bottom` or a number for `vjust`')
      }

      return y1 + Math.abs(y1 - y2) * justification + addFontSize + padding + offset
    }

    var e10$1 = Math.sqrt(50),
        e5$1 = Math.sqrt(10),
        e2$1 = Math.sqrt(2);

    function arrayTicks(start, stop, count) {
      var reverse,
          i = -1,
          n,
          ticks,
          step;

      stop = +stop, start = +start, count = +count;
      if (start === stop && count > 0) return [start];
      if (reverse = stop < start) n = start, start = stop, stop = n;
      if ((step = tickIncrement$1(start, stop, count)) === 0 || !isFinite(step)) return [];

      if (step > 0) {
        start = Math.ceil(start / step);
        stop = Math.floor(stop / step);
        ticks = new Array(n = Math.ceil(stop - start + 1));
        while (++i < n) ticks[i] = (start + i) * step;
      } else {
        start = Math.floor(start * step);
        stop = Math.ceil(stop * step);
        ticks = new Array(n = Math.ceil(start - stop + 1));
        while (++i < n) ticks[i] = (start - i) / step;
      }

      if (reverse) ticks.reverse();

      return ticks;
    }

    function tickIncrement$1(start, stop, count) {
      var step = (stop - start) / Math.max(0, count),
          power = Math.floor(Math.log(step) / Math.LN10),
          error = step / Math.pow(10, power);
      return power >= 0
          ? (error >= e10$1 ? 10 : error >= e5$1 ? 5 : error >= e2$1 ? 2 : 1) * Math.pow(10, power)
          : -Math.pow(10, -power) / (error >= e10$1 ? 10 : error >= e5$1 ? 5 : error >= e2$1 ? 2 : 1);
    }

    function max(values, valueof) {
      let max;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null
              && (max < value || (max === undefined && value >= value))) {
            max = value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (max < value || (max === undefined && value >= value))) {
            max = value;
          }
        }
      }
      return max;
    }

    function mean(values, valueof) {
      let count = 0;
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            ++count, sum += value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            ++count, sum += value;
          }
        }
      }
      if (count) return sum / count;
    }

    // if x1, x2, y1, y2 are values, functions => return true
    // if x1, x2, y1, y2 are all undefined => return false
    // if neither are fulfilled => raise error
    function isValid$1 (x1, x2, y1, y2) {
      let validVariables = 0;

      for (const value in [x1, x2, y1, y2]) {
        if (checkValidType$1(value)) {
          validVariables += 1;
        }
      }

      if (validVariables < 4) {
        throw new Error('Couldn\'t construct legend because of invalid x1, x2, y1, y2 inputs.')
      } else if (validVariables === 4 && x1 === undefined && x2 === undefined && y1 === undefined && y2 === undefined) {
        return false
      }

      return true
    }

    function checkValidType$1 (value) {
      if (!isNaN(value) || {}.toString.call(value) === '[object Function]' || value === undefined) {
        return true
      }

      return false
    }

    function getTicks (scale, labelCount, labelExtra, firstLabel) {
      let tickValues;

      // Bins
      if (Array.isArray(scale[0]) && scale.length > 0) {
        tickValues = [];
        tickValues.push(scale[0][0]);

        for (let i = 0; i < scale.length; i++) {
          tickValues.push(scale[i][1]);
        }
      // Array
      } else if (Array.isArray(scale)) {
        if (scale[0].constructor === Number) {
          tickValues = arrayTicks(...scale, labelCount);

          if (firstLabel !== undefined) {
            if (labelExtra && tickValues[0] !== firstLabel) {
              tickValues.unshift(firstLabel);
            }
          }
        } else {
          tickValues = scale;
        }
      } else if ('ticks' in scale) {
        tickValues = scale.ticks(labelCount);
      } else if ('domain' in scale) {
        tickValues = scale.domain();
      } else {
        throw new Error(`Couldn't construct legend. Please provide 'tickValues' or a scale with
        either a 'ticks' or a 'domain' method.`)
      }

      if (labelExtra && 'domain' in scale && tickValues[0] !== scale.domain()[0]) {
        tickValues.unshift(scale.domain()[0]);
      }

      return tickValues
    }

    function getTickPositions$1 (tickValuesArray, domain, tickExtra, coordinates, flip, orient, padding, useScale) {
      let tickPositions;

      // Bins
      if (useScale) {
        let posScale;
        const locRange = orient === 'vertical' ? [coordinates.y1, coordinates.y2] : [coordinates.x1, coordinates.x2];

        if (!flip) {
          posScale = linear$1().domain(domain).range(locRange);
        } else {
          posScale = linear$1().domain(domain).range(locRange.reverse());
        }

        tickPositions = tickValuesArray.map((value, i) => {
          return posScale(value) + padding
        });

      // Arrays
      // equal interval: works on both vertical and horizontal orientations
      } else if (Array.isArray(domain)) {
        const interval = orient === 'vertical' ? coordinates.height / (tickValuesArray.length) : coordinates.width / (tickValuesArray.length);
        const firstVal = orient === 'vertical' ? coordinates.y1 : coordinates.x1;
        tickValuesArray = flip ? tickValuesArray.reverse() : tickValuesArray;

        tickPositions = tickValuesArray.map((value, i) => {
          return firstVal + interval * (i + 0.5) + padding
        });
      } else {
        throw new Error(`Couldn't construct legend. Please provide 'tickValues' or a scale with
        either a 'ticks' or a 'domain' method.`)
      }

      if (tickExtra && tickPositions[0] !== domain[0] && useScale) {
        tickPositions.unshift(domain[0]);
      }

      return tickPositions
    }

    function getFormat$1 (labelFormat, scale, numberOfTicks) {
      if (labelFormat) return labelFormat
      if ('tickFormat' in scale) return scale.tickFormat(numberOfTicks)

      return x => x
    }

    function getColorGeoms (tickMappable, orient, scale, tickLabelText, tickLabelPositions, tickAlign, labelFontSize, colorBarHeight, colorBarWidth, flipLabels, flip, xCoords, yCoords, useScale) {
      let colorXStartCoords = [];
      let colorXEndCoords = [];
      let colorYStartCoords = [];
      let colorYEndCoords = [];

      if (orient === 'vertical') {
        // x coords
        colorXStartCoords = tickLabelText.map(i => {
          if (flipLabels) {
            return tickAlign - labelFontSize - colorBarWidth * xCoords.width
          } else {
            return tickAlign + labelFontSize
          }
        });

        colorXEndCoords = tickLabelText.map((value, i) => {
          if (flipLabels) {
            return tickAlign - labelFontSize
          } else {
            return tickAlign + labelFontSize + colorBarWidth * xCoords.width
          }
        });

        // y coords
        // Non-uniform distribution along linear scale
        if (useScale) {
          colorYStartCoords = tickLabelText.map((value, i) => {
            return tickLabelPositions[i]
          });

          colorYEndCoords = JSON.parse(JSON.stringify(colorYStartCoords));

          colorXStartCoords.pop();
          colorXEndCoords.pop();
          colorYStartCoords.pop();
          colorYEndCoords.shift();
          tickMappable.pop();

        // Arrays or one tick to one box
        } else if (Array.isArray(scale) || ('ticks' in scale || 'domain' in scale)) {
          const interval = Math.abs(yCoords.y2 - yCoords.y1) / tickMappable.length;
          let start = yCoords.y1;
          colorYStartCoords = tickMappable.map((value, i) => {
            if (i > 0) {
              start += interval;
              colorYEndCoords.push(start);
            }
            return start
          });

          colorYEndCoords.push(start + interval);
        }
      } else if (orient === 'horizontal') {
        const coordsLength = Math.abs(yCoords.y2 - yCoords.y1);

        colorYStartCoords = tickLabelText.map(i => {
          if (flipLabels) {
            return tickAlign + labelFontSize
          } else {
            return tickAlign - labelFontSize
          }
        });

        colorYEndCoords = tickLabelText.map((value, i) => {
          if (flipLabels) {
            return tickAlign + labelFontSize + colorBarHeight * yCoords.height
          } else {
            return tickAlign - labelFontSize - colorBarHeight * yCoords.height
          }
        });

        tickLabelText.map((value, i) => {
          if (flipLabels) {
            return yCoords.y2
          } else {
            return yCoords.y1 + colorBarHeight * coordsLength
          }
        });

        // Bins: follows tick location
        // Non-uniform distribution along linear scale
        if (useScale) {
          colorXStartCoords = tickLabelText.map((value, i) => {
            if (i === 0) {
              return tickLabelPositions[i] - 0.02
            }
            return tickLabelPositions[i]
          });

          colorXEndCoords = tickLabelText.map((value, i) => {
            if (i === tickLabelText.length - 1) {
              return tickLabelPositions[i] + 0.02
            }
            return tickLabelPositions[i]
          });

          colorYStartCoords.pop();
          colorYEndCoords.pop();
          colorXStartCoords.pop();
          colorXEndCoords.shift();
          tickMappable.pop();

        // One to one
        } else if (Array.isArray(scale) || ('ticks' in scale || 'domain' in scale)) {
          const interval = Math.abs(xCoords.x2 - xCoords.x1) / tickMappable.length;
          let start = xCoords.x1;
          colorXStartCoords = tickMappable.map((value, i) => {
            if (i > 0) {
              start += interval;
              colorXEndCoords.push(start);
            }
            return start
          });

          colorXEndCoords.push(start + interval);
        }
      }

      return { colorXStartCoords, colorXEndCoords, colorYStartCoords, colorYEndCoords }
    }

    function getGradientGeoms (tickMappable, orient, scale, colorBarHeight, colorBarWidth, flipLabels, flip, xCoords, yCoords, tickAlign, labelFontSize, labels) {
      let offsets;
      let gradX;
      let gradY;
      let x1;
      let x2;
      let y1;
      let y2;

      if (orient === 'vertical') {
        gradX = { x1: '0%', x2: '0%' };
        gradY = flip ? { y1: '100%', y2: '0%' } : { y1: '0%', y2: '100%' };
        y1 = yCoords.y1;
        y2 = yCoords.y2;

        // Color bar dimensions
        if (flipLabels) {
          x1 = tickAlign - labelFontSize - colorBarWidth * xCoords.width;
          x2 = tickAlign - labelFontSize;
        } else {
          x1 = tickAlign + labelFontSize;
          x2 = tickAlign + labelFontSize + colorBarWidth * xCoords.width;
        }
      } else if (orient === 'horizontal') {
        gradX = flip ? { x1: '100%', x2: '0%' } : { x1: '0%', x2: '100%' };
        gradY = { y1: '0%', y2: '0%' };
        x1 = xCoords.x1;
        x2 = xCoords.x2;

        // Color bar dimensions
        if (flipLabels) {
          y1 = tickAlign + labelFontSize;
          y2 = tickAlign + colorBarHeight * yCoords.height + labelFontSize;
        } else {
          y1 = tickAlign - colorBarHeight * yCoords.height - labelFontSize;
          y2 = tickAlign - labelFontSize;
        }
      }

      const rectCoords = { x1, x2, y1, y2 };

      // Gradient bar color offset assignment
      // Bins
      if (labels) {
        let posScale;
        if (!flip) {
          posScale = linear$1().domain(scale.domain()).range([0, 1]);
        } else {
          posScale = linear$1().domain(scale.domain()).range([1, 0]);
        }

        offsets = labels.map((value, i) => {
          if (!flip) {
            return posScale(value)
          } else {
            return 1 - posScale(value)
          }
        });

      // Array or scale
      // Fix
      } else if (labels === undefined) {
        const interval = 1 / tickMappable.length;

        offsets = tickMappable.map((value, i) => {
          return interval * (i + 0.5)
        });
      } else {
        throw new Error(`Couldn't construct legend. Please provide 'tickValues' or a scale with
        either a 'ticks' or a 'domain' method.`)
      }

      return { offsets, gradX, gradY, rectCoords }
    }

    /* src/components/Guides/Legends/DiscreteLegend.svelte generated by Svelte v3.15.0 */

    const { Error: Error_1 } = globals;

    const file$9 = "src/components/Guides/Legends/DiscreteLegend.svelte";

    // (387:2) {#if title.length > 0}
    function create_if_block$7(ctx) {
    	let current;

    	const label = new Label({
    			props: {
    				x: ctx.func_6,
    				y: ctx.func_7,
    				text: ctx.title,
    				fontFamily: ctx.titleFont,
    				fontSize: ctx.titleFontSize,
    				fontWeight: ctx.titleFontWeight,
    				rotation: ctx.titleRotation,
    				anchorPoint: ctx.titleAnchorPoint,
    				opacity: ctx.titleOpacity,
    				fill: ctx.titleColor,
    				transition: ctx.transition,
    				zoomIdentity: ctx.zoomIdentity
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(label.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(label, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const label_changes = {};
    			if (changed.titleX) label_changes.x = ctx.func_6;
    			if (changed.titleY) label_changes.y = ctx.func_7;
    			if (changed.title) label_changes.text = ctx.title;
    			if (changed.titleFont) label_changes.fontFamily = ctx.titleFont;
    			if (changed.titleFontSize) label_changes.fontSize = ctx.titleFontSize;
    			if (changed.titleFontWeight) label_changes.fontWeight = ctx.titleFontWeight;
    			if (changed.titleRotation) label_changes.rotation = ctx.titleRotation;
    			if (changed.titleAnchorPoint) label_changes.anchorPoint = ctx.titleAnchorPoint;
    			if (changed.titleOpacity) label_changes.opacity = ctx.titleOpacity;
    			if (changed.titleColor) label_changes.fill = ctx.titleColor;
    			if (changed.transition) label_changes.transition = ctx.transition;
    			if (changed.zoomIdentity) label_changes.zoomIdentity = ctx.zoomIdentity;
    			label.$set(label_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(label, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(387:2) {#if title.length > 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let g;
    	let current;

    	const rectanglelayer = new RectangleLayer({
    			props: {
    				x1: ctx.func,
    				x2: ctx.func_1,
    				y1: ctx.func_2,
    				y2: ctx.func_3,
    				fill: ctx.tickColors,
    				fillOpacity: ctx.tickOpacities,
    				transition: ctx.transition,
    				stroke: ctx.stroke,
    				strokeWidth: ctx.strokeWidth,
    				zoomIdentity: ctx.zoomIdentity
    			},
    			$$inline: true
    		});

    	const labellayer = new LabelLayer({
    			props: {
    				x: ctx.func_4,
    				y: ctx.func_5,
    				text: ctx.tickLabelText,
    				anchorPoint: ctx.labelAnchorPoint,
    				rotation: ctx.labelRotate,
    				fontFamily: ctx.labelFont,
    				fontSize: ctx.labelFontSize,
    				fontWeight: ctx.labelFontWeight,
    				opacity: ctx.labelOpacity,
    				fill: ctx.labelColor,
    				transition: ctx.transition,
    				zoomIdentity: ctx.zoomIdentity
    			},
    			$$inline: true
    		});

    	let if_block = ctx.title.length > 0 && create_if_block$7(ctx);

    	const block = {
    		c: function create() {
    			g = svg_element("g");
    			create_component(rectanglelayer.$$.fragment);
    			create_component(labellayer.$$.fragment);
    			if (if_block) if_block.c();
    			attr_dev(g, "class", "discrete-legend");
    			add_location(g, file$9, 357, 0, 11420);
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);
    			mount_component(rectanglelayer, g, null);
    			mount_component(labellayer, g, null);
    			if (if_block) if_block.m(g, null);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const rectanglelayer_changes = {};
    			if (changed.colorXStartCoords) rectanglelayer_changes.x1 = ctx.func;
    			if (changed.colorXEndCoords) rectanglelayer_changes.x2 = ctx.func_1;
    			if (changed.colorYStartCoords) rectanglelayer_changes.y1 = ctx.func_2;
    			if (changed.colorYEndCoords) rectanglelayer_changes.y2 = ctx.func_3;
    			if (changed.tickColors) rectanglelayer_changes.fill = ctx.tickColors;
    			if (changed.tickOpacities) rectanglelayer_changes.fillOpacity = ctx.tickOpacities;
    			if (changed.transition) rectanglelayer_changes.transition = ctx.transition;
    			if (changed.stroke) rectanglelayer_changes.stroke = ctx.stroke;
    			if (changed.strokeWidth) rectanglelayer_changes.strokeWidth = ctx.strokeWidth;
    			if (changed.zoomIdentity) rectanglelayer_changes.zoomIdentity = ctx.zoomIdentity;
    			rectanglelayer.$set(rectanglelayer_changes);
    			const labellayer_changes = {};
    			if (changed.tickLabelXCoords) labellayer_changes.x = ctx.func_4;
    			if (changed.tickLabelYCoords) labellayer_changes.y = ctx.func_5;
    			if (changed.tickLabelText) labellayer_changes.text = ctx.tickLabelText;
    			if (changed.labelAnchorPoint) labellayer_changes.anchorPoint = ctx.labelAnchorPoint;
    			if (changed.labelRotate) labellayer_changes.rotation = ctx.labelRotate;
    			if (changed.labelFont) labellayer_changes.fontFamily = ctx.labelFont;
    			if (changed.labelFontSize) labellayer_changes.fontSize = ctx.labelFontSize;
    			if (changed.labelFontWeight) labellayer_changes.fontWeight = ctx.labelFontWeight;
    			if (changed.labelOpacity) labellayer_changes.opacity = ctx.labelOpacity;
    			if (changed.labelColor) labellayer_changes.fill = ctx.labelColor;
    			if (changed.transition) labellayer_changes.transition = ctx.transition;
    			if (changed.zoomIdentity) labellayer_changes.zoomIdentity = ctx.zoomIdentity;
    			labellayer.$set(labellayer_changes);

    			if (ctx.title.length > 0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$7(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(g, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rectanglelayer.$$.fragment, local);
    			transition_in(labellayer.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rectanglelayer.$$.fragment, local);
    			transition_out(labellayer.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    			destroy_component(rectanglelayer);
    			destroy_component(labellayer);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let $sectionContext;
    	let { x1 = undefined } = $$props;
    	let { x2 = undefined } = $$props;
    	let { y1 = undefined } = $$props;
    	let { y2 = undefined } = $$props;
    	let { orient = "vertical" } = $$props;
    	let { vjust = "center" } = $$props;
    	let { height = undefined } = $$props;
    	let { hjust = "left" } = $$props;
    	let { width = 0 } = $$props;
    	let { xOffset = 0 } = $$props;
    	let { yOffset = 0 } = $$props;
    	let { usePadding = false } = $$props;
    	let { flip = false } = $$props;
    	let { flipLabels = false } = $$props;
    	let { stroke = "none" } = $$props;
    	let { strokeWidth = 2 } = $$props;
    	let { fill = undefined } = $$props;
    	let { fillOpacity = undefined } = $$props;
    	let { labels = undefined } = $$props;
    	let { labelFormat = undefined } = $$props;
    	let { labelRotate = 0 } = $$props;
    	let { labelX = undefined } = $$props;
    	let { labelY = undefined } = $$props;
    	let { labelFont = "Helvetica" } = $$props;
    	let { labelFontSize = 10 } = $$props;
    	let { labelFontWeight = "normal" } = $$props;
    	let { labelOpacity = 1 } = $$props;
    	let { labelColor = "black" } = $$props;
    	let { labelAnchorPoint = "center" } = $$props;
    	let { labelCount = 10 } = $$props;
    	let { labelExtra = false } = $$props;
    	let { firstLabel = undefined } = $$props;
    	let { format = undefined } = $$props;
    	let { labelPaddingY = 0 } = $$props;
    	let { labelPaddingX = 0 } = $$props;
    	let { titleHjust = "center" } = $$props;
    	let { titleXOffset = 0 } = $$props;
    	let { titleX = undefined } = $$props;
    	let { titleVjust = "top" } = $$props;
    	let { titleYOffset = 0 } = $$props;
    	let { titleY = undefined } = $$props;
    	let { title = "Legend" } = $$props;
    	let { titleColor = "black" } = $$props;
    	let { titleFont = "Helvetica" } = $$props;
    	let { titleFontSize = 12 } = $$props;
    	let { titleFontWeight = "bold" } = $$props;
    	let { titleOpacity = 1 } = $$props;
    	let { titleRotation = 0 } = $$props;
    	let { titleAnchorPoint = "t" } = $$props;
    	let { titlePaddingX = 0 } = $$props;
    	let { titlePaddingY = -3 } = $$props;
    	let { transition = undefined } = $$props;
    	let { zoomIdentity = undefined } = $$props;
    	const sectionContext = subscribe$2();
    	validate_store(sectionContext, "sectionContext");
    	component_subscribe($$self, sectionContext, value => $$invalidate("$sectionContext", $sectionContext = value));
    	const graphicContext = subscribe$1();
    	const zoomContext = subscribe$6();
    	let scale;
    	let scaleDomain;
    	let useScale = false;
    	let tickLabelText;
    	let tickLabelPositions;
    	let tickLabelXCoords;
    	let tickLabelYCoords;
    	let tickColors;
    	let tickOpacities;
    	let tickAlign;
    	let _padding;
    	let rangeCoordsX;
    	let rangeCoordsY;
    	let xRange = $sectionContext.scaleX.range();
    	let yRange = $sectionContext.scaleY.range();
    	let colorXStartCoords;
    	let colorXEndCoords;
    	let colorYStartCoords;
    	let colorYEndCoords;
    	let colorGeoms;
    	let colorBarHeight;
    	let colorBarWidth;
    	let posScaleY;
    	let xCoords;
    	let yCoords;
    	let addTitleSize;

    	const writable_props = [
    		"x1",
    		"x2",
    		"y1",
    		"y2",
    		"orient",
    		"vjust",
    		"height",
    		"hjust",
    		"width",
    		"xOffset",
    		"yOffset",
    		"usePadding",
    		"flip",
    		"flipLabels",
    		"stroke",
    		"strokeWidth",
    		"fill",
    		"fillOpacity",
    		"labels",
    		"labelFormat",
    		"labelRotate",
    		"labelX",
    		"labelY",
    		"labelFont",
    		"labelFontSize",
    		"labelFontWeight",
    		"labelOpacity",
    		"labelColor",
    		"labelAnchorPoint",
    		"labelCount",
    		"labelExtra",
    		"firstLabel",
    		"format",
    		"labelPaddingY",
    		"labelPaddingX",
    		"titleHjust",
    		"titleXOffset",
    		"titleX",
    		"titleVjust",
    		"titleYOffset",
    		"titleY",
    		"title",
    		"titleColor",
    		"titleFont",
    		"titleFontSize",
    		"titleFontWeight",
    		"titleOpacity",
    		"titleRotation",
    		"titleAnchorPoint",
    		"titlePaddingX",
    		"titlePaddingY",
    		"transition",
    		"zoomIdentity"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DiscreteLegend> was created with unknown prop '${key}'`);
    	});

    	const func = () => {
    		return colorXStartCoords;
    	};

    	const func_1 = () => {
    		return colorXEndCoords;
    	};

    	const func_2 = () => {
    		return colorYStartCoords;
    	};

    	const func_3 = () => {
    		return colorYEndCoords;
    	};

    	const func_4 = () => {
    		return tickLabelXCoords;
    	};

    	const func_5 = () => {
    		return tickLabelYCoords;
    	};

    	const func_6 = () => {
    		return titleX;
    	};

    	const func_7 = () => {
    		return titleY;
    	};

    	$$self.$set = $$props => {
    		if ("x1" in $$props) $$invalidate("x1", x1 = $$props.x1);
    		if ("x2" in $$props) $$invalidate("x2", x2 = $$props.x2);
    		if ("y1" in $$props) $$invalidate("y1", y1 = $$props.y1);
    		if ("y2" in $$props) $$invalidate("y2", y2 = $$props.y2);
    		if ("orient" in $$props) $$invalidate("orient", orient = $$props.orient);
    		if ("vjust" in $$props) $$invalidate("vjust", vjust = $$props.vjust);
    		if ("height" in $$props) $$invalidate("height", height = $$props.height);
    		if ("hjust" in $$props) $$invalidate("hjust", hjust = $$props.hjust);
    		if ("width" in $$props) $$invalidate("width", width = $$props.width);
    		if ("xOffset" in $$props) $$invalidate("xOffset", xOffset = $$props.xOffset);
    		if ("yOffset" in $$props) $$invalidate("yOffset", yOffset = $$props.yOffset);
    		if ("usePadding" in $$props) $$invalidate("usePadding", usePadding = $$props.usePadding);
    		if ("flip" in $$props) $$invalidate("flip", flip = $$props.flip);
    		if ("flipLabels" in $$props) $$invalidate("flipLabels", flipLabels = $$props.flipLabels);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("labels" in $$props) $$invalidate("labels", labels = $$props.labels);
    		if ("labelFormat" in $$props) $$invalidate("labelFormat", labelFormat = $$props.labelFormat);
    		if ("labelRotate" in $$props) $$invalidate("labelRotate", labelRotate = $$props.labelRotate);
    		if ("labelX" in $$props) $$invalidate("labelX", labelX = $$props.labelX);
    		if ("labelY" in $$props) $$invalidate("labelY", labelY = $$props.labelY);
    		if ("labelFont" in $$props) $$invalidate("labelFont", labelFont = $$props.labelFont);
    		if ("labelFontSize" in $$props) $$invalidate("labelFontSize", labelFontSize = $$props.labelFontSize);
    		if ("labelFontWeight" in $$props) $$invalidate("labelFontWeight", labelFontWeight = $$props.labelFontWeight);
    		if ("labelOpacity" in $$props) $$invalidate("labelOpacity", labelOpacity = $$props.labelOpacity);
    		if ("labelColor" in $$props) $$invalidate("labelColor", labelColor = $$props.labelColor);
    		if ("labelAnchorPoint" in $$props) $$invalidate("labelAnchorPoint", labelAnchorPoint = $$props.labelAnchorPoint);
    		if ("labelCount" in $$props) $$invalidate("labelCount", labelCount = $$props.labelCount);
    		if ("labelExtra" in $$props) $$invalidate("labelExtra", labelExtra = $$props.labelExtra);
    		if ("firstLabel" in $$props) $$invalidate("firstLabel", firstLabel = $$props.firstLabel);
    		if ("format" in $$props) $$invalidate("format", format = $$props.format);
    		if ("labelPaddingY" in $$props) $$invalidate("labelPaddingY", labelPaddingY = $$props.labelPaddingY);
    		if ("labelPaddingX" in $$props) $$invalidate("labelPaddingX", labelPaddingX = $$props.labelPaddingX);
    		if ("titleHjust" in $$props) $$invalidate("titleHjust", titleHjust = $$props.titleHjust);
    		if ("titleXOffset" in $$props) $$invalidate("titleXOffset", titleXOffset = $$props.titleXOffset);
    		if ("titleX" in $$props) $$invalidate("titleX", titleX = $$props.titleX);
    		if ("titleVjust" in $$props) $$invalidate("titleVjust", titleVjust = $$props.titleVjust);
    		if ("titleYOffset" in $$props) $$invalidate("titleYOffset", titleYOffset = $$props.titleYOffset);
    		if ("titleY" in $$props) $$invalidate("titleY", titleY = $$props.titleY);
    		if ("title" in $$props) $$invalidate("title", title = $$props.title);
    		if ("titleColor" in $$props) $$invalidate("titleColor", titleColor = $$props.titleColor);
    		if ("titleFont" in $$props) $$invalidate("titleFont", titleFont = $$props.titleFont);
    		if ("titleFontSize" in $$props) $$invalidate("titleFontSize", titleFontSize = $$props.titleFontSize);
    		if ("titleFontWeight" in $$props) $$invalidate("titleFontWeight", titleFontWeight = $$props.titleFontWeight);
    		if ("titleOpacity" in $$props) $$invalidate("titleOpacity", titleOpacity = $$props.titleOpacity);
    		if ("titleRotation" in $$props) $$invalidate("titleRotation", titleRotation = $$props.titleRotation);
    		if ("titleAnchorPoint" in $$props) $$invalidate("titleAnchorPoint", titleAnchorPoint = $$props.titleAnchorPoint);
    		if ("titlePaddingX" in $$props) $$invalidate("titlePaddingX", titlePaddingX = $$props.titlePaddingX);
    		if ("titlePaddingY" in $$props) $$invalidate("titlePaddingY", titlePaddingY = $$props.titlePaddingY);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    	};

    	$$self.$capture_state = () => {
    		return {
    			x1,
    			x2,
    			y1,
    			y2,
    			orient,
    			vjust,
    			height,
    			hjust,
    			width,
    			xOffset,
    			yOffset,
    			usePadding,
    			flip,
    			flipLabels,
    			stroke,
    			strokeWidth,
    			fill,
    			fillOpacity,
    			labels,
    			labelFormat,
    			labelRotate,
    			labelX,
    			labelY,
    			labelFont,
    			labelFontSize,
    			labelFontWeight,
    			labelOpacity,
    			labelColor,
    			labelAnchorPoint,
    			labelCount,
    			labelExtra,
    			firstLabel,
    			format,
    			labelPaddingY,
    			labelPaddingX,
    			titleHjust,
    			titleXOffset,
    			titleX,
    			titleVjust,
    			titleYOffset,
    			titleY,
    			title,
    			titleColor,
    			titleFont,
    			titleFontSize,
    			titleFontWeight,
    			titleOpacity,
    			titleRotation,
    			titleAnchorPoint,
    			titlePaddingX,
    			titlePaddingY,
    			transition,
    			zoomIdentity,
    			scale,
    			scaleDomain,
    			useScale,
    			tickLabelText,
    			tickLabelPositions,
    			tickLabelXCoords,
    			tickLabelYCoords,
    			tickColors,
    			tickOpacities,
    			tickAlign,
    			_padding,
    			rangeCoordsX,
    			rangeCoordsY,
    			xRange,
    			yRange,
    			colorXStartCoords,
    			colorXEndCoords,
    			colorYStartCoords,
    			colorYEndCoords,
    			colorGeoms,
    			colorBarHeight,
    			colorBarWidth,
    			posScaleY,
    			xCoords,
    			yCoords,
    			addTitleSize,
    			$sectionContext
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("x1" in $$props) $$invalidate("x1", x1 = $$props.x1);
    		if ("x2" in $$props) $$invalidate("x2", x2 = $$props.x2);
    		if ("y1" in $$props) $$invalidate("y1", y1 = $$props.y1);
    		if ("y2" in $$props) $$invalidate("y2", y2 = $$props.y2);
    		if ("orient" in $$props) $$invalidate("orient", orient = $$props.orient);
    		if ("vjust" in $$props) $$invalidate("vjust", vjust = $$props.vjust);
    		if ("height" in $$props) $$invalidate("height", height = $$props.height);
    		if ("hjust" in $$props) $$invalidate("hjust", hjust = $$props.hjust);
    		if ("width" in $$props) $$invalidate("width", width = $$props.width);
    		if ("xOffset" in $$props) $$invalidate("xOffset", xOffset = $$props.xOffset);
    		if ("yOffset" in $$props) $$invalidate("yOffset", yOffset = $$props.yOffset);
    		if ("usePadding" in $$props) $$invalidate("usePadding", usePadding = $$props.usePadding);
    		if ("flip" in $$props) $$invalidate("flip", flip = $$props.flip);
    		if ("flipLabels" in $$props) $$invalidate("flipLabels", flipLabels = $$props.flipLabels);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("labels" in $$props) $$invalidate("labels", labels = $$props.labels);
    		if ("labelFormat" in $$props) $$invalidate("labelFormat", labelFormat = $$props.labelFormat);
    		if ("labelRotate" in $$props) $$invalidate("labelRotate", labelRotate = $$props.labelRotate);
    		if ("labelX" in $$props) $$invalidate("labelX", labelX = $$props.labelX);
    		if ("labelY" in $$props) $$invalidate("labelY", labelY = $$props.labelY);
    		if ("labelFont" in $$props) $$invalidate("labelFont", labelFont = $$props.labelFont);
    		if ("labelFontSize" in $$props) $$invalidate("labelFontSize", labelFontSize = $$props.labelFontSize);
    		if ("labelFontWeight" in $$props) $$invalidate("labelFontWeight", labelFontWeight = $$props.labelFontWeight);
    		if ("labelOpacity" in $$props) $$invalidate("labelOpacity", labelOpacity = $$props.labelOpacity);
    		if ("labelColor" in $$props) $$invalidate("labelColor", labelColor = $$props.labelColor);
    		if ("labelAnchorPoint" in $$props) $$invalidate("labelAnchorPoint", labelAnchorPoint = $$props.labelAnchorPoint);
    		if ("labelCount" in $$props) $$invalidate("labelCount", labelCount = $$props.labelCount);
    		if ("labelExtra" in $$props) $$invalidate("labelExtra", labelExtra = $$props.labelExtra);
    		if ("firstLabel" in $$props) $$invalidate("firstLabel", firstLabel = $$props.firstLabel);
    		if ("format" in $$props) $$invalidate("format", format = $$props.format);
    		if ("labelPaddingY" in $$props) $$invalidate("labelPaddingY", labelPaddingY = $$props.labelPaddingY);
    		if ("labelPaddingX" in $$props) $$invalidate("labelPaddingX", labelPaddingX = $$props.labelPaddingX);
    		if ("titleHjust" in $$props) $$invalidate("titleHjust", titleHjust = $$props.titleHjust);
    		if ("titleXOffset" in $$props) $$invalidate("titleXOffset", titleXOffset = $$props.titleXOffset);
    		if ("titleX" in $$props) $$invalidate("titleX", titleX = $$props.titleX);
    		if ("titleVjust" in $$props) $$invalidate("titleVjust", titleVjust = $$props.titleVjust);
    		if ("titleYOffset" in $$props) $$invalidate("titleYOffset", titleYOffset = $$props.titleYOffset);
    		if ("titleY" in $$props) $$invalidate("titleY", titleY = $$props.titleY);
    		if ("title" in $$props) $$invalidate("title", title = $$props.title);
    		if ("titleColor" in $$props) $$invalidate("titleColor", titleColor = $$props.titleColor);
    		if ("titleFont" in $$props) $$invalidate("titleFont", titleFont = $$props.titleFont);
    		if ("titleFontSize" in $$props) $$invalidate("titleFontSize", titleFontSize = $$props.titleFontSize);
    		if ("titleFontWeight" in $$props) $$invalidate("titleFontWeight", titleFontWeight = $$props.titleFontWeight);
    		if ("titleOpacity" in $$props) $$invalidate("titleOpacity", titleOpacity = $$props.titleOpacity);
    		if ("titleRotation" in $$props) $$invalidate("titleRotation", titleRotation = $$props.titleRotation);
    		if ("titleAnchorPoint" in $$props) $$invalidate("titleAnchorPoint", titleAnchorPoint = $$props.titleAnchorPoint);
    		if ("titlePaddingX" in $$props) $$invalidate("titlePaddingX", titlePaddingX = $$props.titlePaddingX);
    		if ("titlePaddingY" in $$props) $$invalidate("titlePaddingY", titlePaddingY = $$props.titlePaddingY);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("scale" in $$props) $$invalidate("scale", scale = $$props.scale);
    		if ("scaleDomain" in $$props) $$invalidate("scaleDomain", scaleDomain = $$props.scaleDomain);
    		if ("useScale" in $$props) $$invalidate("useScale", useScale = $$props.useScale);
    		if ("tickLabelText" in $$props) $$invalidate("tickLabelText", tickLabelText = $$props.tickLabelText);
    		if ("tickLabelPositions" in $$props) $$invalidate("tickLabelPositions", tickLabelPositions = $$props.tickLabelPositions);
    		if ("tickLabelXCoords" in $$props) $$invalidate("tickLabelXCoords", tickLabelXCoords = $$props.tickLabelXCoords);
    		if ("tickLabelYCoords" in $$props) $$invalidate("tickLabelYCoords", tickLabelYCoords = $$props.tickLabelYCoords);
    		if ("tickColors" in $$props) $$invalidate("tickColors", tickColors = $$props.tickColors);
    		if ("tickOpacities" in $$props) $$invalidate("tickOpacities", tickOpacities = $$props.tickOpacities);
    		if ("tickAlign" in $$props) $$invalidate("tickAlign", tickAlign = $$props.tickAlign);
    		if ("_padding" in $$props) $$invalidate("_padding", _padding = $$props._padding);
    		if ("rangeCoordsX" in $$props) $$invalidate("rangeCoordsX", rangeCoordsX = $$props.rangeCoordsX);
    		if ("rangeCoordsY" in $$props) $$invalidate("rangeCoordsY", rangeCoordsY = $$props.rangeCoordsY);
    		if ("xRange" in $$props) $$invalidate("xRange", xRange = $$props.xRange);
    		if ("yRange" in $$props) $$invalidate("yRange", yRange = $$props.yRange);
    		if ("colorXStartCoords" in $$props) $$invalidate("colorXStartCoords", colorXStartCoords = $$props.colorXStartCoords);
    		if ("colorXEndCoords" in $$props) $$invalidate("colorXEndCoords", colorXEndCoords = $$props.colorXEndCoords);
    		if ("colorYStartCoords" in $$props) $$invalidate("colorYStartCoords", colorYStartCoords = $$props.colorYStartCoords);
    		if ("colorYEndCoords" in $$props) $$invalidate("colorYEndCoords", colorYEndCoords = $$props.colorYEndCoords);
    		if ("colorGeoms" in $$props) $$invalidate("colorGeoms", colorGeoms = $$props.colorGeoms);
    		if ("colorBarHeight" in $$props) $$invalidate("colorBarHeight", colorBarHeight = $$props.colorBarHeight);
    		if ("colorBarWidth" in $$props) $$invalidate("colorBarWidth", colorBarWidth = $$props.colorBarWidth);
    		if ("posScaleY" in $$props) posScaleY = $$props.posScaleY;
    		if ("xCoords" in $$props) $$invalidate("xCoords", xCoords = $$props.xCoords);
    		if ("yCoords" in $$props) $$invalidate("yCoords", yCoords = $$props.yCoords);
    		if ("addTitleSize" in $$props) $$invalidate("addTitleSize", addTitleSize = $$props.addTitleSize);
    		if ("$sectionContext" in $$props) sectionContext.set($sectionContext = $$props.$sectionContext);
    	};

    	$$self.$$.update = (changed = { usePadding: 1, $sectionContext: 1, xRange: 1, _padding: 1, yRange: 1, orient: 1, title: 1, titleFontSize: 1, x1: 1, x2: 1, y1: 1, y2: 1, hjust: 1, width: 1, xOffset: 1, labelFontSize: 1, flip: 1, rangeCoordsX: 1, vjust: 1, height: 1, yOffset: 1, addTitleSize: 1, rangeCoordsY: 1, titleX: 1, titleHjust: 1, xCoords: 1, titleXOffset: 1, titlePaddingX: 1, titleY: 1, titleVjust: 1, yCoords: 1, titleYOffset: 1, titlePaddingY: 1, fill: 1, fillOpacity: 1, scale: 1, labels: 1, scaleDomain: 1, labelCount: 1, labelExtra: 1, firstLabel: 1, format: 1, tickLabelText: 1, labelPaddingY: 1, useScale: 1, flipLabels: 1, colorBarHeight: 1, labelX: 1, tickLabelXCoords: 1, labelPaddingX: 1, labelFormat: 1, tickLabelYCoords: 1, colorBarWidth: 1, labelY: 1, tickColors: 1, tickLabelPositions: 1, tickAlign: 1, tickOpacities: 1, colorGeoms: 1 }) => {
    		if (changed.usePadding || changed.$sectionContext || changed.xRange || changed._padding || changed.yRange) {
    			 {
    				if (usePadding === true) {
    					$$invalidate("_padding", _padding = $sectionContext.padding);
    					$$invalidate("xRange", xRange = removePadding(xRange, _padding.left, _padding.right));
    					$$invalidate("yRange", yRange = removePadding(yRange, _padding.top, _padding.bottom));
    				}
    			}
    		}

    		if (changed.orient || changed.title || changed.titleFontSize || changed.x1 || changed.x2 || changed.y1 || changed.y2 || changed.xRange || changed.hjust || changed.width || changed.xOffset || changed.labelFontSize || changed.flip || changed.rangeCoordsX || changed.yRange || changed.vjust || changed.height || changed.yOffset || changed.addTitleSize || changed.rangeCoordsY || changed.$sectionContext) {
    			 {
    				if (!["horizontal", "vertical"].includes(orient)) {
    					throw Error("Invalid input for `orient` property. Please provide either `horizontal` or `vertical` as inputs.");
    				}

    				$$invalidate("addTitleSize", addTitleSize = title.length > 0 ? titleFontSize * 1.5 : 0);

    				if (!isValid$1(x1, x2, y1, y2) && ["horizontal", "vertical"].includes(orient)) {
    					if (sectionContext.flipX) xRange.reverse();
    					$$invalidate("rangeCoordsX", rangeCoordsX = createPosXCoords(hjust, xRange, orient, width, xOffset, labelFontSize));
    					$$invalidate("x1", x1 = rangeCoordsX.x1);
    					$$invalidate("x2", x2 = rangeCoordsX.x2);
    					$$invalidate("width", width = Math.abs(x2 - x1));
    					$$invalidate("xCoords", xCoords = { x1, x2, width });
    					if (sectionContext.flipY) yRange.reverse();
    					$$invalidate("rangeCoordsY", rangeCoordsY = createPosYCoords(vjust, yRange, orient, height, yOffset, addTitleSize));
    					$$invalidate("y1", y1 = rangeCoordsY.y1);
    					$$invalidate("y2", y2 = rangeCoordsY.y2);
    					$$invalidate("height", height = Math.abs(y2 - y1));
    					$$invalidate("yCoords", yCoords = { y1, y2, height });
    				} else {
    					let _x1, _x2, _y1, _y2;

    					if (({}).toString.call(x1) === "[object Function]") {
    						_x1 = x1();
    					} else {
    						_x1 = $sectionContext.scaleX(x1);
    					}

    					if (({}).toString.call(x2) === "[object Function]") {
    						_x2 = x2();
    					} else {
    						_x2 = $sectionContext.scaleX(x2);
    					}

    					if (({}).toString.call(y1) === "[object Function]") {
    						_y1 = y1();
    					} else {
    						_y1 = $sectionContext.scaleY(y1);
    					}

    					if (({}).toString.call(y2) === "[object Function]") {
    						_y2 = y2();
    					} else {
    						_y2 = $sectionContext.scaleY(y2);
    					}

    					$$invalidate("xCoords", xCoords = {
    						x1: _x1,
    						x2: _x2,
    						width: Math.abs(_x2 - _x1)
    					});

    					$$invalidate("yCoords", yCoords = {
    						y1: _y1,
    						y2: _y2,
    						height: Math.abs(_y2 - _y1)
    					});
    				}
    			}
    		}

    		if (changed.title || changed.titleX || changed.titleHjust || changed.xCoords || changed.titleXOffset || changed.addTitleSize || changed.labelFontSize || changed.orient || changed.titlePaddingX || changed.$sectionContext || changed.titleY || changed.titleVjust || changed.yCoords || changed.titleYOffset || changed.titlePaddingY) {
    			 {
    				if (title.length > 0) {
    					if (!titleX && titleX !== 0) {
    						$$invalidate("titleX", titleX = createTitleXCoord$3(titleHjust, xCoords, titleX, titleXOffset, addTitleSize, labelFontSize, orient, titlePaddingX));
    					} else {
    						if (({}).toString.call(titleX) === "[object Function]") {
    							$$invalidate("titleX", titleX = titleX());
    						} else {
    							$$invalidate("titleX", titleX = $sectionContext.scaleX(titleX));
    						}
    					}

    					if (!titleY && titleY !== 0) {
    						$$invalidate("titleY", titleY = createTitleYCoord$3(titleVjust, yCoords, titleY, titleYOffset, addTitleSize, labelFontSize, orient, titlePaddingY));
    					} else {
    						if (({}).toString.call(titleY) === "[object Function]") {
    							$$invalidate("titleY", titleY = titleY());
    						} else {
    							$$invalidate("titleY", titleY = $sectionContext.scaleY(titleY));
    						}
    					}
    				}
    			}
    		}

    		if (changed.fill || changed.fillOpacity || changed.scale) {
    			 {
    				if (fill || fillOpacity) {
    					if (typeof fill === "function") {
    						$$invalidate("scale", scale = fill);
    					}

    					if (typeof fillOpacity === "function") {
    						$$invalidate("scale", scale = fillOpacity);
    					}

    					if (scale) {
    						if (scale.hasOwnProperty("domain")) {
    							if (typeof scale.domain === "function") {
    								$$invalidate("scaleDomain", scaleDomain = scale.domain());
    							} else {
    								$$invalidate("scaleDomain", scaleDomain = scale.domain);
    							}
    						}
    					} else {
    						throw new Error(`Couldn't construct legend. Please provide at least 'fill' or 'fillOpacity'
        with a scale or function that has domain and range properties or methods.`);
    					}
    				} else if (fill === undefined && fillOpacity === undefined) {
    					throw new Error(`Couldn't construct legend. Please provide at least 'fill' or 'fillOpacity'
      with a scale or function that has domain and range properties or methods.`);
    				}
    			}
    		}

    		if (changed.orient) {
    			 {
    				$$invalidate("colorBarHeight", colorBarHeight = orient === "horizontal" ? 0.75 : 1);
    				$$invalidate("colorBarWidth", colorBarWidth = orient === "horizontal" ? 0 : 0.75);
    			}
    		}

    		if (changed.labels || changed.scaleDomain || changed.labelCount || changed.labelExtra || changed.firstLabel || changed.format || changed.tickLabelText || changed.orient || changed.yCoords || changed.flip || changed.labelPaddingY || changed.useScale || changed.flipLabels || changed.x1 || changed.colorBarHeight || changed.xCoords || changed.labelX || changed.tickLabelXCoords || changed.labelPaddingX || changed.labelFormat || changed.tickLabelYCoords || changed.colorBarWidth || changed.labelY) {
    			 {
    				if (labels === undefined) {
    					$$invalidate("tickLabelText", tickLabelText = getTicks(scaleDomain, labelCount, labelExtra, firstLabel));

    					$$invalidate("tickLabelText", tickLabelText = format !== undefined
    					? tickLabelText.map(format)
    					: tickLabelText);
    				} else {
    					$$invalidate("tickLabelText", tickLabelText = format !== undefined ? labels.map(format) : labels);
    					$$invalidate("useScale", useScale = true);
    				}

    				if (orient === "vertical") {
    					$$invalidate("tickLabelYCoords", tickLabelYCoords = getTickPositions$1(tickLabelText, scaleDomain, labelExtra, yCoords, flip, orient, labelPaddingY, useScale));

    					$$invalidate("tickLabelXCoords", tickLabelXCoords = flipLabels
    					? x1 + colorBarHeight * xCoords.width
    					: x1 + (1 - colorBarHeight) * xCoords.width);

    					$$invalidate("tickLabelXCoords", tickLabelXCoords = labelX || tickLabelXCoords);

    					if (labelPaddingX !== undefined) {
    						$$invalidate("tickLabelXCoords", tickLabelXCoords = flipLabels
    						? tickLabelXCoords + labelPaddingX
    						: tickLabelXCoords - labelPaddingX);
    					}

    					$$invalidate("format", format = getFormat$1(labelFormat, scaleDomain, tickLabelYCoords.length));
    				} else if (orient === "horizontal") {
    					$$invalidate("tickLabelXCoords", tickLabelXCoords = getTickPositions$1(tickLabelText, scaleDomain, labelExtra, xCoords, flip, orient, labelPaddingX, useScale));

    					$$invalidate("tickLabelYCoords", tickLabelYCoords = flipLabels
    					? yCoords.y2 - (1 - colorBarWidth) * yCoords.height
    					: yCoords.y2 - colorBarWidth * yCoords.height);

    					$$invalidate("tickLabelYCoords", tickLabelYCoords = labelY || tickLabelYCoords);

    					if (labelPaddingY !== undefined) {
    						$$invalidate("tickLabelYCoords", tickLabelYCoords = flipLabels
    						? tickLabelYCoords - labelPaddingY
    						: tickLabelYCoords + labelPaddingY);
    					}

    					$$invalidate("format", format = getFormat$1(labelFormat, scaleDomain, tickLabelXCoords.length));
    				} else {
    					throw new Error("Could not construct legend. Please provide either 'vertical' or 'horizontal' to 'orient' prop.");
    				}
    			}
    		}

    		if (changed.fill || changed.tickLabelText || changed.scaleDomain || changed.orient || changed.tickLabelYCoords || changed.tickLabelXCoords || changed.labelPaddingX || changed.labelPaddingY || changed.tickColors || changed.scale || changed.tickLabelPositions || changed.tickAlign || changed.labelFontSize || changed.colorBarHeight || changed.colorBarWidth || changed.flipLabels || changed.flip || changed.xCoords || changed.yCoords || changed.useScale || changed.tickOpacities) {
    			 {
    				if (fill) {
    					if (typeof fill === "function") {
    						$$invalidate("tickColors", tickColors = tickLabelText.map((value, i) => {
    							if (Array.isArray(scaleDomain[0]) && scaleDomain.length > 0) {
    								return fill(i);
    							} else {
    								return fill(value);
    							}
    						}));

    						if (orient === "vertical") {
    							$$invalidate("tickLabelPositions", tickLabelPositions = tickLabelYCoords);
    							$$invalidate("tickAlign", tickAlign = tickLabelXCoords - labelPaddingX);
    						} else {
    							$$invalidate("tickLabelPositions", tickLabelPositions = tickLabelXCoords);
    							$$invalidate("tickAlign", tickAlign = tickLabelYCoords - labelPaddingY);
    						}

    						$$invalidate("colorGeoms", colorGeoms = getColorGeoms(tickColors, orient, scale, tickLabelText, tickLabelPositions, tickAlign, labelFontSize, colorBarHeight, colorBarWidth, flipLabels, flip, xCoords, yCoords, useScale));

    						if (!tickOpacities) {
    							$$invalidate("tickOpacities", tickOpacities = 1);
    						}
    					}
    				}
    			}
    		}

    		if (changed.fillOpacity || changed.tickLabelText || changed.scale || changed.orient || changed.tickLabelYCoords || changed.tickLabelXCoords || changed.tickOpacities || changed.tickLabelPositions || changed.tickAlign || changed.labelFontSize || changed.colorBarHeight || changed.colorBarWidth || changed.flipLabels || changed.flip || changed.xCoords || changed.yCoords || changed.useScale || changed.tickColors || changed.fill) {
    			 {
    				if (fillOpacity) {
    					if (typeof fillOpacity === "function") {
    						$$invalidate("tickOpacities", tickOpacities = tickLabelText.map((value, i) => {
    							if (Array.isArray(scale[0]) && scale.length > 0) {
    								return fillOpacity(i);
    							} else {
    								return fillOpacity(value);
    							}
    						}));

    						if (orient === "vertical") {
    							$$invalidate("tickLabelPositions", tickLabelPositions = tickLabelYCoords);
    							$$invalidate("tickAlign", tickAlign = tickLabelXCoords);
    						} else {
    							$$invalidate("tickLabelPositions", tickLabelPositions = tickLabelXCoords);
    							$$invalidate("tickAlign", tickAlign = tickLabelYCoords);
    						}

    						$$invalidate("colorGeoms", colorGeoms = getColorGeoms(tickOpacities, orient, scale, tickLabelText, tickLabelPositions, tickAlign, labelFontSize, colorBarHeight, colorBarWidth, flipLabels, flip, xCoords, yCoords, useScale));

    						if (!tickColors) {
    							$$invalidate("tickColors", tickColors = fill);
    						}
    					} else if (fillOpacity.constructor === Number) {
    						$$invalidate("tickOpacities", tickOpacities = fillOpacity);
    					}
    				}
    			}
    		}

    		if (changed.colorGeoms) {
    			 {
    				$$invalidate("colorXStartCoords", colorXStartCoords = colorGeoms.colorXStartCoords);
    				$$invalidate("colorXEndCoords", colorXEndCoords = colorGeoms.colorXEndCoords);
    				$$invalidate("colorYStartCoords", colorYStartCoords = colorGeoms.colorYStartCoords);
    				$$invalidate("colorYEndCoords", colorYEndCoords = colorGeoms.colorYEndCoords);
    			}
    		}
    	};

    	return {
    		x1,
    		x2,
    		y1,
    		y2,
    		orient,
    		vjust,
    		height,
    		hjust,
    		width,
    		xOffset,
    		yOffset,
    		usePadding,
    		flip,
    		flipLabels,
    		stroke,
    		strokeWidth,
    		fill,
    		fillOpacity,
    		labels,
    		labelFormat,
    		labelRotate,
    		labelX,
    		labelY,
    		labelFont,
    		labelFontSize,
    		labelFontWeight,
    		labelOpacity,
    		labelColor,
    		labelAnchorPoint,
    		labelCount,
    		labelExtra,
    		firstLabel,
    		format,
    		labelPaddingY,
    		labelPaddingX,
    		titleHjust,
    		titleXOffset,
    		titleX,
    		titleVjust,
    		titleYOffset,
    		titleY,
    		title,
    		titleColor,
    		titleFont,
    		titleFontSize,
    		titleFontWeight,
    		titleOpacity,
    		titleRotation,
    		titleAnchorPoint,
    		titlePaddingX,
    		titlePaddingY,
    		transition,
    		zoomIdentity,
    		sectionContext,
    		tickLabelText,
    		tickLabelXCoords,
    		tickLabelYCoords,
    		tickColors,
    		tickOpacities,
    		colorXStartCoords,
    		colorXEndCoords,
    		colorYStartCoords,
    		colorYEndCoords,
    		func,
    		func_1,
    		func_2,
    		func_3,
    		func_4,
    		func_5,
    		func_6,
    		func_7
    	};
    }

    class DiscreteLegend extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$n, create_fragment$n, safe_not_equal, {
    			x1: 0,
    			x2: 0,
    			y1: 0,
    			y2: 0,
    			orient: 0,
    			vjust: 0,
    			height: 0,
    			hjust: 0,
    			width: 0,
    			xOffset: 0,
    			yOffset: 0,
    			usePadding: 0,
    			flip: 0,
    			flipLabels: 0,
    			stroke: 0,
    			strokeWidth: 0,
    			fill: 0,
    			fillOpacity: 0,
    			labels: 0,
    			labelFormat: 0,
    			labelRotate: 0,
    			labelX: 0,
    			labelY: 0,
    			labelFont: 0,
    			labelFontSize: 0,
    			labelFontWeight: 0,
    			labelOpacity: 0,
    			labelColor: 0,
    			labelAnchorPoint: 0,
    			labelCount: 0,
    			labelExtra: 0,
    			firstLabel: 0,
    			format: 0,
    			labelPaddingY: 0,
    			labelPaddingX: 0,
    			titleHjust: 0,
    			titleXOffset: 0,
    			titleX: 0,
    			titleVjust: 0,
    			titleYOffset: 0,
    			titleY: 0,
    			title: 0,
    			titleColor: 0,
    			titleFont: 0,
    			titleFontSize: 0,
    			titleFontWeight: 0,
    			titleOpacity: 0,
    			titleRotation: 0,
    			titleAnchorPoint: 0,
    			titlePaddingX: 0,
    			titlePaddingY: 0,
    			transition: 0,
    			zoomIdentity: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DiscreteLegend",
    			options,
    			id: create_fragment$n.name
    		});
    	}

    	get x1() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x1(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get x2() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x2(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y1() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y1(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y2() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y2(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get orient() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set orient(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get vjust() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set vjust(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hjust() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hjust(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xOffset() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xOffset(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get yOffset() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set yOffset(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get usePadding() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set usePadding(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flip() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flip(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flipLabels() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flipLabels(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stroke() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stroke(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeWidth() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeWidth(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fill() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fill(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillOpacity() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillOpacity(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labels() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labels(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelFormat() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelFormat(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelRotate() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelRotate(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelX() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelX(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelY() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelY(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelFont() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelFont(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelFontSize() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelFontSize(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelFontWeight() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelFontWeight(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelOpacity() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelOpacity(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelColor() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelColor(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelAnchorPoint() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelAnchorPoint(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelCount() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelCount(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelExtra() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelExtra(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get firstLabel() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set firstLabel(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get format() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set format(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelPaddingY() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelPaddingY(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelPaddingX() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelPaddingX(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleHjust() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleHjust(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleXOffset() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleXOffset(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleX() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleX(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleVjust() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleVjust(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleYOffset() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleYOffset(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleY() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleY(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleColor() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleColor(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleFont() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleFont(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleFontSize() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleFontSize(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleFontWeight() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleFontWeight(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleOpacity() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleOpacity(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleRotation() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleRotation(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleAnchorPoint() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleAnchorPoint(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titlePaddingX() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titlePaddingX(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titlePaddingY() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titlePaddingY(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transition() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transition(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zoomIdentity() {
    		throw new Error_1("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoomIdentity(value) {
    		throw new Error_1("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Guides/Legends/GradientLegend.svelte generated by Svelte v3.15.0 */

    const { Error: Error_1$1 } = globals;

    const file$a = "src/components/Guides/Legends/GradientLegend.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.o = list[i];
    	child_ctx.i = i;
    	return child_ctx;
    }

    // (380:6) {#each offsets as o, i}
    function create_each_block$1(ctx) {
    	let stop;
    	let stop_key_value;
    	let stop_offset_value;
    	let stop_style_value;

    	const block = {
    		c: function create() {
    			stop = svg_element("stop");
    			attr_dev(stop, "key", stop_key_value = ctx.i);
    			attr_dev(stop, "offset", stop_offset_value = `${ctx.o * 100 + "%"}`);

    			attr_dev(stop, "style", stop_style_value = `stop-color:${Array.isArray(ctx.tickColors)
			? ctx.tickColors[ctx.i]
			: ctx.tickColors};stop-opacity:${Array.isArray(ctx.tickOpacities)
			? ctx.tickOpacities[ctx.i]
			: ctx.tickOpacities}`);

    			add_location(stop, file$a, 380, 10, 11683);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, stop, anchor);
    		},
    		p: function update(changed, ctx) {
    			if (changed.offsets && stop_offset_value !== (stop_offset_value = `${ctx.o * 100 + "%"}`)) {
    				attr_dev(stop, "offset", stop_offset_value);
    			}

    			if ((changed.tickColors || changed.tickOpacities) && stop_style_value !== (stop_style_value = `stop-color:${Array.isArray(ctx.tickColors)
			? ctx.tickColors[ctx.i]
			: ctx.tickColors};stop-opacity:${Array.isArray(ctx.tickOpacities)
			? ctx.tickOpacities[ctx.i]
			: ctx.tickOpacities}`)) {
    				attr_dev(stop, "style", stop_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(stop);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(380:6) {#each offsets as o, i}",
    		ctx
    	});

    	return block;
    }

    // (417:2) {#if title.length > 0}
    function create_if_block$8(ctx) {
    	let current;

    	const label = new Label({
    			props: {
    				x: ctx.func_6,
    				y: ctx.func_7,
    				text: ctx.title,
    				fontFamily: ctx.titleFont,
    				fontSize: ctx.titleFontSize,
    				fontWeight: ctx.titleFontWeight,
    				rotation: ctx.titleRotation,
    				anchorPoint: ctx.titleAnchorPoint,
    				opacity: ctx.titleOpacity,
    				fill: ctx.titleColor,
    				transition: ctx.transition,
    				zoomIdentity: ctx.zoomIdentity
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(label.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(label, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const label_changes = {};
    			if (changed.titleX) label_changes.x = ctx.func_6;
    			if (changed.titleY) label_changes.y = ctx.func_7;
    			if (changed.title) label_changes.text = ctx.title;
    			if (changed.titleFont) label_changes.fontFamily = ctx.titleFont;
    			if (changed.titleFontSize) label_changes.fontSize = ctx.titleFontSize;
    			if (changed.titleFontWeight) label_changes.fontWeight = ctx.titleFontWeight;
    			if (changed.titleRotation) label_changes.rotation = ctx.titleRotation;
    			if (changed.titleAnchorPoint) label_changes.anchorPoint = ctx.titleAnchorPoint;
    			if (changed.titleOpacity) label_changes.opacity = ctx.titleOpacity;
    			if (changed.titleColor) label_changes.fill = ctx.titleColor;
    			if (changed.transition) label_changes.transition = ctx.transition;
    			if (changed.zoomIdentity) label_changes.zoomIdentity = ctx.zoomIdentity;
    			label.$set(label_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(label, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(417:2) {#if title.length > 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let g;
    	let defs;
    	let linearGradient;
    	let linearGradient_x__value;
    	let linearGradient_y__value;
    	let linearGradient_x__value_1;
    	let linearGradient_y__value_1;
    	let current;
    	let each_value = ctx.offsets;
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const rectangle = new Rectangle({
    			props: {
    				x1: ctx.func,
    				x2: ctx.func_1,
    				y1: ctx.func_2,
    				y2: ctx.func_3,
    				fill: `url(#${ctx.gradientId})`,
    				transition: ctx.transition,
    				stroke: ctx.stroke,
    				strokeWidth: ctx.strokeWidth,
    				zoomIdentity: ctx.zoomIdentity
    			},
    			$$inline: true
    		});

    	const labellayer = new LabelLayer({
    			props: {
    				x: ctx.func_4,
    				y: ctx.func_5,
    				text: ctx.tickLabelText,
    				anchorPoint: ctx.labelAnchorPoint,
    				rotation: ctx.labelRotate,
    				fontFamily: ctx.labelFont,
    				fontSize: ctx.labelFontSize,
    				fontWeight: ctx.labelFontWeight,
    				opacity: ctx.labelOpacity,
    				fill: ctx.labelColor,
    				transition: ctx.transition,
    				zoomIdentity: ctx.zoomIdentity
    			},
    			$$inline: true
    		});

    	let if_block = ctx.title.length > 0 && create_if_block$8(ctx);

    	const block = {
    		c: function create() {
    			g = svg_element("g");
    			defs = svg_element("defs");
    			linearGradient = svg_element("linearGradient");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			create_component(rectangle.$$.fragment);
    			create_component(labellayer.$$.fragment);
    			if (if_block) if_block.c();
    			attr_dev(linearGradient, "id", ctx.gradientId);
    			attr_dev(linearGradient, "x1", linearGradient_x__value = ctx.gradX.x1);
    			attr_dev(linearGradient, "y1", linearGradient_y__value = ctx.gradY.y1);
    			attr_dev(linearGradient, "x2", linearGradient_x__value_1 = ctx.gradX.x2);
    			attr_dev(linearGradient, "y2", linearGradient_y__value_1 = ctx.gradY.y2);
    			add_location(linearGradient, file$a, 372, 4, 11517);
    			add_location(defs, file$a, 371, 2, 11506);
    			attr_dev(g, "class", "gradient-legend");
    			add_location(g, file$a, 369, 0, 11445);
    		},
    		l: function claim(nodes) {
    			throw new Error_1$1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);
    			append_dev(g, defs);
    			append_dev(defs, linearGradient);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(linearGradient, null);
    			}

    			mount_component(rectangle, g, null);
    			mount_component(labellayer, g, null);
    			if (if_block) if_block.m(g, null);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (changed.offsets || changed.Array || changed.tickColors || changed.tickOpacities) {
    				each_value = ctx.offsets;
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(linearGradient, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (!current || changed.gradX && linearGradient_x__value !== (linearGradient_x__value = ctx.gradX.x1)) {
    				attr_dev(linearGradient, "x1", linearGradient_x__value);
    			}

    			if (!current || changed.gradY && linearGradient_y__value !== (linearGradient_y__value = ctx.gradY.y1)) {
    				attr_dev(linearGradient, "y1", linearGradient_y__value);
    			}

    			if (!current || changed.gradX && linearGradient_x__value_1 !== (linearGradient_x__value_1 = ctx.gradX.x2)) {
    				attr_dev(linearGradient, "x2", linearGradient_x__value_1);
    			}

    			if (!current || changed.gradY && linearGradient_y__value_1 !== (linearGradient_y__value_1 = ctx.gradY.y2)) {
    				attr_dev(linearGradient, "y2", linearGradient_y__value_1);
    			}

    			const rectangle_changes = {};
    			if (changed.rectCoords) rectangle_changes.x1 = ctx.func;
    			if (changed.rectCoords) rectangle_changes.x2 = ctx.func_1;
    			if (changed.rectCoords) rectangle_changes.y1 = ctx.func_2;
    			if (changed.rectCoords) rectangle_changes.y2 = ctx.func_3;
    			if (changed.transition) rectangle_changes.transition = ctx.transition;
    			if (changed.stroke) rectangle_changes.stroke = ctx.stroke;
    			if (changed.strokeWidth) rectangle_changes.strokeWidth = ctx.strokeWidth;
    			if (changed.zoomIdentity) rectangle_changes.zoomIdentity = ctx.zoomIdentity;
    			rectangle.$set(rectangle_changes);
    			const labellayer_changes = {};
    			if (changed.tickLabelXCoords) labellayer_changes.x = ctx.func_4;
    			if (changed.tickLabelYCoords) labellayer_changes.y = ctx.func_5;
    			if (changed.tickLabelText) labellayer_changes.text = ctx.tickLabelText;
    			if (changed.labelAnchorPoint) labellayer_changes.anchorPoint = ctx.labelAnchorPoint;
    			if (changed.labelRotate) labellayer_changes.rotation = ctx.labelRotate;
    			if (changed.labelFont) labellayer_changes.fontFamily = ctx.labelFont;
    			if (changed.labelFontSize) labellayer_changes.fontSize = ctx.labelFontSize;
    			if (changed.labelFontWeight) labellayer_changes.fontWeight = ctx.labelFontWeight;
    			if (changed.labelOpacity) labellayer_changes.opacity = ctx.labelOpacity;
    			if (changed.labelColor) labellayer_changes.fill = ctx.labelColor;
    			if (changed.transition) labellayer_changes.transition = ctx.transition;
    			if (changed.zoomIdentity) labellayer_changes.zoomIdentity = ctx.zoomIdentity;
    			labellayer.$set(labellayer_changes);

    			if (ctx.title.length > 0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$8(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(g, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rectangle.$$.fragment, local);
    			transition_in(labellayer.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rectangle.$$.fragment, local);
    			transition_out(labellayer.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    			destroy_each(each_blocks, detaching);
    			destroy_component(rectangle);
    			destroy_component(labellayer);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let idCounter$4 = 0;

    function getId$4() {
    	return "gradient" + idCounter$4++;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let $sectionContext;
    	const gradientId = getId$4();
    	let { x1 = undefined } = $$props;
    	let { x2 = undefined } = $$props;
    	let { y1 = undefined } = $$props;
    	let { y2 = undefined } = $$props;
    	let { orient = "vertical" } = $$props;
    	let { vjust = "center" } = $$props;
    	let { height = undefined } = $$props;
    	let { hjust = "left" } = $$props;
    	let { width = 0 } = $$props;
    	let { xOffset = 0 } = $$props;
    	let { yOffset = 0 } = $$props;
    	let { usePadding = false } = $$props;
    	let { flip = false } = $$props;
    	let { flipLabels = false } = $$props;
    	let { stroke = "none" } = $$props;
    	let { strokeWidth = 2 } = $$props;
    	let { fill = undefined } = $$props;
    	let { fillOpacity = undefined } = $$props;
    	let { labels = undefined } = $$props;
    	let { labelFormat = undefined } = $$props;
    	let { labelRotate = 0 } = $$props;
    	let { labelX = undefined } = $$props;
    	let { labelY = undefined } = $$props;
    	let { labelFont = "Helvetica" } = $$props;
    	let { labelFontSize = 10 } = $$props;
    	let { labelFontWeight = "normal" } = $$props;
    	let { labelOpacity = 1 } = $$props;
    	let { labelColor = "black" } = $$props;
    	let { labelAnchorPoint = "center" } = $$props;
    	let { labelCount = 10 } = $$props;
    	let { labelExtra = false } = $$props;
    	let { firstLabel = undefined } = $$props;
    	let { format = undefined } = $$props;
    	let { labelPaddingX = 0 } = $$props;
    	let { labelPaddingY = 0 } = $$props;
    	let { titleHjust = "center" } = $$props;
    	let { titleXOffset = 0 } = $$props;
    	let { titleX = undefined } = $$props;
    	let { titleVjust = "top" } = $$props;
    	let { titleYOffset = 0 } = $$props;
    	let { titleY = undefined } = $$props;
    	let { title = "Legend" } = $$props;
    	let { titleColor = "black" } = $$props;
    	let { titleFont = "Helvetica" } = $$props;
    	let { titleFontSize = 12 } = $$props;
    	let { titleFontWeight = "bold" } = $$props;
    	let { titleOpacity = 1 } = $$props;
    	let { titleRotation = 0 } = $$props;
    	let { titleAnchorPoint = "t" } = $$props;
    	let { titlePaddingX = 0 } = $$props;
    	let { titlePaddingY = -3 } = $$props;
    	let { transition } = $$props;
    	let { zoomIdentity } = $$props;
    	const sectionContext = subscribe$2();
    	validate_store(sectionContext, "sectionContext");
    	component_subscribe($$self, sectionContext, value => $$invalidate("$sectionContext", $sectionContext = value));
    	const graphicContext = subscribe$1();
    	const zoomContext = subscribe$6();
    	let scale;
    	let scaleDomain;
    	let scaleDomainGroups;
    	let tickLabelText;
    	let tickLabelPositions;
    	let tickLabelXCoords;
    	let tickLabelYCoords;
    	let tickColors;
    	let tickOpacities;
    	let tickAlign;
    	let _padding;
    	let rangeCoordsX;
    	let rangeCoordsY;
    	let xRange = $sectionContext.scaleX.range();
    	let yRange = $sectionContext.scaleY.range();
    	let colorGeoms;
    	let offsets;
    	let gradX;
    	let gradY;
    	let rectCoords;
    	let colorBarHeight;
    	let colorBarWidth;
    	let posScaleY;
    	let xCoords;
    	let yCoords;
    	let addTitleSize;

    	const writable_props = [
    		"x1",
    		"x2",
    		"y1",
    		"y2",
    		"orient",
    		"vjust",
    		"height",
    		"hjust",
    		"width",
    		"xOffset",
    		"yOffset",
    		"usePadding",
    		"flip",
    		"flipLabels",
    		"stroke",
    		"strokeWidth",
    		"fill",
    		"fillOpacity",
    		"labels",
    		"labelFormat",
    		"labelRotate",
    		"labelX",
    		"labelY",
    		"labelFont",
    		"labelFontSize",
    		"labelFontWeight",
    		"labelOpacity",
    		"labelColor",
    		"labelAnchorPoint",
    		"labelCount",
    		"labelExtra",
    		"firstLabel",
    		"format",
    		"labelPaddingX",
    		"labelPaddingY",
    		"titleHjust",
    		"titleXOffset",
    		"titleX",
    		"titleVjust",
    		"titleYOffset",
    		"titleY",
    		"title",
    		"titleColor",
    		"titleFont",
    		"titleFontSize",
    		"titleFontWeight",
    		"titleOpacity",
    		"titleRotation",
    		"titleAnchorPoint",
    		"titlePaddingX",
    		"titlePaddingY",
    		"transition",
    		"zoomIdentity"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GradientLegend> was created with unknown prop '${key}'`);
    	});

    	const func = () => {
    		return rectCoords.x1;
    	};

    	const func_1 = () => {
    		return rectCoords.x2;
    	};

    	const func_2 = () => {
    		return rectCoords.y1;
    	};

    	const func_3 = () => {
    		return rectCoords.y2;
    	};

    	const func_4 = () => {
    		return tickLabelXCoords;
    	};

    	const func_5 = () => {
    		return tickLabelYCoords;
    	};

    	const func_6 = () => {
    		return titleX;
    	};

    	const func_7 = () => {
    		return titleY;
    	};

    	$$self.$set = $$props => {
    		if ("x1" in $$props) $$invalidate("x1", x1 = $$props.x1);
    		if ("x2" in $$props) $$invalidate("x2", x2 = $$props.x2);
    		if ("y1" in $$props) $$invalidate("y1", y1 = $$props.y1);
    		if ("y2" in $$props) $$invalidate("y2", y2 = $$props.y2);
    		if ("orient" in $$props) $$invalidate("orient", orient = $$props.orient);
    		if ("vjust" in $$props) $$invalidate("vjust", vjust = $$props.vjust);
    		if ("height" in $$props) $$invalidate("height", height = $$props.height);
    		if ("hjust" in $$props) $$invalidate("hjust", hjust = $$props.hjust);
    		if ("width" in $$props) $$invalidate("width", width = $$props.width);
    		if ("xOffset" in $$props) $$invalidate("xOffset", xOffset = $$props.xOffset);
    		if ("yOffset" in $$props) $$invalidate("yOffset", yOffset = $$props.yOffset);
    		if ("usePadding" in $$props) $$invalidate("usePadding", usePadding = $$props.usePadding);
    		if ("flip" in $$props) $$invalidate("flip", flip = $$props.flip);
    		if ("flipLabels" in $$props) $$invalidate("flipLabels", flipLabels = $$props.flipLabels);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("labels" in $$props) $$invalidate("labels", labels = $$props.labels);
    		if ("labelFormat" in $$props) $$invalidate("labelFormat", labelFormat = $$props.labelFormat);
    		if ("labelRotate" in $$props) $$invalidate("labelRotate", labelRotate = $$props.labelRotate);
    		if ("labelX" in $$props) $$invalidate("labelX", labelX = $$props.labelX);
    		if ("labelY" in $$props) $$invalidate("labelY", labelY = $$props.labelY);
    		if ("labelFont" in $$props) $$invalidate("labelFont", labelFont = $$props.labelFont);
    		if ("labelFontSize" in $$props) $$invalidate("labelFontSize", labelFontSize = $$props.labelFontSize);
    		if ("labelFontWeight" in $$props) $$invalidate("labelFontWeight", labelFontWeight = $$props.labelFontWeight);
    		if ("labelOpacity" in $$props) $$invalidate("labelOpacity", labelOpacity = $$props.labelOpacity);
    		if ("labelColor" in $$props) $$invalidate("labelColor", labelColor = $$props.labelColor);
    		if ("labelAnchorPoint" in $$props) $$invalidate("labelAnchorPoint", labelAnchorPoint = $$props.labelAnchorPoint);
    		if ("labelCount" in $$props) $$invalidate("labelCount", labelCount = $$props.labelCount);
    		if ("labelExtra" in $$props) $$invalidate("labelExtra", labelExtra = $$props.labelExtra);
    		if ("firstLabel" in $$props) $$invalidate("firstLabel", firstLabel = $$props.firstLabel);
    		if ("format" in $$props) $$invalidate("format", format = $$props.format);
    		if ("labelPaddingX" in $$props) $$invalidate("labelPaddingX", labelPaddingX = $$props.labelPaddingX);
    		if ("labelPaddingY" in $$props) $$invalidate("labelPaddingY", labelPaddingY = $$props.labelPaddingY);
    		if ("titleHjust" in $$props) $$invalidate("titleHjust", titleHjust = $$props.titleHjust);
    		if ("titleXOffset" in $$props) $$invalidate("titleXOffset", titleXOffset = $$props.titleXOffset);
    		if ("titleX" in $$props) $$invalidate("titleX", titleX = $$props.titleX);
    		if ("titleVjust" in $$props) $$invalidate("titleVjust", titleVjust = $$props.titleVjust);
    		if ("titleYOffset" in $$props) $$invalidate("titleYOffset", titleYOffset = $$props.titleYOffset);
    		if ("titleY" in $$props) $$invalidate("titleY", titleY = $$props.titleY);
    		if ("title" in $$props) $$invalidate("title", title = $$props.title);
    		if ("titleColor" in $$props) $$invalidate("titleColor", titleColor = $$props.titleColor);
    		if ("titleFont" in $$props) $$invalidate("titleFont", titleFont = $$props.titleFont);
    		if ("titleFontSize" in $$props) $$invalidate("titleFontSize", titleFontSize = $$props.titleFontSize);
    		if ("titleFontWeight" in $$props) $$invalidate("titleFontWeight", titleFontWeight = $$props.titleFontWeight);
    		if ("titleOpacity" in $$props) $$invalidate("titleOpacity", titleOpacity = $$props.titleOpacity);
    		if ("titleRotation" in $$props) $$invalidate("titleRotation", titleRotation = $$props.titleRotation);
    		if ("titleAnchorPoint" in $$props) $$invalidate("titleAnchorPoint", titleAnchorPoint = $$props.titleAnchorPoint);
    		if ("titlePaddingX" in $$props) $$invalidate("titlePaddingX", titlePaddingX = $$props.titlePaddingX);
    		if ("titlePaddingY" in $$props) $$invalidate("titlePaddingY", titlePaddingY = $$props.titlePaddingY);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    	};

    	$$self.$capture_state = () => {
    		return {
    			idCounter: idCounter$4,
    			x1,
    			x2,
    			y1,
    			y2,
    			orient,
    			vjust,
    			height,
    			hjust,
    			width,
    			xOffset,
    			yOffset,
    			usePadding,
    			flip,
    			flipLabels,
    			stroke,
    			strokeWidth,
    			fill,
    			fillOpacity,
    			labels,
    			labelFormat,
    			labelRotate,
    			labelX,
    			labelY,
    			labelFont,
    			labelFontSize,
    			labelFontWeight,
    			labelOpacity,
    			labelColor,
    			labelAnchorPoint,
    			labelCount,
    			labelExtra,
    			firstLabel,
    			format,
    			labelPaddingX,
    			labelPaddingY,
    			titleHjust,
    			titleXOffset,
    			titleX,
    			titleVjust,
    			titleYOffset,
    			titleY,
    			title,
    			titleColor,
    			titleFont,
    			titleFontSize,
    			titleFontWeight,
    			titleOpacity,
    			titleRotation,
    			titleAnchorPoint,
    			titlePaddingX,
    			titlePaddingY,
    			transition,
    			zoomIdentity,
    			scale,
    			scaleDomain,
    			scaleDomainGroups,
    			tickLabelText,
    			tickLabelPositions,
    			tickLabelXCoords,
    			tickLabelYCoords,
    			tickColors,
    			tickOpacities,
    			tickAlign,
    			_padding,
    			rangeCoordsX,
    			rangeCoordsY,
    			xRange,
    			yRange,
    			colorGeoms,
    			offsets,
    			gradX,
    			gradY,
    			rectCoords,
    			colorBarHeight,
    			colorBarWidth,
    			posScaleY,
    			xCoords,
    			yCoords,
    			addTitleSize,
    			$sectionContext
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("x1" in $$props) $$invalidate("x1", x1 = $$props.x1);
    		if ("x2" in $$props) $$invalidate("x2", x2 = $$props.x2);
    		if ("y1" in $$props) $$invalidate("y1", y1 = $$props.y1);
    		if ("y2" in $$props) $$invalidate("y2", y2 = $$props.y2);
    		if ("orient" in $$props) $$invalidate("orient", orient = $$props.orient);
    		if ("vjust" in $$props) $$invalidate("vjust", vjust = $$props.vjust);
    		if ("height" in $$props) $$invalidate("height", height = $$props.height);
    		if ("hjust" in $$props) $$invalidate("hjust", hjust = $$props.hjust);
    		if ("width" in $$props) $$invalidate("width", width = $$props.width);
    		if ("xOffset" in $$props) $$invalidate("xOffset", xOffset = $$props.xOffset);
    		if ("yOffset" in $$props) $$invalidate("yOffset", yOffset = $$props.yOffset);
    		if ("usePadding" in $$props) $$invalidate("usePadding", usePadding = $$props.usePadding);
    		if ("flip" in $$props) $$invalidate("flip", flip = $$props.flip);
    		if ("flipLabels" in $$props) $$invalidate("flipLabels", flipLabels = $$props.flipLabels);
    		if ("stroke" in $$props) $$invalidate("stroke", stroke = $$props.stroke);
    		if ("strokeWidth" in $$props) $$invalidate("strokeWidth", strokeWidth = $$props.strokeWidth);
    		if ("fill" in $$props) $$invalidate("fill", fill = $$props.fill);
    		if ("fillOpacity" in $$props) $$invalidate("fillOpacity", fillOpacity = $$props.fillOpacity);
    		if ("labels" in $$props) $$invalidate("labels", labels = $$props.labels);
    		if ("labelFormat" in $$props) $$invalidate("labelFormat", labelFormat = $$props.labelFormat);
    		if ("labelRotate" in $$props) $$invalidate("labelRotate", labelRotate = $$props.labelRotate);
    		if ("labelX" in $$props) $$invalidate("labelX", labelX = $$props.labelX);
    		if ("labelY" in $$props) $$invalidate("labelY", labelY = $$props.labelY);
    		if ("labelFont" in $$props) $$invalidate("labelFont", labelFont = $$props.labelFont);
    		if ("labelFontSize" in $$props) $$invalidate("labelFontSize", labelFontSize = $$props.labelFontSize);
    		if ("labelFontWeight" in $$props) $$invalidate("labelFontWeight", labelFontWeight = $$props.labelFontWeight);
    		if ("labelOpacity" in $$props) $$invalidate("labelOpacity", labelOpacity = $$props.labelOpacity);
    		if ("labelColor" in $$props) $$invalidate("labelColor", labelColor = $$props.labelColor);
    		if ("labelAnchorPoint" in $$props) $$invalidate("labelAnchorPoint", labelAnchorPoint = $$props.labelAnchorPoint);
    		if ("labelCount" in $$props) $$invalidate("labelCount", labelCount = $$props.labelCount);
    		if ("labelExtra" in $$props) $$invalidate("labelExtra", labelExtra = $$props.labelExtra);
    		if ("firstLabel" in $$props) $$invalidate("firstLabel", firstLabel = $$props.firstLabel);
    		if ("format" in $$props) $$invalidate("format", format = $$props.format);
    		if ("labelPaddingX" in $$props) $$invalidate("labelPaddingX", labelPaddingX = $$props.labelPaddingX);
    		if ("labelPaddingY" in $$props) $$invalidate("labelPaddingY", labelPaddingY = $$props.labelPaddingY);
    		if ("titleHjust" in $$props) $$invalidate("titleHjust", titleHjust = $$props.titleHjust);
    		if ("titleXOffset" in $$props) $$invalidate("titleXOffset", titleXOffset = $$props.titleXOffset);
    		if ("titleX" in $$props) $$invalidate("titleX", titleX = $$props.titleX);
    		if ("titleVjust" in $$props) $$invalidate("titleVjust", titleVjust = $$props.titleVjust);
    		if ("titleYOffset" in $$props) $$invalidate("titleYOffset", titleYOffset = $$props.titleYOffset);
    		if ("titleY" in $$props) $$invalidate("titleY", titleY = $$props.titleY);
    		if ("title" in $$props) $$invalidate("title", title = $$props.title);
    		if ("titleColor" in $$props) $$invalidate("titleColor", titleColor = $$props.titleColor);
    		if ("titleFont" in $$props) $$invalidate("titleFont", titleFont = $$props.titleFont);
    		if ("titleFontSize" in $$props) $$invalidate("titleFontSize", titleFontSize = $$props.titleFontSize);
    		if ("titleFontWeight" in $$props) $$invalidate("titleFontWeight", titleFontWeight = $$props.titleFontWeight);
    		if ("titleOpacity" in $$props) $$invalidate("titleOpacity", titleOpacity = $$props.titleOpacity);
    		if ("titleRotation" in $$props) $$invalidate("titleRotation", titleRotation = $$props.titleRotation);
    		if ("titleAnchorPoint" in $$props) $$invalidate("titleAnchorPoint", titleAnchorPoint = $$props.titleAnchorPoint);
    		if ("titlePaddingX" in $$props) $$invalidate("titlePaddingX", titlePaddingX = $$props.titlePaddingX);
    		if ("titlePaddingY" in $$props) $$invalidate("titlePaddingY", titlePaddingY = $$props.titlePaddingY);
    		if ("transition" in $$props) $$invalidate("transition", transition = $$props.transition);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("scale" in $$props) $$invalidate("scale", scale = $$props.scale);
    		if ("scaleDomain" in $$props) $$invalidate("scaleDomain", scaleDomain = $$props.scaleDomain);
    		if ("scaleDomainGroups" in $$props) scaleDomainGroups = $$props.scaleDomainGroups;
    		if ("tickLabelText" in $$props) $$invalidate("tickLabelText", tickLabelText = $$props.tickLabelText);
    		if ("tickLabelPositions" in $$props) tickLabelPositions = $$props.tickLabelPositions;
    		if ("tickLabelXCoords" in $$props) $$invalidate("tickLabelXCoords", tickLabelXCoords = $$props.tickLabelXCoords);
    		if ("tickLabelYCoords" in $$props) $$invalidate("tickLabelYCoords", tickLabelYCoords = $$props.tickLabelYCoords);
    		if ("tickColors" in $$props) $$invalidate("tickColors", tickColors = $$props.tickColors);
    		if ("tickOpacities" in $$props) $$invalidate("tickOpacities", tickOpacities = $$props.tickOpacities);
    		if ("tickAlign" in $$props) $$invalidate("tickAlign", tickAlign = $$props.tickAlign);
    		if ("_padding" in $$props) $$invalidate("_padding", _padding = $$props._padding);
    		if ("rangeCoordsX" in $$props) $$invalidate("rangeCoordsX", rangeCoordsX = $$props.rangeCoordsX);
    		if ("rangeCoordsY" in $$props) $$invalidate("rangeCoordsY", rangeCoordsY = $$props.rangeCoordsY);
    		if ("xRange" in $$props) $$invalidate("xRange", xRange = $$props.xRange);
    		if ("yRange" in $$props) $$invalidate("yRange", yRange = $$props.yRange);
    		if ("colorGeoms" in $$props) $$invalidate("colorGeoms", colorGeoms = $$props.colorGeoms);
    		if ("offsets" in $$props) $$invalidate("offsets", offsets = $$props.offsets);
    		if ("gradX" in $$props) $$invalidate("gradX", gradX = $$props.gradX);
    		if ("gradY" in $$props) $$invalidate("gradY", gradY = $$props.gradY);
    		if ("rectCoords" in $$props) $$invalidate("rectCoords", rectCoords = $$props.rectCoords);
    		if ("colorBarHeight" in $$props) $$invalidate("colorBarHeight", colorBarHeight = $$props.colorBarHeight);
    		if ("colorBarWidth" in $$props) $$invalidate("colorBarWidth", colorBarWidth = $$props.colorBarWidth);
    		if ("posScaleY" in $$props) posScaleY = $$props.posScaleY;
    		if ("xCoords" in $$props) $$invalidate("xCoords", xCoords = $$props.xCoords);
    		if ("yCoords" in $$props) $$invalidate("yCoords", yCoords = $$props.yCoords);
    		if ("addTitleSize" in $$props) $$invalidate("addTitleSize", addTitleSize = $$props.addTitleSize);
    		if ("$sectionContext" in $$props) sectionContext.set($sectionContext = $$props.$sectionContext);
    	};

    	$$self.$$.update = (changed = { usePadding: 1, $sectionContext: 1, xRange: 1, _padding: 1, yRange: 1, orient: 1, title: 1, titleFontSize: 1, x1: 1, x2: 1, y1: 1, y2: 1, hjust: 1, width: 1, xOffset: 1, labelFontSize: 1, flip: 1, rangeCoordsX: 1, vjust: 1, height: 1, yOffset: 1, addTitleSize: 1, rangeCoordsY: 1, titleX: 1, titleHjust: 1, xCoords: 1, titleXOffset: 1, titlePaddingX: 1, titleY: 1, titleVjust: 1, yCoords: 1, titleYOffset: 1, titlePaddingY: 1, fill: 1, fillOpacity: 1, scale: 1, labels: 1, scaleDomain: 1, labelCount: 1, labelExtra: 1, firstLabel: 1, format: 1, tickLabelText: 1, labelPaddingY: 1, flipLabels: 1, colorBarHeight: 1, labelX: 1, tickLabelXCoords: 1, labelPaddingX: 1, labelFormat: 1, tickLabelYCoords: 1, colorBarWidth: 1, labelY: 1, tickColors: 1, tickAlign: 1, tickOpacities: 1, colorGeoms: 1 }) => {
    		if (changed.usePadding || changed.$sectionContext || changed.xRange || changed._padding || changed.yRange) {
    			 {
    				if (usePadding === true) {
    					$$invalidate("_padding", _padding = $sectionContext.padding);
    					$$invalidate("xRange", xRange = removePadding(xRange, _padding.left, _padding.right));
    					$$invalidate("yRange", yRange = removePadding(yRange, _padding.top, _padding.bottom));
    				}
    			}
    		}

    		if (changed.orient || changed.title || changed.titleFontSize || changed.x1 || changed.x2 || changed.y1 || changed.y2 || changed.xRange || changed.hjust || changed.width || changed.xOffset || changed.labelFontSize || changed.flip || changed.rangeCoordsX || changed.yRange || changed.vjust || changed.height || changed.yOffset || changed.addTitleSize || changed.rangeCoordsY || changed.$sectionContext) {
    			 {
    				if (!["horizontal", "vertical"].includes(orient)) {
    					throw Error("Invalid input for `orient` property. Please provide either `horizontal` or `vertical` as inputs.");
    				}

    				$$invalidate("addTitleSize", addTitleSize = title.length > 0 ? titleFontSize * 1.5 : 0);

    				if (!isValid$1(x1, x2, y1, y2) && ["horizontal", "vertical"].includes(orient)) {
    					if (sectionContext.flipX) xRange.reverse();
    					$$invalidate("rangeCoordsX", rangeCoordsX = createPosXCoords(hjust, xRange, orient, width, xOffset, labelFontSize));
    					$$invalidate("x1", x1 = rangeCoordsX.x1);
    					$$invalidate("x2", x2 = rangeCoordsX.x2);
    					$$invalidate("width", width = Math.abs(x2 - x1));
    					$$invalidate("xCoords", xCoords = { x1, x2, width });
    					if (sectionContext.flipY) yRange.reverse();
    					$$invalidate("rangeCoordsY", rangeCoordsY = createPosYCoords(vjust, yRange, orient, height, yOffset, addTitleSize));
    					$$invalidate("y1", y1 = rangeCoordsY.y1);
    					$$invalidate("y2", y2 = rangeCoordsY.y2);
    					$$invalidate("height", height = Math.abs(y2 - y1));
    					$$invalidate("yCoords", yCoords = { y1, y2, height });
    				} else {
    					let _x1, _x2, _y1, _y2;

    					if (({}).toString.call(x1) === "[object Function]") {
    						_x1 = x1();
    					} else {
    						_x1 = $sectionContext.scaleX(x1);
    					}

    					if (({}).toString.call(x2) === "[object Function]") {
    						_x2 = x2();
    					} else {
    						_x2 = $sectionContext.scaleX(x2);
    					}

    					if (({}).toString.call(y1) === "[object Function]") {
    						_y1 = y1();
    					} else {
    						_y1 = $sectionContext.scaleY(y1);
    					}

    					if (({}).toString.call(y2) === "[object Function]") {
    						_y2 = y2();
    					} else {
    						_y2 = $sectionContext.scaleY(y2);
    					}

    					$$invalidate("xCoords", xCoords = {
    						x1: _x1,
    						x2: _x2,
    						width: Math.abs(_x2 - _x1)
    					});

    					$$invalidate("yCoords", yCoords = {
    						y1: _y1,
    						y2: _y2,
    						height: Math.abs(_y2 - _y1)
    					});
    				}
    			}
    		}

    		if (changed.title || changed.titleX || changed.titleHjust || changed.xCoords || changed.titleXOffset || changed.addTitleSize || changed.labelFontSize || changed.orient || changed.titlePaddingX || changed.$sectionContext || changed.titleY || changed.titleVjust || changed.yCoords || changed.titleYOffset || changed.titlePaddingY) {
    			 {
    				if (title.length > 0) {
    					if (!titleX && titleX !== 0) {
    						$$invalidate("titleX", titleX = createTitleXCoord$3(titleHjust, xCoords, titleX, titleXOffset, addTitleSize, labelFontSize, orient, titlePaddingX));
    					} else {
    						if (({}).toString.call(titleX) === "[object Function]") {
    							$$invalidate("titleX", titleX = titleX());
    						} else {
    							$$invalidate("titleX", titleX = $sectionContext.scaleX(titleX));
    						}
    					}

    					if (!titleY && titleY !== 0) {
    						$$invalidate("titleY", titleY = createTitleYCoord$3(titleVjust, yCoords, titleY, titleYOffset, addTitleSize, labelFontSize, orient, titlePaddingY));
    					} else {
    						if (({}).toString.call(titleY) === "[object Function]") {
    							$$invalidate("titleY", titleY = titleY());
    						} else {
    							$$invalidate("titleY", titleY = $sectionContext.scaleY(titleY));
    						}
    					}
    				}
    			}
    		}

    		if (changed.fill || changed.fillOpacity || changed.scale) {
    			 {
    				if (fill || fillOpacity) {
    					if (typeof fill === "function") {
    						$$invalidate("scale", scale = fill);
    					}

    					if (typeof fillOpacity === "function") {
    						$$invalidate("scale", scale = fillOpacity);
    					}

    					if (scale) {
    						if (scale.hasOwnProperty("domain")) {
    							if (typeof scale.domain === "function") {
    								$$invalidate("scaleDomain", scaleDomain = scale.domain());
    							} else {
    								$$invalidate("scaleDomain", scaleDomain = scale.domain);
    							}
    						}
    					} else {
    						throw new Error(`Couldn't construct legend. Please provide at least 'fill' or 'fillOpacity'
        with a scale or function that has domain and range properties or methods.`);
    					}
    				} else if (fill === undefined && fillOpacity === undefined) {
    					throw new Error(`Couldn't construct legend. Please provide at least 'fill' or 'fillOpacity'
      with a scale or function that has domain and range properties or methods.`);
    				}
    			}
    		}

    		if (changed.orient) {
    			 {
    				$$invalidate("colorBarHeight", colorBarHeight = orient === "horizontal" ? 0.75 : 1);
    				$$invalidate("colorBarWidth", colorBarWidth = orient === "horizontal" ? 0 : 0.75);
    			}
    		}

    		if (changed.labels || changed.scaleDomain || changed.labelCount || changed.labelExtra || changed.firstLabel || changed.format || changed.tickLabelText || changed.orient || changed.yCoords || changed.flip || changed.labelPaddingY || changed.flipLabels || changed.x1 || changed.colorBarHeight || changed.xCoords || changed.labelX || changed.tickLabelXCoords || changed.labelPaddingX || changed.labelFormat || changed.tickLabelYCoords || changed.colorBarWidth || changed.labelY) {
    			 {
    				let useScale = false;

    				if (labels === undefined) {
    					$$invalidate("tickLabelText", tickLabelText = getTicks(scaleDomain, labelCount, labelExtra, firstLabel));

    					$$invalidate("tickLabelText", tickLabelText = format !== undefined
    					? tickLabelText.map(format)
    					: tickLabelText);
    				} else {
    					$$invalidate("tickLabelText", tickLabelText = format !== undefined ? labels.map(format) : labels);
    					useScale = true;
    				}

    				if (orient === "vertical") {
    					$$invalidate("tickLabelYCoords", tickLabelYCoords = getTickPositions$1(tickLabelText, scaleDomain, labelExtra, yCoords, flip, orient, labelPaddingY, useScale));

    					$$invalidate("tickLabelXCoords", tickLabelXCoords = flipLabels
    					? x1 + colorBarHeight * xCoords.width
    					: x1 + (1 - colorBarHeight) * xCoords.width);

    					$$invalidate("tickLabelXCoords", tickLabelXCoords = labelX || tickLabelXCoords);

    					if (labelPaddingX !== undefined) {
    						$$invalidate("tickLabelXCoords", tickLabelXCoords = flipLabels
    						? tickLabelXCoords + labelPaddingX
    						: tickLabelXCoords - labelPaddingX);
    					}

    					$$invalidate("format", format = getFormat$1(labelFormat, scaleDomain, tickLabelYCoords.length));
    				} else if (orient === "horizontal") {
    					$$invalidate("tickLabelXCoords", tickLabelXCoords = getTickPositions$1(tickLabelText, scaleDomain, labelExtra, xCoords, flip, orient, labelPaddingX, useScale));

    					$$invalidate("tickLabelYCoords", tickLabelYCoords = flipLabels
    					? yCoords.y2 - (1 - colorBarWidth) * yCoords.height
    					: yCoords.y2 - colorBarWidth * yCoords.height);

    					$$invalidate("tickLabelYCoords", tickLabelYCoords = labelY || tickLabelYCoords);

    					if (labelPaddingY !== undefined) {
    						$$invalidate("tickLabelYCoords", tickLabelYCoords = flipLabels
    						? tickLabelYCoords - labelPaddingY
    						: tickLabelYCoords + labelPaddingY);
    					}

    					$$invalidate("format", format = getFormat$1(labelFormat, scaleDomain, tickLabelXCoords.length));
    				} else {
    					throw new Error("Could not construct legend. Please provide either 'vertical' or 'horizontal' to 'orient' prop.");
    				}
    			}
    		}

    		if (changed.fill || changed.tickLabelText || changed.scale || changed.orient || changed.tickLabelYCoords || changed.tickLabelXCoords || changed.tickColors || changed.colorBarHeight || changed.colorBarWidth || changed.flipLabels || changed.flip || changed.xCoords || changed.yCoords || changed.tickAlign || changed.labelFontSize || changed.tickOpacities || changed.fillOpacity) {
    			 {
    				if (fill) {
    					if (typeof fill === "function") {
    						$$invalidate("tickColors", tickColors = tickLabelText.map((value, i) => {
    							if (Array.isArray(scale[0]) && scale.length > 0) {
    								return fill(i);
    							} else {
    								return fill(value);
    							}
    						}));

    						if (orient === "vertical") {
    							tickLabelPositions = tickLabelYCoords;
    							$$invalidate("tickAlign", tickAlign = tickLabelXCoords);
    						} else {
    							tickLabelPositions = tickLabelXCoords;
    							$$invalidate("tickAlign", tickAlign = tickLabelYCoords);
    						}

    						$$invalidate("colorGeoms", colorGeoms = getGradientGeoms(tickColors, orient, scale, colorBarHeight, colorBarWidth, flipLabels, flip, xCoords, yCoords, tickAlign, labelFontSize));

    						if (!tickOpacities) {
    							$$invalidate("tickOpacities", tickOpacities = fillOpacity !== undefined ? fillOpacity : 1);
    						}
    					}
    				}
    			}
    		}

    		if (changed.fillOpacity || changed.tickLabelText || changed.scale || changed.orient || changed.tickLabelYCoords || changed.tickLabelXCoords || changed.labelPaddingX || changed.labelPaddingY || changed.tickOpacities || changed.colorBarHeight || changed.colorBarWidth || changed.flipLabels || changed.flip || changed.xCoords || changed.yCoords || changed.tickAlign || changed.labelFontSize || changed.labels || changed.tickColors || changed.fill) {
    			 {
    				if (fillOpacity) {
    					if (fillOpacity.constructor === Function) {
    						$$invalidate("tickOpacities", tickOpacities = tickLabelText.map((value, i) => {
    							if (Array.isArray(scale[0]) && scale.length > 0) {
    								return fillOpacity(i);
    							} else {
    								return fillOpacity(value);
    							}
    						}));
    					}

    					if (orient === "vertical") {
    						tickLabelPositions = tickLabelYCoords;
    						$$invalidate("tickAlign", tickAlign = tickLabelXCoords - labelPaddingX);
    					} else {
    						tickLabelPositions = tickLabelXCoords;
    						$$invalidate("tickAlign", tickAlign = tickLabelYCoords - labelPaddingY);
    					}

    					$$invalidate("colorGeoms", colorGeoms = getGradientGeoms(tickOpacities, orient, scale, colorBarHeight, colorBarWidth, flipLabels, flip, xCoords, yCoords, tickAlign, labelFontSize, labels));

    					if (!tickColors) {
    						$$invalidate("tickColors", tickColors = fill !== undefined ? fill : "black");
    					}
    				}
    			}
    		}

    		if (changed.colorGeoms) {
    			 {
    				$$invalidate("offsets", offsets = colorGeoms.offsets);
    				$$invalidate("gradX", gradX = colorGeoms.gradX);
    				$$invalidate("gradY", gradY = colorGeoms.gradY);
    				$$invalidate("rectCoords", rectCoords = colorGeoms.rectCoords);
    			}
    		}
    	};

    	return {
    		gradientId,
    		x1,
    		x2,
    		y1,
    		y2,
    		orient,
    		vjust,
    		height,
    		hjust,
    		width,
    		xOffset,
    		yOffset,
    		usePadding,
    		flip,
    		flipLabels,
    		stroke,
    		strokeWidth,
    		fill,
    		fillOpacity,
    		labels,
    		labelFormat,
    		labelRotate,
    		labelX,
    		labelY,
    		labelFont,
    		labelFontSize,
    		labelFontWeight,
    		labelOpacity,
    		labelColor,
    		labelAnchorPoint,
    		labelCount,
    		labelExtra,
    		firstLabel,
    		format,
    		labelPaddingX,
    		labelPaddingY,
    		titleHjust,
    		titleXOffset,
    		titleX,
    		titleVjust,
    		titleYOffset,
    		titleY,
    		title,
    		titleColor,
    		titleFont,
    		titleFontSize,
    		titleFontWeight,
    		titleOpacity,
    		titleRotation,
    		titleAnchorPoint,
    		titlePaddingX,
    		titlePaddingY,
    		transition,
    		zoomIdentity,
    		sectionContext,
    		tickLabelText,
    		tickLabelXCoords,
    		tickLabelYCoords,
    		tickColors,
    		tickOpacities,
    		offsets,
    		gradX,
    		gradY,
    		rectCoords,
    		func,
    		func_1,
    		func_2,
    		func_3,
    		func_4,
    		func_5,
    		func_6,
    		func_7
    	};
    }

    class GradientLegend extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {
    			x1: 0,
    			x2: 0,
    			y1: 0,
    			y2: 0,
    			orient: 0,
    			vjust: 0,
    			height: 0,
    			hjust: 0,
    			width: 0,
    			xOffset: 0,
    			yOffset: 0,
    			usePadding: 0,
    			flip: 0,
    			flipLabels: 0,
    			stroke: 0,
    			strokeWidth: 0,
    			fill: 0,
    			fillOpacity: 0,
    			labels: 0,
    			labelFormat: 0,
    			labelRotate: 0,
    			labelX: 0,
    			labelY: 0,
    			labelFont: 0,
    			labelFontSize: 0,
    			labelFontWeight: 0,
    			labelOpacity: 0,
    			labelColor: 0,
    			labelAnchorPoint: 0,
    			labelCount: 0,
    			labelExtra: 0,
    			firstLabel: 0,
    			format: 0,
    			labelPaddingX: 0,
    			labelPaddingY: 0,
    			titleHjust: 0,
    			titleXOffset: 0,
    			titleX: 0,
    			titleVjust: 0,
    			titleYOffset: 0,
    			titleY: 0,
    			title: 0,
    			titleColor: 0,
    			titleFont: 0,
    			titleFontSize: 0,
    			titleFontWeight: 0,
    			titleOpacity: 0,
    			titleRotation: 0,
    			titleAnchorPoint: 0,
    			titlePaddingX: 0,
    			titlePaddingY: 0,
    			transition: 0,
    			zoomIdentity: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GradientLegend",
    			options,
    			id: create_fragment$o.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || ({});

    		if (ctx.transition === undefined && !("transition" in props)) {
    			console.warn("<GradientLegend> was created without expected prop 'transition'");
    		}

    		if (ctx.zoomIdentity === undefined && !("zoomIdentity" in props)) {
    			console.warn("<GradientLegend> was created without expected prop 'zoomIdentity'");
    		}
    	}

    	get x1() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x1(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get x2() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x2(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y1() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y1(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y2() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y2(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get orient() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set orient(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get vjust() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set vjust(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hjust() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hjust(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xOffset() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xOffset(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get yOffset() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set yOffset(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get usePadding() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set usePadding(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flip() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flip(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flipLabels() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flipLabels(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stroke() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stroke(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strokeWidth() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strokeWidth(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fill() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fill(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillOpacity() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillOpacity(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labels() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labels(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelFormat() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelFormat(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelRotate() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelRotate(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelX() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelX(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelY() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelY(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelFont() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelFont(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelFontSize() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelFontSize(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelFontWeight() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelFontWeight(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelOpacity() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelOpacity(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelColor() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelColor(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelAnchorPoint() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelAnchorPoint(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelCount() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelCount(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelExtra() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelExtra(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get firstLabel() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set firstLabel(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get format() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set format(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelPaddingX() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelPaddingX(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelPaddingY() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelPaddingY(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleHjust() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleHjust(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleXOffset() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleXOffset(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleX() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleX(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleVjust() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleVjust(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleYOffset() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleYOffset(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleY() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleY(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleColor() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleColor(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleFont() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleFont(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleFontSize() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleFontSize(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleFontWeight() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleFontWeight(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleOpacity() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleOpacity(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleRotation() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleRotation(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleAnchorPoint() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleAnchorPoint(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titlePaddingX() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titlePaddingX(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titlePaddingY() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titlePaddingY(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transition() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transition(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zoomIdentity() {
    		throw new Error_1$1("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoomIdentity(value) {
    		throw new Error_1$1("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var florenceDatacontainer_umd = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
       module.exports = factory() ;
    }(commonjsGlobal, function () {
      var obj;
      var NOTHING = typeof Symbol !== "undefined" ? Symbol("immer-nothing") : ( obj = {}, obj["immer-nothing"] = true, obj );
      var DRAFTABLE = typeof Symbol !== "undefined" && Symbol.for ? Symbol.for("immer-draftable") : "__$immer_draftable";
      var DRAFT_STATE = typeof Symbol !== "undefined" && Symbol.for ? Symbol.for("immer-state") : "__$immer_state";
      function isDraft(value) {
        return !!value && !!value[DRAFT_STATE];
      }
      function isDraftable(value) {
        if (!value) { return false; }
        return isPlainObject(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE];
      }
      function isPlainObject(value) {
        if (!value || typeof value !== "object") { return false; }
        if (Array.isArray(value)) { return true; }
        var proto = Object.getPrototypeOf(value);
        return !proto || proto === Object.prototype;
      }
      var assign = Object.assign || function assign(target, value) {
        for (var key in value) {
          if (has(value, key)) {
            target[key] = value[key];
          }
        }

        return target;
      };
      var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== "undefined" ? function (obj) { return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj)); } : Object.getOwnPropertyNames;
      function shallowCopy(base, invokeGetters) {
        if ( invokeGetters === void 0 ) invokeGetters = false;

        if (Array.isArray(base)) { return base.slice(); }
        var clone = Object.create(Object.getPrototypeOf(base));
        ownKeys(base).forEach(function (key) {
          if (key === DRAFT_STATE) {
            return; // Never copy over draft state.
          }

          var desc = Object.getOwnPropertyDescriptor(base, key);
          var value = desc.value;

          if (desc.get) {
            if (!invokeGetters) {
              throw new Error("Immer drafts cannot have computed properties");
            }

            value = desc.get.call(base);
          }

          if (desc.enumerable) {
            clone[key] = value;
          } else {
            Object.defineProperty(clone, key, {
              value: value,
              writable: true,
              configurable: true
            });
          }
        });
        return clone;
      }
      function each(value, cb) {
        if (Array.isArray(value)) {
          for (var i = 0; i < value.length; i++) { cb(i, value[i], value); }
        } else {
          ownKeys(value).forEach(function (key) { return cb(key, value[key], value); });
        }
      }
      function isEnumerable(base, prop) {
        var desc = Object.getOwnPropertyDescriptor(base, prop);
        return !!desc && desc.enumerable;
      }
      function has(thing, prop) {
        return Object.prototype.hasOwnProperty.call(thing, prop);
      }
      function is(x, y) {
        // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function clone(obj) {
        if (!isDraftable(obj)) { return obj; }
        if (Array.isArray(obj)) { return obj.map(clone); }
        var cloned = Object.create(Object.getPrototypeOf(obj));

        for (var key in obj) { cloned[key] = clone(obj[key]); }

        return cloned;
      }
      function deepFreeze(obj) {
        if (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) { return; }
        Object.freeze(obj);
        if (Array.isArray(obj)) { obj.forEach(deepFreeze); }else { for (var key in obj) { deepFreeze(obj[key]); } }
      }

      /** Each scope represents a `produce` call. */

      var ImmerScope = function ImmerScope(parent) {
        this.drafts = [];
        this.parent = parent; // Whenever the modified draft contains a draft from another scope, we
        // need to prevent auto-freezing so the unowned draft can be finalized.

        this.canAutoFreeze = true; // To avoid prototype lookups:

        this.patches = null;
      };

      ImmerScope.prototype.usePatches = function usePatches (patchListener) {
        if (patchListener) {
          this.patches = [];
          this.inversePatches = [];
          this.patchListener = patchListener;
        }
      };

      ImmerScope.prototype.revoke = function revoke$1 () {
        this.leave();
        this.drafts.forEach(revoke);
        this.drafts = null; // Make draft-related methods throw.
      };

      ImmerScope.prototype.leave = function leave () {
        if (this === ImmerScope.current) {
          ImmerScope.current = this.parent;
        }
      };
      ImmerScope.current = null;

      ImmerScope.enter = function () {
        return this.current = new ImmerScope(this.current);
      };

      function revoke(draft) {
        draft[DRAFT_STATE].revoke();
      }

      // but share them all instead

      var descriptors = {};
      function willFinalize(scope, result, isReplaced) {
        scope.drafts.forEach(function (draft) {
          draft[DRAFT_STATE].finalizing = true;
        });

        if (!isReplaced) {
          if (scope.patches) {
            markChangesRecursively(scope.drafts[0]);
          } // This is faster when we don't care about which attributes changed.


          markChangesSweep(scope.drafts);
        } // When a child draft is returned, look for changes.
        else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {
            markChangesSweep(scope.drafts);
          }
      }
      function createProxy(base, parent) {
        var isArray = Array.isArray(base);
        var draft = clonePotentialDraft(base);
        each(draft, function (prop) {
          proxyProperty(draft, prop, isArray || isEnumerable(base, prop));
        }); // See "proxy.js" for property documentation.

        var scope = parent ? parent.scope : ImmerScope.current;
        var state = {
          scope: scope,
          modified: false,
          finalizing: false,
          // es5 only
          finalized: false,
          assigned: {},
          parent: parent,
          base: base,
          draft: draft,
          copy: null,
          revoke: revoke$1,
          revoked: false // es5 only

        };
        createHiddenProperty(draft, DRAFT_STATE, state);
        scope.drafts.push(draft);
        return draft;
      }

      function revoke$1() {
        this.revoked = true;
      }

      function source(state) {
        return state.copy || state.base;
      } // Access a property without creating an Immer draft.


      function peek(draft, prop) {
        var state = draft[DRAFT_STATE];

        if (state && !state.finalizing) {
          state.finalizing = true;
          var value = draft[prop];
          state.finalizing = false;
          return value;
        }

        return draft[prop];
      }

      function get(state, prop) {
        assertUnrevoked(state);
        var value = peek(source(state), prop);
        if (state.finalizing) { return value; } // Create a draft if the value is unmodified.

        if (value === peek(state.base, prop) && isDraftable(value)) {
          prepareCopy(state);
          return state.copy[prop] = createProxy(value, state);
        }

        return value;
      }

      function set(state, prop, value) {
        assertUnrevoked(state);
        state.assigned[prop] = true;

        if (!state.modified) {
          if (is(value, peek(source(state), prop))) { return; }
          markChanged(state);
          prepareCopy(state);
        }

        state.copy[prop] = value;
      }

      function markChanged(state) {
        if (!state.modified) {
          state.modified = true;
          if (state.parent) { markChanged(state.parent); }
        }
      }

      function prepareCopy(state) {
        if (!state.copy) { state.copy = clonePotentialDraft(state.base); }
      }

      function clonePotentialDraft(base) {
        var state = base && base[DRAFT_STATE];

        if (state) {
          state.finalizing = true;
          var draft = shallowCopy(state.draft, true);
          state.finalizing = false;
          return draft;
        }

        return shallowCopy(base);
      }

      function proxyProperty(draft, prop, enumerable) {
        var desc = descriptors[prop];

        if (desc) {
          desc.enumerable = enumerable;
        } else {
          descriptors[prop] = desc = {
            configurable: true,
            enumerable: enumerable,

            get: function get$1() {
              return get(this[DRAFT_STATE], prop);
            },

            set: function set$1(value) {
              set(this[DRAFT_STATE], prop, value);
            }

          };
        }

        Object.defineProperty(draft, prop, desc);
      }

      function assertUnrevoked(state) {
        if (state.revoked === true) { throw new Error("Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + JSON.stringify(source(state))); }
      } // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.


      function markChangesSweep(drafts) {
        // The natural order of drafts in the `scope` array is based on when they
        // were accessed. By processing drafts in reverse natural order, we have a
        // better chance of processing leaf nodes first. When a leaf node is known to
        // have changed, we can avoid any traversal of its ancestor nodes.
        for (var i = drafts.length - 1; i >= 0; i--) {
          var state = drafts[i][DRAFT_STATE];

          if (!state.modified) {
            if (Array.isArray(state.base)) {
              if (hasArrayChanges(state)) { markChanged(state); }
            } else if (hasObjectChanges(state)) { markChanged(state); }
          }
        }
      }

      function markChangesRecursively(object) {
        if (!object || typeof object !== "object") { return; }
        var state = object[DRAFT_STATE];
        if (!state) { return; }
        var base = state.base;
        var draft = state.draft;
        var assigned = state.assigned;

        if (!Array.isArray(object)) {
          // Look for added keys.
          Object.keys(draft).forEach(function (key) {
            // The `undefined` check is a fast path for pre-existing keys.
            if (base[key] === undefined && !has(base, key)) {
              assigned[key] = true;
              markChanged(state);
            } else if (!assigned[key]) {
              // Only untouched properties trigger recursion.
              markChangesRecursively(draft[key]);
            }
          }); // Look for removed keys.

          Object.keys(base).forEach(function (key) {
            // The `undefined` check is a fast path for pre-existing keys.
            if (draft[key] === undefined && !has(draft, key)) {
              assigned[key] = false;
              markChanged(state);
            }
          });
        } else if (hasArrayChanges(state)) {
          markChanged(state);
          assigned.length = true;

          if (draft.length < base.length) {
            for (var i = draft.length; i < base.length; i++) { assigned[i] = false; }
          } else {
            for (var i$1 = base.length; i$1 < draft.length; i$1++) { assigned[i$1] = true; }
          }

          for (var i$2 = 0; i$2 < draft.length; i$2++) {
            // Only untouched indices trigger recursion.
            if (assigned[i$2] === undefined) { markChangesRecursively(draft[i$2]); }
          }
        }
      }

      function hasObjectChanges(state) {
        var base = state.base;
        var draft = state.draft; // Search for added keys and changed keys. Start at the back, because
        // non-numeric keys are ordered by time of definition on the object.

        var keys = Object.keys(draft);

        for (var i = keys.length - 1; i >= 0; i--) {
          var key = keys[i];
          var baseValue = base[key]; // The `undefined` check is a fast path for pre-existing keys.

          if (baseValue === undefined && !has(base, key)) {
            return true;
          } // Once a base key is deleted, future changes go undetected, because its
          // descriptor is erased. This branch detects any missed changes.
          else {
              var value = draft[key];
              var state$1 = value && value[DRAFT_STATE];

              if (state$1 ? state$1.base !== baseValue : !is(value, baseValue)) {
                return true;
              }
            }
        } // At this point, no keys were added or changed.
        // Compare key count to determine if keys were deleted.


        return keys.length !== Object.keys(base).length;
      }

      function hasArrayChanges(state) {
        var draft = state.draft;
        if (draft.length !== state.base.length) { return true; } // See #116
        // If we first shorten the length, our array interceptors will be removed.
        // If after that new items are added, result in the same original length,
        // those last items will have no intercepting property.
        // So if there is no own descriptor on the last position, we know that items were removed and added
        // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check
        // the last one

        var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)

        if (descriptor && !descriptor.get) { return true; } // For all other cases, we don't have to compare, as they would have been picked up by the index setters

        return false;
      }

      function createHiddenProperty(target, prop, value) {
        Object.defineProperty(target, prop, {
          value: value,
          enumerable: false,
          writable: true
        });
      }

      var legacyProxy = /*#__PURE__*/Object.freeze({
      	willFinalize: willFinalize,
      	createProxy: createProxy
      });

      function willFinalize$1() {}
      function createProxy$1(base, parent) {
        var scope = parent ? parent.scope : ImmerScope.current;
        var state = {
          // Track which produce call this is associated with.
          scope: scope,
          // True for both shallow and deep changes.
          modified: false,
          // Used during finalization.
          finalized: false,
          // Track which properties have been assigned (true) or deleted (false).
          assigned: {},
          // The parent draft state.
          parent: parent,
          // The base state.
          base: base,
          // The base proxy.
          draft: null,
          // Any property proxies.
          drafts: {},
          // The base copy with any updated values.
          copy: null,
          // Called by the `produce` function.
          revoke: null
        };
        var ref = Array.isArray(base) ? // [state] is used for arrays, to make sure the proxy is array-ish and not violate invariants,
        // although state itself is an object
        Proxy.revocable([state], arrayTraps) : Proxy.revocable(state, objectTraps);
        var revoke = ref.revoke;
        var proxy = ref.proxy;
        state.draft = proxy;
        state.revoke = revoke;
        scope.drafts.push(proxy);
        return proxy;
      }
      var objectTraps = {
        get: get$1,

        has: function has(target, prop) {
          return prop in source$1(target);
        },

        ownKeys: function ownKeys(target) {
          return Reflect.ownKeys(source$1(target));
        },

        set: set$1,
        deleteProperty: deleteProperty,
        getOwnPropertyDescriptor: getOwnPropertyDescriptor,

        defineProperty: function defineProperty() {
          throw new Error("Object.defineProperty() cannot be used on an Immer draft"); // prettier-ignore
        },

        getPrototypeOf: function getPrototypeOf(target) {
          return Object.getPrototypeOf(target.base);
        },

        setPrototypeOf: function setPrototypeOf() {
          throw new Error("Object.setPrototypeOf() cannot be used on an Immer draft"); // prettier-ignore
        }

      };
      var arrayTraps = {};
      each(objectTraps, function (key, fn) {
        arrayTraps[key] = function () {
          arguments[0] = arguments[0][0];
          return fn.apply(this, arguments);
        };
      });

      arrayTraps.deleteProperty = function (state, prop) {
        if (isNaN(parseInt(prop))) {
          throw new Error("Immer only supports deleting array indices"); // prettier-ignore
        }

        return objectTraps.deleteProperty.call(this, state[0], prop);
      };

      arrayTraps.set = function (state, prop, value) {
        if (prop !== "length" && isNaN(parseInt(prop))) {
          throw new Error("Immer only supports setting array indices and the 'length' property"); // prettier-ignore
        }

        return objectTraps.set.call(this, state[0], prop, value);
      }; // returns the object we should be reading the current value from, which is base, until some change has been made


      function source$1(state) {
        return state.copy || state.base;
      } // Access a property without creating an Immer draft.


      function peek$1(draft, prop) {
        var state = draft[DRAFT_STATE];
        var desc = Reflect.getOwnPropertyDescriptor(state ? source$1(state) : draft, prop);
        return desc && desc.value;
      }

      function get$1(state, prop) {
        if (prop === DRAFT_STATE) { return state; }
        var drafts = state.drafts; // Check for existing draft in unmodified state.

        if (!state.modified && has(drafts, prop)) {
          return drafts[prop];
        }

        var value = source$1(state)[prop];

        if (state.finalized || !isDraftable(value)) {
          return value;
        } // Check for existing draft in modified state.


        if (state.modified) {
          // Assigned values are never drafted. This catches any drafts we created, too.
          if (value !== peek$1(state.base, prop)) { return value; } // Store drafts on the copy (when one exists).

          drafts = state.copy;
        }

        return drafts[prop] = createProxy$1(value, state);
      }

      function set$1(state, prop, value) {
        if (!state.modified) {
          var baseValue = peek$1(state.base, prop); // Optimize based on value's truthiness. Truthy values are guaranteed to
          // never be undefined, so we can avoid the `in` operator. Lastly, truthy
          // values may be drafts, but falsy values are never drafts.

          var isUnchanged = value ? is(baseValue, value) || value === state.drafts[prop] : is(baseValue, value) && prop in state.base;
          if (isUnchanged) { return true; }
          markChanged$1(state);
        }

        state.assigned[prop] = true;
        state.copy[prop] = value;
        return true;
      }

      function deleteProperty(state, prop) {
        // The `undefined` check is a fast path for pre-existing keys.
        if (peek$1(state.base, prop) !== undefined || prop in state.base) {
          state.assigned[prop] = false;
          markChanged$1(state);
        } else if (state.assigned[prop]) {
          // if an originally not assigned property was deleted
          delete state.assigned[prop];
        }

        if (state.copy) { delete state.copy[prop]; }
        return true;
      } // Note: We never coerce `desc.value` into an Immer draft, because we can't make
      // the same guarantee in ES5 mode.


      function getOwnPropertyDescriptor(state, prop) {
        var owner = source$1(state);
        var desc = Reflect.getOwnPropertyDescriptor(owner, prop);

        if (desc) {
          desc.writable = true;
          desc.configurable = !Array.isArray(owner) || prop !== "length";
        }

        return desc;
      }

      function markChanged$1(state) {
        if (!state.modified) {
          state.modified = true;
          state.copy = assign(shallowCopy(state.base), state.drafts);
          state.drafts = null;
          if (state.parent) { markChanged$1(state.parent); }
        }
      }

      var modernProxy = /*#__PURE__*/Object.freeze({
      	willFinalize: willFinalize$1,
      	createProxy: createProxy$1
      });

      function generatePatches(state, basePath, patches, inversePatches) {
        Array.isArray(state.base) ? generateArrayPatches(state, basePath, patches, inversePatches) : generateObjectPatches(state, basePath, patches, inversePatches);
      }

      function generateArrayPatches(state, basePath, patches, inversePatches) {
        var assign, assign$1;

        var base = state.base;
        var copy = state.copy;
        var assigned = state.assigned; // Reduce complexity by ensuring `base` is never longer.

        if (copy.length < base.length) {
          (assign = [copy, base], base = assign[0], copy = assign[1]);
          (assign$1 = [inversePatches, patches], patches = assign$1[0], inversePatches = assign$1[1]);
        }

        var delta = copy.length - base.length; // Find the first replaced index.

        var start = 0;

        while (base[start] === copy[start] && start < base.length) {
          ++start;
        } // Find the last replaced index. Search from the end to optimize splice patches.


        var end = base.length;

        while (end > start && base[end - 1] === copy[end + delta - 1]) {
          --end;
        } // Process replaced indices.


        for (var i = start; i < end; ++i) {
          if (assigned[i] && copy[i] !== base[i]) {
            var path = basePath.concat([i]);
            patches.push({
              op: "replace",
              path: path,
              value: copy[i]
            });
            inversePatches.push({
              op: "replace",
              path: path,
              value: base[i]
            });
          }
        }

        var replaceCount = patches.length; // Process added indices.

        for (var i$1 = end + delta - 1; i$1 >= end; --i$1) {
          var path$1 = basePath.concat([i$1]);
          patches[replaceCount + i$1 - end] = {
            op: "add",
            path: path$1,
            value: copy[i$1]
          };
          inversePatches.push({
            op: "remove",
            path: path$1
          });
        }
      }

      function generateObjectPatches(state, basePath, patches, inversePatches) {
        var base = state.base;
        var copy = state.copy;
        each(state.assigned, function (key, assignedValue) {
          var origValue = base[key];
          var value = copy[key];
          var op = !assignedValue ? "remove" : key in base ? "replace" : "add";
          if (origValue === value && op === "replace") { return; }
          var path = basePath.concat(key);
          patches.push(op === "remove" ? {
            op: op,
            path: path
          } : {
            op: op,
            path: path,
            value: value
          });
          inversePatches.push(op === "add" ? {
            op: "remove",
            path: path
          } : op === "remove" ? {
            op: "add",
            path: path,
            value: origValue
          } : {
            op: "replace",
            path: path,
            value: origValue
          });
        });
      }

      var applyPatches = function (draft, patches) {
        for (var i$1 = 0, list = patches; i$1 < list.length; i$1 += 1) {
          var patch = list[i$1];

          var path = patch.path;
          var op = patch.op;
          var value = clone(patch.value); // used to clone patch to ensure original patch is not modified, see #411

          if (!path.length) { throw new Error("Illegal state"); }
          var base = draft;

          for (var i = 0; i < path.length - 1; i++) {
            base = base[path[i]];
            if (!base || typeof base !== "object") { throw new Error("Cannot apply patch, path doesn't resolve: " + path.join("/")); } // prettier-ignore
          }

          var key = path[path.length - 1];

          switch (op) {
            case "replace":
              // if value is an object, then it's assigned by reference
              // in the following add or remove ops, the value field inside the patch will also be modifyed
              // so we use value from the cloned patch
              base[key] = value;
              break;

            case "add":
              if (Array.isArray(base)) {
                // TODO: support "foo/-" paths for appending to an array
                base.splice(key, 0, value);
              } else {
                base[key] = value;
              }

              break;

            case "remove":
              if (Array.isArray(base)) {
                base.splice(key, 1);
              } else {
                delete base[key];
              }

              break;

            default:
              throw new Error("Unsupported patch operation: " + op);
          }
        }

        return draft;
      };

      function verifyMinified() {}

      var configDefaults = {
        useProxies: typeof Proxy !== "undefined" && typeof Reflect !== "undefined",
        autoFreeze: typeof process !== "undefined" ? process.env.NODE_ENV !== "production" : verifyMinified.name === "verifyMinified",
        onAssign: null,
        onDelete: null,
        onCopy: null
      };
      var Immer = function Immer(config) {
        assign(this, configDefaults, config);
        this.setUseProxies(this.useProxies);
        this.produce = this.produce.bind(this);
      };

      Immer.prototype.produce = function produce (base, recipe, patchListener) {
          var this$1 = this;

        // curried invocation
        if (typeof base === "function" && typeof recipe !== "function") {
          var defaultBase = recipe;
          recipe = base;
          var self = this;
          return function curriedProduce(base) {
              var this$1 = this;
              if ( base === void 0 ) base = defaultBase;
              var args = [], len = arguments.length - 1;
              while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

            return self.produce(base, function (draft) { return recipe.call.apply(recipe, [ this$1, draft ].concat( args )); }); // prettier-ignore
          };
        } // prettier-ignore


        {
          if (typeof recipe !== "function") {
            throw new Error("The first or second argument to `produce` must be a function");
          }

          if (patchListener !== undefined && typeof patchListener !== "function") {
            throw new Error("The third argument to `produce` must be a function or undefined");
          }
        }
        var result; // Only plain objects, arrays, and "immerable classes" are drafted.

        if (isDraftable(base)) {
          var scope = ImmerScope.enter();
          var proxy = this.createProxy(base);
          var hasError = true;

          try {
            result = recipe(proxy);
            hasError = false;
          } finally {
            // finally instead of catch + rethrow better preserves original stack
            if (hasError) { scope.revoke(); }else { scope.leave(); }
          }

          if (result instanceof Promise) {
            return result.then(function (result) {
              scope.usePatches(patchListener);
              return this$1.processResult(result, scope);
            }, function (error) {
              scope.revoke();
              throw error;
            });
          }

          scope.usePatches(patchListener);
          return this.processResult(result, scope);
        } else {
          result = recipe(base);
          if (result === NOTHING) { return undefined; }
          if (result === undefined) { result = base; }
          this.maybeFreeze(result, true);
          return result;
        }
      };

      Immer.prototype.produceWithPatches = function produceWithPatches (arg1, arg2, arg3) {
          var this$1 = this;

        if (typeof arg1 === "function") {
          return function (state) {
              var args = [], len = arguments.length - 1;
              while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

              return this$1.produceWithPatches(state, function (draft) { return arg1.apply(void 0, [ draft ].concat( args )); });
            };
        } // non-curried form


        if (arg3) { throw new Error("A patch listener cannot be passed to produceWithPatches"); }
        var patches, inversePatches;
        var nextState = this.produce(arg1, arg2, function (p, ip) {
          patches = p;
          inversePatches = ip;
        });
        return [nextState, patches, inversePatches];
      };

      Immer.prototype.createDraft = function createDraft (base) {
        if (!isDraftable(base)) {
          throw new Error("First argument to `createDraft` must be a plain object, an array, or an immerable object"); // prettier-ignore
        }

        var scope = ImmerScope.enter();
        var proxy = this.createProxy(base);
        proxy[DRAFT_STATE].isManual = true;
        scope.leave();
        return proxy;
      };

      Immer.prototype.finishDraft = function finishDraft (draft, patchListener) {
        var state = draft && draft[DRAFT_STATE];

        if (!state || !state.isManual) {
          throw new Error("First argument to `finishDraft` must be a draft returned by `createDraft`"); // prettier-ignore
        }

        if (state.finalized) {
          throw new Error("The given draft is already finalized"); // prettier-ignore
        }

        var scope = state.scope;
        scope.usePatches(patchListener);
        return this.processResult(undefined, scope);
      };

      Immer.prototype.setAutoFreeze = function setAutoFreeze (value) {
        this.autoFreeze = value;
      };

      Immer.prototype.setUseProxies = function setUseProxies (value) {
        this.useProxies = value;
        assign(this, value ? modernProxy : legacyProxy);
      };

      Immer.prototype.applyPatches = function applyPatches$1 (base, patches) {
        // If a patch replaces the entire state, take that replacement as base
        // before applying patches
        var i;

        for (i = patches.length - 1; i >= 0; i--) {
          var patch = patches[i];

          if (patch.path.length === 0 && patch.op === "replace") {
            base = patch.value;
            break;
          }
        }

        if (isDraft(base)) {
          // N.B: never hits if some patch a replacement, patches are never drafts
          return applyPatches(base, patches);
        } // Otherwise, produce a copy of the base state.


        return this.produce(base, function (draft) { return applyPatches(draft, patches.slice(i + 1)); });
      };
      /** @internal */


      Immer.prototype.processResult = function processResult (result, scope) {
        var baseDraft = scope.drafts[0];
        var isReplaced = result !== undefined && result !== baseDraft;
        this.willFinalize(scope, result, isReplaced);

        if (isReplaced) {
          if (baseDraft[DRAFT_STATE].modified) {
            scope.revoke();
            throw new Error("An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft."); // prettier-ignore
          }

          if (isDraftable(result)) {
            // Finalize the result in case it contains (or is) a subset of the draft.
            result = this.finalize(result, null, scope);
            this.maybeFreeze(result);
          }

          if (scope.patches) {
            scope.patches.push({
              op: "replace",
              path: [],
              value: result
            });
            scope.inversePatches.push({
              op: "replace",
              path: [],
              value: baseDraft[DRAFT_STATE].base
            });
          }
        } else {
          // Finalize the base draft.
          result = this.finalize(baseDraft, [], scope);
        }

        scope.revoke();

        if (scope.patches) {
          scope.patchListener(scope.patches, scope.inversePatches);
        }

        return result !== NOTHING ? result : undefined;
      };
      /**
       * @internal
       * Finalize a draft, returning either the unmodified base state or a modified
       * copy of the base state.
       */


      Immer.prototype.finalize = function finalize (draft, path, scope) {
          var this$1 = this;

        var state = draft[DRAFT_STATE];

        if (!state) {
          if (Object.isFrozen(draft)) { return draft; }
          return this.finalizeTree(draft, null, scope);
        } // Never finalize drafts owned by another scope.


        if (state.scope !== scope) {
          return draft;
        }

        if (!state.modified) {
          this.maybeFreeze(state.base, true);
          return state.base;
        }

        if (!state.finalized) {
          state.finalized = true;
          this.finalizeTree(state.draft, path, scope);

          if (this.onDelete) {
            // The `assigned` object is unreliable with ES5 drafts.
            if (this.useProxies) {
              var assigned = state.assigned;

              for (var prop in assigned) {
                if (!assigned[prop]) { this.onDelete(state, prop); }
              }
            } else {
              var base = state.base;
                var copy = state.copy;
              each(base, function (prop) {
                if (!has(copy, prop)) { this$1.onDelete(state, prop); }
              });
            }
          }

          if (this.onCopy) {
            this.onCopy(state);
          } // At this point, all descendants of `state.copy` have been finalized,
          // so we can be sure that `scope.canAutoFreeze` is accurate.


          if (this.autoFreeze && scope.canAutoFreeze) {
            Object.freeze(state.copy);
          }

          if (path && scope.patches) {
            generatePatches(state, path, scope.patches, scope.inversePatches);
          }
        }

        return state.copy;
      };
      /**
       * @internal
       * Finalize all drafts in the given state tree.
       */


      Immer.prototype.finalizeTree = function finalizeTree (root, rootPath, scope) {
          var this$1 = this;

        var state = root[DRAFT_STATE];

        if (state) {
          if (!this.useProxies) {
            // Create the final copy, with added keys and without deleted keys.
            state.copy = shallowCopy(state.draft, true);
          }

          root = state.copy;
        }

        var needPatches = !!rootPath && !!scope.patches;

        var finalizeProperty = function (prop, value, parent) {
          if (value === parent) {
            throw Error("Immer forbids circular references");
          } // In the `finalizeTree` method, only the `root` object may be a draft.


          var isDraftProp = !!state && parent === root;

          if (isDraft(value)) {
            var path = isDraftProp && needPatches && !state.assigned[prop] ? rootPath.concat(prop) : null; // Drafts owned by `scope` are finalized here.

            value = this$1.finalize(value, path, scope); // Drafts from another scope must prevent auto-freezing.

            if (isDraft(value)) {
              scope.canAutoFreeze = false;
            } // Preserve non-enumerable properties.


            if (Array.isArray(parent) || isEnumerable(parent, prop)) {
              parent[prop] = value;
            } else {
              Object.defineProperty(parent, prop, {
                value: value
              });
            } // Unchanged drafts are never passed to the `onAssign` hook.


            if (isDraftProp && value === state.base[prop]) { return; }
          } // Unchanged draft properties are ignored.
          else if (isDraftProp && is(value, state.base[prop])) {
              return;
            } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.
            else if (isDraftable(value) && !Object.isFrozen(value)) {
                each(value, finalizeProperty);
                this$1.maybeFreeze(value);
              }

          if (isDraftProp && this$1.onAssign) {
            this$1.onAssign(state, prop, value);
          }
        };

        each(root, finalizeProperty);
        return root;
      };

      Immer.prototype.maybeFreeze = function maybeFreeze (value, deep) {
          if ( deep === void 0 ) deep = false;

        if (this.autoFreeze && !isDraft(value)) {
          if (deep) { deepFreeze(value); }else { Object.freeze(value); }
        }
      };

      var immer = new Immer();
      /**
       * The `produce` function takes a value and a "recipe function" (whose
       * return value often depends on the base state). The recipe function is
       * free to mutate its first argument however it wants. All mutations are
       * only ever applied to a __copy__ of the base state.
       *
       * Pass only a function to create a "curried producer" which relieves you
       * from passing the recipe function every time.
       *
       * Only plain objects and arrays are made mutable. All other objects are
       * considered uncopyable.
       *
       * Note: This function is __bound__ to its `Immer` instance.
       *
       * @param {any} base - the initial state
       * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
       * @param {Function} patchListener - optional function that will be called with all the patches produced here
       * @returns {any} a new state, or the initial state if nothing was modified
       */

      var produce = immer.produce;
      /**
       * Like `produce`, but `produceWithPatches` always returns a tuple
       * [nextState, patches, inversePatches] (instead of just the next state)
       */

      var produceWithPatches = immer.produceWithPatches.bind(immer);
      /**
       * Pass true to automatically freeze all copies created by Immer.
       *
       * By default, auto-freezing is disabled in production.
       */

      var setAutoFreeze = immer.setAutoFreeze.bind(immer);
      /**
       * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
       * always faster than using ES5 proxies.
       *
       * By default, feature detection is used, so calling this is rarely necessary.
       */

      var setUseProxies = immer.setUseProxies.bind(immer);
      /**
       * Apply an array of Immer patches to the first argument.
       *
       * This function is a producer, which means copy-on-write is in effect.
       */

      var applyPatches$1 = immer.applyPatches.bind(immer);
      /**
       * Create an Immer draft from the given base state, which may be a draft itself.
       * The draft can be modified until you finalize it with the `finishDraft` function.
       */

      var createDraft = immer.createDraft.bind(immer);
      /**
       * Finalize an Immer draft from a `createDraft` call, returning the base state
       * (if no changes were made) or a modified copy. The draft must *not* be
       * mutated afterwards.
       *
       * Pass a function as the 2nd argument to generate Immer patches based on the
       * changes that were made.
       */

      var finishDraft = immer.finishDraft.bind(immer);

      function isColumnOriented (data) {
        if (data.constructor === Object) {
          const columns = Object.keys(data).map(key => data[key]);
          return columns.every(column => column.constructor === Array)
        }

        return false
      }

      function isRowOriented (data) {
        if (data.constructor === Array) {
          return data.every(row => row.constructor === Object)
        }

        return false
      }

      function isGeoJSON (data) {
        const hasCorrectType = data.type === 'FeatureCollection';
        const hasCorrectFeatures = data.features && data.features.length > 0;

        return hasCorrectType && hasCorrectFeatures
      }

      function checkFormatColumnData (data) {
        checkFormat(data, checkRegularColumnName);
      }

      function checkFormatInternal (data) {
        checkFormat(data, checkInternalDataColumnName);
      }

      function checkFormat (data, columnNameChecker) {
        let dataLength = null;

        for (const columnName in data) {
          columnNameChecker(columnName);
          const column = data[columnName];

          dataLength = dataLength || column.length;

          if (dataLength === 0) {
            throw new Error('Invalid data: columns cannot be empty')
          }

          if (dataLength !== column.length) {
            throw new Error('Invalid data: columns must be of same length')
          }
        }
      }

      function checkRegularColumnName (columnName) {
        if (columnName.match(forbiddenChars)) {
          throw new Error(`Invalid column name '${columnName}': '$' and '/' are not allowed'`)
        }
      }

      const forbiddenChars = /[/$]/;

      function checkInternalDataColumnName (columnName) {
        if (!['$key', '$geometry', '$grouped'].includes(columnName)) {
          checkRegularColumnName(columnName);
        }
      }

      // Adds floating point numbers with twice the normal precision.
      // Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
      // Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
      // 305–363 (1997).
      // Code adapted from GeographicLib by Charles F. F. Karney,
      // http://geographiclib.sourceforge.net/

      function adder() {
        return new Adder;
      }

      function Adder() {
        this.reset();
      }

      Adder.prototype = {
        constructor: Adder,
        reset: function() {
          this.s = // rounded value
          this.t = 0; // exact error
        },
        add: function(y) {
          add(temp, y, this.t);
          add(this, temp.s, this.s);
          if (this.s) this.t += temp.t;
          else this.s = temp.t;
        },
        valueOf: function() {
          return this.s;
        }
      };

      var temp = new Adder;

      function add(adder, a, b) {
        var x = adder.s = a + b,
            bv = x - a,
            av = x - bv;
        adder.t = (a - av) + (b - bv);
      }

      var pi = Math.PI;
      var tau = pi * 2;

      var abs = Math.abs;
      var sqrt = Math.sqrt;

      function noop() {}

      function streamGeometry(geometry, stream) {
        if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
          streamGeometryType[geometry.type](geometry, stream);
        }
      }

      var streamObjectType = {
        Feature: function(object, stream) {
          streamGeometry(object.geometry, stream);
        },
        FeatureCollection: function(object, stream) {
          var features = object.features, i = -1, n = features.length;
          while (++i < n) streamGeometry(features[i].geometry, stream);
        }
      };

      var streamGeometryType = {
        Sphere: function(object, stream) {
          stream.sphere();
        },
        Point: function(object, stream) {
          object = object.coordinates;
          stream.point(object[0], object[1], object[2]);
        },
        MultiPoint: function(object, stream) {
          var coordinates = object.coordinates, i = -1, n = coordinates.length;
          while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
        },
        LineString: function(object, stream) {
          streamLine(object.coordinates, stream, 0);
        },
        MultiLineString: function(object, stream) {
          var coordinates = object.coordinates, i = -1, n = coordinates.length;
          while (++i < n) streamLine(coordinates[i], stream, 0);
        },
        Polygon: function(object, stream) {
          streamPolygon(object.coordinates, stream);
        },
        MultiPolygon: function(object, stream) {
          var coordinates = object.coordinates, i = -1, n = coordinates.length;
          while (++i < n) streamPolygon(coordinates[i], stream);
        },
        GeometryCollection: function(object, stream) {
          var geometries = object.geometries, i = -1, n = geometries.length;
          while (++i < n) streamGeometry(geometries[i], stream);
        }
      };

      function streamLine(coordinates, stream, closed) {
        var i = -1, n = coordinates.length - closed, coordinate;
        stream.lineStart();
        while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
        stream.lineEnd();
      }

      function streamPolygon(coordinates, stream) {
        var i = -1, n = coordinates.length;
        stream.polygonStart();
        while (++i < n) streamLine(coordinates[i], stream, 1);
        stream.polygonEnd();
      }

      function geoStream(object, stream) {
        if (object && streamObjectType.hasOwnProperty(object.type)) {
          streamObjectType[object.type](object, stream);
        } else {
          streamGeometry(object, stream);
        }
      }

      var areaRingSum = adder();

      var areaSum = adder();

      var deltaSum = adder();

      var sum = adder();

      function ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
      }

      function bisector(compare) {
        if (compare.length === 1) compare = ascendingComparator(compare);
        return {
          left: function(a, x, lo, hi) {
            if (lo == null) lo = 0;
            if (hi == null) hi = a.length;
            while (lo < hi) {
              var mid = lo + hi >>> 1;
              if (compare(a[mid], x) < 0) lo = mid + 1;
              else hi = mid;
            }
            return lo;
          },
          right: function(a, x, lo, hi) {
            if (lo == null) lo = 0;
            if (hi == null) hi = a.length;
            while (lo < hi) {
              var mid = lo + hi >>> 1;
              if (compare(a[mid], x) > 0) hi = mid;
              else lo = mid + 1;
            }
            return lo;
          }
        };
      }

      function ascendingComparator(f) {
        return function(d, x) {
          return ascending(f(d), x);
        };
      }

      var ascendingBisect = bisector(ascending);

      var lengthSum = adder();

      function identity(x) {
        return x;
      }

      var areaSum$1 = adder(),
          areaRingSum$1 = adder(),
          x00,
          y00,
          x0,
          y0;

      var areaStream = {
        point: noop,
        lineStart: noop,
        lineEnd: noop,
        polygonStart: function() {
          areaStream.lineStart = areaRingStart;
          areaStream.lineEnd = areaRingEnd;
        },
        polygonEnd: function() {
          areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop;
          areaSum$1.add(abs(areaRingSum$1));
          areaRingSum$1.reset();
        },
        result: function() {
          var area = areaSum$1 / 2;
          areaSum$1.reset();
          return area;
        }
      };

      function areaRingStart() {
        areaStream.point = areaPointFirst;
      }

      function areaPointFirst(x, y) {
        areaStream.point = areaPoint;
        x00 = x0 = x, y00 = y0 = y;
      }

      function areaPoint(x, y) {
        areaRingSum$1.add(y0 * x - x0 * y);
        x0 = x, y0 = y;
      }

      function areaRingEnd() {
        areaPoint(x00, y00);
      }

      var x0$1 = Infinity,
          y0$1 = x0$1,
          x1 = -x0$1,
          y1 = x1;

      var boundsStream = {
        point: boundsPoint,
        lineStart: noop,
        lineEnd: noop,
        polygonStart: noop,
        polygonEnd: noop,
        result: function() {
          var bounds = [[x0$1, y0$1], [x1, y1]];
          x1 = y1 = -(y0$1 = x0$1 = Infinity);
          return bounds;
        }
      };

      function boundsPoint(x, y) {
        if (x < x0$1) x0$1 = x;
        if (x > x1) x1 = x;
        if (y < y0$1) y0$1 = y;
        if (y > y1) y1 = y;
      }

      // TODO Enforce positive area for exterior, negative area for interior?

      var X0 = 0,
          Y0 = 0,
          Z0 = 0,
          X1 = 0,
          Y1 = 0,
          Z1 = 0,
          X2 = 0,
          Y2 = 0,
          Z2 = 0,
          x00$1,
          y00$1,
          x0$2,
          y0$2;

      var centroidStream = {
        point: centroidPoint,
        lineStart: centroidLineStart,
        lineEnd: centroidLineEnd,
        polygonStart: function() {
          centroidStream.lineStart = centroidRingStart;
          centroidStream.lineEnd = centroidRingEnd;
        },
        polygonEnd: function() {
          centroidStream.point = centroidPoint;
          centroidStream.lineStart = centroidLineStart;
          centroidStream.lineEnd = centroidLineEnd;
        },
        result: function() {
          var centroid = Z2 ? [X2 / Z2, Y2 / Z2]
              : Z1 ? [X1 / Z1, Y1 / Z1]
              : Z0 ? [X0 / Z0, Y0 / Z0]
              : [NaN, NaN];
          X0 = Y0 = Z0 =
          X1 = Y1 = Z1 =
          X2 = Y2 = Z2 = 0;
          return centroid;
        }
      };

      function centroidPoint(x, y) {
        X0 += x;
        Y0 += y;
        ++Z0;
      }

      function centroidLineStart() {
        centroidStream.point = centroidPointFirstLine;
      }

      function centroidPointFirstLine(x, y) {
        centroidStream.point = centroidPointLine;
        centroidPoint(x0$2 = x, y0$2 = y);
      }

      function centroidPointLine(x, y) {
        var dx = x - x0$2, dy = y - y0$2, z = sqrt(dx * dx + dy * dy);
        X1 += z * (x0$2 + x) / 2;
        Y1 += z * (y0$2 + y) / 2;
        Z1 += z;
        centroidPoint(x0$2 = x, y0$2 = y);
      }

      function centroidLineEnd() {
        centroidStream.point = centroidPoint;
      }

      function centroidRingStart() {
        centroidStream.point = centroidPointFirstRing;
      }

      function centroidRingEnd() {
        centroidPointRing(x00$1, y00$1);
      }

      function centroidPointFirstRing(x, y) {
        centroidStream.point = centroidPointRing;
        centroidPoint(x00$1 = x0$2 = x, y00$1 = y0$2 = y);
      }

      function centroidPointRing(x, y) {
        var dx = x - x0$2,
            dy = y - y0$2,
            z = sqrt(dx * dx + dy * dy);

        X1 += z * (x0$2 + x) / 2;
        Y1 += z * (y0$2 + y) / 2;
        Z1 += z;

        z = y0$2 * x - x0$2 * y;
        X2 += z * (x0$2 + x);
        Y2 += z * (y0$2 + y);
        Z2 += z * 3;
        centroidPoint(x0$2 = x, y0$2 = y);
      }

      function PathContext(context) {
        this._context = context;
      }

      PathContext.prototype = {
        _radius: 4.5,
        pointRadius: function(_) {
          return this._radius = _, this;
        },
        polygonStart: function() {
          this._line = 0;
        },
        polygonEnd: function() {
          this._line = NaN;
        },
        lineStart: function() {
          this._point = 0;
        },
        lineEnd: function() {
          if (this._line === 0) this._context.closePath();
          this._point = NaN;
        },
        point: function(x, y) {
          switch (this._point) {
            case 0: {
              this._context.moveTo(x, y);
              this._point = 1;
              break;
            }
            case 1: {
              this._context.lineTo(x, y);
              break;
            }
            default: {
              this._context.moveTo(x + this._radius, y);
              this._context.arc(x, y, this._radius, 0, tau);
              break;
            }
          }
        },
        result: noop
      };

      var lengthSum$1 = adder(),
          lengthRing,
          x00$2,
          y00$2,
          x0$3,
          y0$3;

      var lengthStream = {
        point: noop,
        lineStart: function() {
          lengthStream.point = lengthPointFirst;
        },
        lineEnd: function() {
          if (lengthRing) lengthPoint(x00$2, y00$2);
          lengthStream.point = noop;
        },
        polygonStart: function() {
          lengthRing = true;
        },
        polygonEnd: function() {
          lengthRing = null;
        },
        result: function() {
          var length = +lengthSum$1;
          lengthSum$1.reset();
          return length;
        }
      };

      function lengthPointFirst(x, y) {
        lengthStream.point = lengthPoint;
        x00$2 = x0$3 = x, y00$2 = y0$3 = y;
      }

      function lengthPoint(x, y) {
        x0$3 -= x, y0$3 -= y;
        lengthSum$1.add(sqrt(x0$3 * x0$3 + y0$3 * y0$3));
        x0$3 = x, y0$3 = y;
      }

      function PathString() {
        this._string = [];
      }

      PathString.prototype = {
        _radius: 4.5,
        _circle: circle(4.5),
        pointRadius: function(_) {
          if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
          return this;
        },
        polygonStart: function() {
          this._line = 0;
        },
        polygonEnd: function() {
          this._line = NaN;
        },
        lineStart: function() {
          this._point = 0;
        },
        lineEnd: function() {
          if (this._line === 0) this._string.push("Z");
          this._point = NaN;
        },
        point: function(x, y) {
          switch (this._point) {
            case 0: {
              this._string.push("M", x, ",", y);
              this._point = 1;
              break;
            }
            case 1: {
              this._string.push("L", x, ",", y);
              break;
            }
            default: {
              if (this._circle == null) this._circle = circle(this._radius);
              this._string.push("M", x, ",", y, this._circle);
              break;
            }
          }
        },
        result: function() {
          if (this._string.length) {
            var result = this._string.join("");
            this._string = [];
            return result;
          } else {
            return null;
          }
        }
      };

      function circle(radius) {
        return "m0," + radius
            + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
            + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
            + "z";
      }

      function geoPath(projection, context) {
        var pointRadius = 4.5,
            projectionStream,
            contextStream;

        function path(object) {
          if (object) {
            if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
            geoStream(object, projectionStream(contextStream));
          }
          return contextStream.result();
        }

        path.area = function(object) {
          geoStream(object, projectionStream(areaStream));
          return areaStream.result();
        };

        path.measure = function(object) {
          geoStream(object, projectionStream(lengthStream));
          return lengthStream.result();
        };

        path.bounds = function(object) {
          geoStream(object, projectionStream(boundsStream));
          return boundsStream.result();
        };

        path.centroid = function(object) {
          geoStream(object, projectionStream(centroidStream));
          return centroidStream.result();
        };

        path.projection = function(_) {
          return arguments.length ? (projectionStream = _ == null ? (projection = null, identity) : (projection = _).stream, path) : projection;
        };

        path.context = function(_) {
          if (!arguments.length) return context;
          contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
          if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
          return path;
        };

        path.pointRadius = function(_) {
          if (!arguments.length) return pointRadius;
          pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
          return path;
        };

        return path.projection(projection).context(context);
      }

      function isInvalid (value) {
        if (value === undefined || value === null) { return true }

        if (value.constructor === Number) {
          return !isFinite(value)
        }

        return false
      }

      function isDefined (value) {
        return value !== undefined
      }

      function isUndefined (value) {
        return value === undefined
      }

      function calculateBBoxGeometries (geometries) {
        let bbox = [[Infinity, Infinity], [-Infinity, -Infinity]];

        for (let i = 0; i < geometries.length; i++) {
          const geometry = geometries[i];

          if (!isInvalid(geometry)) {
            bbox = updateBBox(bbox, geometry);
          }
        }

        const bboxObj = {
          x: [bbox[0][0], bbox[1][0]],
          y: [bbox[0][1], bbox[1][1]]
        };

        return bboxObj
      }

      const path = geoPath();

      function updateBBox (bbox, geometry) {
        const newBBox = path.bounds(geometry);

        bbox[0][0] = bbox[0][0] < newBBox[0][0] ? bbox[0][0] : newBBox[0][0];
        bbox[0][1] = bbox[0][1] < newBBox[0][1] ? bbox[0][1] : newBBox[0][1];
        bbox[1][0] = bbox[1][0] > newBBox[1][0] ? bbox[1][0] : newBBox[1][0];
        bbox[1][1] = bbox[1][1] > newBBox[1][1] ? bbox[1][1] : newBBox[1][1];

        return bbox
      }

      function warn (message) {
        if (!process) console.warn(message);

        if (process && process.env.NODE_ENV !== 'test') {
          console.warn(message);
        }
      }

      function calculateDomain (column, columnName) {
        if (columnName === '$grouped') {
          throw new Error(`Cannot calculate domain of column '${columnName}'.`)
        }

        const { firstValidValue, nValidValues } = findFirstValidValue(column);

        if (nValidValues === 0) {
          throw new Error(`Cannot calculate domain of column '${column}'. Column contains only missing values.`)
        }

        if (nValidValues > 0) {
          ensureValidDataType(firstValidValue);
          const type = getDataType(firstValidValue);

          if (columnName === '$geometry') {
            return calculateBBoxGeometries(column)
          }

          if (columnName !== '$geometry') {
            return calculateNonGeometryColumnDomain(column, columnName, nValidValues, firstValidValue, type)
          }
        }
      }

      function findFirstValidValue (column) {
        let firstValidValue;
        let nValidValues = 0;

        for (let i = 0; i < column.length; i++) {
          if (!isInvalid(column[i])) {
            nValidValues++;
            firstValidValue = firstValidValue || column[i];
          }

          if (nValidValues > 1) break
        }

        return { firstValidValue, nValidValues }
      }

      function calculateNonGeometryColumnDomain (column, columnName, nValidValues, firstValidValue, type) {
        let domain;
        const nUniqueValues = calculateNumberOfUniqueValues(column, type);

        if (columnHasOnlyOneUniqueValue(nValidValues, nUniqueValues)) {
          domain = calculateDomainForColumnWithOneUniqueValue(
            nValidValues, nUniqueValues, type, firstValidValue, columnName
          );
        } else {
          domain = calculateDomainForRegularColumn(type, column, columnName);
        }

        return domain
      }

      function calculateNumberOfUniqueValues (col, type) {
        const uniqueVals = {};

        if (['quantitative', 'categorical'].includes(type)) {
          for (let i = 0; i < col.length; i++) {
            const val = col[i];
            if (!isInvalid(val)) {
              uniqueVals[val] = 0;
            }
          }
        }

        if (type === 'temporal') {
          for (let i = 0; i < col.length; i++) {
            const val = col[i];
            if (!isInvalid(val)) {
              uniqueVals[val.getTime()] = 0;
            }
          }
        }

        if (type === 'interval') {
          for (let i = 0; i < col.length; i++) {
            const val = col[i];
            if (!isInvalid(val)) {
              const str = JSON.stringify(val);
              uniqueVals[str] = 0;
            }
          }
        }

        return Object.keys(uniqueVals).length
      }

      function columnHasOnlyOneUniqueValue (nValidValues, nUniqueValues) {
        return nValidValues === 1 || nUniqueValues === 1
      }

      function calculateDomainForColumnWithOneUniqueValue (nValidValues, nUniqueValues, type, firstValidValue, columnName) {
        const domain = createDomainForSingleValue(type, firstValidValue);
        const warningText = nValidValues === 1 ? 'valid' : 'unique';

        if (type !== 'categorical') {
          warn(
            `Column '${columnName}' contains only 1 ${warningText} value: ${firstValidValue}.\n` +
            `Using domain ${JSON.stringify(domain)}`
          );
        }

        return domain
      }

      function calculateDomainForRegularColumn (type, column, columnName) {
        let domain = initDomain(type);

        for (let i = 0; i < column.length; i++) {
          const value = column[i];

          if (!isInvalid(value)) {
            if (getDataType(value) !== type) {
              throw new Error(`Invalid column ${columnName}: column contains multiple data types`)
            }

            domain = updateDomain(domain, value, type);
          }
        }

        return domain
      }

      const minUnixTime = new Date(0);
      const maxUnixTime = new Date('19 January 2038');

      function initDomain (type) {
        let domain;
        switch (type) {
          case 'quantitative': {
            domain = [Infinity, -Infinity];
            break
          }
          case 'categorical': {
            domain = [];
            break
          }
          case 'temporal': {
            domain = [maxUnixTime, minUnixTime];
            break
          }
          case 'interval': {
            domain = [Infinity, -Infinity];
            break
          }
        }

        return domain
      }

      function updateDomain (domain, value, type) {
        if (!['quantitative', 'categorical', 'temporal', 'interval'].includes(type)) {
          throw new Error(`Cannot set domain for column of type '${type}'`)
        }

        if (type === 'quantitative') {
          if (domain[0] >= value) { domain[0] = value; }
          if (domain[1] <= value) { domain[1] = value; }
        }

        if (type === 'categorical') {
          if (!domain.includes(value)) { domain.push(value); }
        }

        if (type === 'temporal') {
          const epoch = value.getTime();

          if (domain[0].getTime() >= epoch) { domain[0] = value; }
          if (domain[1].getTime() <= epoch) { domain[1] = value; }
        }

        if (type === 'interval') {
          domain = updateDomain(domain, value[0], 'quantitative');
          domain = updateDomain(domain, value[1], 'quantitative');
        }

        return domain
      }

      function createDomainForSingleValue (type, value) {
        let domain;

        if (type === 'quantitative') {
          domain = [value - 1, value + 1];
        }

        if (type === 'categorical') {
          domain = [value];
        }

        if (type === 'temporal') {
          domain = [getDay(value, -1), getDay(value, 1)];
        }

        if (type === 'interval') {
          domain = value.sort((a, b) => a > b);
        }

        return domain
      }

      function getDay (date, days) {
        const dateCopy = new Date(date.getTime());
        return new Date(dateCopy.setDate(dateCopy.getDate() + days))
      }

      function getColumnType (column) {
        const { firstValidValue } = findFirstValidValue(column);
        return getDataType(firstValidValue)
      }

      function getDataType (value) {
        if (isInvalid(value)) return undefined

        if (value.constructor === Number) return 'quantitative'
        if (value.constructor === String) return 'categorical'
        if (value.constructor === Date) return 'temporal'
        if (isInterval(value)) return 'interval'
        if (isGeometry(value)) return 'geometry'
        if (value.constructor === DataContainer) return 'grouped'

        return undefined
      }

      function ensureValidDataType (value) {
        if (isInvalid(getDataType(value))) {
          throw new Error('Invalid data')
        }
      }

      function isGeometry (value) {
        return value.constructor === Object && 'type' in value && 'coordinates' in value
      }

      function isInterval (value) {
        return value.constructor === Array && value.length === 2 && value.every(entry => entry.constructor === Number)
      }

      function generateKeyColumn (length) {
        return new Array(length).fill(0).map((_, i) => i)
      }

      function validateKeyColumn (keyColumn, requiredLength) {
        if (keyColumn.length !== requiredLength) {
          throw new Error('Key column must be of same length as rest of the data')
        }

        ensureAllSameType(keyColumn);
        ensureUnique(keyColumn);
      }

      function ensureAllSameType (keyColumn) {
        for (let i = 0; i < keyColumn.length; i++) {
          const key = keyColumn[i];
          validateKey(key);
        }
      }

      function validateKey (key) {
        const type = getDataType(key);

        if (type !== 'quantitative' || !Number.isInteger(key)) {
          throw new Error('Key column can contain only integers')
        }
      }

      function ensureUnique (keyColumn) {
        if (keyColumn.length !== new Set(keyColumn).size) {
          throw new Error('Keys must be unique')
        }
      }

      function getDataLength (data) {
        const firstKey = Object.keys(data)[0];
        const firstColumn = data[firstKey];
        return firstColumn.length
      }

      function convertRowToColumnData (data) {
        checkIfDataIsEmpty(data);
        let columnData = initColumnData(data);

        for (let row of data) {
          for (let key in row) {
            columnData[key].push(row[key]);
          }
        }

        return columnData
      }

      function initColumnData (data) {
        let firstRow = data[0];
        let columnKeys = Object.keys(firstRow);
        let columnData = {};

        for (let key of columnKeys) {
          columnData[key] = [];
        }

        return columnData
      }

      function checkIfDataIsEmpty (data) {
        if (data.length === 0) {
          throw new Error('Received empty Array while trying to load row-oriented data. This is not allowed.')
        }
      }

      function parseGeoJSON (geojsonData) {
        const geometryData = [];
        const data = {};

        const features = geojsonData.features;
        const firstFeature = features[0];

        if ('properties' in firstFeature) {
          for (const columnName in firstFeature.properties) {
            data[columnName] = [];
          }
        }

        for (let i = 0; i < features.length; i++) {
          const { geometry, properties } = features[i];
          geometryData.push(geometry);

          for (const columnName in properties) {
            data[columnName].push(properties[columnName]);
          }
        }

        checkFormatColumnData(data);

        data.$geometry = geometryData;

        return data
      }

      const methods = {
        _setColumnData (data, options) {
          if (options.validate === false) {
            checkFormatInternal(data);
          } else {
            checkFormatColumnData(data);
          }

          this._storeData(data, options);
        },

        _setRowData (rowData, options) {
          const columnData = convertRowToColumnData(rowData);
          this._setColumnData(columnData, options);
        },

        _setGeoJSON (geojsonData, options) {
          const data = parseGeoJSON(geojsonData);
          this._storeData(data, options);
        },

        _setGroup (group, options) {
          const data = group.data;
          checkFormatInternal(data);
          this._storeData(data, options);
        },

        _storeData (data, options) {
          this._data = data;

          this._setupKeyColumn();

          if (options.validate === true) {
            this.validateAllColumns();
          }
        },

        _setupKeyColumn () {
          const length = getDataLength(this._data);

          if ('$key' in this._data) {
            validateKeyColumn(this._data.$key, length);
            this._syncKeyToRowNumber();
          } else {
            const keyColumn = generateKeyColumn(length);
            this._setKeyColumn(keyColumn);
          }
        },

        _setKeyColumn (keyColumn) {
          this._data = produce(this._data, draft => {
            draft.$key = keyColumn;
          });

          this._syncKeyToRowNumber();
        },

        _syncKeyToRowNumber () {
          const length = getDataLength(this._data);

          for (let i = 0; i < length; i++) {
            const key = this._data.$key[i];
            this._keyToRowNumber[key] = i;
          }
        }
      };

      function dataLoadingMixin (targetClass) {
        Object.assign(targetClass.prototype, methods);
      }

      function filter (data, filterFunction) {
        const length = getDataLength(data);
        const newData = {};
        for (const colName in data) { newData[colName] = []; }

        for (let i = 0; i < length; i++) {
          const row = {};
          for (const colName in data) { row[colName] = data[colName][i]; }

          if (filterFunction(row, i) === true) {
            for (const colName in row) { newData[colName].push(row[colName]); }
          }
        }

        return newData
      }

      function select (data, selection) {
        if (selection.constructor === String) {
          selection = [selection];
        }

        if (selection.constructor === Array) {
          validateSelectionInstructions(data, selection);

          for (const columnName in data) {
            if (!selection.includes(columnName)) {
              delete data[columnName];
            }
          }
        } else {
          throw new Error('select can only be used with a string or array of strings')
        }
      }

      function validateSelectionInstructions (data, selection) {
        for (const columnName of selection) {
          if (!(columnName in data)) {
            throw new Error(`Column '${columnName}' not found`)
          }
        }
      }

      function arrange (data, sortInstructions) {
        if (sortInstructions.constructor === Object) {
          sort(data, sortInstructions);
        } else if (sortInstructions.constructor === Array) {
          for (let i = sortInstructions.length - 1; i >= 0; i--) {
            const instruction = sortInstructions[i];
            sort(data, instruction);
          }
        } else {
          throw new Error('arrange requires a key-value object or array of key-value objects')
        }
      }

      const sortFuncs = {
        quantitative: {
          // https://beta.observablehq.com/@mbostock/manipulating-flat-arrays
          ascending: (a, b) => a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN,
          descending: (a, b) => b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN
        },
        categorical: {
          ascending: (a, b) => {
            const sorted = [a, b].sort();
            return sorted[0] === a ? -1 : 1
          },
          descending: (a, b) => {
            const sorted = [a, b].sort();
            return sorted[0] === a ? 1 : -1
          }
        },
        temporal: {
          ascending: (c, d) => {
            const a = c.getTime();
            const b = c.getTime();
            return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN
          },
          descending: (c, d) => {
            const a = c.getTime();
            const b = c.getTime();
            return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN
          }
        }
      };

      function sort (data, sortInstructions) {
        if (Object.keys(sortInstructions).length !== 1) {
          throw new Error('Only one key-value pair allowed')
        }

        const variable = Object.keys(sortInstructions)[0];
        const sortMethod = sortInstructions[variable];

        ensureValidDataType(data[variable][0]);
        const dataType = getDataType(data[variable][0]);

        let sortFunc;
        if (sortMethod.constructor === String) {
          sortFunc = sortFuncs[dataType][sortMethod];
        }
        if (sortMethod.constructor === Function) {
          sortFunc = sortMethod;
        }

        const column = data[variable];

        const indices = column.map((v, i) => i);
        const sortedIndices = indices.sort((a, b) => sortFunc(column[a], column[b]));

        for (const colName in data) {
          data[colName] = reorder(data[colName], sortedIndices);
        }
      }

      function reorder (column, indices) {
        return indices.map(i => column[i])
      }

      function rename (data, renameInstructions) {
        if (renameInstructions.constructor !== Object) {
          throw new Error('Rename only accepts an object')
        }

        for (const oldName in renameInstructions) {
          if (oldName in data) {
            const newName = renameInstructions[oldName];
            checkRegularColumnName(newName);
            data[newName] = data[oldName];
            delete data[oldName];
          } else {
            warn(`Rename: column '${oldName}' not found`);
          }
        }
      }

      function mutate (data, mutateInstructions) {
        const length = getDataLength(data);
        const newData = {};

        for (const key in mutateInstructions) {
          newData[key] = new Array(length);
        }

        for (let i = 0; i < length; i++) {
          const row = {};
          let prevRow = {};
          let nextRow = {};

          for (const colName in data) {
            row[colName] = data[colName][i];
            prevRow[colName] = data[colName][i - 1];
            nextRow[colName] = data[colName][i + 1];
          }

          if (i === 0) { prevRow = undefined; }
          if (i === length - 1) { nextRow = undefined; }

          for (const key in mutateInstructions) {
            const mutateFunction = mutateInstructions[key];
            newData[key][i] = mutateFunction(row, i, prevRow, nextRow);
          }
        }

        Object.assign(data, newData);
      }

      function transmute (data, mutateObj) {
        data = mutate(data, mutateObj);

        for (const key in data) {
          if (!(key in mutateObj)) {
            delete data[key];
          }
        }
      }

      var aggregations = {
        count,
        sum: sum$1,
        mean,
        median,
        mode,
        min,
        max
      };

      function count (column) {
        return column.length
      }

      function sum$1 (column) {
        let total = 0;
        for (const value of column) {
          total += value;
        }

        return total
      }

      function mean (column) {
        return sum$1(column) / count(column)
      }

      function median (column) {
        const asc = column.sort((a, b) => a > b);
        const len = count(column);

        if (len % 2 === 1) {
          // Odd
          return asc[Math.floor(len / 2)]
        } else {
          // Even
          const lower = asc[(len / 2) - 1];
          const upper = asc[(len / 2)];
          return (lower + upper) / 2
        }
      }

      function mode (column) {
        const counts = {};

        for (const value of column) {
          if (value in counts) {
            counts[value]++;
          } else {
            counts[value] = 1;
          }
        }

        let winner;
        let winningVal = 0;

        for (const value in counts) {
          if (counts[value] > winningVal) {
            winningVal = counts[value];
            winner = value;
          }
        }

        return winner
      }

      function min (column) {
        let winner = Infinity;
        for (const value of column) {
          if (value < winner) { winner = value; }
        }
        return winner
      }

      function max (column) {
        let winner = -Infinity;
        for (const value of column) {
          if (value > winner) { winner = value; }
        }
        return winner
      }

      function checkKeyValuePair (obj, allowedKeys) {
        const keys = Object.keys(obj);
        if (keys.length !== 1) {
          throw new Error('Invalid transformation syntax')
        }

        const key = keys[0];

        if (!allowedKeys.includes(key)) {
          throw new Error(`Unknown transformation ${key}`)
        }

        return key
      }

      function summarise (data, summariseInstructions) {
        if (summariseInstructions.constructor !== Object) {
          throw new Error('summarise must be an object')
        }

        let newData = initNewData(summariseInstructions, data);

        if ('$grouped' in data) {
          checkSummariseInstructions(summariseInstructions, data);

          for (const columnName in data) {
            if (columnName !== '$grouped') {
              newData[columnName] = data[columnName];
            }
          }

          for (const group of data.$grouped) {
            const data = group.data();
            newData = summariseGroup(data, summariseInstructions, newData);
          }
        } else {
          newData = summariseGroup(data, summariseInstructions, newData);
        }
        return newData
      }

      function initNewData (summariseInstructions, data) {
        const newData = {};
        for (const newCol in summariseInstructions) { newData[newCol] = []; }
        if (data && '$grouped' in data) {
          for (const col in data) {
            if (col !== '$grouped') {
              newData[col] = [];
            }
          }
        }
        return newData
      }

      function summariseGroup (data, summariseInstructions, newData) {
        for (const newColName in summariseInstructions) {
          const instruction = summariseInstructions[newColName];

          if (instruction.constructor === Object) {
            const column = checkKeyValuePair(instruction, Object.keys(data));
            const aggregation = instruction[column];

            if (aggregation.constructor === String) {
              if (!(aggregation in aggregations)) {
                throw new Error(`Unkown summaryMethod: '${aggregation}'.`)
              }

              newData[newColName].push(aggregations[aggregation](data[column]));
            } else if (aggregation.constructor === Function) {
              newData[newColName].push(aggregation(data[column]));
            } else {
              throw new Error(`Invalid summaryMethod: '${aggregation}'. Must be String or Function`)
            }
          }
        }

        return newData
      }

      function checkSummariseInstructions (summariseInstructions, data) {
        for (const newColName in summariseInstructions) {
          const instruction = summariseInstructions[newColName];
          const name = Object.keys(instruction)[0];

          checkRegularColumnName(name);

          if (name in data) {
            throw new Error(`Cannot summarise the column '${name}': used for grouping`)
          }
        }
      }

      function mutarise (data, mutariseInstructions) {
        if (mutariseInstructions.constructor !== Object) {
          throw new Error('mutarise must be an object')
        }

        let newCols = initNewData(mutariseInstructions);

        if ('$grouped' in data) {
          checkSummariseInstructions(mutariseInstructions, data);

          for (const group of data.$grouped) {
            let summarizedData = initNewData(mutariseInstructions);
            const dataInGroup = group.data();
            summarizedData = summariseGroup(dataInGroup, mutariseInstructions, summarizedData);

            const length = getDataLength(dataInGroup);
            newCols = addGroupSummaries(newCols, summarizedData, length);
          }

          data = ungroup(data);
        } else {
          let summarizedData = initNewData(mutariseInstructions);
          summarizedData = summariseGroup(data, mutariseInstructions, summarizedData);

          const length = getDataLength(data);
          newCols = addGroupSummaries(newCols, summarizedData, length);
        }

        return join(data, newCols)
      }

      function addGroupSummaries (newCols, summarizedData, length) {
        for (let i = 0; i < length; i++) {
          for (const key in summarizedData) {
            newCols[key].push(summarizedData[key][0]);
          }
        }

        return newCols
      }

      function ungroup (data) {
        const newData = initNewData(data.$grouped[0].data());

        for (const group of data.$grouped) {
          const groupData = group.data();
          for (const col in newData) {
            newData[col].push(...groupData[col]);
          }
        }

        return newData
      }

      function join (data, newCols) {
        for (const col in newCols) {
          data[col] = newCols[col];
        }

        return data
      }

      function groupBy (data, groupByInstructions) {
        const groupedData = {};

        const groupedColumns = getGroupedColumns(data, groupByInstructions);
        const groups = groupBy$1(data, groupedColumns);

        groupedData.$grouped = groups.map(group => new DataContainer(group));
        for (const col of groupedColumns) {
          groupedData[col] = [];
        }

        for (let i = 0; i < groupedColumns.length; i++) {
          const col = groupedColumns[i];

          for (const group of groups) {
            groupedData[col].push(group.groupedValues[i]);
          }
        }

        return groupedData
      }

      function getGroupedColumns (data, groupByInstructions) {
        const con = groupByInstructions.constructor;
        if (![String, Array].includes(con)) {
          throw new Error('groupBy can only be used with a string or array of strings')
        }

        const groupedColumns = con === String ? [groupByInstructions] : groupByInstructions;

        for (const col of groupedColumns) {
          if (!(col in data)) {
            throw new Error(`Column '${col}' not found`)
          }
        }

        if (groupedColumns.length === Object.keys(data).length) {
          throw new Error('Cannot group by all columns')
        }

        return groupedColumns
      }

      function getGroupedValues (data, i, columns) {
        const groupedValues = [];
        for (const col of columns) {
          groupedValues.push(data[col][i]);
        }

        return groupedValues
      }

      function groupBy$1 (data, groupedColumns) {
        const groups = {};

        const length = getDataLength(data);

        for (let i = 0; i < length; i++) {
          // Ge grouped values
          const groupedValues = getGroupedValues(data, i, groupedColumns);

          // Get unique identifier for group
          const groupID = JSON.stringify(groupedValues);

          // If groups object has no entry for this group yet: create new group object
          groups[groupID] = groups[groupID] || new Group(data, groupedValues);

          // Add row to group
          groups[groupID].addRow(data, i);
        }

        // Convert groups object to array
        return Object.keys(groups).map(group => {
          return groups[group]
        })
      }

      class Group {
        constructor (data, groupedValues) {
          this.data = {};
          this.groupedValues = groupedValues;

          for (const col in data) {
            this.data[col] = [];
          }
        }

        addRow (data, i) {
          for (const col in data) {
            this.data[col].push(data[col][i]);
          }
        }
      }

      /**
      * geostats() is a tiny and standalone javascript library for classification
      * Project page - https://github.com/simogeo/geostats
      * Copyright (c) 2011 Simon Georget, http://www.intermezzo-coop.eu
      * Licensed under the MIT license
      */

      var _t = function (str) {
        return str
      };

      // taking from http://stackoverflow.com/questions/18082/validate-decimal-numbers-in-javascript-isnumeric
      var isNumber = function (n) {
        return !isNaN(parseFloat(n)) && isFinite(n)
      };

      function Geostats (a) {
        this.objectID = '';
        this.separator = ' - ';
        this.legendSeparator = this.separator;
        this.method = '';
        this.precision = 0;
        this.precisionflag = 'auto';
        this.roundlength = 2; // Number of decimals, round values
        this.is_uniqueValues = false;
        this.debug = false;
        this.silent = false;

        this.bounds = [];
        this.ranges = [];
        this.inner_ranges = null;
        this.colors = [];
        this.counter = [];

        // statistics information
        this.stat_sorted = null;
        this.stat_mean = null;
        this.stat_median = null;
        this.stat_sum = null;
        this.stat_max = null;
        this.stat_min = null;
        this.stat_pop = null;
        this.stat_variance = null;
        this.stat_stddev = null;
        this.stat_cov = null;

        /**
       * logging method
       */
        this.log = function (msg, force) {
          if (this.debug === true || force != null) {
            console.log(this.objectID + '(object id) :: ' + msg);
          }
        };

        /**
       * Set bounds
       */
        this.setBounds = function (a) {
          this.log('Setting bounds (' + a.length + ') : ' + a.join());

          this.bounds = []; // init empty array to prevent bug when calling classification after another with less items (sample getQuantile(6) and getQuantile(4))

          this.bounds = a;
          // this.bounds = this.decimalFormat(a);
        };

        /**
       * Set a new serie
       */
        this.setSerie = function (a) {
          this.log('Setting serie (' + a.length + ') : ' + a.join());

          this.serie = []; // init empty array to prevent bug when calling classification after another with less items (sample getQuantile(6) and getQuantile(4))
          this.serie = a;

          // reset statistics after changing serie
          this.resetStatistics();

          this.setPrecision();
        };

        /**
       * Set colors
       */
        this.setColors = function (colors) {
          this.log('Setting color ramp (' + colors.length + ') : ' + colors.join());

          this.colors = colors;
        };

        /**
         * Get feature count
         * With bounds array(0, 0.75, 1.5, 2.25, 3);
         * should populate this.counter with 5 keys
         * and increment counters for each key
         */
        this.doCount = function () {
          if (this._nodata()) { return }

          var tmp = this.sorted();

          this.counter = [];

          // we init counter with 0 value
          for (let i = 0; i < this.bounds.length - 1; i++) {
            this.counter[i] = 0;
          }

          for (let j = 0; j < tmp.length; j++) {
            // get current class for value to increment the counter
            var cclass = this.getClass(tmp[j]);
            this.counter[cclass]++;
          }
        };

        /**
         * Set decimal precision according to user input
         * or automatcally determined according
         * to the given serie.
         */
        this.setPrecision = function (decimals) {
          // only when called from user
          if (typeof decimals !== 'undefined') {
            this.precisionflag = 'manual';
            this.precision = decimals;
          }

          // we calculate the maximal decimal length on given serie
          if (this.precisionflag === 'auto') {
            for (var i = 0; i < this.serie.length; i++) {
              // check if the given value is a number and a float
              var precision;
              if (!isNaN((this.serie[i] + '')) && (this.serie[i] + '').toString().indexOf('.') !== -1) {
                precision = (this.serie[i] + '').split('.')[1].length;
              } else {
                precision = 0;
              }

              if (precision > this.precision) {
                this.precision = precision;
              }
            }
          }
          if (this.precision > 20) {
            // prevent "Uncaught RangeError: toFixed() digits argument must be between 0 and 20" bug. See https://github.com/simogeo/geostats/issues/34
            this.log('this.precision value (' + this.precision + ') is greater than max value. Automatic set-up to 20 to prevent "Uncaught RangeError: toFixed()" when calling decimalFormat() method.');
            this.precision = 20;
          }

          this.log('Calling setPrecision(). Mode : ' + this.precisionflag + ' - Decimals : ' + this.precision);

          this.serie = this.decimalFormat(this.serie);
        };

        /**
         * Format array numbers regarding to precision
         */
        this.decimalFormat = function (a) {
          var b = [];

          for (var i = 0; i < a.length; i++) {
            // check if the given value is a number
            if (isNumber(a[i])) {
              b[i] = parseFloat(parseFloat(a[i]).toFixed(this.precision));
            } else {
              b[i] = a[i];
            }
          }

          return b
        };

        /**
         * Transform a bounds array to a range array the following array : array(0,
         * 0.75, 1.5, 2.25, 3); becomes : array('0-0.75', '0.75-1.5', '1.5-2.25',
         * '2.25-3');
         */
        this.setRanges = function () {
          this.ranges = []; // init empty array to prevent bug when calling classification after another with less items (sample getQuantile(6) and getQuantile(4))

          for (let i = 0; i < (this.bounds.length - 1); i++) {
            this.ranges[i] = this.bounds[i] + this.separator + this.bounds[i + 1];
          }
        };

        /** return min value */
        this.min = function () {
          if (this._nodata()) { return }

          this.stat_min = this.serie[0];

          for (let i = 0; i < this.pop(); i++) {
            if (this.serie[i] < this.stat_min) {
              this.stat_min = this.serie[i];
            }
          }

          return this.stat_min
        };

        /** return max value */
        this.max = function () {
          if (this._nodata()) { return }

          this.stat_max = this.serie[0];
          for (let i = 0; i < this.pop(); i++) {
            if (this.serie[i] > this.stat_max) {
              this.stat_max = this.serie[i];
            }
          }

          return this.stat_max
        };

        /** return sum value */
        this.sum = function () {
          if (this._nodata()) { return }

          if (this.stat_sum === null) {
            this.stat_sum = 0;
            for (let i = 0; i < this.pop(); i++) {
              this.stat_sum += parseFloat(this.serie[i]);
            }
          }

          return this.stat_sum
        };

        /** return population number */
        this.pop = function () {
          if (this._nodata()) { return }

          if (this.stat_pop === null) {
            this.stat_pop = this.serie.length;
          }

          return this.stat_pop
        };

        /** return mean value */
        this.mean = function () {
          if (this._nodata()) { return }

          if (this.stat_mean === null) {
            this.stat_mean = parseFloat(this.sum() / this.pop());
          }

          return this.stat_mean
        };

        /** return median value */
        this.median = function () {
          if (this._nodata()) { return }

          if (this.stat_median === null) {
            this.stat_median = 0;
            var tmp = this.sorted();

            // serie pop is odd
            if (tmp.length % 2) {
              this.stat_median = parseFloat(tmp[(Math.ceil(tmp.length / 2) - 1)]);

            // serie pop is even
            } else {
              this.stat_median = (parseFloat(tmp[((tmp.length / 2) - 1)]) + parseFloat(tmp[(tmp.length / 2)])) / 2;
            }
          }

          return this.stat_median
        };

        /** return variance value */
        this.variance = function (round) {
          round = (typeof round === 'undefined');

          if (this._nodata()) { return }

          if (this.stat_variance === null) {
            var tmp = 0;
            var serieMean = this.mean();
            for (var i = 0; i < this.pop(); i++) {
              tmp += Math.pow((this.serie[i] - serieMean), 2);
            }

            this.stat_variance = tmp / this.pop();

            if (round === true) {
              this.stat_variance = Math.round(this.stat_variance * Math.pow(10, this.roundlength)) / Math.pow(10, this.roundlength);
            }
          }

          return this.stat_variance
        };

        /** return standard deviation value */
        this.stddev = function (round) {
          round = (typeof round === 'undefined');

          if (this._nodata()) { return }

          if (this.stat_stddev === null) {
            this.stat_stddev = Math.sqrt(this.variance());

            if (round === true) {
              this.stat_stddev = Math.round(this.stat_stddev * Math.pow(10, this.roundlength)) / Math.pow(10, this.roundlength);
            }
          }

          return this.stat_stddev
        };

        /** coefficient of variation - measure of dispersion */
        this.cov = function (round) {
          round = (typeof round === 'undefined');

          if (this._nodata()) { return }

          if (this.stat_cov === null) {
            this.stat_cov = this.stddev() / this.mean();

            if (round === true) {
              this.stat_cov = Math.round(this.stat_cov * Math.pow(10, this.roundlength)) / Math.pow(10, this.roundlength);
            }
          }

          return this.stat_cov
        };

        /** reset all attributes after setting a new serie */
        this.resetStatistics = function () {
          this.stat_sorted = null;
          this.stat_mean = null;
          this.stat_median = null;
          this.stat_sum = null;
          this.stat_max = null;
          this.stat_min = null;
          this.stat_pop = null;
          this.stat_variance = null;
          this.stat_stddev = null;
          this.stat_cov = null;
        };

        /** data test */
        this._nodata = function () {
          if (this.serie.length === 0) {
            if (this.silent) this.log('[silent mode] Error. You should first enter a serie!', true);
            else throw new TypeError('Error. You should first enter a serie!')
            return 1
          } else { return 0 }
        };

        /** ensure nbClass is an integer */
        this._nbClassInt = function (nbClass) {
          var nbclassTmp = parseInt(nbClass, 10);
          if (isNaN(nbclassTmp)) {
            if (this.silent) this.log("[silent mode] '" + nbclassTmp + "' is not a valid integer. Enable to set class number.", true);
            else throw new TypeError("'" + nbclassTmp + "' is not a valid integer. Enable to set class number.")
          } else {
            return nbclassTmp
          }
        };

        /** check if the serie contains negative value */
        this._hasNegativeValue = function () {
          for (let i = 0; i < this.serie.length; i++) {
            if (this.serie[i] < 0) { return true }
          }
          return false
        };

        /** check if the serie contains zero value */
        this._hasZeroValue = function () {
          for (let i = 0; i < this.serie.length; i++) {
            if (parseFloat(this.serie[i]) === 0) { return true }
          }
          return false
        };

        /** return sorted values (as array) */
        this.sorted = function () {
          if (this.stat_sorted === null) {
            if (this.is_uniqueValues === false) {
              this.stat_sorted = this.serie.sort(function (a, b) {
                return a - b
              });
            } else {
              this.stat_sorted = this.serie.sort(function (a, b) {
                var nameA = a.toString().toLowerCase(); var nameB = b.toString().toLowerCase();
                if (nameA < nameB) return -1
                if (nameA > nameB) return 1
                return 0
              });
            }
          }

          return this.stat_sorted
        };

        /**
       * Set Manual classification Return an array with bounds : ie array(0,
       * 0.75, 1.5, 2.25, 3);
       * Set ranges and prepare data for displaying legend
       *
       */
        this.setClassManually = function (array) {
          if (this._nodata()) { return }

          if (array[0] !== this.min() || array[array.length - 1] !== this.max()) {
            if (this.silent) this.log('[silent mode] ' + _t('Given bounds may not be correct! please check your input.\nMin value : ' + this.min() + ' / Max value : ' + this.max()), true);
            else throw new TypeError(_t('Given bounds may not be correct! please check your input.\nMin value : ' + this.min() + ' / Max value : ' + this.max()))
            return
          }

          this.setBounds(array);
          this.setRanges();

          // we specify the classification method
          this.method = _t('manual classification') + ' (' + (array.length - 1) + ' ' + _t('classes') + ')';

          return this.bounds
        };

        /**
       * Equal intervals classification Return an array with bounds : ie array(0,
       * 0.75, 1.5, 2.25, 3);
       */
        this.getClassEqInterval = function (nbClass, forceMin, forceMax) {
          nbClass = this._nbClassInt(nbClass); // ensure nbClass is an integer

          if (this._nodata()) { return }

          var tmpMin = (typeof forceMin === 'undefined') ? this.min() : forceMin;
          var tmpMax = (typeof forceMax === 'undefined') ? this.max() : forceMax;

          var a = [];
          var val = tmpMin;
          var interval = (tmpMax - tmpMin) / nbClass;

          for (let i = 0; i <= nbClass; i++) {
            a[i] = val;
            val += interval;
          }

          // -> Fix last bound to Max of values
          a[nbClass] = tmpMax;

          this.setBounds(a);
          this.setRanges();

          // we specify the classification method
          this.method = _t('eq. intervals') + ' (' + nbClass + ' ' + _t('classes') + ')';

          return this.bounds
        };

        this.getQuantiles = function (nbClass) {
          nbClass = this._nbClassInt(nbClass); // ensure nbClass is an integer

          var tmp = this.sorted();
          var quantiles = [];

          var step = this.pop() / nbClass;
          for (var i = 1; i < nbClass; i++) {
            var qidx = Math.round(i * step + 0.49);
            quantiles.push(tmp[qidx - 1]); // zero-based
          }

          return quantiles
        };

        /**
       * Quantile classification Return an array with bounds : ie array(0, 0.75,
       * 1.5, 2.25, 3);
       */
        this.getClassQuantile = function (nbClass) {
          nbClass = this._nbClassInt(nbClass); // ensure nbClass is an integer

          if (this._nodata()) { return }

          var tmp = this.sorted();
          var bounds = this.getQuantiles(nbClass);
          bounds.unshift(tmp[0]);

          if (bounds[tmp.length - 1] !== tmp[tmp.length - 1]) { bounds.push(tmp[tmp.length - 1]); }

          this.setBounds(bounds);
          this.setRanges();

          // we specify the classification method
          this.method = _t('quantile') + ' (' + nbClass + ' ' + _t('classes') + ')';

          return this.bounds
        };

        /**
       * Standard Deviation classification
       * Return an array with bounds : ie array(0,
       * 0.75, 1.5, 2.25, 3);
       */
        this.getClassStdDeviation = function (nbClass, matchBounds) {
          nbClass = this._nbClassInt(nbClass); // ensure nbClass is an integer

          if (this._nodata()) { return }

          var tmpMax = this.max();
          var tmpMin = this.min();
          var tmpStdDev = this.stddev();
          var tmpMean = this.mean();

          var a = [];

          // number of classes is odd
          if (nbClass % 2 === 1) {
            // Euclidean division to get the inferior bound
            var infBound = Math.floor(nbClass / 2);

            var supBound = infBound + 1;

            // we set the central bounds
            a[infBound] = tmpMean - (tmpStdDev / 2);
            a[supBound] = tmpMean + (tmpStdDev / 2);

            // Values < to infBound, except first one
            for (let i = infBound - 1; i > 0; i--) {
              let val = a[i + 1] - tmpStdDev;
              a[i] = val;
            }

            // Values > to supBound, except last one
            for (let i = supBound + 1; i < nbClass; i++) {
              let val = a[i - 1] + tmpStdDev;
              a[i] = val;
            }

            // number of classes is even
          } else {
            var meanBound = nbClass / 2;

            // we get the mean value
            a[meanBound] = tmpMean;

            // Values < to the mean, except first one
            for (let i = meanBound - 1; i > 0; i--) {
              let val = a[i + 1] - tmpStdDev;
              a[i] = val;
            }

            // Values > to the mean, except last one
            for (let i = meanBound + 1; i < nbClass; i++) {
              let val = a[i - 1] + tmpStdDev;
              a[i] = val;
            }
          }

          // we finally set the first value
          // do we excatly match min value or not ?
          a[0] = (typeof matchBounds === 'undefined') ? a[1] - tmpStdDev : tmpMin;

          // we finally set the last value
          // do we excatly match max value or not ?
          a[nbClass] = (typeof matchBounds === 'undefined') ? a[nbClass - 1] + tmpStdDev : tmpMax;

          this.setBounds(a);
          this.setRanges();

          // we specify the classification method
          this.method = _t('std deviation') + ' (' + nbClass + ' ' + _t('classes') + ')';

          return this.bounds
        };

        /**
       * Geometric Progression classification
       * http://en.wikipedia.org/wiki/Geometric_progression
       * Return an array with bounds : ie array(0,
       * 0.75, 1.5, 2.25, 3);
       */
        this.getClassGeometricProgression = function (nbClass) {
          nbClass = this._nbClassInt(nbClass); // ensure nbClass is an integer

          if (this._nodata()) { return }

          if (this._hasNegativeValue() || this._hasZeroValue()) {
            if (this.silent) this.log('[silent mode] ' + _t('geometric progression can\'t be applied with a serie containing negative or zero values.'), true);
            else throw new TypeError(_t('geometric progression can\'t be applied with a serie containing negative or zero values.'))
            return
          }

          var a = [];
          var tmpMin = this.min();
          var tmpMax = this.max();

          var logMax = Math.log(tmpMax) / Math.LN10; // max decimal logarithm (or base 10)
          var logMin = Math.log(tmpMin) / Math.LN10; // min decimal logarithm (or base 10)

          var interval = (logMax - logMin) / nbClass;

          // we compute log bounds
          for (let i = 0; i < nbClass; i++) {
            if (i === 0) {
              a[i] = logMin;
            } else {
              a[i] = a[i - 1] + interval;
            }
          }

          // we compute antilog
          a = a.map(function (x) { return Math.pow(10, x) });

          // and we finally add max value
          a.push(this.max());

          this.setBounds(a);
          this.setRanges();

          // we specify the classification method
          this.method = _t('geometric progression') + ' (' + nbClass + ' ' + _t('classes') + ')';

          return this.bounds
        };

        /**
       * Arithmetic Progression classification
       * http://en.wikipedia.org/wiki/Arithmetic_progression
       * Return an array with bounds : ie array(0,
       * 0.75, 1.5, 2.25, 3);
       */
        this.getClassArithmeticProgression = function (nbClass) {
          nbClass = this._nbClassInt(nbClass); // ensure nbClass is an integer

          if (this._nodata()) { return }

          var denominator = 0;

          // we compute the (french) "Raison"
          for (let i = 1; i <= nbClass; i++) {
            denominator += i;
          }

          var a = [];
          var tmpMin = this.min();
          var tmpMax = this.max();

          var interval = (tmpMax - tmpMin) / denominator;

          for (let i = 0; i <= nbClass; i++) {
            if (i === 0) {
              a[i] = tmpMin;
            } else {
              a[i] = a[i - 1] + (i * interval);
            }
          }

          this.setBounds(a);
          this.setRanges();

          // we specify the classification method
          this.method = _t('arithmetic progression') + ' (' + nbClass + ' ' + _t('classes') + ')';

          return this.bounds
        };

        /**
       * Credits : Doug Curl (javascript) and Daniel J Lewis (python implementation)
       * http://www.arcgis.com/home/item.html?id=0b633ff2f40d412995b8be377211c47b
       * http://danieljlewis.org/2010/06/07/jenks-natural-breaks-algorithm-in-python/
       */
        this.getClassJenks = function (nbClass) {
          nbClass = this._nbClassInt(nbClass); // ensure nbClass is an integer

          if (this._nodata()) { return }

          let dataList = this.sorted();

          // now iterate through the datalist:
          // determine mat1 and mat2
          // really not sure how these 2 different arrays are set - the code for
          // each seems the same!
          // but the effect are 2 different arrays: mat1 and mat2
          var mat1 = [];
          // for (var x = 0, xl = dataList.length + 1; x < xl; x++) {
          for (var x = 0; x < dataList.length + 1; x++) {
            var temp = [];
            for (var j = 0, jl = nbClass + 1; j < jl; j++) {
              temp.push(0);
            }
            mat1.push(temp);
          }

          var mat2 = [];
          // for (var i = 0, il = dataList.length + 1; i < il; i++) {
          for (var i = 0; i < dataList.length + 1; i++) {
            var temp2 = [];
            for (var c = 0, cl = nbClass + 1; c < cl; c++) {
              temp2.push(0);
            }
            mat2.push(temp2);
          }

          // absolutely no idea what this does - best I can tell, it sets the 1st
          // group in the
          // mat1 and mat2 arrays to 1 and 0 respectively
          for (var y = 1, yl = nbClass + 1; y < yl; y++) {
            mat1[0][y] = 1;
            mat2[0][y] = 0;
            for (var t = 1, tl = dataList.length + 1; t < tl; t++) {
              mat2[t][y] = Infinity;
            }
            var v = 0.0;
          }

          // and this part - I'm a little clueless on - but it works
          // pretty sure it iterates across the entire dataset and compares each
          // value to
          // one another to and adjust the indices until you meet the rules:
          // minimum deviation
          // within a class and maximum separation between classes
          for (var l = 2, ll = dataList.length + 1; l < ll; l++) {
            var s1 = 0.0;
            var s2 = 0.0;
            var w = 0.0;
            for (var m = 1, ml = l + 1; m < ml; m++) {
              var i3 = l - m + 1;
              var val = parseFloat(dataList[i3 - 1]);
              s2 += val * val;
              s1 += val;
              w += 1;
              v = s2 - (s1 * s1) / w;
              var i4 = i3 - 1;
              if (i4 !== 0) {
                for (var p = 2, pl = nbClass + 1; p < pl; p++) {
                  if (mat2[l][p] >= (v + mat2[i4][p - 1])) {
                    mat1[l][p] = i3;
                    mat2[l][p] = v + mat2[i4][p - 1];
                  }
                }
              }
            }
            mat1[l][1] = 1;
            mat2[l][1] = v;
          }

          var k = dataList.length;
          var kclass = [];

          // fill the kclass (classification) array with zeros:
          for (i = 0; i <= nbClass; i++) {
            kclass.push(0);
          }

          // this is the last number in the array:
          kclass[nbClass] = parseFloat(dataList[dataList.length - 1]);
          // this is the first number - can set to zero, but want to set to lowest
          // to use for legend:
          kclass[0] = parseFloat(dataList[0]);
          var countNum = nbClass;
          while (countNum >= 2) {
            var id = parseInt((mat1[k][countNum]) - 2);
            kclass[countNum - 1] = dataList[id];
            k = parseInt((mat1[k][countNum] - 1));
            // spits out the rank and value of the break values:
            // console.log("id="+id,"rank = " + String(mat1[k][countNum]),"val =
            // " + String(dataList[id]))
            // count down:
            countNum -= 1;
          }
          // check to see if the 0 and 1 in the array are the same - if so, set 0
          // to 0:
          if (kclass[0] === kclass[1]) {
            kclass[0] = 0;
          }

          this.setBounds(kclass);
          this.setRanges();

          this.method = _t('Jenks') + ' (' + nbClass + ' ' + _t('classes') + ')';

          return this.bounds // array of breaks
        };

        /**
       * Quantile classification Return an array with bounds : ie array(0, 0.75,
       * 1.5, 2.25, 3);
       */
        this.getClassUniqueValues = function () {
          if (this._nodata()) { return }

          this.is_uniqueValues = true;
          var tmp = this.sorted(); // display in alphabetical order

          var a = [];

          for (let i = 0; i < this.pop(); i++) {
            if (a.indexOf(tmp[i]) === -1) {
              a.push(tmp[i]);
            }
          }

          this.bounds = a;

          // we specify the classification method
          this.method = _t('unique values');

          return a
        };

        /**
       * Return the class of a given value.
       * For example value : 6
       * and bounds array = (0, 4, 8, 12);
       * Return 2
       */
        this.getClass = function (value) {
          for (let i = 0; i < this.bounds.length; i++) {
            if (this.is_uniqueValues === true) {
              if (value === this.bounds[i]) { return i }
            } else {
            // parseFloat() is necessary
              if (parseFloat(value) <= this.bounds[i + 1]) {
                return i
              }
            }
          }

          return _t("Unable to get value's class.")
        };

        /**
       * Return the ranges array : array('0-0.75', '0.75-1.5', '1.5-2.25',
       * '2.25-3');
       */
        this.getRanges = function () {
          return this.ranges
        };

        /**
       * Returns the number/index of this.ranges that value falls into
       */
        this.getRangeNum = function (value) {
          var bounds, i;

          for (i = 0; i < this.ranges.length; i++) {
            bounds = this.ranges[i].split(/ - /);
            if (value <= parseFloat(bounds[1])) {
              return i
            }
          }
        };

        /*
       * Compute inner ranges based on serie.
       * Produce discontinous ranges used for legend - return an array similar to :
       * array('0.00-0.74', '0.98-1.52', '1.78-2.25', '2.99-3.14');
       * If inner ranges already computed, return array values.
       */
        this.getInnerRanges = function () {
          // if already computed, we return the result
          if (this.inner_ranges != null) {
            return this.inner_ranges
          }

          var a = [];
          var tmp = this.sorted();
          var cnt = 1; // bounds array counter

          for (let i = 0; i < tmp.length; i++) {
            let rangeFirstValue;
            if (i === 0) {
              rangeFirstValue = tmp[i]; // we init first range value
            }

            if (parseFloat(tmp[i]) > parseFloat(this.bounds[cnt])) {
              a[cnt - 1] = '' + rangeFirstValue + this.separator + tmp[i - 1];

              rangeFirstValue = tmp[i];

              cnt++;
            }

            // we reach the last range, we finally complete manually
            // and return the array
            if (cnt === (this.bounds.length - 1)) {
            // we set the last value
              a[cnt - 1] = '' + rangeFirstValue + this.separator + tmp[tmp.length - 1];

              this.inner_ranges = a;
              return this.inner_ranges
            }
          }
        };

        this.getSortedlist = function () {
          return this.sorted().join(', ')
        };

        // object constructor
        // At the end of script. If not setPrecision() method is not known

        // we create an object identifier for debugging
        this.objectID = new Date().getUTCMilliseconds();
        this.log('Creating new geostats object');

        if (typeof a !== 'undefined' && a.length > 0) {
          this.serie = a;
          this.setPrecision();
          this.log('Setting serie (' + a.length + ') : ' + a.join());
        } else {
          this.serie = [];
        }

        // creating aliases on classification function for backward compatibility
        this.getJenks = this.getClassJenks;
        this.getGeometricProgression = this.getClassGeometricProgression;
        this.getEqInterval = this.getClassEqInterval;
        this.getQuantile = this.getClassQuantile;
        this.getStdDeviation = this.getClassStdDeviation;
        this.getUniqueValues = this.getClassUniqueValues;
        this.getArithmeticProgression = this.getClassArithmeticProgression;
      }

      function bin (data, binInstructions) {
        if (binInstructions.constructor === Object) {
          const intervalBounds = getIntervalBounds(data, binInstructions);
          const ranges = pairRanges(intervalBounds);

          return bin1d(data, binInstructions.groupBy, ranges)
        }

        if (binInstructions.constructor === Array) {
          const intervalBoundsPerVariable = binInstructions.map(instructions => getIntervalBounds(data, instructions));
          const rangesPerVariable = intervalBoundsPerVariable.map(bounds => pairRanges(bounds));
          const variables = binInstructions.map(instructions => instructions.groupBy);

          return binKd(data, variables, rangesPerVariable)
        }
      }

      function getIntervalBounds (data, binInstructions) {
        const { groupBy, method, numClasses } = parseBinInstructions(binInstructions);

        const variableData = data[groupBy];
        if (!variableData) {
          throw new Error(`groupBy column '${groupBy}' does not exist`)
        }

        if (method === 'IntervalSize') {
          return createRangesFromBinSize(variableData, binInstructions.binSize)
        }

        if (method === 'Manual') {
          return binInstructions.manualClasses
        }

        const geoStat = new Geostats(variableData);
        return geoStat[methodMap[method]](numClasses)
      }

      function parseBinInstructions (binInstructions) {
        if (binInstructions.constructor !== Object) {
          throw new Error('Bin only accepts an Object')
        }

        const groupBy = binInstructions.groupBy;
        if (groupBy.constructor !== String) {
          throw new Error('groupBy only accepts a String variable name')
        }

        let method = binInstructions.method;
        if (!method) {
          warn('No binning method specified, defaulting to EqualInterval');
          method = 'EqualInterval';
        }
        if (method.constructor !== String) {
          warn('Binning method not recognized, defaulting to EqualInterval');
          method = 'EqualInterval';
        }

        let numClasses = binInstructions.numClasses;
        if (!numClasses) {
          warn('numClasses not specified, defaulting to 5');
          numClasses = 5;
        }

        return { groupBy, method, numClasses }
      }

      function createRangesFromBinSize (variableData, binSize) {
        if (!binSize) {
          throw new Error('Missing required option \'binSize\'')
        }

        const domain = calculateDomain(variableData);

        const binCount = Math.floor((domain[1] - domain[0]) / binSize);

        let lowerBound = domain[0];
        const ranges = [lowerBound];

        for (let i = 0; i < binCount - 1; i++) {
          const upperBound = lowerBound + binSize;
          ranges.push(upperBound);
          lowerBound = upperBound;
        }

        ranges.push(domain[1]);

        return ranges
      }

      const methodMap = {
        EqualInterval: 'getClassEqInterval',
        StandardDeviation: 'getClassStdDeviation',
        ArithmeticProgression: 'getClassArithmeticProgression',
        GeometricProgression: 'getClassGeometricProgression',
        Quantile: 'getClassQuantile',
        Jenks: 'getClassJenks'
      };

      function pairRanges (ranges) {
        const l = ranges.length;
        const newRange = [];

        for (let i = 0; i < l - 1; i++) {
          newRange.push([ranges[i], ranges[i + 1]]);
        }

        return newRange
      }

      function bin1d (data, variable, ranges) {
        // Create an empty array to store new groups divided by range
        const groups = Array(ranges.length);

        for (let i = 0; i < groups.length; i++) {
          groups[i] = {};

          for (const col in data) {
            groups[i][col] = [];
          }
        }

        const length = getDataLength(data);

        for (let i = 0; i < length; i++) {
          const value = data[variable][i];
          const binIndex = getBinIndex(ranges, value);

          if (binIndex !== -1) {
            for (const col in data) {
              groups[binIndex][col].push(data[col][i]);
            }
          }
        }

        // Remove empty bins
        const nonEmptyBinIndices = getNonEmptyBinIndices(groups);
        const nonEmptyRanges = nonEmptyBinIndices.map(i => ranges[i]);
        const nonEmptyGroups = nonEmptyBinIndices.map(i => groups[i]);

        // Add new grouped column to newData
        const newData = {
          bins: nonEmptyRanges,
          $grouped: nonEmptyGroups.map(group => new DataContainer(group, { validate: false }))
        };

        return newData
      }

      function getBinIndex (bins, value) {
        // Find index of bin in which the instance belongs
        const binIndex = bins.findIndex(function (bin, i) {
          if (i === bins.length - 1) {
            return value >= bin[0] && value <= bin[1]
          } else {
            return value >= bin[0] && value < bin[1]
          }
        });

        return binIndex
      }

      function getNonEmptyBinIndices (groups) {
        const nonEmptyBinIndices = [];

        for (let i = 0; i < groups.length; i++) {
          if (getDataLength(groups[i]) > 0) nonEmptyBinIndices.push(i);
        }

        return nonEmptyBinIndices
      }

      function binKd (data, variables, rangesPerVariable) {
        const binIndexTree = constructBinIndexTree(data, variables, rangesPerVariable);
        const binnedData = convertTreeIntoColumnData(binIndexTree, variables, rangesPerVariable);

        binnedData.$grouped = binnedData.$grouped.map(group => new DataContainer(group, { validate: false }));

        return binnedData
      }

      function constructBinIndexTree (data, variables, rangesPerVariable) {
        let binIndexTree = {};
        const dataLength = getDataLength(data);

        for (let i = 0; i < dataLength; i++) {
          const binIndices = getBinIndices(data, i, variables, rangesPerVariable);
          if (rowIsNotEmpty(binIndices)) {
            binIndexTree = updateBranch(binIndexTree, binIndices, data, i);
          }
        }

        return binIndexTree
      }

      function getBinIndices (data, index, variables, rangesPerVariable) {
        const binIndices = [];

        for (let i = 0; i < variables.length; i++) {
          const variable = variables[i];
          const value = data[variable][index];

          binIndices.push(getBinIndex(rangesPerVariable[i], value));
        }

        return binIndices
      }

      function rowIsNotEmpty (binIndices) {
        return binIndices.every(binIndex => binIndex > -1)
      }

      function updateBranch (tree, indices, data, rowIndex) {
        let currentLevel = tree;

        for (let i = 0; i < indices.length; i++) {
          const index = indices[i];

          if (lastIndex(i, indices.length)) {
            if (!(index in currentLevel)) {
              currentLevel[index] = initGroup(data);
            }

            currentLevel[index] = addRow(currentLevel[index], data, rowIndex);
          } else {
            if (!(index in currentLevel)) {
              currentLevel[index] = {};
            }

            currentLevel = currentLevel[index];
          }
        }

        return tree
      }

      function lastIndex (i, length) {
        return i === (length - 1)
      }

      function initGroup (data) {
        const group = {};
        for (const columnName in data) {
          group[columnName] = [];
        }

        return group
      }

      function addRow (group, data, rowIndex) {
        for (const columnName in data) {
          group[columnName].push(data[columnName][rowIndex]);
        }

        return group
      }

      function convertTreeIntoColumnData (binIndexTree, variables, binsPerVariable) {
        const columnData = initColumnData$1(variables);
        const dataIndex = variables.length;

        forEachBranch(binIndexTree, branchArray => {
          for (let i = 0; i < variables.length; i++) {
            const binIndex = branchArray[i];
            const bin = binsPerVariable[i][binIndex];

            const binnedColumnName = getBinnedColumnName(variables[i]);

            columnData[binnedColumnName].push(bin);
          }

          columnData.$grouped.push(branchArray[dataIndex]);
        });

        return columnData
      }

      function initColumnData$1 (variables) {
        const columnData = { $grouped: [] };

        for (let i = 0; i < variables.length; i++) {
          const binnedColumnName = getBinnedColumnName(variables[i]);
          columnData[binnedColumnName] = [];
        }

        return columnData
      }

      function forEachBranch (tree, callback) {
        for (const path of traverse(tree)) {
          callback(path);
        }
      }

      // https://stackoverflow.com/a/45628445
      function * traverse (o) {
        const memory = new Set();

        function * innerTraversal (o, path = []) {
          if (memory.has(o)) {
            // we've seen this object before don't iterate it
            return
          }

          // add the new object to our memory.
          memory.add(o);

          for (const i of Object.keys(o)) {
            const itemPath = path.concat(i);

            if (!('$key' in o[i])) {
              yield * innerTraversal(o[i], itemPath);
            } else {
              itemPath.push(o[i]);
              yield itemPath;
            }
          }
        }

        yield * innerTraversal(o);
      }

      function getBinnedColumnName (columnName) {
        return 'bins_' + columnName
      }

      function dropNA (data, dropInstructions) {
        let filterFunc;

        if (!dropInstructions) {
          // If the instructions are falsy, we will check all columns for invalid values
          filterFunc = row => {
            let keep = true;

            for (const key in row) {
              const val = row[key];
              if (isInvalid(val)) {
                keep = false;
                break
              }
            }

            return keep
          };
        } else if (dropInstructions.constructor === String) {
          // If the instructions are a string, we check only one column for invalid values
          checkIfColumnsExist(data, [dropInstructions]);
          filterFunc = row => !isInvalid(row[dropInstructions]);
        } else if (dropInstructions.constructor === Array) {
          // if the instructions are an array, we check the columns named in the array
          checkIfColumnsExist(data, dropInstructions);
          filterFunc = row => {
            let keep = true;
            for (const col of dropInstructions) {
              if (isInvalid(row[col])) {
                keep = false;
                break
              }
            }

            return keep
          };
        } else {
          throw new Error('dropNA can only be passed undefined, a String or an Array of Strings')
        }

        return filter(data, filterFunc)
      }

      function checkIfColumnsExist (data, columns) {
        for (const col of columns) {
          if (!(col in data)) {
            throw new Error(`Column '${col}' not found`)
          }
        }
      }

      // This function comes from Turf's wonderful geospatial lib
      // We only need this single function and importing it from @turf/meta
      // doesn't work well for in-browser compilation
      // https://github.com/Turfjs/turf

      // The MIT License (MIT)

      // Copyright (c) 2019 Morgan Herlocker

      // Permission is hereby granted, free of charge, to any person obtaining a copy of
      // this software and associated documentation files (the "Software"), to deal in
      // the Software without restriction, including without limitation the rights to
      // use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
      // the Software, and to permit persons to whom the Software is furnished to do so,
      // subject to the following conditions:

      // The above copyright notice and this permission notice shall be included in all
      // copies or substantial portions of the Software.

      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
      // FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
      // COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
      // IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
      // CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

      function coordEach (geojson, callback, excludeWrapCoord) {
        // Handles null Geometry -- Skips this GeoJSON
        if (geojson === null) return
        var j; var k; var l; var geometry; var stopG; var coords;
        var geometryMaybeCollection;
        var wrapShrink = 0;
        var coordIndex = 0;
        var isGeometryCollection;
        var type = geojson.type;
        var isFeatureCollection = type === 'FeatureCollection';
        var isFeature = type === 'Feature';
        var stop = isFeatureCollection ? geojson.features.length : 1;

        // This logic may look a little weird. The reason why it is that way
        // is because it's trying to be fast. GeoJSON supports multiple kinds
        // of objects at its root: FeatureCollection, Features, Geometries.
        // This function has the responsibility of handling all of them, and that
        // means that some of the `for` loops you see below actually just don't apply
        // to certain inputs. For instance, if you give this just a
        // Point geometry, then both loops are short-circuited and all we do
        // is gradually rename the input until it's called 'geometry'.
        //
        // This also aims to allocate as few resources as possible: just a
        // few numbers and booleans, rather than any temporary arrays as would
        // be required with the normalization approach.
        for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
          geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry
            : (isFeature ? geojson.geometry : geojson));
          isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

          for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
            var multiFeatureIndex = 0;
            var geometryIndex = 0;
            geometry = isGeometryCollection
              ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;

            // Handles null Geometry -- Skips this geometry
            if (geometry === null) continue
            coords = geometry.coordinates;
            var geomType = geometry.type;

            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

            switch (geomType) {
              case null:
                break
              case 'Point':
                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false
                coordIndex++;
                multiFeatureIndex++;
                break
              case 'LineString':
              case 'MultiPoint':
                for (j = 0; j < coords.length; j++) {
                  if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false
                  coordIndex++;
                  if (geomType === 'MultiPoint') multiFeatureIndex++;
                }
                if (geomType === 'LineString') multiFeatureIndex++;
                break
              case 'Polygon':
              case 'MultiLineString':
                for (j = 0; j < coords.length; j++) {
                  for (k = 0; k < coords[j].length - wrapShrink; k++) {
                    if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false
                    coordIndex++;
                  }
                  if (geomType === 'MultiLineString') multiFeatureIndex++;
                  if (geomType === 'Polygon') geometryIndex++;
                }
                if (geomType === 'Polygon') multiFeatureIndex++;
                break
              case 'MultiPolygon':
                for (j = 0; j < coords.length; j++) {
                  geometryIndex = 0;
                  for (k = 0; k < coords[j].length; k++) {
                    for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                      if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false
                      coordIndex++;
                    }
                    geometryIndex++;
                  }
                  multiFeatureIndex++;
                }
                break
              case 'GeometryCollection':
                for (j = 0; j < geometry.geometries.length; j++) { if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false }
                break
              default:
                throw new Error('Unknown Geometry Type')
            }
          }
        }
      }

      function transformGeometries (geometries, transformFunc) {
        const geometriesClone = JSON.parse(JSON.stringify(geometries));

        if (geometriesClone.constructor === Array) {
          for (let i = 0; i < geometriesClone.length; i++) {
            transformGeometryInplace(geometriesClone[i], transformFunc);
          }
        }

        if (geometriesClone.constructor === Object) {
          for (const key in geometriesClone) {
            transformGeometryInplace(geometriesClone[key], transformFunc);
          }
        }

        return geometriesClone
      }

      function transformGeometryInplace (geometry, transformFunc) {
        coordEach(geometry, coord => {
          const transformedPosition = transformFunc(coord);
          coord[0] = transformedPosition[0];
          coord[1] = transformedPosition[1];
        });
      }

      function reproject (data, transformation) {
        if (!('$geometry' in data)) {
          warn('No geometry column found. Skipping reproject-transformation.');
          return data
        }

        const transformedGeometries = transformGeometries(data.$geometry, transformation);
        data.$geometry = transformedGeometries;

        return data
      }

      function transform (data, transformFunction) {
        if (transformFunction.constructor !== Function) {
          throw new Error(`Invalid 'transform' transformation: must be a Function`)
        }

        transformFunction(data);
      }

      function cumsum (data, cumsumInstructions, options = { asInterval: false }) {
        const asInterval = options.asInterval;
        const length = getDataLength(data);
        const newColumns = {};

        for (const newColName in cumsumInstructions) {
          checkRegularColumnName(newColName);

          const oldColName = cumsumInstructions[newColName];

          if (getColumnType(data[oldColName]) !== 'quantitative') {
            throw new Error('cumsum columns can only be of type \'quantitative\'')
          }

          let previousSum = 0;
          let currentSum = 0;
          newColumns[newColName] = [];

          for (let i = 0; i < length; i++) {
            const value = data[oldColName][i];

            if (!isInvalid(value)) {
              currentSum += value;
            }

            if (asInterval) {
              newColumns[newColName].push([previousSum, currentSum]);
            } else {
              newColumns[newColName].push(currentSum);
            }

            previousSum = currentSum;
          }
        }

        Object.assign(data, newColumns);
      }

      function rowCumsum (data, _cumsumInstructions, options = { asInterval: false }) {
        const asInterval = options.asInterval;
        const cumsumInstructions = parseCumsumInstructions(_cumsumInstructions);
        validateColumns(data, cumsumInstructions);

        const rowCumsumColumns = {};
        let previousColumnName;

        for (const [newName, oldName] of cumsumInstructions) {
          checkRegularColumnName(newName);
          const oldColumn = data[oldName];

          if (previousColumnName === undefined) {
            if (asInterval) {
              rowCumsumColumns[newName] = oldColumn.map(value => [0, value]);
            } else {
              rowCumsumColumns[newName] = oldColumn;
            }
          } else {
            const previousColumn = rowCumsumColumns[previousColumnName];
            let newColumn;

            if (asInterval) {
              newColumn = oldColumn.map((value, i) => {
                const previousValue = previousColumn[i][1];
                const newValue = previousValue + value;
                return [previousValue, newValue]
              });
            } else {
              newColumn = oldColumn.map((value, i) => value + previousColumn[i]);
            }

            rowCumsumColumns[newName] = newColumn;
          }

          previousColumnName = newName;
        }

        Object.assign(data, rowCumsumColumns);
      }

      const invalidInstructionsError = new Error('Invalid rowCumsum instrutions');

      function parseCumsumInstructions (cumsumInstructions) {
        if (cumsumInstructions && cumsumInstructions.constructor === Array) {
          const parsedInstructions = [];

          for (const instruction of cumsumInstructions) {
            validateInstruction(instruction);

            if (instruction.constructor === String) {
              parsedInstructions.push([instruction, instruction]);
            }

            if (instruction.constructor === Object) {
              const newName = Object.keys(instruction)[0];
              const oldName = instruction[newName];
              parsedInstructions.push([newName, oldName]);
            }
          }

          return parsedInstructions
        }

        throw invalidInstructionsError
      }

      function validateInstruction (instruction) {
        if (instruction.constructor === String) return

        if (instruction.constructor === Object) {
          if (Object.keys(instruction).length === 1) return
        }

        throw invalidInstructionsError
      }

      function validateColumns (data, stackInstructions) {
        for (const [, oldName] of stackInstructions) {
          const column = data[oldName];

          if (!column) {
            throw new Error(`Column '${oldName}' does not exist`)
          }

          const columnType = getColumnType(column);

          if (columnType !== 'quantitative') {
            throw new Error('rowCumsum columns can only be of type \'quantitative\'')
          }
        }
      }

      const transformations = {
        filter,
        select: produce(select),
        arrange: produce(arrange),
        rename: produce(rename),
        mutate: produce(mutate),
        transmute: produce(transmute),
        summarise,
        mutarise,
        groupBy,
        bin,
        dropNA,
        reproject,
        transform: produce(transform),
        cumsum: produce(cumsum),
        rowCumsum: produce(rowCumsum)
      };

      const methods$1 = {
        arrange (sortInstructions) {
          const data = transformations.arrange(this._data, sortInstructions);
          return new DataContainer(data, { validate: false })
        },

        bin (binInstructions) {
          const data = transformations.bin(this._data, binInstructions);
          return new DataContainer(data, { validate: false })
        },

        cumsum (cumsumInstructions, options) {
          const data = transformations.cumsum(this._data, cumsumInstructions, options);
          return new DataContainer(data, { validate: false })
        },

        dropNA (dropInstructions) {
          const data = transformations.dropNA(this._data, dropInstructions);
          return new DataContainer(data, { validate: false })
        },

        filter (filterFunction) {
          const data = transformations.filter(this._data, filterFunction);
          return new DataContainer(data, { validate: false })
        },

        groupBy (groupByInstructions) {
          const data = transformations.groupBy(this._data, groupByInstructions);
          return new DataContainer(data, { validate: false })
        },

        mutarise (mutariseInstructions) {
          const data = transformations.mutarise(this._data, mutariseInstructions);
          return new DataContainer(data, { validate: false })
        },

        mutarize (mutariseInstructions) {
          const data = transformations.mutarise(this._data, mutariseInstructions);
          return new DataContainer(data, { validate: false })
        },

        mutate (mutateInstructions) {
          const data = transformations.mutate(this._data, mutateInstructions);
          return new DataContainer(data, { validate: false })
        },

        transmute (transmuteInstructions) {
          const data = transformations.transmute(this._data, transmuteInstructions);
          return new DataContainer(data, { validate: false })
        },

        rename (renameInstructions) {
          const data = transformations.rename(this._data, renameInstructions);
          return new DataContainer(data, { validate: false })
        },

        reproject (reprojectInstructions) {
          const data = transformations.reproject(this._data, reprojectInstructions);
          return new DataContainer(data, { validate: false })
        },

        rowCumsum (cumsumInstructions, options) {
          const data = transformations.rowCumsum(this._data, cumsumInstructions, options);
          return new DataContainer(data, { validate: false })
        },

        select (selection) {
          const data = transformations.select(this._data, selection);
          return new DataContainer(data, { validate: false })
        },

        summarise (summariseInstructions) {
          const data = transformations.summarise(this._data, summariseInstructions);
          return new DataContainer(data, { validate: false })
        },

        summarize (summariseInstructions) {
          const data = transformations.summarise(this._data, summariseInstructions);
          return new DataContainer(data, { validate: false })
        },

        transform (transformFunction) {
          const data = transformations.transform(this._data, transformFunction);
          return new DataContainer(data, { validate: false })
        }
      };

      function transformationsMixin (targetClass) {
        Object.assign(targetClass.prototype, methods$1);
      }

      function ensureValidRow (row, self) {
        for (const columnName in row) {
          if (!(columnName in self._data)) throw new Error(`Column '${columnName}' not found`)
        }

        for (const columnName in self._data) {
          if (columnName === '$key') {
            if (columnName in row) throw new Error('Cannot set \'$key\' column')
          } else {
            if (!(columnName in row)) throw new Error(`Missing column '${columnName}'`)

            const value = row[columnName];
            ensureValueIsRightForColumn(value, columnName, self);
          }
        }
      }

      function ensureValidRowUpdate (row, self) {
        for (const columnName in row) {
          if (!(columnName in self._data)) throw new Error(`Column '${columnName}' not found`)

          const value = row[columnName];
          ensureValueIsRightForColumn(value, columnName, self);
        }
      }

      function ensureRowExists (key, self) {
        if (isUndefined(self._keyToRowNumber[key])) {
          throw new Error(`Key '${key}' not found`)
        }
      }

      function ensureValueIsRightForColumn (value, columnName, self) {
        if (!isInvalid(value)) {
          const columnType = getColumnType(self._data[columnName]);

          ensureValidDataType(value);
          const valueType = getDataType(value);

          if (columnType !== valueType) {
            throw new Error(`Column '${columnName}' is of type '${columnType}'. Received value of type '${valueType}'`)
          }
        }
      }

      function isValidColumn (column, columnName) {
        const columnType = getColumnType(column);

        if (columnType === undefined) return false
        if (!columnNameMatchesType(columnName, columnType)) return false
        if (!allValidValuesHaveTheSameType(column, columnType)) return false

        return true
      }

      function ensureValidColumn (column, columnName) {
        const { nValidValues } = findFirstValidValue(column);

        if (nValidValues === 0) {
          throw new Error(`Invalid column '${columnName}'. Column contains only invalid values.`)
        }

        const columnType = getColumnType(column);

        if (columnType === undefined) throw new Error(`Column '${columnName}' contains data of unknown type`)
        ensureColumnNameMatchesType(columnType);
        ensureAllValidValuesHaveTheSameType(column, columnType, columnName);
      }

      function columnNameMatchesType (columnName, columnType) {
        if (columnName === '$geometry' && columnType !== 'geometry') return false
        if (columnName !== '$geometry' && columnType === 'geometry') return false

        return true
      }

      function ensureColumnNameMatchesType (columnName, columnType) {
        if (columnName === '$geometry' && columnType !== 'geometry') {
          throw new Error(`Column '$geometry' can only contain data of type 'geometry', received '${columnType}'`)
        }

        if (columnName !== '$geometry' && columnType === 'geometry') {
          throw new Error(`Only the '$geometry' column can contain data of type 'geometry'`)
        }
      }

      function allValidValuesHaveTheSameType (column, columnType) {
        for (let i = 0; i < column.length; i++) {
          const value = column[i];

          if (isInvalid(value)) continue

          const valueType = getDataType(value);

          if (valueType !== columnType) {
            return false
          }
        }

        return true
      }

      function ensureAllValidValuesHaveTheSameType (column, columnType, columnName) {
        if (!allValidValuesHaveTheSameType(column, columnType)) {
          throw new Error(`Column '${columnName}' mixes types`)
        }
      }

      function columnExists (columnName, self) {
        return columnName in self._data
      }

      function ensureColumnExists (columnName, self) {
        if (!columnExists(columnName, self)) {
          throw new Error(`Invalid column name: '${columnName}'`)
        }
      }

      const methods$2 = {
        // Rows
        addRow (row) {
          ensureValidRow(row, this);
          const self = this;

          this._data = produce(this._data, draft => {
            for (const columnName in row) {
              const value = row[columnName];
              draft[columnName].push(value);

              self._updateDomainIfNecessary(columnName, value);
            }
          });

          const rowNumber = getDataLength(this._data) - 1;
          const keyDomain = this.domain('$key');
          keyDomain[1]++;
          const key = keyDomain[1];

          this._data = produce(this._data, draft => {
            draft.$key.push(key);
          });

          this._keyToRowNumber[key] = rowNumber;
        },

        updateRow (key, row) {
          if (row.constructor === Function) {
            const result = row(this.row(key));

            if (!(result && result.constructor === Object)) {
              throw new Error('updateRow function must return Object')
            }

            this.updateRow(key, result);
          }

          ensureRowExists(key, this);
          ensureValidRowUpdate(row, this);
          const self = this;
          const rowNumber = this._keyToRowNumber[key];

          this._data = produce(this._data, draft => {
            for (const columnName in row) {
              throwErrorIfColumnIsKey(columnName);

              const value = row[columnName];
              draft[columnName][rowNumber] = value;

              self._resetDomainIfNecessary(columnName);
            }
          });
        },

        deleteRow (key) {
          ensureRowExists(key, this);
          const self = this;
          const rowNumber = this._keyToRowNumber[key];
          delete this._keyToRowNumber[key];

          this._data = produce(this._data, draft => {
            for (const columnName in draft) {
              draft[columnName].splice(rowNumber, 1);
              self._resetDomainIfNecessary(columnName);
            }
          });
        },

        // Columns
        addColumn (columnName, column) {
          this._validateNewColumn(columnName, column);

          this._data = produce(this._data, draft => {
            draft[columnName] = column;
          });
        },

        replaceColumn (columnName, column) {
          this.deleteColumn(columnName);
          this.addColumn(columnName, column);
        },

        deleteColumn (columnName) {
          ensureColumnExists(columnName, this);
          throwErrorIfColumnIsKey(columnName);

          if (Object.keys(this._data).length === 2) {
            throw new Error('Cannot delete last column')
          }

          this._data = produce(this._data, draft => {
            delete draft[columnName];
          });
        },

        // Private methods
        _updateDomainIfNecessary (columnName, value) {
          const type = getDataType(value);

          if (columnName in this._domains) {
            this._domains[columnName] = updateDomain(
              this._domains[columnName],
              value,
              type
            );
          }
        },

        _resetDomainIfNecessary (columnName) {
          if (columnName in this._domains) {
            delete this._domains[columnName];
          }
        },

        _validateNewColumn (columnName, column) {
          checkRegularColumnName(columnName);

          if (columnName in this._data) {
            throw new Error(`Column '${columnName}' already exists`)
          }

          const dataLength = getDataLength(this._data);
          if (dataLength !== column.length) {
            throw new Error('Column must be of same length as rest of data')
          }

          ensureValidColumn(column);
        }
      };

      function modifyingRowsAndColumnsMixin (targetClass) {
        Object.assign(targetClass.prototype, methods$2);
      }

      function throwErrorIfColumnIsKey (columnName) {
        if (columnName === '$key') throw new Error('Cannot modify key column')
      }

      function getJoinColumns (left, right, by) {
        const leftData = left.data();
        const rightData = right.data();

        if (isUndefined(by)) {
          const leftDataLength = getDataLength(leftData);
          const joinColumns = {};

          for (const columnName in rightData) {
            if (columnName !== '$key') {
              const rightColumn = rightData[columnName];
              joinColumns[columnName] = rightColumn.slice(0, leftDataLength);
            }
          }

          return joinColumns
        }

        if (isDefined(by)) {
          const joinColumns = initJoinColumns(rightData, by[1]);

          const rightRowsByKey = generateRightRowsByKey(rightData, by[1]);
          const leftByColumn = leftData[by[0]];

          for (let i = 0; i < leftByColumn.length; i++) {
            const leftKey = leftByColumn[i];
            const row = rightRowsByKey[leftKey];

            for (const columnName in row) {
              joinColumns[columnName].push(row[columnName]);
            }
          }

          return joinColumns
        }
      }

      function initJoinColumns (right, byColumnName) {
        const joinColumns = {};

        for (const columnName in right) {
          if (columnName !== '$key' && columnName !== byColumnName) {
            joinColumns[columnName] = [];
          }
        }

        return joinColumns
      }

      function generateRightRowsByKey (right, byColumnName) {
        const rightRowsByKey = {};
        const byColumn = right[byColumnName];

        for (let i = 0; i < byColumn.length; i++) {
          const key = byColumn[i];
          const row = {};

          for (const columnName in right) {
            if (columnName !== '$key' && columnName !== byColumnName) {
              row[columnName] = right[columnName][i];
            }
          }

          rightRowsByKey[key] = row;
        }

        return rightRowsByKey
      }

      function validateJoin (left, right, by) {
        const leftData = left.data();
        const rightData = getRightData(right);

        if (isUndefined(by)) {
          const leftLength = getDataLength(leftData);
          const rightLength = getDataLength(rightData);

          if (rightLength < leftLength) {
            throw new Error(
              'Without \'by\', the right DataContainer must be the same length as or longer than left DataContainer'
            )
          }
        }

        if (isDefined(by)) {
          validateByColumnsExist(leftData, rightData, by);
          ensureColumnsAreCompatible(leftData, rightData, by);
          ensureNoDuplicateColumnNames(leftData, rightData, by);
        }
      }

      function getRightData (right) {
        if (!(right instanceof DataContainer)) {
          throw new Error('It is only possible to join another DataContainer')
        }

        return right.data()
      }

      function validateByColumnsExist (left, right, by) {
        if (!(by.constructor === Array && by.length === 2 && by.every(c => c.constructor === String))) {
          throw new Error('Invalid format of \'by\'. Must be Array of two column names.')
        }

        const [leftColumnName, rightColumnName] = by;

        if (!(leftColumnName in left)) {
          throw new Error(`Column '${leftColumnName}' not found`)
        }

        if (!(rightColumnName in right)) {
          throw new Error(`Column '${rightColumnName}' not found`)
        }
      }

      function ensureColumnsAreCompatible (left, right, by) {
        const [leftColumnName, rightColumnName] = by;
        const leftColumn = left[leftColumnName];
        const rightColumn = right[rightColumnName];

        const leftType = getColumnType(leftColumn);
        const rightType = getColumnType(rightColumn);

        if (leftType !== rightType) throw new Error('\'by\' columns must be of the same type')

        ensureRightByColumnIsUnique(right[rightColumnName]);
        ensureLeftColumnIsSubsetOfRightColumn(leftColumn, rightColumn);
      }

      function ensureRightByColumnIsUnique (column) {
        if (column.length !== new Set(column).size) {
          throw new Error('Right \'by\' column must contain only unique values')
        }
      }

      function ensureLeftColumnIsSubsetOfRightColumn (leftColumn, rightColumn) {
        const rightSet = new Set(rightColumn);

        for (let i = 0; i < leftColumn.length; i++) {
          const leftKey = leftColumn[i];
          if (!rightSet.has(leftKey)) {
            throw new Error('Left \'by\' column must be subset of right column')
          }
        }
      }

      function ensureNoDuplicateColumnNames (left, right, by) {
        const rightColumnName = by[1];

        for (const columnName in right) {
          if (columnName !== '$key' && columnName in left) {
            if (columnName !== rightColumnName) {
              throw new Error(`Duplicate column name: '${columnName}'`)
            }
          }
        }
      }

      class DataContainer {
        constructor (data, options = { validate: true }) {
          this._data = {};
          this._keyToRowNumber = {};
          this._domains = {};

          if (isColumnOriented(data)) {
            this._setColumnData(data, options);
            return
          }

          if (isRowOriented(data)) {
            this._setRowData(data, options);
            return
          }

          if (isGeoJSON(data)) {
            this._setGeoJSON(data, options);
            return
          }

          if (data instanceof Group) {
            this._setGroup(data, options);
            return
          }

          throw invalidDataError
        }

        // Accessing data
        data () {
          return this._data
        }

        row (key) {
          const rowNumber = this._keyToRowNumber[key];
          return this._row(rowNumber)
        }

        prevRow (key) {
          const rowNumber = this._keyToRowNumber[key];
          const previousRowNumber = rowNumber - 1;
          return this._row(previousRowNumber)
        }

        nextRow (key) {
          const rowNumber = this._keyToRowNumber[key];
          const nextRowNumber = rowNumber + 1;
          return this._row(nextRowNumber)
        }

        rows () {
          const rows = [];
          const length = getDataLength(this._data);

          for (let i = 0; i < length; i++) {
            rows.push(this._row(i));
          }

          return rows
        }

        column (columnName) {
          ensureColumnExists(columnName, this);
          return this._data[columnName]
        }

        map (columnName, mapFunction) {
          return this.column(columnName).map(mapFunction)
        }

        domain (columnName) {
          if (columnName in this._domains) {
            return this._domains[columnName]
          }

          const column = this.column(columnName);
          const domain = calculateDomain(column, columnName);
          this._domains[columnName] = domain;
          return domain
        }

        type (columnName) {
          const column = this.column(columnName);
          return getColumnType(column)
        }

        columnNames () {
          return Object.keys(this._data)
        }

        // Checks
        hasColumn (columnName) {
          return columnExists(columnName, this)
        }

        columnIsValid (columnName) {
          const column = this.column(columnName);
          return isValidColumn(column, columnName)
        }

        validateColumn (columnName) {
          const column = this.column(columnName);
          ensureValidColumn(column, columnName);
        }

        validateAllColumns () {
          for (const columnName in this._data) {
            this.validateColumn(columnName);
          }
        }

        // Join
        join (dataContainer, { by = undefined } = {}) {
          validateJoin(this, dataContainer, by);
          const joinColumns = getJoinColumns(this, dataContainer, by);

          for (const columnName in joinColumns) {
            this.addColumn(columnName, joinColumns[columnName]);
          }
        }

        // Private methods
        _row (rowNumber) {
          const length = getDataLength(this._data);

          if (rowNumber < 0 || rowNumber >= length) {
            return undefined
          }

          const row = {};

          for (const columnName in this._data) {
            const value = this._data[columnName][rowNumber];
            row[columnName] = value;
          }

          return row
        }
      }

      dataLoadingMixin(DataContainer);
      transformationsMixin(DataContainer);
      modifyingRowsAndColumnsMixin(DataContainer);

      const invalidDataError = new Error('Data passed to DataContainer is of unknown format');

      return DataContainer;

    }));
    });

    /* test/sandbox/src/examples/BarChart.svelte generated by Svelte v3.15.0 */
    const file$b = "test/sandbox/src/examples/BarChart.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.row = list[i];
    	return child_ctx;
    }

    // (64:4) {#each data.rows() as row (row.$key)}
    function create_each_block$2(key_1, ctx) {
    	let first;
    	let current;

    	function func(...args) {
    		return ctx.func(ctx, ...args);
    	}

    	const rectangle = new Rectangle({
    			props: {
    				x1: ctx.row.fruit,
    				x2: func,
    				y1: 0,
    				y2: ctx.row.meanQuantity,
    				fill: ctx.transformation === "identity" ? "green" : "blue",
    				transition: 2000,
    				onClick: ctx.handler
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(rectangle.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(rectangle, target, anchor);
    			current = true;
    		},
    		p: function update(changed, new_ctx) {
    			ctx = new_ctx;
    			const rectangle_changes = {};
    			if (changed.data) rectangle_changes.x1 = ctx.row.fruit;
    			if (changed.data) rectangle_changes.x2 = func;
    			if (changed.data) rectangle_changes.y2 = ctx.row.meanQuantity;
    			if (changed.transformation) rectangle_changes.fill = ctx.transformation === "identity" ? "green" : "blue";
    			if (changed.handler) rectangle_changes.onClick = ctx.handler;
    			rectangle.$set(rectangle_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rectangle.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rectangle.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(rectangle, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(64:4) {#each data.rows() as row (row.$key)}",
    		ctx
    	});

    	return block;
    }

    // (55:2) <Section     x1={50} x2={450}     y1={50} y2={450}     scaleX={scaleFruit}    scaleY={scaleMeanQuantity}     flipY     {transformation}   >
    function create_default_slot_1(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value = ctx.data.rows();
    	const get_key = ctx => ctx.row.$key;

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$2(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const each_value = ctx.data.rows();
    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$2, each_1_anchor, get_each_context$2);
    			check_outros();
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(55:2) <Section     x1={50} x2={450}     y1={50} y2={450}     scaleX={scaleFruit}    scaleY={scaleMeanQuantity}     flipY     {transformation}   >",
    		ctx
    	});

    	return block;
    }

    // (49:0) <Graphic    width={500} {height}   scaleX={scaleLinear().domain([0, 500])}   scaleY={scaleLinear().domain([0, 500])} >
    function create_default_slot(ctx) {
    	let current;

    	const section = new Section({
    			props: {
    				x1: 50,
    				x2: 450,
    				y1: 50,
    				y2: 450,
    				scaleX: ctx.scaleFruit,
    				scaleY: ctx.scaleMeanQuantity,
    				flipY: true,
    				transformation: ctx.transformation,
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const section_changes = {};
    			if (changed.transformation) section_changes.transformation = ctx.transformation;

    			if (changed.$$scope || changed.data || changed.transformation || changed.handler) {
    				section_changes.$$scope = { changed, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(49:0) <Graphic    width={500} {height}   scaleX={scaleLinear().domain([0, 500])}   scaleY={scaleLinear().domain([0, 500])} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let div0;
    	let label0;
    	let t1;
    	let input0;
    	let t2;
    	let div1;
    	let label1;
    	let t4;
    	let select;
    	let option0;
    	let option1;
    	let t7;
    	let div2;
    	let label2;
    	let t9;
    	let input1;
    	let t10;
    	let current;
    	let dispose;

    	const graphic = new Graphic({
    			props: {
    				width: 500,
    				height: ctx.height,
    				scaleX: linear$1().domain([0, 500]),
    				scaleY: linear$1().domain([0, 500]),
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			label0 = element("label");
    			label0.textContent = "Height:";
    			t1 = space();
    			input0 = element("input");
    			t2 = space();
    			div1 = element("div");
    			label1 = element("label");
    			label1.textContent = "Coordinates:";
    			t4 = space();
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "Identity";
    			option1 = element("option");
    			option1.textContent = "Polar";
    			t7 = space();
    			div2 = element("div");
    			label2 = element("label");
    			label2.textContent = "Transition time";
    			t9 = space();
    			input1 = element("input");
    			t10 = space();
    			create_component(graphic.$$.fragment);
    			attr_dev(label0, "for", "height-slider");
    			add_location(label0, file$b, 31, 2, 987);
    			attr_dev(input0, "type", "range");
    			attr_dev(input0, "min", "0");
    			attr_dev(input0, "max", "500");
    			attr_dev(input0, "name", "height-slider");
    			add_location(input0, file$b, 32, 2, 1032);
    			add_location(div0, file$b, 30, 0, 979);
    			attr_dev(label1, "for", "coordinate-select");
    			add_location(label1, file$b, 36, 2, 1130);
    			option0.__value = "identity";
    			option0.value = option0.__value;
    			add_location(option0, file$b, 38, 4, 1250);
    			option1.__value = "polar";
    			option1.value = option1.__value;
    			add_location(option1, file$b, 39, 4, 1297);
    			attr_dev(select, "name", "coordinate-select");
    			if (ctx.transformation === void 0) add_render_callback(() => ctx.select_change_handler.call(select));
    			add_location(select, file$b, 37, 2, 1184);
    			add_location(div1, file$b, 35, 0, 1122);
    			attr_dev(label2, "for", "duration");
    			add_location(label2, file$b, 44, 2, 1362);
    			attr_dev(input1, "name", "duration");
    			attr_dev(input1, "type", "range");
    			attr_dev(input1, "min", "100");
    			attr_dev(input1, "max", "5000");
    			add_location(input1, file$b, 45, 2, 1410);
    			add_location(div2, file$b, 43, 0, 1354);

    			dispose = [
    				listen_dev(input0, "change", ctx.input0_change_input_handler),
    				listen_dev(input0, "input", ctx.input0_change_input_handler),
    				listen_dev(select, "change", ctx.select_change_handler),
    				listen_dev(input1, "change", ctx.input1_change_input_handler),
    				listen_dev(input1, "input", ctx.input1_change_input_handler)
    			];
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, label0);
    			append_dev(div0, t1);
    			append_dev(div0, input0);
    			set_input_value(input0, ctx.height);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, label1);
    			append_dev(div1, t4);
    			append_dev(div1, select);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			select_option(select, ctx.transformation);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, label2);
    			append_dev(div2, t9);
    			append_dev(div2, input1);
    			set_input_value(input1, ctx.duration);
    			insert_dev(target, t10, anchor);
    			mount_component(graphic, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (changed.height) {
    				set_input_value(input0, ctx.height);
    			}

    			if (changed.transformation) {
    				select_option(select, ctx.transformation);
    			}

    			if (changed.duration) {
    				set_input_value(input1, ctx.duration);
    			}

    			const graphic_changes = {};
    			if (changed.height) graphic_changes.height = ctx.height;

    			if (changed.$$scope || changed.transformation || changed.data || changed.handler) {
    				graphic_changes.$$scope = { changed, ctx };
    			}

    			graphic.$set(graphic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t10);
    			destroy_component(graphic, detaching);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let data = new florenceDatacontainer_umd({
    			quantity: [1, 4, 2, 3, 3, 5, 6, 9],
    			fruit: [
    				NaN,
    				"anchovies",
    				"banana",
    				"banana",
    				"coconut",
    				"coconut",
    				"durian",
    				"durian"
    			]
    		});

    	$$invalidate("data", data = data.dropNA().filter(row => row.fruit !== "anchovies").groupBy("fruit").summarise({ meanQuantity: { quantity: "mean" } }).arrange({ meanQuantity: "descending" }));
    	const scaleFruit = band().domain(data.domain("fruit")).padding(0.2);
    	let meanQuantityDomain = [0, data.domain("meanQuantity")[1]];
    	const scaleMeanQuantity = linear$1().domain(meanQuantityDomain);
    	let height = 500;
    	let transformation = "identity";
    	let duration = 2000;

    	function input0_change_input_handler() {
    		height = to_number(this.value);
    		$$invalidate("height", height);
    	}

    	function select_change_handler() {
    		transformation = select_value(this);
    		$$invalidate("transformation", transformation);
    	}

    	function input1_change_input_handler() {
    		duration = to_number(this.value);
    		$$invalidate("duration", duration);
    	}

    	const func = ({ row }, { scaleX }) => scaleX(row.fruit) + scaleX.bandwidth();

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate("data", data = $$props.data);
    		if ("meanQuantityDomain" in $$props) meanQuantityDomain = $$props.meanQuantityDomain;
    		if ("height" in $$props) $$invalidate("height", height = $$props.height);
    		if ("transformation" in $$props) $$invalidate("transformation", transformation = $$props.transformation);
    		if ("duration" in $$props) $$invalidate("duration", duration = $$props.duration);
    		if ("handler" in $$props) $$invalidate("handler", handler = $$props.handler);
    	};

    	let handler;

    	$$self.$$.update = (changed = { transformation: 1 }) => {
    		if (changed.transformation) {
    			 $$invalidate("handler", handler = transformation === "identity"
    			? e => {
    					console.log(e);
    				}
    			: () => {
    					console.log("polar");
    				});
    		}
    	};

    	return {
    		data,
    		scaleFruit,
    		scaleMeanQuantity,
    		height,
    		transformation,
    		duration,
    		handler,
    		input0_change_input_handler,
    		select_change_handler,
    		input1_change_input_handler,
    		func
    	};
    }

    class BarChart extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BarChart",
    			options,
    			id: create_fragment$p.name
    		});
    	}
    }

    /* test/sandbox/src/examples/Polygons.svelte generated by Svelte v3.15.0 */
    const file$c = "test/sandbox/src/examples/Polygons.svelte";

    // (65:2) <Section     x1={50} x2={450}     y1={50} y2={450}     scaleX={scaleLinear().domain([0, 10])}     scaleY={scaleLinear().domain([0, 10])}     {transformation}   >
    function create_default_slot_1$1(ctx) {
    	let current;

    	const polygonlayer = new PolygonLayer({
    			props: {
    				geometry: [ctx.geometries[ctx.chosenGeometry]],
    				interpolate: true,
    				onMouseover: ctx.func,
    				onMouseout: ctx.func_1,
    				fill: ctx.isHovering ? "blue" : "yellow",
    				key: [0],
    				transition: 2000
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(polygonlayer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(polygonlayer, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const polygonlayer_changes = {};
    			if (changed.chosenGeometry) polygonlayer_changes.geometry = [ctx.geometries[ctx.chosenGeometry]];
    			if (changed.isHovering) polygonlayer_changes.onMouseover = ctx.func;
    			if (changed.isHovering) polygonlayer_changes.onMouseout = ctx.func_1;
    			if (changed.isHovering) polygonlayer_changes.fill = ctx.isHovering ? "blue" : "yellow";
    			polygonlayer.$set(polygonlayer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(polygonlayer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(polygonlayer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(polygonlayer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(65:2) <Section     x1={50} x2={450}     y1={50} y2={450}     scaleX={scaleLinear().domain([0, 10])}     scaleY={scaleLinear().domain([0, 10])}     {transformation}   >",
    		ctx
    	});

    	return block;
    }

    // (63:0) <Graphic width={500} height={500}>
    function create_default_slot$1(ctx) {
    	let current;

    	const section = new Section({
    			props: {
    				x1: 50,
    				x2: 450,
    				y1: 50,
    				y2: 450,
    				scaleX: linear$1().domain([0, 10]),
    				scaleY: linear$1().domain([0, 10]),
    				transformation: ctx.transformation,
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const section_changes = {};
    			if (changed.transformation) section_changes.transformation = ctx.transformation;

    			if (changed.$$scope || changed.chosenGeometry || changed.isHovering) {
    				section_changes.$$scope = { changed, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(63:0) <Graphic width={500} height={500}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let div0;
    	let label0;
    	let t1;
    	let select0;
    	let option0;
    	let option1;
    	let t4;
    	let div1;
    	let label1;
    	let t6;
    	let select1;
    	let option2;
    	let option3;
    	let option4;
    	let t10;
    	let current;
    	let dispose;

    	const graphic = new Graphic({
    			props: {
    				width: 500,
    				height: 500,
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			label0 = element("label");
    			label0.textContent = "Coordinates:";
    			t1 = space();
    			select0 = element("select");
    			option0 = element("option");
    			option0.textContent = "Identity";
    			option1 = element("option");
    			option1.textContent = "Polar";
    			t4 = space();
    			div1 = element("div");
    			label1 = element("label");
    			label1.textContent = "Geometry:";
    			t6 = space();
    			select1 = element("select");
    			option2 = element("option");
    			option2.textContent = "A";
    			option3 = element("option");
    			option3.textContent = "B";
    			option4 = element("option");
    			option4.textContent = "C";
    			t10 = space();
    			create_component(graphic.$$.fragment);
    			attr_dev(label0, "for", "coordinate-select");
    			add_location(label0, file$c, 46, 2, 1129);
    			option0.__value = "identity";
    			option0.value = option0.__value;
    			add_location(option0, file$c, 48, 4, 1249);
    			option1.__value = "polar";
    			option1.value = option1.__value;
    			add_location(option1, file$c, 49, 4, 1296);
    			attr_dev(select0, "name", "coordinate-select");
    			if (ctx.transformation === void 0) add_render_callback(() => ctx.select0_change_handler.call(select0));
    			add_location(select0, file$c, 47, 2, 1183);
    			add_location(div0, file$c, 45, 0, 1121);
    			attr_dev(label1, "for", "geometry-select");
    			add_location(label1, file$c, 54, 2, 1361);
    			option2.__value = "a";
    			option2.value = option2.__value;
    			add_location(option2, file$c, 56, 4, 1474);
    			option3.__value = "b";
    			option3.value = option3.__value;
    			add_location(option3, file$c, 57, 4, 1507);
    			option4.__value = "c";
    			option4.value = option4.__value;
    			add_location(option4, file$c, 58, 4, 1540);
    			attr_dev(select1, "name", "geometry-select");
    			if (ctx.chosenGeometry === void 0) add_render_callback(() => ctx.select1_change_handler.call(select1));
    			add_location(select1, file$c, 55, 2, 1410);
    			add_location(div1, file$c, 53, 0, 1353);

    			dispose = [
    				listen_dev(select0, "change", ctx.select0_change_handler),
    				listen_dev(select1, "change", ctx.select1_change_handler)
    			];
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, label0);
    			append_dev(div0, t1);
    			append_dev(div0, select0);
    			append_dev(select0, option0);
    			append_dev(select0, option1);
    			select_option(select0, ctx.transformation);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, label1);
    			append_dev(div1, t6);
    			append_dev(div1, select1);
    			append_dev(select1, option2);
    			append_dev(select1, option3);
    			append_dev(select1, option4);
    			select_option(select1, ctx.chosenGeometry);
    			insert_dev(target, t10, anchor);
    			mount_component(graphic, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (changed.transformation) {
    				select_option(select0, ctx.transformation);
    			}

    			if (changed.chosenGeometry) {
    				select_option(select1, ctx.chosenGeometry);
    			}

    			const graphic_changes = {};

    			if (changed.$$scope || changed.transformation || changed.chosenGeometry || changed.isHovering) {
    				graphic_changes.$$scope = { changed, ctx };
    			}

    			graphic.$set(graphic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t10);
    			destroy_component(graphic, detaching);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let geometries = {
    		a: {
    			type: "Polygon",
    			coordinates: [[[0, 0], [10, 0], [5, 10], [0, 0]], [[2, 2], [5, 8], [8, 2], [2, 2]]]
    		},
    		b: {
    			type: "Polygon",
    			coordinates: [
    				[[0, 0], [10, 0], [10, 10], [0, 10], [0, 0]],
    				[[3, 3], [3, 7], [7, 7], [7, 3], [3, 3]],
    				[[7.5, 7.5], [7.5, 9.5], [9.5, 9.5], [9.5, 7.5], [7.5, 7.5]]
    			]
    		},
    		c: {
    			type: "MultiPolygon",
    			coordinates: [
    				[
    					[[0, 0], [3, 0], [4.5, 5], [3, 10], [0, 10], [0, 0]],
    					[[1, 1], [1, 9], [2, 9], [4, 5], [2, 1], [1, 1]]
    				],
    				[[[7, 0], [10, 0], [10, 10], [7, 10], [5.5, 5], [7, 0]]]
    			]
    		}
    	};

    	let isHovering = false;
    	let transformation = "identity";
    	let chosenGeometry = "a";

    	function select0_change_handler() {
    		transformation = select_value(this);
    		$$invalidate("transformation", transformation);
    	}

    	function select1_change_handler() {
    		chosenGeometry = select_value(this);
    		$$invalidate("chosenGeometry", chosenGeometry);
    	}

    	const func = () => $$invalidate("isHovering", isHovering = true);
    	const func_1 = () => $$invalidate("isHovering", isHovering = false);

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("geometries" in $$props) $$invalidate("geometries", geometries = $$props.geometries);
    		if ("isHovering" in $$props) $$invalidate("isHovering", isHovering = $$props.isHovering);
    		if ("transformation" in $$props) $$invalidate("transformation", transformation = $$props.transformation);
    		if ("chosenGeometry" in $$props) $$invalidate("chosenGeometry", chosenGeometry = $$props.chosenGeometry);
    	};

    	return {
    		geometries,
    		isHovering,
    		transformation,
    		chosenGeometry,
    		select0_change_handler,
    		select1_change_handler,
    		func,
    		func_1
    	};
    }

    class Polygons extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Polygons",
    			options,
    			id: create_fragment$q.name
    		});
    	}
    }

    /* test/sandbox/src/examples/GridLayout.svelte generated by Svelte v3.15.0 */
    const file$d = "test/sandbox/src/examples/GridLayout.svelte";

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.row = list[i];
    	return child_ctx;
    }

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.facet = list[i];
    	return child_ctx;
    }

    // (63:5) {#each facet.$grouped.rows() as row (row.$key)}
    function create_each_block_1$1(key_1, ctx) {
    	let first;
    	let current;

    	const point = new Point({
    			props: {
    				x: ctx.row.a,
    				y: ctx.row.b,
    				fill: ctx.row.color
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(point.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(point, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(point.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(point.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(point, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(63:5) {#each facet.$grouped.rows() as row (row.$key)}",
    		ctx
    	});

    	return block;
    }

    // (55:4) <Section      {...cells[facet.color]}      scaleX={scaleA}      scaleY={scaleB}     >
    function create_default_slot_2(ctx) {
    	let t0;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t1;
    	let current;

    	const rectangle = new Rectangle({
    			props: { fill: ctx.facet.color, opacity: 0.4 },
    			$$inline: true
    		});

    	let each_value_1 = ctx.facet.$grouped.rows();
    	const get_key = ctx => ctx.row.$key;

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$1(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$1(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			create_component(rectangle.$$.fragment);
    			t0 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(rectangle, target, anchor);
    			insert_dev(target, t0, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const each_value_1 = ctx.facet.$grouped.rows();
    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value_1, each_1_lookup, t1.parentNode, outro_and_destroy_block, create_each_block_1$1, t1, get_each_context_1$1);
    			check_outros();
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rectangle.$$.fragment, local);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rectangle.$$.fragment, local);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(rectangle, detaching);
    			if (detaching) detach_dev(t0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(55:4) <Section      {...cells[facet.color]}      scaleX={scaleA}      scaleY={scaleB}     >",
    		ctx
    	});

    	return block;
    }

    // (53:3) {#each groupedData.rows() as facet (facet.$key)}
    function create_each_block$3(key_1, ctx) {
    	let first;
    	let current;
    	const section_spread_levels = [ctx.cells[ctx.facet.color], { scaleX: ctx.scaleA }, { scaleY: ctx.scaleB }];

    	let section_props = {
    		$$slots: { default: [create_default_slot_2] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < section_spread_levels.length; i += 1) {
    		section_props = assign(section_props, section_spread_levels[i]);
    	}

    	const section = new Section({ props: section_props, $$inline: true });

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(section.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const section_changes = changed.cells || changed.groupedData || changed.scaleA || changed.scaleB
    			? get_spread_update(section_spread_levels, [
    					(changed.cells || changed.groupedData) && get_spread_object(ctx.cells[ctx.facet.color]),
    					changed.scaleA && ({ scaleX: ctx.scaleA }),
    					changed.scaleB && ({ scaleY: ctx.scaleB })
    				])
    			: {};

    			if (changed.$$scope) {
    				section_changes.$$scope = { changed, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(53:3) {#each groupedData.rows() as facet (facet.$key)}",
    		ctx
    	});

    	return block;
    }

    // (44:2) <Grid    x1={50} x2={450}    y1={50} y2={450}    columns={cols}    rows={rows}    areaNames={groupedData.domain('color')}    let:cells   >
    function create_default_slot_1$2(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value = ctx.groupedData.rows();
    	const get_key = ctx => ctx.facet.$key;

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$3(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const each_value = ctx.groupedData.rows();
    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$3, each_1_anchor, get_each_context$3);
    			check_outros();
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(44:2) <Grid    x1={50} x2={450}    y1={50} y2={450}    columns={cols}    rows={rows}    areaNames={groupedData.domain('color')}    let:cells   >",
    		ctx
    	});

    	return block;
    }

    // (40:1) <Graphic    width={500} height={500}  >
    function create_default_slot$2(ctx) {
    	let current;

    	const grid = new Grid({
    			props: {
    				x1: 50,
    				x2: 450,
    				y1: 50,
    				y2: 450,
    				columns: ctx.cols,
    				rows: ctx.rows,
    				areaNames: ctx.groupedData.domain("color"),
    				$$slots: {
    					default: [create_default_slot_1$2, ({ cells }) => ({ cells })]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(grid.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(grid, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const grid_changes = {};
    			if (changed.cols) grid_changes.columns = ctx.cols;
    			if (changed.rows) grid_changes.rows = ctx.rows;

    			if (changed.$$scope) {
    				grid_changes.$$scope = { changed, ctx };
    			}

    			grid.$set(grid_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(grid.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(grid.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(grid, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(40:1) <Graphic    width={500} height={500}  >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let div0;
    	let label;
    	let t1;
    	let input;
    	let t2;
    	let div1;
    	let current;
    	let dispose;

    	const graphic = new Graphic({
    			props: {
    				width: 500,
    				height: 500,
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			label = element("label");
    			label.textContent = "Columns:";
    			t1 = space();
    			input = element("input");
    			t2 = space();
    			div1 = element("div");
    			create_component(graphic.$$.fragment);
    			attr_dev(label, "for", "cols-slider");
    			add_location(label, file$d, 33, 2, 851);
    			attr_dev(input, "type", "range");
    			attr_dev(input, "min", "1");
    			attr_dev(input, "max", "4");
    			attr_dev(input, "name", "cols-slider");
    			add_location(input, file$d, 34, 2, 895);
    			add_location(div0, file$d, 32, 0, 843);
    			add_location(div1, file$d, 37, 0, 979);

    			dispose = [
    				listen_dev(input, "change", ctx.input_change_input_handler),
    				listen_dev(input, "input", ctx.input_change_input_handler)
    			];
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, label);
    			append_dev(div0, t1);
    			append_dev(div0, input);
    			set_input_value(input, ctx.cols);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(graphic, div1, null);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (changed.cols) {
    				set_input_value(input, ctx.cols);
    			}

    			const graphic_changes = {};

    			if (changed.$$scope || changed.cols || changed.rows) {
    				graphic_changes.$$scope = { changed, ctx };
    			}

    			graphic.$set(graphic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div1);
    			destroy_component(graphic);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function generateData(N) {
    	let newData = { a: [], b: [], color: [] };
    	let allColors = ["red", "blue", "green", "orange"];

    	for (let i = 0; i < N; i++) {
    		let cat = Math.floor(Math.random() * 4);
    		newData.color.push(allColors[cat]);
    		newData.a.push(Math.floor(Math.random() * 50) + 25);
    		newData.b.push(Math.floor(Math.random() * 50));
    	}

    	return newData;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let cols = 2;
    	let data = new florenceDatacontainer_umd(generateData(50));
    	const scaleA = linear$1().domain(data.domain("a"));
    	const scaleB = linear$1().domain(data.domain("b"));
    	const groupedData = data.groupBy("color");

    	function input_change_input_handler() {
    		cols = to_number(this.value);
    		$$invalidate("cols", cols);
    	}

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("cols" in $$props) $$invalidate("cols", cols = $$props.cols);
    		if ("data" in $$props) data = $$props.data;
    		if ("rows" in $$props) $$invalidate("rows", rows = $$props.rows);
    	};

    	let rows;

    	$$self.$$.update = (changed = { cols: 1 }) => {
    		if (changed.cols) {
    			 $$invalidate("rows", rows = Math.ceil(4 / cols));
    		}
    	};

    	return {
    		cols,
    		scaleA,
    		scaleB,
    		groupedData,
    		rows,
    		input_change_input_handler
    	};
    }

    class GridLayout extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$r, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GridLayout",
    			options,
    			id: create_fragment$r.name
    		});
    	}
    }

    /* test/sandbox/src/examples/ResizeLayout.svelte generated by Svelte v3.15.0 */
    const file$e = "test/sandbox/src/examples/ResizeLayout.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.facet = list[i];
    	return child_ctx;
    }

    // (72:3) {#each groupedData.rows() as facet}
    function create_each_block$4(ctx) {
    	let current;
    	const rectangle_spread_levels = [ctx.cells[ctx.facet.fruit], { fill: ctx.facet.fruit }];
    	let rectangle_props = {};

    	for (let i = 0; i < rectangle_spread_levels.length; i += 1) {
    		rectangle_props = assign(rectangle_props, rectangle_spread_levels[i]);
    	}

    	const rectangle = new Rectangle({ props: rectangle_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(rectangle.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(rectangle, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const rectangle_changes = changed.cells || changed.groupedData
    			? get_spread_update(rectangle_spread_levels, [
    					get_spread_object(ctx.cells[ctx.facet.fruit]),
    					changed.groupedData && ({ fill: ctx.facet.fruit })
    				])
    			: {};

    			rectangle.$set(rectangle_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rectangle.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rectangle.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(rectangle, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(72:3) {#each groupedData.rows() as facet}",
    		ctx
    	});

    	return block;
    }

    // (59:2) <Grid    x1={0} x2={420}    y1={0} y2={height}    columns={cols}    rows={rows}    areaNames={layout}       rowGap={10}       columnGap={10}    let:cells   >
    function create_default_slot_1$3(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = ctx.groupedData.rows();
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (changed.cells || changed.groupedData) {
    				each_value = ctx.groupedData.rows();
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(59:2) <Grid    x1={0} x2={420}    y1={0} y2={height}    columns={cols}    rows={rows}    areaNames={layout}       rowGap={10}       columnGap={10}    let:cells   >",
    		ctx
    	});

    	return block;
    }

    // (53:1) <Graphic    width={420} {height}   scaleX={scaleLinear().domain([0, 420])}     scaleY={scaleLinear().domain([0, height])}  >
    function create_default_slot$3(ctx) {
    	let current;

    	const grid = new Grid({
    			props: {
    				x1: 0,
    				x2: 420,
    				y1: 0,
    				y2: ctx.height,
    				columns: cols,
    				rows: ctx.rows,
    				areaNames: ctx.layout,
    				rowGap: 10,
    				columnGap: 10,
    				$$slots: {
    					default: [create_default_slot_1$3, ({ cells }) => ({ cells })]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(grid.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(grid, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const grid_changes = {};
    			if (changed.height) grid_changes.y2 = ctx.height;
    			if (changed.rows) grid_changes.rows = ctx.rows;
    			if (changed.layout) grid_changes.areaNames = ctx.layout;

    			if (changed.$$scope) {
    				grid_changes.$$scope = { changed, ctx };
    			}

    			grid.$set(grid_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(grid.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(grid.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(grid, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(53:1) <Graphic    width={420} {height}   scaleX={scaleLinear().domain([0, 420])}     scaleY={scaleLinear().domain([0, height])}  >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let div0;
    	let label;
    	let t1;
    	let input;
    	let t2;
    	let div1;
    	let current;
    	let dispose;

    	const graphic = new Graphic({
    			props: {
    				width: 420,
    				height: ctx.height,
    				scaleX: linear$1().domain([0, 420]),
    				scaleY: linear$1().domain([0, ctx.height]),
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			label = element("label");
    			label.textContent = "Height:";
    			t1 = space();
    			input = element("input");
    			t2 = space();
    			div1 = element("div");
    			create_component(graphic.$$.fragment);
    			attr_dev(label, "for", "height-slider");
    			add_location(label, file$e, 46, 2, 1202);
    			attr_dev(input, "type", "range");
    			attr_dev(input, "min", "1");
    			attr_dev(input, "max", "420");
    			attr_dev(input, "name", "height-slider");
    			add_location(input, file$e, 47, 2, 1247);
    			add_location(div0, file$e, 45, 0, 1194);
    			set_style(div1, "padding-top", "50px");
    			add_location(div1, file$e, 50, 0, 1337);

    			dispose = [
    				listen_dev(input, "change", ctx.input_change_input_handler),
    				listen_dev(input, "input", ctx.input_change_input_handler)
    			];
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, label);
    			append_dev(div0, t1);
    			append_dev(div0, input);
    			set_input_value(input, ctx.height);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(graphic, div1, null);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (changed.height) {
    				set_input_value(input, ctx.height);
    			}

    			const graphic_changes = {};
    			if (changed.height) graphic_changes.height = ctx.height;
    			if (changed.height) graphic_changes.scaleY = linear$1().domain([0, ctx.height]);

    			if (changed.$$scope || changed.height || changed.rows || changed.layout) {
    				graphic_changes.$$scope = { changed, ctx };
    			}

    			graphic.$set(graphic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div1);
    			destroy_component(graphic);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let cols = "50px 2fr 1fr";

    function generateData$1(N) {
    	let newData = { a: [], b: [], fruit: [] };
    	let allFruit = ["red", "blue", "green"];

    	for (let i = 0; i < N; i++) {
    		let cat = Math.floor(Math.random() * 3);
    		newData.fruit.push(allFruit[cat]);
    		newData.a.push(Math.floor(Math.random() * 50) + 25);
    		newData.b.push(Math.floor(Math.random() * 50));
    	}

    	return newData;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let data = new florenceDatacontainer_umd(generateData$1(50));
    	const groupedData = data.groupBy("fruit");
    	let height = 420;
    	let layout;

    	function input_change_input_handler() {
    		height = to_number(this.value);
    		$$invalidate("height", height);
    	}

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) data = $$props.data;
    		if ("height" in $$props) $$invalidate("height", height = $$props.height);
    		if ("cols" in $$props) $$invalidate("cols", cols = $$props.cols);
    		if ("layout" in $$props) $$invalidate("layout", layout = $$props.layout);
    		if ("rows" in $$props) $$invalidate("rows", rows = $$props.rows);
    	};

    	let rows;

    	$$self.$$.update = (changed = { height: 1, rows: 1 }) => {
    		if (changed.height) {
    			 $$invalidate("rows", rows = Math.ceil(height / 140));
    		}

    		if (changed.rows) {
    			 if (rows === 3) {
    				$$invalidate("layout", layout = [
    					"blue",
    					"blue",
    					undefined,
    					undefined,
    					"red",
    					undefined,
    					undefined,
    					"red",
    					"green"
    				]);
    			} else if (rows === 2) {
    				$$invalidate("layout", layout = ["blue", "blue", undefined, undefined, "red", "green"]);
    			} else {
    				$$invalidate("layout", layout = ["blue", "red", "green"]);
    			}
    		}
    	};

    	return {
    		groupedData,
    		height,
    		layout,
    		rows,
    		input_change_input_handler
    	};
    }

    class ResizeLayout extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ResizeLayout",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    /* test/sandbox/src/examples/Scatterplot.svelte generated by Svelte v3.15.0 */
    const file$f = "test/sandbox/src/examples/Scatterplot.svelte";

    // (92:2) <Section       bind:this={section}    x1={50} x2={450}    y1={50} y2={450}    scaleX={scaleA}    scaleY={scaleB}       backgroundColor={background}       flipY       {transformation}   >
    function create_default_slot_1$4(ctx) {
    	let current;

    	const pointlayer = new PointLayer({
    			props: {
    				x: ctx.filteredData.column("a"),
    				y: ctx.filteredData.column("b"),
    				key: ctx.filteredData.column("$key"),
    				fill: ctx.transformation === "identity" ? "black" : "blue",
    				radius: ctx.transformation === "identity" ? 4 : 6,
    				onSelect,
    				onDeselect
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pointlayer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pointlayer, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const pointlayer_changes = {};
    			if (changed.filteredData) pointlayer_changes.x = ctx.filteredData.column("a");
    			if (changed.filteredData) pointlayer_changes.y = ctx.filteredData.column("b");
    			if (changed.filteredData) pointlayer_changes.key = ctx.filteredData.column("$key");
    			if (changed.transformation) pointlayer_changes.fill = ctx.transformation === "identity" ? "black" : "blue";
    			if (changed.transformation) pointlayer_changes.radius = ctx.transformation === "identity" ? 4 : 6;
    			pointlayer.$set(pointlayer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointlayer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointlayer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pointlayer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$4.name,
    		type: "slot",
    		source: "(92:2) <Section       bind:this={section}    x1={50} x2={450}    y1={50} y2={450}    scaleX={scaleA}    scaleY={scaleB}       backgroundColor={background}       flipY       {transformation}   >",
    		ctx
    	});

    	return block;
    }

    // (86:1) <Graphic      width={500} {height}     scaleX={scaleLinear().domain([0, 500])}     scaleY={scaleLinear().domain([0, 500])}   >
    function create_default_slot$4(ctx) {
    	let current;

    	let section_1_props = {
    		x1: 50,
    		x2: 450,
    		y1: 50,
    		y2: 450,
    		scaleX: ctx.scaleA,
    		scaleY: ctx.scaleB,
    		backgroundColor: background,
    		flipY: true,
    		transformation: ctx.transformation,
    		$$slots: { default: [create_default_slot_1$4] },
    		$$scope: { ctx }
    	};

    	const section_1 = new Section({ props: section_1_props, $$inline: true });
    	ctx.section_1_binding(section_1);

    	const block = {
    		c: function create() {
    			create_component(section_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(section_1, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const section_1_changes = {};
    			if (changed.transformation) section_1_changes.transformation = ctx.transformation;

    			if (changed.$$scope || changed.filteredData || changed.transformation) {
    				section_1_changes.$$scope = { changed, ctx };
    			}

    			section_1.$set(section_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			ctx.section_1_binding(null);
    			destroy_component(section_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(86:1) <Graphic      width={500} {height}     scaleX={scaleLinear().domain([0, 500])}     scaleY={scaleLinear().domain([0, 500])}   >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let div0;
    	let label0;
    	let t1;
    	let input0;
    	let t2;
    	let div1;
    	let label1;
    	let t4;
    	let select_1;
    	let option0;
    	let option1;
    	let t7;
    	let div2;
    	let label2;
    	let t9;
    	let input1;
    	let t10;
    	let div3;
    	let button0;
    	let t12;
    	let div4;
    	let button1;
    	let br;
    	let t14;
    	let button2;
    	let t16;
    	let div5;
    	let current;
    	let dispose;

    	const graphic = new Graphic({
    			props: {
    				width: 500,
    				height: ctx.height,
    				scaleX: linear$1().domain([0, 500]),
    				scaleY: linear$1().domain([0, 500]),
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			label0 = element("label");
    			label0.textContent = "Height:";
    			t1 = space();
    			input0 = element("input");
    			t2 = space();
    			div1 = element("div");
    			label1 = element("label");
    			label1.textContent = "Coordinates:";
    			t4 = space();
    			select_1 = element("select");
    			option0 = element("option");
    			option0.textContent = "Identity";
    			option1 = element("option");
    			option1.textContent = "Polar";
    			t7 = space();
    			div2 = element("div");
    			label2 = element("label");
    			label2.textContent = "Transition time";
    			t9 = space();
    			input1 = element("input");
    			t10 = space();
    			div3 = element("div");
    			button0 = element("button");
    			button0.textContent = "Filter: x > 40";
    			t12 = space();
    			div4 = element("div");
    			button1 = element("button");
    			button1.textContent = "Select";
    			br = element("br");
    			t14 = space();
    			button2 = element("button");
    			button2.textContent = "Deselect";
    			t16 = space();
    			div5 = element("div");
    			create_component(graphic.$$.fragment);
    			attr_dev(label0, "for", "height-slider");
    			add_location(label0, file$f, 57, 2, 1185);
    			attr_dev(input0, "type", "range");
    			attr_dev(input0, "min", "0");
    			attr_dev(input0, "max", "500");
    			attr_dev(input0, "name", "height-slider");
    			add_location(input0, file$f, 58, 2, 1230);
    			add_location(div0, file$f, 56, 0, 1177);
    			attr_dev(label1, "for", "coordinate-select");
    			add_location(label1, file$f, 62, 2, 1328);
    			option0.__value = "identity";
    			option0.value = option0.__value;
    			add_location(option0, file$f, 64, 4, 1448);
    			option1.__value = "polar";
    			option1.value = option1.__value;
    			add_location(option1, file$f, 65, 4, 1495);
    			attr_dev(select_1, "name", "coordinate-select");
    			if (ctx.transformation === void 0) add_render_callback(() => ctx.select_1_change_handler.call(select_1));
    			add_location(select_1, file$f, 63, 2, 1382);
    			add_location(div1, file$f, 61, 0, 1320);
    			attr_dev(label2, "for", "duration");
    			add_location(label2, file$f, 70, 2, 1560);
    			attr_dev(input1, "name", "duration");
    			attr_dev(input1, "type", "range");
    			attr_dev(input1, "min", "100");
    			attr_dev(input1, "max", "5000");
    			add_location(input1, file$f, 71, 2, 1608);
    			add_location(div2, file$f, 69, 0, 1552);
    			add_location(button0, file$f, 75, 2, 1706);
    			add_location(div3, file$f, 74, 0, 1698);
    			add_location(button1, file$f, 79, 2, 1786);
    			add_location(br, file$f, 79, 51, 1835);
    			add_location(button2, file$f, 80, 2, 1844);
    			add_location(div4, file$f, 78, 0, 1778);
    			add_location(div5, file$f, 83, 0, 1906);

    			dispose = [
    				listen_dev(input0, "change", ctx.input0_change_input_handler),
    				listen_dev(input0, "input", ctx.input0_change_input_handler),
    				listen_dev(select_1, "change", ctx.select_1_change_handler),
    				listen_dev(input1, "change", ctx.input1_change_input_handler),
    				listen_dev(input1, "input", ctx.input1_change_input_handler),
    				listen_dev(button0, "click", ctx.click_handler, false, false, false),
    				listen_dev(button1, "click", ctx.click_handler_1, false, false, false),
    				listen_dev(button2, "click", ctx.click_handler_2, false, false, false)
    			];
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, label0);
    			append_dev(div0, t1);
    			append_dev(div0, input0);
    			set_input_value(input0, ctx.height);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, label1);
    			append_dev(div1, t4);
    			append_dev(div1, select_1);
    			append_dev(select_1, option0);
    			append_dev(select_1, option1);
    			select_option(select_1, ctx.transformation);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, label2);
    			append_dev(div2, t9);
    			append_dev(div2, input1);
    			set_input_value(input1, ctx.duration);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, button0);
    			insert_dev(target, t12, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, button1);
    			append_dev(div4, br);
    			append_dev(div4, t14);
    			append_dev(div4, button2);
    			insert_dev(target, t16, anchor);
    			insert_dev(target, div5, anchor);
    			mount_component(graphic, div5, null);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (changed.height) {
    				set_input_value(input0, ctx.height);
    			}

    			if (changed.transformation) {
    				select_option(select_1, ctx.transformation);
    			}

    			if (changed.duration) {
    				set_input_value(input1, ctx.duration);
    			}

    			const graphic_changes = {};
    			if (changed.height) graphic_changes.height = ctx.height;

    			if (changed.$$scope || changed.transformation || changed.section || changed.filteredData) {
    				graphic_changes.$$scope = { changed, ctx };
    			}

    			graphic.$set(graphic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(div3);
    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(div4);
    			if (detaching) detach_dev(t16);
    			if (detaching) detach_dev(div5);
    			destroy_component(graphic);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const N = 100;
    let background = "white";
    let big = false;

    function generateData$2(N, error) {
    	const getError = () => -error + Math.random() * (2 * error) * N;
    	let data = { a: [], b: [] };

    	for (let i = 0; i < N; i++) {
    		data.a.push(i + getError());
    		data.b.push(i + getError());
    	}

    	return data;
    }

    function onSelect(event) {
    	console.log(event);
    }

    function onDeselect(event) {
    	console.log(event);
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let data = new florenceDatacontainer_umd(generateData$2(N, 0.25));
    	let threshold = 0;
    	let filteredData;
    	const scaleA = linear$1().domain(data.domain("a"));
    	const scaleB = linear$1().domain(data.domain("b"));
    	let height = 500;
    	let transformation = "identity";
    	let duration = 2000;
    	let section;

    	function select() {
    		section.selectRectangle({ x1: 50, x2: 200, y1: 50, y2: 450 });
    	}

    	function deselect() {
    		section.resetSelection();
    	}

    	function input0_change_input_handler() {
    		height = to_number(this.value);
    		$$invalidate("height", height);
    	}

    	function select_1_change_handler() {
    		transformation = select_value(this);
    		$$invalidate("transformation", transformation);
    	}

    	function input1_change_input_handler() {
    		duration = to_number(this.value);
    		$$invalidate("duration", duration);
    	}

    	const click_handler = () => $$invalidate("threshold", threshold = 40);
    	const click_handler_1 = () => select();
    	const click_handler_2 = () => deselect();

    	function section_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate("section", section = $$value);
    		});
    	}

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate("data", data = $$props.data);
    		if ("threshold" in $$props) $$invalidate("threshold", threshold = $$props.threshold);
    		if ("filteredData" in $$props) $$invalidate("filteredData", filteredData = $$props.filteredData);
    		if ("height" in $$props) $$invalidate("height", height = $$props.height);
    		if ("transformation" in $$props) $$invalidate("transformation", transformation = $$props.transformation);
    		if ("duration" in $$props) $$invalidate("duration", duration = $$props.duration);
    		if ("background" in $$props) $$invalidate("background", background = $$props.background);
    		if ("big" in $$props) big = $$props.big;
    		if ("section" in $$props) $$invalidate("section", section = $$props.section);
    	};

    	$$self.$$.update = (changed = { data: 1, threshold: 1 }) => {
    		if (changed.data || changed.threshold) {
    			 {
    				$$invalidate("filteredData", filteredData = data.filter(row => row.a > threshold));
    			}
    		}
    	};

    	return {
    		threshold,
    		filteredData,
    		scaleA,
    		scaleB,
    		height,
    		transformation,
    		duration,
    		section,
    		select,
    		deselect,
    		input0_change_input_handler,
    		select_1_change_handler,
    		input1_change_input_handler,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		section_1_binding
    	};
    }

    class Scatterplot extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$t, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Scatterplot",
    			options,
    			id: create_fragment$t.name
    		});
    	}
    }

    /* test/sandbox/src/examples/ZoomPan.svelte generated by Svelte v3.15.0 */

    // (39:2) <Section      x1={50} x2={450}     y1={50} y2={450}     padding={30}     scaleX={scaleLinear().domain([0, 4])}     scaleY={scaleLinear().domain([0, 4])}     {zoomIdentity}     {...pan.handlers}     {...zoom.handlers}     {blockReindexing}   >
    function create_default_slot_1$5(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let current;

    	const rectangle = new Rectangle({
    			props: { fill: "blue", opacity: 0.3 },
    			$$inline: true
    		});

    	const polygonlayer = new PolygonLayer({
    			props: {
    				x: [[0, 1, 1, 0, 0], [1, 2, 2, 1, 1], [2, 3, 3, 2, 2]],
    				y: [[0, 0, 1, 1, 0], [1, 1, 2, 2, 1], [2, 2, 3, 3, 2]],
    				fill: ["red", "green", "yellow"]
    			},
    			$$inline: true
    		});

    	const xaxis = new XAxis({
    			props: { zoomIdentity: { y: 0, ky: 1 } },
    			$$inline: true
    		});

    	const yaxis = new YAxis({
    			props: { zoomIdentity: { x: 0, kx: 1 } },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(rectangle.$$.fragment);
    			t0 = space();
    			create_component(polygonlayer.$$.fragment);
    			t1 = space();
    			create_component(xaxis.$$.fragment);
    			t2 = space();
    			create_component(yaxis.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(rectangle, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(polygonlayer, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(xaxis, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(yaxis, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rectangle.$$.fragment, local);
    			transition_in(polygonlayer.$$.fragment, local);
    			transition_in(xaxis.$$.fragment, local);
    			transition_in(yaxis.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rectangle.$$.fragment, local);
    			transition_out(polygonlayer.$$.fragment, local);
    			transition_out(xaxis.$$.fragment, local);
    			transition_out(yaxis.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(rectangle, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(polygonlayer, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(xaxis, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(yaxis, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$5.name,
    		type: "slot",
    		source: "(39:2) <Section      x1={50} x2={450}     y1={50} y2={450}     padding={30}     scaleX={scaleLinear().domain([0, 4])}     scaleY={scaleLinear().domain([0, 4])}     {zoomIdentity}     {...pan.handlers}     {...zoom.handlers}     {blockReindexing}   >",
    		ctx
    	});

    	return block;
    }

    // (35:0) <Graphic width={500} height={500}>
    function create_default_slot$5(ctx) {
    	let current;

    	const section_spread_levels = [
    		{ x1: 50 },
    		{ x2: 450 },
    		{ y1: 50 },
    		{ y2: 450 },
    		{ padding: 30 },
    		{ scaleX: linear$1().domain([0, 4]) },
    		{ scaleY: linear$1().domain([0, 4]) },
    		{ zoomIdentity: ctx.zoomIdentity },
    		ctx.pan.handlers,
    		ctx.zoom.handlers,
    		{ blockReindexing: ctx.blockReindexing }
    	];

    	let section_props = {
    		$$slots: { default: [create_default_slot_1$5] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < section_spread_levels.length; i += 1) {
    		section_props = assign(section_props, section_spread_levels[i]);
    	}

    	const section = new Section({ props: section_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const section_changes = changed.scaleLinear || changed.zoomIdentity || changed.pan || changed.zoom || changed.blockReindexing
    			? get_spread_update(section_spread_levels, [
    					section_spread_levels[0],
    					section_spread_levels[1],
    					section_spread_levels[2],
    					section_spread_levels[3],
    					section_spread_levels[4],
    					changed.scaleLinear && ({ scaleX: linear$1().domain([0, 4]) }),
    					changed.scaleLinear && ({ scaleY: linear$1().domain([0, 4]) }),
    					changed.zoomIdentity && ({ zoomIdentity: ctx.zoomIdentity }),
    					changed.pan && get_spread_object(ctx.pan.handlers),
    					changed.zoom && get_spread_object(ctx.zoom.handlers),
    					changed.blockReindexing && ({ blockReindexing: ctx.blockReindexing })
    				])
    			: {};

    			if (changed.$$scope) {
    				section_changes.$$scope = { changed, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(35:0) <Graphic width={500} height={500}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let current;

    	const graphic = new Graphic({
    			props: {
    				width: 500,
    				height: 500,
    				$$slots: { default: [create_default_slot$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(graphic.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphic, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const graphic_changes = {};

    			if (changed.$$scope || changed.zoomIdentity || changed.blockReindexing) {
    				graphic_changes.$$scope = { changed, ctx };
    			}

    			graphic.$set(graphic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphic, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let zoomIdentity = { x: 0, y: 0, kx: 1, ky: 1 };
    	let blockReindexing = false;

    	const setZoomIdentity = zoomId => {
    		$$invalidate("zoomIdentity", zoomIdentity = zoomId);
    	};

    	const setBlockReindexing = bool => {
    		$$invalidate("blockReindexing", blockReindexing = bool);
    	};

    	const pan = createPanHandler(zoomIdentity, {
    		setZoomIdentity,
    		setBlockReindexing,
    		extentX: [-500, 500],
    		extentY: [-500, 500]
    	});

    	const zoom = createZoomHandler(zoomIdentity, {
    		setZoomIdentity,
    		minZoom: 0.2,
    		maxZoom: 3,
    		extentX: [-500, 500],
    		extentY: [-500, 500],
    		step: 1,
    		center: { x: 0, y: 0 }
    	});

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	return { zoomIdentity, blockReindexing, pan, zoom };
    }

    class ZoomPan extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$u, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ZoomPan",
    			options,
    			id: create_fragment$u.name
    		});
    	}
    }

    /* test/sandbox/src/examples/BaseMark.svelte generated by Svelte v3.15.0 */
    const file$g = "test/sandbox/src/examples/BaseMark.svelte";

    // (82:2) <Section     x1={50} x2={450}     y1={50} y2={450}     scaleX={scales.x}     scaleY={scales.y}     padding={10}   >
    function create_default_slot_1$6(ctx) {
    	let current;
    	const layer_1_spread_levels = [ctx.layer, { transition: 2000 }];
    	let layer_1_props = {};

    	for (let i = 0; i < layer_1_spread_levels.length; i += 1) {
    		layer_1_props = assign(layer_1_props, layer_1_spread_levels[i]);
    	}

    	const layer_1 = new Layer({ props: layer_1_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(layer_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(layer_1, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const layer_1_changes = changed.layer
    			? get_spread_update(layer_1_spread_levels, [get_spread_object(ctx.layer), layer_1_spread_levels[1]])
    			: {};

    			layer_1.$set(layer_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(layer_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(layer_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(layer_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$6.name,
    		type: "slot",
    		source: "(82:2) <Section     x1={50} x2={450}     y1={50} y2={450}     scaleX={scales.x}     scaleY={scales.y}     padding={10}   >",
    		ctx
    	});

    	return block;
    }

    // (80:0) <Graphic width={500} height={500}>
    function create_default_slot$6(ctx) {
    	let current;

    	const section = new Section({
    			props: {
    				x1: 50,
    				x2: 450,
    				y1: 50,
    				y2: 450,
    				scaleX: ctx.scales.x,
    				scaleY: ctx.scales.y,
    				padding: 10,
    				$$slots: { default: [create_default_slot_1$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const section_changes = {};
    			if (changed.scales) section_changes.scaleX = ctx.scales.x;
    			if (changed.scales) section_changes.scaleY = ctx.scales.y;

    			if (changed.$$scope || changed.layer) {
    				section_changes.$$scope = { changed, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(80:0) <Graphic width={500} height={500}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let label;
    	let t1;
    	let select;
    	let option0;
    	let option1;
    	let t4;
    	let current;
    	let dispose;

    	const graphic = new Graphic({
    			props: {
    				width: 500,
    				height: 500,
    				$$slots: { default: [create_default_slot$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			label = element("label");
    			label.textContent = "Chart:";
    			t1 = space();
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "Scatterplot";
    			option1 = element("option");
    			option1.textContent = "Bar chart";
    			t4 = space();
    			create_component(graphic.$$.fragment);
    			attr_dev(label, "for", "type-selector");
    			add_location(label, file$g, 73, 0, 1685);
    			option0.__value = "scatterplot";
    			option0.value = option0.__value;
    			add_location(option0, file$g, 75, 2, 1789);
    			option1.__value = "barchart";
    			option1.value = option1.__value;
    			add_location(option1, file$g, 76, 2, 1840);
    			attr_dev(select, "name", "type-selector");
    			if (ctx.currentChartType === void 0) add_render_callback(() => ctx.select_change_handler.call(select));
    			add_location(select, file$g, 74, 0, 1727);
    			dispose = listen_dev(select, "change", ctx.select_change_handler);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, select, anchor);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			select_option(select, ctx.currentChartType);
    			insert_dev(target, t4, anchor);
    			mount_component(graphic, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (changed.currentChartType) {
    				select_option(select, ctx.currentChartType);
    			}

    			const graphic_changes = {};

    			if (changed.$$scope || changed.scales || changed.layer) {
    				graphic_changes.$$scope = { changed, ctx };
    			}

    			graphic.$set(graphic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(select);
    			if (detaching) detach_dev(t4);
    			destroy_component(graphic, detaching);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let currentChartType = "scatterplot";

    	const data = new florenceDatacontainer_umd({
    			a: ["a", "b", "c", "d"],
    			b: [10, 30, 20, 50],
    			c: [4, 9, 10, 8]
    		});

    	const scatterplotScales = {
    		x: linear$1().domain(data.domain("b")),
    		y: linear$1().domain(data.domain("c"))
    	};

    	const barchartScales = {
    		x: band().domain(data.domain("a")).padding(0.2),
    		y: linear$1().domain([0, data.domain("b")[1]])
    	};

    	const scatterplotMarks = [];
    	const barchartMarks = [];

    	for (let row of data.rows()) {
    		scatterplotMarks.push({
    			type: "Point",
    			x: row.b,
    			y: row.c,
    			radius: 6,
    			fill: "red"
    		});

    		barchartMarks.push({
    			type: "Rectangle",
    			x1: row.a,
    			x2: ({ scaleX }) => scaleX(row.a) + scaleX.bandwidth(),
    			y1: 0,
    			y2: row.b,
    			fill: "blue"
    		});
    	}

    	const scatterplotLayer = {
    		type: "Point",
    		x: data.column("b"),
    		y: data.column("c"),
    		radius: 6,
    		fill: "red"
    	};

    	const barchartLayer = {
    		type: "Rectangle",
    		x1: data.column("a"),
    		x2: ({ scaleX }) => data.map("a", a => scaleX(a) + scaleX.bandwidth()),
    		y1: 0,
    		y2: data.column("b"),
    		fill: "blue"
    	};

    	function select_change_handler() {
    		currentChartType = select_value(this);
    		$$invalidate("currentChartType", currentChartType);
    	}

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("currentChartType" in $$props) $$invalidate("currentChartType", currentChartType = $$props.currentChartType);
    		if ("scales" in $$props) $$invalidate("scales", scales = $$props.scales);
    		if ("marks" in $$props) marks = $$props.marks;
    		if ("layer" in $$props) $$invalidate("layer", layer = $$props.layer);
    	};

    	let scales;
    	let marks;
    	let layer;

    	$$self.$$.update = (changed = { currentChartType: 1 }) => {
    		if (changed.currentChartType) {
    			 $$invalidate("scales", scales = currentChartType === "scatterplot"
    			? scatterplotScales
    			: barchartScales);
    		}

    		if (changed.currentChartType) {
    			 marks = currentChartType === "scatterplot"
    			? scatterplotMarks
    			: barchartMarks;
    		}

    		if (changed.currentChartType) {
    			 $$invalidate("layer", layer = currentChartType === "scatterplot"
    			? scatterplotLayer
    			: barchartLayer);
    		}
    	};

    	return {
    		currentChartType,
    		scales,
    		layer,
    		select_change_handler
    	};
    }

    class BaseMark extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BaseMark",
    			options,
    			id: create_fragment$v.name
    		});
    	}
    }

    /* test/sandbox/src/examples/Line.svelte generated by Svelte v3.15.0 */

    // (44:2) <Section     x1={50}     x2={450}     y1={50}     y2={450}     scaleX={scaleLinear().domain(data.domain('x'))}     scaleY={scaleLinear().domain(data.domain('y'))}     padding={10}>
    function create_default_slot_1$7(ctx) {
    	let t0;
    	let t1;
    	let current;

    	const line = new Line({
    			props: {
    				geometry: ctx.geometry,
    				strokeWidth: ctx.hovered ? 9 : 2,
    				stroke: ctx.clicked ? "green" : "red",
    				onClick: ctx.func,
    				onMouseover: ctx.func_1,
    				transition: 2000
    			},
    			$$inline: true
    		});

    	const linelayer0 = new LineLayer({
    			props: {
    				x: [ctx.data.column("x")],
    				y: [ctx.data.column("y")],
    				strokeWidth: ctx.hovered ? 2 : 10,
    				stroke: ctx.clicked ? "green" : "red",
    				onClick: ctx.func_2,
    				onMouseover: ctx.func_3
    			},
    			$$inline: true
    		});

    	const linelayer1 = new LineLayer({
    			props: {
    				x: ctx.lineStrings.x,
    				y: ctx.lineStrings.y,
    				onMouseover: ctx.func_4,
    				onMouseout: ctx.func_5,
    				stroke: ctx.func_6,
    				strokeWidth: 3
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(line.$$.fragment);
    			t0 = space();
    			create_component(linelayer0.$$.fragment);
    			t1 = space();
    			create_component(linelayer1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(line, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(linelayer0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(linelayer1, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const line_changes = {};
    			if (changed.geometry) line_changes.geometry = ctx.geometry;
    			if (changed.hovered) line_changes.strokeWidth = ctx.hovered ? 9 : 2;
    			if (changed.clicked) line_changes.stroke = ctx.clicked ? "green" : "red";
    			if (changed.clicked) line_changes.onClick = ctx.func;
    			if (changed.hovered) line_changes.onMouseover = ctx.func_1;
    			line.$set(line_changes);
    			const linelayer0_changes = {};
    			if (changed.hovered) linelayer0_changes.strokeWidth = ctx.hovered ? 2 : 10;
    			if (changed.clicked) linelayer0_changes.stroke = ctx.clicked ? "green" : "red";
    			if (changed.clicked) linelayer0_changes.onClick = ctx.func_2;
    			if (changed.hovered) linelayer0_changes.onMouseover = ctx.func_3;
    			linelayer0.$set(linelayer0_changes);
    			const linelayer1_changes = {};
    			if (changed.hoverKey) linelayer1_changes.onMouseover = ctx.func_4;
    			if (changed.hoverKey) linelayer1_changes.onMouseout = ctx.func_5;
    			if (changed.hoverKey) linelayer1_changes.stroke = ctx.func_6;
    			linelayer1.$set(linelayer1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(line.$$.fragment, local);
    			transition_in(linelayer0.$$.fragment, local);
    			transition_in(linelayer1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(line.$$.fragment, local);
    			transition_out(linelayer0.$$.fragment, local);
    			transition_out(linelayer1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(line, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(linelayer0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(linelayer1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$7.name,
    		type: "slot",
    		source: "(44:2) <Section     x1={50}     x2={450}     y1={50}     y2={450}     scaleX={scaleLinear().domain(data.domain('x'))}     scaleY={scaleLinear().domain(data.domain('y'))}     padding={10}>",
    		ctx
    	});

    	return block;
    }

    // (42:0) <Graphic width={500} height={500}>
    function create_default_slot$7(ctx) {
    	let current;

    	const section = new Section({
    			props: {
    				x1: 50,
    				x2: 450,
    				y1: 50,
    				y2: 450,
    				scaleX: linear$1().domain(ctx.data.domain("x")),
    				scaleY: linear$1().domain(ctx.data.domain("y")),
    				padding: 10,
    				$$slots: { default: [create_default_slot_1$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const section_changes = {};

    			if (changed.$$scope || changed.hoverKey || changed.hovered || changed.clicked || changed.geometry) {
    				section_changes.$$scope = { changed, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(42:0) <Graphic width={500} height={500}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let current;

    	const graphic = new Graphic({
    			props: {
    				width: 500,
    				height: 500,
    				$$slots: { default: [create_default_slot$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(graphic.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphic, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const graphic_changes = {};

    			if (changed.$$scope || changed.hoverKey || changed.hovered || changed.clicked || changed.geometry) {
    				graphic_changes.$$scope = { changed, ctx };
    			}

    			graphic.$set(graphic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphic, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	const data = new florenceDatacontainer_umd({
    			x: [1, 2, 4, 6, 9, 10, 12, 13],
    			y: [1.5, 3.3, 2.8, 7.95, 3.39, 5.3, 6.34, 7]
    		});

    	const multiLineString = {
    		type: "MultiLineString",
    		coordinates: [[[0, 0], [2, 8], [9, 9]], [[1, 1], [4, 4], [1, 4], [4, 1]]]
    	};

    	const multiLineString2 = {
    		type: "MultiLineString",
    		coordinates: [[[0, 0], [4, 4], [8, 8]], [[2, 0], [6, 1], [8, 2]]]
    	};

    	const lineStrings = {
    		x: [[5.5, 6, 7], [8, 8.75, 10]],
    		y: [[5, 6.5, 5], [6, 5, 6]]
    	};

    	let hoverKey;
    	let clicked = false;
    	let hovered = false;

    	const func = () => {
    		$$invalidate("clicked", clicked = !clicked);
    	};

    	const func_1 = () => {
    		$$invalidate("hovered", hovered = !hovered);
    	};

    	const func_2 = () => {
    		$$invalidate("clicked", clicked = !clicked);
    	};

    	const func_3 = () => {
    		$$invalidate("hovered", hovered = !hovered);
    	};

    	const func_4 = ({ key }) => {
    		$$invalidate("hoverKey", hoverKey = key);
    	};

    	const func_5 = () => {
    		$$invalidate("hoverKey", hoverKey = null);
    	};

    	const func_6 = key => key === hoverKey ? "#3f88c5" : "#f49d37";

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("hoverKey" in $$props) $$invalidate("hoverKey", hoverKey = $$props.hoverKey);
    		if ("clicked" in $$props) $$invalidate("clicked", clicked = $$props.clicked);
    		if ("hovered" in $$props) $$invalidate("hovered", hovered = $$props.hovered);
    		if ("geometry" in $$props) $$invalidate("geometry", geometry = $$props.geometry);
    	};

    	let geometry;

    	$$self.$$.update = (changed = { clicked: 1 }) => {
    		if (changed.clicked) {
    			 $$invalidate("geometry", geometry = clicked ? multiLineString2 : multiLineString);
    		}
    	};

    	return {
    		data,
    		lineStrings,
    		hoverKey,
    		clicked,
    		hovered,
    		geometry,
    		func,
    		func_1,
    		func_2,
    		func_3,
    		func_4,
    		func_5,
    		func_6
    	};
    }

    class Line_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Line_1",
    			options,
    			id: create_fragment$w.name
    		});
    	}
    }

    var type="FeatureCollection";var features=[{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2971330.946649554,-5548087.999411765],[2975532.7286153506,-5550513.899360795],[2971511.3663789546,-5550055.0168350125],[2971330.946649554,-5548087.999411765]]]},properties:{hex:"ID621"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2976641.4289274495,-5550640.41449911],[2992395.154656755,-5541544.996708551],[2994279.513820293,-5543518.008204886],[2994883.4179379935,-5545254.506919619],[2990955.747166417,-5549814.503859086],[2986905.794982391,-5551811.693768164],[2976641.4289274495,-5550640.41449911]]]},properties:{hex:"ID622"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2975532.7286153506,-5550513.899360795],[2971330.946649554,-5548087.999411765],[2971133.4139083186,-5545934.408199963],[2977911.9858307764,-5539604.942693067],[2981561.878489863,-5536936.377622037],[2989372.941415926,-5538380.599186088],[2992395.154656755,-5541544.996708551],[2976641.4289274495,-5550640.41449911],[2975532.7286153506,-5550513.899360795]]]},properties:{hex:"ID649"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1623694.4782770728,-4022363.623897876],[1726196.64409514,-3963183.9708703],[1851196.64409514,-4035352.754519],[1851196.64409514,-4156790.0379152684],[1847578.8228775144,-4158944.3039066712],[1825481.6735666643,-4161603.8551407326],[1816397.4921987338,-4166832.3736557527],[1775887.6173378404,-4198651.452924034],[1767667.1449127975,-4197385.286635032],[1761141.5461662875,-4195312.221888552],[1742106.4146462244,-4194931.207622267],[1722419.3538717327,-4177981.45559974],[1714014.870986089,-4179057.9684781805],[1716805.0977424313,-4173977.7718212274],[1718481.7275748162,-4164969.977396853],[1714624.0394849766,-4158607.6320599634],[1711847.451555936,-4155768.189335474],[1703293.5772044144,-4156295.698647102],[1699621.5612656225,-4148617.679877622],[1686691.1148316767,-4147887.9235891253],[1681977.8038347645,-4149830.15199256],[1675687.0509943112,-4150223.0704386183],[1675972.10188836,-4142453.3918800456],[1676996.937437869,-4137556.8355654483],[1677426.0598474487,-4130030.4916646034],[1676852.6480320005,-4120793.673736854],[1672117.9597655209,-4117848.883887079],[1668374.7815302887,-4116612.421783292],[1659076.8734261047,-4117241.9007838895],[1652615.3071717294,-4118231.0511264424],[1649345.0703964373,-4120917.302613719],[1645218.7538474475,-4127682.271288017],[1642997.3118867055,-4148247.1908244244],[1639058.5257279095,-4142352.3256220985],[1635164.5500971575,-4130030.4916646034],[1634879.2963265704,-4116882.2003730005],[1638375.6891325,-4101320.37945865],[1648870.1903785118,-4095414.7934683957],[1649200.4708023649,-4084893.914391399],[1648054.5570368883,-4075764.8907280695],[1639411.5145042674,-4052370.676114817],[1636182.6417792244,-4041663.481929951],[1627518.6057982289,-4034402.676564046],[1623694.4782770728,-4022363.623897876]]]},properties:{hex:"ID820"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1851196.64409514,-4156790.0379152684],[1851196.64409514,-4035352.754519],[1976196.64409514,-3963183.9708703],[2101196.64409514,-4035352.754519],[2101196.64409514,-4108109.817830714],[2082349.9385228544,-4116275.194591097],[2074830.7620490915,-4117680.278898142],[2044553.181828456,-4115611.9682948273],[2028393.6515632386,-4109518.4846205474],[2012182.4205714222,-4109495.9967884333],[1999107.047358537,-4114532.7841062336],[1983815.4325637436,-4116297.6765406253],[1938743.4490292124,-4151210.9529985315],[1917761.9529135327,-4151255.8558442034],[1899165.0072651014,-4155296.788809627],[1890207.8611558466,-4155162.1013458855],[1874006.9987194254,-4150290.4272802984],[1867710.994870643,-4150615.982846951],[1857889.0929498463,-4152804.955707044],[1851196.64409514,-4156790.0379152684]]]},properties:{hex:"ID821"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2101196.64409514,-4108109.817830714],[2101196.64409514,-4035352.754519],[2226196.64409514,-3963183.9708703],[2351196.64409514,-4035352.754519],[2351196.64409514,-4079039.1602664078],[2323768.832923526,-4075078.1155776433],[2306912.9182556714,-4078050.2589888424],[2291321.247031217,-4091015.6686368706],[2287342.9736703546,-4109619.679623821],[2281230.5693228757,-4112408.008817236],[2272701.197761885,-4111576.038752544],[2246378.7960639885,-4103817.195663186],[2231281.5552251013,-4105301.675417682],[2221187.933841751,-4115218.5209363205],[2212413.7779744808,-4127783.395234912],[2191681.571856263,-4128423.837684827],[2156719.1046904963,-4115420.8660389483],[2114518.5922440733,-4107505.746463107],[2104615.390161979,-4106628.638556344],[2101196.64409514,-4108109.817830714]]]},properties:{hex:"ID822"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2351196.64409514,-4079039.1602664078],[2351196.64409514,-4035352.754519],[2476196.64409514,-3963183.9708703],[2516836.8888569693,-3986647.6271234713],[2502826.6827514498,-3999175.5796733345],[2493231.8897540867,-4004041.5193684874],[2452832.7255083723,-4034605.645229302],[2424368.8506597513,-4053148.1881011245],[2379639.9699027785,-4074627.761467289],[2362276.9925416578,-4080639.351951013],[2351196.64409514,-4079039.1602664078]]]},properties:{hex:"ID823"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1605104.4464139848,-3748933.79064491],[1726196.64409514,-3818846.40357289],[1726196.64409514,-3963183.9708703],[1623694.4782770728,-4022363.623897876],[1621961.4541897504,-4016907.747193035],[1615213.8806844722,-4010554.4061789],[1613356.4012593247,-3998306.166236929],[1607116.0915317,-3988492.275058487],[1606188.90104559,-3972979.308285625],[1611037.0556778996,-3964072.0232191724],[1617805.164585756,-3959221.531228226],[1623470.2112739591,-3966920.8620559955],[1631730.4157756926,-3963913.745684618],[1644174.8951095222,-3952685.0106010023],[1652566.5905069276,-3935635.2437149948],[1655665.0465584362,-3908335.9916686355],[1655600.9300039907,-3891270.2786404225],[1650809.2829335514,-3847130.227611391],[1647498.0379202848,-3836978.8636170384],[1630030.9508205561,-3805332.1626821016],[1610153.925398087,-3762904.3529154537],[1605104.4464139848,-3748933.79064491]]]},properties:{hex:"ID861"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1726196.64409514,-3818846.40357289],[1851196.64409514,-3746677.61992419],[1976196.64409514,-3818846.40357289],[1976196.64409514,-3963183.9708703],[1851196.64409514,-4035352.754519],[1726196.64409514,-3963183.9708703],[1726196.64409514,-3818846.40357289]]]},properties:{hex:"ID862"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1976196.64409514,-3818846.40357289],[2101196.64409514,-3746677.61992419],[2226196.64409514,-3818846.40357289],[2226196.64409514,-3963183.9708703],[2101196.64409514,-4035352.754519],[1976196.64409514,-3963183.9708703],[1976196.64409514,-3818846.40357289]]]},properties:{hex:"ID863"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2226196.64409514,-3818846.40357289],[2351196.64409514,-3746677.61992419],[2476196.64409514,-3818846.40357289],[2476196.64409514,-3963183.9708703],[2351196.64409514,-4035352.754519],[2226196.64409514,-3963183.9708703],[2226196.64409514,-3818846.40357289]]]},properties:{hex:"ID864"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2516836.8888569693,-3986647.6271234713],[2476196.64409514,-3963183.9708703],[2476196.64409514,-3818846.40357289],[2601196.64409514,-3746677.61992419],[2710331.4685291015,-3809686.640189101],[2709868.3751300788,-3810061.4906015885],[2700392.1467807065,-3815483.349141694],[2673836.1235897094,-3839250.1754883314],[2635788.449002304,-3877415.1652812124],[2606001.288293127,-3911201.9181277775],[2563426.0809204276,-3949495.3468700848],[2539656.1578374705,-3966242.5940456456],[2516836.8888569693,-3986647.6271234713]]]},properties:{hex:"ID865"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1560669.4258120547,-3578941.6522415304],[1601196.64409514,-3602340.05262678],[1601196.64409514,-3738121.9433616],[1585928.3371396502,-3695878.6082058297],[1574921.1539762504,-3655534.094066143],[1560669.4258120547,-3578941.6522415304]]]},properties:{hex:"ID903"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1601196.64409514,-3738121.9433616],[1601196.64409514,-3602340.05262678],[1726196.64409514,-3530171.26897808],[1851196.64409514,-3602340.05262678],[1851196.64409514,-3746677.61992419],[1726196.64409514,-3818846.40357289],[1605104.4464139848,-3748933.79064491],[1601196.64409514,-3738121.9433616]]]},properties:{hex:"ID904"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1851196.64409514,-3602340.05262678],[1976196.64409514,-3530171.26897808],[2101196.64409514,-3602340.05262678],[2101196.64409514,-3746677.61992419],[1976196.64409514,-3818846.40357289],[1851196.64409514,-3746677.61992419],[1851196.64409514,-3602340.05262678]]]},properties:{hex:"ID905"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2101196.64409514,-3602340.05262678],[2226196.64409514,-3530171.26897808],[2351196.64409514,-3602340.05262678],[2351196.64409514,-3746677.61992419],[2226196.64409514,-3818846.40357289],[2101196.64409514,-3746677.61992419],[2101196.64409514,-3602340.05262678]]]},properties:{hex:"ID906"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2351196.64409514,-3602340.05262678],[2476196.64409514,-3530171.26897808],[2529537.318456381,-3560967.521679297],[2601196.64409514,-3602340.05262678],[2601196.64409514,-3661040.394570312],[2601196.64409514,-3746677.61992419],[2476196.64409514,-3818846.40357289],[2351196.64409514,-3746677.61992419],[2351196.64409514,-3602340.05262678]]]},properties:{hex:"ID907"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2710331.4685291015,-3809686.640189101],[2601196.64409514,-3746677.61992419],[2601196.64409514,-3661040.394570312],[2601196.64409514,-3602340.05262678],[2702930.553536408,-3543603.952625153],[2726196.64409514,-3530171.26897808],[2851196.64409514,-3602340.05262678],[2851196.64409514,-3622304.927528277],[2846010.0030171596,-3632248.638730202],[2829626.204372636,-3652174.3979056114],[2803558.8711379813,-3694634.7038785988],[2781062.8690332193,-3727381.26796728],[2759731.3220355874,-3757199.385763021],[2724504.894028781,-3798213.9774257536],[2710331.4685291015,-3809686.640189101]]]},properties:{hex:"ID908"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2851196.64409514,-3622304.927528277],[2851196.64409514,-3602340.05262678],[2867022.600848033,-3593202.9322353164],[2864959.347060203,-3595919.384055168],[2851196.64409514,-3622304.927528277]]]},properties:{hex:"ID909"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1441548.912320431,-3365829.8244137387],[1476196.64409514,-3385833.70168067],[1476196.64409514,-3429606.6338020144],[1473218.236518793,-3426852.044664855],[1458857.1312473163,-3404839.3331609145],[1441548.912320431,-3365829.8244137387]]]},properties:{hex:"ID948"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1476196.64409514,-3429606.6338020144],[1476196.64409514,-3385833.70168067],[1601196.64409514,-3313664.91803197],[1726196.64409514,-3385833.70168067],[1726196.64409514,-3510232.071636847],[1726196.64409514,-3530171.26897808],[1601196.64409514,-3602340.05262678],[1560669.4258120547,-3578941.6522415304],[1559738.964289991,-3573941.113417211],[1544049.2345678685,-3527678.4285579687],[1523528.7131151506,-3484428.1049729623],[1520674.667303273,-3481613.170037086],[1510996.5498087844,-3472075.055742165],[1483309.1334516774,-3436184.640813301],[1476196.64409514,-3429606.6338020144]]]},properties:{hex:"ID949"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1726196.64409514,-3385833.70168067],[1851196.64409514,-3313664.91803197],[1861921.6991502948,-3319857.031455137],[1976196.64409514,-3385833.70168067],[1976196.64409514,-3530171.26897808],[1851196.64409514,-3602340.05262678],[1726196.64409514,-3530171.26897808],[1726196.64409514,-3510232.071636847],[1726196.64409514,-3385833.70168067]]]},properties:{hex:"ID950"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1976196.64409514,-3385833.70168067],[2101196.64409514,-3313664.91803197],[2226196.64409514,-3385833.70168067],[2226196.64409514,-3530171.26897808],[2101196.64409514,-3602340.05262678],[1976196.64409514,-3530171.26897808],[1976196.64409514,-3385833.70168067]]]},properties:{hex:"ID951"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2226196.64409514,-3385833.70168067],[2351196.64409514,-3313664.91803197],[2476196.64409514,-3385833.70168067],[2476196.64409514,-3530171.26897808],[2351196.64409514,-3602340.05262678],[2226196.64409514,-3530171.26897808],[2226196.64409514,-3385833.70168067]]]},properties:{hex:"ID952"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2476196.64409514,-3385833.70168067],[2601196.64409514,-3313664.91803197],[2726196.64409514,-3385833.70168067],[2726196.64409514,-3530171.26897808],[2702930.553536408,-3543603.952625153],[2601196.64409514,-3602340.05262678],[2529537.318456381,-3560967.521679297],[2476196.64409514,-3530171.26897808],[2476196.64409514,-3385833.70168067]]]},properties:{hex:"ID953"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2867022.600848033,-3593202.9322353164],[2851196.64409514,-3602340.05262678],[2726196.64409514,-3530171.26897808],[2726196.64409514,-3385833.70168067],[2851196.64409514,-3313664.91803197],[2976196.64409514,-3385833.70168067],[2976196.64409514,-3490157.878894988],[2957205.234639887,-3507719.5170211187],[2949788.650578715,-3512919.8960210006],[2943394.058710756,-3516248.6167676756],[2932499.498956779,-3519186.7878004643],[2883906.6567857238,-3570973.6142769805],[2867022.600848033,-3593202.9322353164]]]},properties:{hex:"ID954"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2976196.64409514,-3490157.878894988],[2976196.64409514,-3385833.70168067],[3042768.3963195244,-3347398.4826134956],[3037054.5176248024,-3362535.004819084],[3015413.1740748365,-3432410.4908304024],[2995388.231394062,-3467569.3409284432],[2984940.000111743,-3482072.7678486863],[2976196.64409514,-3490157.878894988]]]},properties:{hex:"ID955"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1395708.5005703766,-3143628.4184164517],[1476196.64409514,-3097158.56708586],[1601196.64409514,-3169327.35073456],[1601196.64409514,-3313664.91803197],[1476196.64409514,-3385833.70168067],[1441548.912320431,-3365829.8244137387],[1428514.7474190579,-3336453.239111685],[1424384.661542329,-3323272.181404576],[1419892.9878967737,-3290170.5308915423],[1413767.0658956903,-3265607.0670510177],[1413841.695339552,-3251427.6320254137],[1418060.3684613712,-3243410.1665299926],[1416502.1948519864,-3232485.934603558],[1413153.9588877063,-3222739.2682644734],[1401907.1925502964,-3209967.3774294415],[1401163.5673023828,-3167265.343048054],[1395708.5005703766,-3143628.4184164517]]]},properties:{hex:"ID998"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1601196.64409514,-3169327.35073456],[1726196.64409514,-3097158.56708586],[1851196.64409514,-3169327.35073456],[1851196.64409514,-3313664.91803197],[1726196.64409514,-3385833.70168067],[1601196.64409514,-3313664.91803197],[1601196.64409514,-3169327.35073456]]]},properties:{hex:"ID999"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1851196.64409514,-3169327.35073456],[1875994.9987387396,-3155010.014005618],[1940229.9718831102,-3117923.9349693293],[1976196.64409514,-3097158.56708586],[2101196.64409514,-3169327.35073456],[2101196.64409514,-3201821.3040612973],[2101196.64409514,-3313664.91803197],[1976196.64409514,-3385833.70168067],[1861921.6991502948,-3319857.031455137],[1851196.64409514,-3313664.91803197],[1851196.64409514,-3169327.35073456]]]},properties:{hex:"ID1000"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2101196.64409514,-3169327.35073456],[2136537.010360784,-3148923.580757831],[2221277.6211165306,-3099998.56632671],[2226196.64409514,-3097158.56708586],[2315029.236884283,-3148446.0884454814],[2351196.64409514,-3169327.35073456],[2351196.64409514,-3313664.91803197],[2226196.64409514,-3385833.70168067],[2101196.64409514,-3313664.91803197],[2101196.64409514,-3201821.3040612973],[2101196.64409514,-3169327.35073456]]]},properties:{hex:"ID1001"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2351196.64409514,-3169327.35073456],[2476196.64409514,-3097158.56708586],[2601196.64409514,-3169327.35073456],[2601196.64409514,-3313664.91803197],[2476196.64409514,-3385833.70168067],[2351196.64409514,-3313664.91803197],[2351196.64409514,-3169327.35073456]]]},properties:{hex:"ID1002"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2601196.64409514,-3169327.35073456],[2726196.64409514,-3097158.56708586],[2851196.64409514,-3169327.35073456],[2851196.64409514,-3313664.91803197],[2726196.64409514,-3385833.70168067],[2601196.64409514,-3313664.91803197],[2601196.64409514,-3169327.35073456]]]},properties:{hex:"ID1003"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3042768.3963195244,-3347398.4826134956],[2976196.64409514,-3385833.70168067],[2851196.64409514,-3313664.91803197],[2851196.64409514,-3169327.35073456],[2976196.64409514,-3097158.56708586],[3008089.283404545,-3115571.7909763125],[3071824.197903122,-3152369.1610188433],[3065369.7067448096,-3160562.922210208],[3057578.0912055923,-3172714.509294467],[3061504.0316166165,-3183146.826421036],[3065677.4312331327,-3191038.6373275174],[3071146.685838596,-3196322.0677681216],[3073729.7722108243,-3200874.935448284],[3077500.610204089,-3204037.2788318605],[3084006.8260282273,-3187643.3975488045],[3086807.408238259,-3182544.1511608325],[3090470.0372881284,-3182150.088893698],[3085701.262593854,-3202172.340407333],[3071914.070765799,-3270682.9909432265],[3071313.9570521656,-3272914.3169776765],[3063955.967633542,-3300233.704856873],[3044443.4556472595,-3342961.1163226496],[3042768.3963195244,-3347398.4826134956]]]},properties:{hex:"ID1004"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4224048.21852751,-3098398.961165667],[4226196.64409514,-3097158.56708586],[4266990.294419119,-3120710.7920816336],[4250758.601994983,-3121205.2458575903],[4242848.972820026,-3117942.9154138016],[4224048.21852751,-3098398.961165667]]]},properties:{hex:"ID1008"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1375958.2528474175,-2894948.337618447],[1476196.64409514,-2952820.99978845],[1476196.64409514,-3097158.56708586],[1395708.5005703766,-3143628.4184164517],[1394789.8156907142,-3139647.7365425956],[1397918.1603289738,-3116816.7070394587],[1395308.8370428213,-3096004.8174764053],[1395733.24687645,-3082654.5613999334],[1398995.1725032215,-3057277.3558251313],[1394193.400419103,-3028066.467436152],[1382620.846345688,-2999462.5326138036],[1373004.7184295892,-2958167.375090462],[1372292.5327777027,-2940069.8071502675],[1375958.2528474175,-2894948.337618447]]]},properties:{hex:"ID1052"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1476196.64409514,-2952820.99978845],[1601196.64409514,-2880652.21613975],[1726196.64409514,-2952820.99978845],[1726196.64409514,-3097158.56708586],[1601196.64409514,-3169327.35073456],[1476196.64409514,-3097158.56708586],[1476196.64409514,-2952820.99978845]]]},properties:{hex:"ID1053"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1726196.64409514,-2952820.99978845],[1851196.64409514,-2880652.21613975],[1895599.487256211,-2906288.2095915778],[1976196.64409514,-2952820.99978845],[1976196.64409514,-3097158.56708586],[1940229.9718831102,-3117923.9349693293],[1875994.9987387396,-3155010.014005618],[1851196.64409514,-3169327.35073456],[1726196.64409514,-3097158.56708586],[1726196.64409514,-2952820.99978845]]]},properties:{hex:"ID1054"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1976196.64409514,-2952820.99978845],[2101196.64409514,-2880652.21613975],[2226196.64409514,-2952820.99978845],[2226196.64409514,-3097158.56708586],[2221277.6211165306,-3099998.56632671],[2136537.010360784,-3148923.580757831],[2101196.64409514,-3169327.35073456],[1976196.64409514,-3097158.56708586],[1976196.64409514,-2952820.99978845]]]},properties:{hex:"ID1055"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2226196.64409514,-2952820.99978845],[2351196.64409514,-2880652.21613975],[2476196.64409514,-2952820.99978845],[2476196.64409514,-3012088.7130890577],[2476196.64409514,-3097158.56708586],[2351196.64409514,-3169327.35073456],[2315029.236884283,-3148446.0884454814],[2226196.64409514,-3097158.56708586],[2226196.64409514,-2952820.99978845]]]},properties:{hex:"ID1056"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2476196.64409514,-2952820.99978845],[2559265.628246878,-2904861.0994271375],[2601196.64409514,-2880652.21613975],[2726196.64409514,-2952820.99978845],[2726196.64409514,-3097158.56708586],[2601196.64409514,-3169327.35073456],[2476196.64409514,-3097158.56708586],[2476196.64409514,-3012088.7130890577],[2476196.64409514,-2952820.99978845]]]},properties:{hex:"ID1057"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2726196.64409514,-2952820.99978845],[2851196.64409514,-2880652.21613975],[2976196.64409514,-2952820.99978845],[2976196.64409514,-3097158.56708586],[2851196.64409514,-3169327.35073456],[2726196.64409514,-3097158.56708586],[2726196.64409514,-2952820.99978845]]]},properties:{hex:"ID1058"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3071824.197903122,-3152369.1610188433],[3008089.283404545,-3115571.7909763125],[2976196.64409514,-3097158.56708586],[2976196.64409514,-2952820.99978845],[3016863.945254421,-2929341.7225169246],[3101196.64409514,-2880652.21613975],[3226196.64409514,-2952820.99978845],[3226196.64409514,-3047504.6435913215],[3189848.053365036,-3061416.97537271],[3159064.5374285826,-3075809.14083188],[3140704.510992682,-3084386.060342662],[3100663.4352300204,-3111684.4848706657],[3082312.373181703,-3129980.7820058484],[3072934.7040317403,-3150959.4105371605],[3071824.197903122,-3152369.1610188433]]]},properties:{hex:"ID1059"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3226196.64409514,-3047504.6435913215],[3226196.64409514,-2952820.99978845],[3351196.64409514,-2880652.21613975],[3361364.3393613873,-2886522.5377387535],[3357447.847619538,-2899133.86395808],[3355381.934686635,-2909943.642236372],[3357445.0998280444,-2914658.892093159],[3363231.912924712,-2916257.751581445],[3366506.8457237957,-2908297.845164692],[3370019.5778636667,-2908356.207896424],[3371237.6329065165,-2913071.64109484],[3362375.1221280294,-2941877.5977084334],[3355771.770232292,-2954494.8812870537],[3334200.0087195793,-2985414.884922045],[3323023.5189088206,-2998670.5926451483],[3305745.8793755323,-3011688.992998985],[3266614.8662792225,-3032034.6705952813],[3226196.64409514,-3047504.6435913215]]]},properties:{hex:"ID1060"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4141480.2548265713,-2903909.9696394713],[4226196.64409514,-2952820.99978845],[4226196.64409514,-3097158.56708586],[4224048.21852751,-3098398.961165667],[4218951.205625992,-3093100.4616799806],[4208670.645550282,-3088999.13250298],[4188381.9756199857,-3085594.5766775073],[4182443.4418104524,-3083479.6479010456],[4177294.0512572215,-3080237.30368789],[4171156.385382589,-3067241.919988067],[4156319.202940037,-3056254.0103808357],[4152892.0865460373,-3052811.6487715957],[4151672.858758183,-3045228.065342182],[4151361.1830242337,-3037061.2552105994],[4148605.407015976,-3027915.1789539005],[4148396.4380148035,-3010501.446693364],[4145014.5473746653,-2998309.5559046613],[4133175.0428357236,-2976781.144972147],[4132686.113802861,-2969905.435338795],[4135288.7386148367,-2947043.932674118],[4138376.3470313805,-2931566.274393844],[4141480.2548265713,-2903909.9696394713]]]},properties:{hex:"ID1063"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4266990.294419119,-3120710.7920816336],[4226196.64409514,-3097158.56708586],[4226196.64409514,-2952820.99978845],[4351196.64409514,-2880652.21613975],[4476196.64409514,-2952820.99978845],[4476196.64409514,-2980695.658333536],[4474181.202970746,-2986952.6817834033],[4467833.838478854,-3001407.3764107367],[4453868.996306627,-3027973.3669012757],[4436153.362393504,-3050822.8469965663],[4425466.876528701,-3059126.2859430024],[4403439.177436541,-3071171.222857525],[4392968.639547192,-3073612.302478574],[4370722.191375658,-3073891.273081387],[4347960.190878835,-3080748.659455503],[4323107.640081659,-3093948.5565792075],[4298764.793101276,-3109071.6594336806],[4289188.750001492,-3116236.1740688616],[4279341.559041239,-3120334.544844398],[4266990.294419119,-3120710.7920816336]]]},properties:{hex:"ID1064"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4476196.64409514,-2980695.658333536],[4476196.64409514,-2952820.99978845],[4496970.661989206,-2940827.11496516],[4492111.750924287,-2949003.001407963],[4484863.188000696,-2960137.5583903547],[4479007.810073001,-2971968.2729328624],[4476196.64409514,-2980695.658333536]]]},properties:{hex:"ID1065"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1371493.958269954,-2724595.9890396893],[1476196.64409514,-2664145.86519364],[1601196.64409514,-2736314.64884234],[1601196.64409514,-2880652.21613975],[1476196.64409514,-2952820.99978845],[1375958.2528474175,-2894948.337618447],[1376249.0306268153,-2891369.144318329],[1375008.9612511077,-2871489.470295938],[1376396.6544637796,-2848093.5545545653],[1372929.1314667633,-2823842.450209665],[1371673.8582088351,-2810600.201262048],[1375572.3188995726,-2800115.7824725634],[1377380.168499108,-2803427.5456182957],[1380766.8367899386,-2805007.271531636],[1383806.9121388511,-2791080.2705930113],[1385028.5745446105,-2778776.2786579346],[1380576.194545585,-2748381.7846642253],[1371493.958269954,-2724595.9890396893]]]},properties:{hex:"ID1118"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1601196.64409514,-2736314.64884234],[1726196.64409514,-2664145.86519364],[1851196.64409514,-2736314.64884234],[1851196.64409514,-2880652.21613975],[1726196.64409514,-2952820.99978845],[1601196.64409514,-2880652.21613975],[1601196.64409514,-2736314.64884234]]]},properties:{hex:"ID1119"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1851196.64409514,-2736314.64884234],[1910231.192659588,-2702231.0363371694],[1923644.77936223,-2694486.698443601],[1976196.64409514,-2664145.86519364],[2007501.6578306707,-2682219.823300833],[2101196.64409514,-2736314.64884234],[2101196.64409514,-2880652.21613975],[1976196.64409514,-2952820.99978845],[1895599.487256211,-2906288.2095915778],[1851196.64409514,-2880652.21613975],[1851196.64409514,-2736314.64884234]]]},properties:{hex:"ID1120"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2101196.64409514,-2736314.64884234],[2226196.64409514,-2664145.86519364],[2351196.64409514,-2736314.64884234],[2351196.64409514,-2880652.21613975],[2226196.64409514,-2952820.99978845],[2101196.64409514,-2880652.21613975],[2101196.64409514,-2736314.64884234]]]},properties:{hex:"ID1121"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2351196.64409514,-2736314.64884234],[2476196.64409514,-2664145.86519364],[2601196.64409514,-2736314.64884234],[2601196.64409514,-2862096.8291192437],[2601196.64409514,-2880652.21613975],[2559265.628246878,-2904861.0994271375],[2476196.64409514,-2952820.99978845],[2351196.64409514,-2880652.21613975],[2351196.64409514,-2736314.64884234]]]},properties:{hex:"ID1122"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2601196.64409514,-2736314.64884234],[2726196.64409514,-2664145.86519364],[2776517.2304637856,-2693198.469279356],[2795177.801251298,-2703972.1548467577],[2795617.596833959,-2704226.0709447954],[2815889.9517735266,-2715930.320526262],[2851196.64409514,-2736314.64884234],[2851196.64409514,-2880652.21613975],[2726196.64409514,-2952820.99978845],[2601196.64409514,-2880652.21613975],[2601196.64409514,-2862096.8291192437],[2601196.64409514,-2736314.64884234]]]},properties:{hex:"ID1123"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2851196.64409514,-2736314.64884234],[2872683.910351645,-2723908.969884998],[2976196.64409514,-2664145.86519364],[3032241.472253905,-2696503.361817788],[3101196.64409514,-2736314.64884234],[3101196.64409514,-2880652.21613975],[3016863.945254421,-2929341.7225169246],[2976196.64409514,-2952820.99978845],[2851196.64409514,-2880652.21613975],[2851196.64409514,-2736314.64884234]]]},properties:{hex:"ID1124"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3101196.64409514,-2736314.64884234],[3226196.64409514,-2664145.86519364],[3351196.64409514,-2736314.64884234],[3351196.64409514,-2880652.21613975],[3226196.64409514,-2952820.99978845],[3101196.64409514,-2880652.21613975],[3101196.64409514,-2736314.64884234]]]},properties:{hex:"ID1125"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3384801.636545125,-2716912.797405224],[3393034.787293331,-2712159.385604476],[3393091.4352701902,-2717297.8267221265],[3394629.470337168,-2724261.9759101644],[3394780.3948868774,-2730803.0558774965],[3393833.3198478804,-2739675.33419316],[3384622.5023121093,-2773401.692523139],[3384350.813523193,-2787112.0028599175],[3388034.574633432,-2810003.5010538516],[3376867.598915139,-2836601.159989866],[3361364.3393613873,-2886522.5377387535],[3351196.64409514,-2880652.21613975],[3351196.64409514,-2736314.64884234],[3375371.2291335873,-2722357.4456628403],[3374909.5142528126,-2725727.355857159],[3371922.232187223,-2742112.8459367915],[3377476.5855877926,-2749037.920732973],[3380629.5720424033,-2742792.512559381],[3381265.61112203,-2732432.313740247],[3384801.636545125,-2716912.797405224]]]},properties:{hex:"ID1126"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4134306.4325371124,-2717198.703572558],[4226196.64409514,-2664145.86519364],[4351196.64409514,-2736314.64884234],[4351196.64409514,-2880652.21613975],[4226196.64409514,-2952820.99978845],[4141480.2548265713,-2903909.9696394713],[4141559.004834715,-2903208.2947288975],[4145524.390326768,-2889862.7357049924],[4152957.25385486,-2877832.8485131655],[4152843.7481522923,-2864817.947630168],[4149250.7129196553,-2851132.725802329],[4149349.9845986445,-2836963.63342062],[4147121.4611062557,-2824064.6788402903],[4134460.653922991,-2800806.2418928123],[4132415.5203812737,-2789359.5623235884],[4131605.832833768,-2777500.021346369],[4131143.5467869034,-2740519.103582875],[4132374.323791722,-2727649.860597118],[4134306.4325371124,-2717198.703572558]]]},properties:{hex:"ID1129"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4496970.661989206,-2940827.11496516],[4476196.64409514,-2952820.99978845],[4351196.64409514,-2880652.21613975],[4351196.64409514,-2736314.64884234],[4476196.64409514,-2664145.86519364],[4584585.437293072,-2726724.164123598],[4576812.020899782,-2741761.2901015063],[4572855.192213006,-2750385.312140307],[4562287.9313384835,-2784138.488544418],[4552046.811372912,-2813408.0899656103],[4540817.527249314,-2842376.9780178564],[4519465.616557911,-2890201.3905046834],[4515357.875235703,-2904936.0112488205],[4509900.753019454,-2919070.1915422],[4496970.661989206,-2940827.11496516]]]},properties:{hex:"ID1130"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1272981.248891824,-2492797.1937229363],[1351196.64409514,-2447639.51424753],[1476196.64409514,-2519808.29789623],[1476196.64409514,-2664145.86519364],[1371493.958269954,-2724595.9890396893],[1368698.3143685875,-2717274.3765580473],[1337843.802474124,-2666534.5633987254],[1330610.9557967822,-2647185.613609654],[1326697.0031231763,-2631141.373822367],[1292439.0973538,-2564144.2871924746],[1278519.287725613,-2516804.702592177],[1272981.248891824,-2492797.1937229363]]]},properties:{hex:"ID1189"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1476196.64409514,-2519808.29789623],[1601196.64409514,-2447639.51424753],[1726196.64409514,-2519808.29789623],[1726196.64409514,-2664145.86519364],[1601196.64409514,-2736314.64884234],[1476196.64409514,-2664145.86519364],[1476196.64409514,-2519808.29789623]]]},properties:{hex:"ID1190"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1726196.64409514,-2519808.29789623],[1851196.64409514,-2447639.51424753],[1976196.64409514,-2519808.29789623],[1976196.64409514,-2664145.86519364],[1923644.77936223,-2694486.698443601],[1910231.192659588,-2702231.0363371694],[1851196.64409514,-2736314.64884234],[1726196.64409514,-2664145.86519364],[1726196.64409514,-2519808.29789623]]]},properties:{hex:"ID1191"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1976196.64409514,-2519808.29789623],[2020395.7983140557,-2494289.9043099866],[2101196.64409514,-2447639.51424753],[2226196.64409514,-2519808.29789623],[2226196.64409514,-2664145.86519364],[2101196.64409514,-2736314.64884234],[2007501.6578306707,-2682219.823300833],[1976196.64409514,-2664145.86519364],[1976196.64409514,-2519808.29789623]]]},properties:{hex:"ID1192"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2226196.64409514,-2519808.29789623],[2351196.64409514,-2447639.51424753],[2476196.64409514,-2519808.29789623],[2476196.64409514,-2664145.86519364],[2351196.64409514,-2736314.64884234],[2226196.64409514,-2664145.86519364],[2226196.64409514,-2519808.29789623]]]},properties:{hex:"ID1193"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2476196.64409514,-2519808.29789623],[2594442.6355635207,-2451538.9428913696],[2601196.64409514,-2447639.51424753],[2726196.64409514,-2519808.29789623],[2726196.64409514,-2650983.3872910487],[2726196.64409514,-2664145.86519364],[2601196.64409514,-2736314.64884234],[2476196.64409514,-2664145.86519364],[2476196.64409514,-2519808.29789623]]]},properties:{hex:"ID1194"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2726196.64409514,-2519808.29789623],[2851196.64409514,-2447639.51424753],[2976196.64409514,-2519808.29789623],[2976196.64409514,-2664145.86519364],[2872683.910351645,-2723908.969884998],[2851196.64409514,-2736314.64884234],[2815889.9517735266,-2715930.320526262],[2795617.596833959,-2704226.0709447954],[2795177.801251298,-2703972.1548467577],[2776517.2304637856,-2693198.469279356],[2726196.64409514,-2664145.86519364],[2726196.64409514,-2650983.3872910487],[2726196.64409514,-2519808.29789623]]]},properties:{hex:"ID1195"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2976196.64409514,-2519808.29789623],[3101196.64409514,-2447639.51424753],[3164673.2293885266,-2484287.7378539033],[3226196.64409514,-2519808.29789623],[3226196.64409514,-2664145.86519364],[3101196.64409514,-2736314.64884234],[3032241.472253905,-2696503.361817788],[2976196.64409514,-2664145.86519364],[2976196.64409514,-2519808.29789623]]]},properties:{hex:"ID1196"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[3375371.2291335873,-2722357.4456628403],[3351196.64409514,-2736314.64884234],[3226196.64409514,-2664145.86519364],[3226196.64409514,-2519808.29789623],[3351196.64409514,-2447639.51424753],[3351626.307913866,-2447887.5807689307],[3350217.705143764,-2464550.4048778177],[3341040.389137221,-2502388.7957717306],[3340784.3636960643,-2510669.0426701833],[3345325.763591623,-2521385.3318542424],[3354647.3474353147,-2534512.4918519226],[3362908.805828761,-2550836.967722969],[3370467.7150991354,-2597684.2308605225],[3368629.615956565,-2621765.9397348166],[3378337.3135325313,-2652516.788054154],[3377232.66309043,-2665830.25582521],[3378577.4828508543,-2698956.0186409135],[3375371.2291335873,-2722357.4456628403]]],[[[3393034.787293331,-2712159.385604476],[3384801.636545125,-2716912.797405224],[3385055.866056963,-2715796.991213321],[3389560.285951623,-2708385.871969904],[3393004.822476956,-2709441.3283483726],[3393034.787293331,-2712159.385604476]]]]},properties:{hex:"ID1197"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4226196.64409514,-2549733.8728285497],[4226196.64409514,-2664145.86519364],[4134306.4325371124,-2717198.703572558],[4137414.409224233,-2700387.0450863247],[4141813.8675568555,-2686356.3189483383],[4147268.756426724,-2676581.4911773275],[4149359.6415889496,-2669281.2583099524],[4152883.9127101796,-2663012.9161232095],[4157540.812736528,-2657988.2263627797],[4161040.3583116927,-2652000.137610059],[4172330.415489769,-2617089.2599476622],[4181260.1608565664,-2609332.921243822],[4193474.491969931,-2604878.317022788],[4204078.3412919445,-2595756.21546722],[4211202.015960499,-2583433.8520996105],[4220215.891085247,-2558014.675933075],[4226196.64409514,-2549733.8728285497]]]},properties:{hex:"ID1200"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4259236.213043126,-2500732.8938701954],[4351196.64409514,-2447639.51424753],[4476196.64409514,-2519808.29789623],[4476196.64409514,-2664145.86519364],[4351196.64409514,-2736314.64884234],[4226196.64409514,-2664145.86519364],[4226196.64409514,-2549733.8728285497],[4238456.9999544,-2532758.486502779],[4245560.252356628,-2519477.770288531],[4259236.213043126,-2500732.8938701954]]]},properties:{hex:"ID1201"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4584585.437293072,-2726724.164123598],[4476196.64409514,-2664145.86519364],[4476196.64409514,-2519808.29789623],[4601196.64409514,-2447639.51424753],[4685331.3368983,-2496214.7017856184],[4679308.805044594,-2508796.3931888742],[4657564.68151081,-2562132.5442453534],[4637543.844830816,-2616196.1718848743],[4611010.154034082,-2675607.412561431],[4584585.437293072,-2726724.164123598]]]},properties:{hex:"ID1202"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1166950.4100017597,-2265338.992503701],[1226196.64409514,-2231133.16330142],[1351196.64409514,-2303301.94695012],[1351196.64409514,-2447639.51424753],[1272981.248891824,-2492797.1937229363],[1269078.3080188748,-2475877.867146215],[1257687.2352308915,-2456993.3959059846],[1206447.341895474,-2323836.3937739087],[1194680.4444535729,-2302566.356519844],[1172999.3332993526,-2277111.6259803954],[1168011.2350787872,-2268604.3331453972],[1166950.4100017597,-2265338.992503701]]]},properties:{hex:"ID1269"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1351196.64409514,-2303301.94695012],[1476196.64409514,-2231133.16330142],[1601196.64409514,-2303301.94695012],[1601196.64409514,-2447639.51424753],[1476196.64409514,-2519808.29789623],[1351196.64409514,-2447639.51424753],[1351196.64409514,-2303301.94695012]]]},properties:{hex:"ID1270"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1601196.64409514,-2303301.94695012],[1726196.64409514,-2231133.16330142],[1851196.64409514,-2303301.94695012],[1851196.64409514,-2447639.51424753],[1726196.64409514,-2519808.29789623],[1601196.64409514,-2447639.51424753],[1601196.64409514,-2303301.94695012]]]},properties:{hex:"ID1271"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1851196.64409514,-2303301.94695012],[1976196.64409514,-2231133.16330142],[2034745.07682133,-2264936.1166965147],[2101196.64409514,-2303301.94695012],[2101196.64409514,-2447639.51424753],[2020395.7983140557,-2494289.9043099866],[1976196.64409514,-2519808.29789623],[1851196.64409514,-2447639.51424753],[1851196.64409514,-2303301.94695012]]]},properties:{hex:"ID1272"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2101196.64409514,-2303301.94695012],[2226196.64409514,-2231133.16330142],[2351196.64409514,-2303301.94695012],[2351196.64409514,-2447639.51424753],[2226196.64409514,-2519808.29789623],[2101196.64409514,-2447639.51424753],[2101196.64409514,-2303301.94695012]]]},properties:{hex:"ID1273"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2351196.64409514,-2303301.94695012],[2467915.768890835,-2235914.128829751],[2476196.64409514,-2231133.16330142],[2601196.64409514,-2303301.94695012],[2601196.64409514,-2447639.51424753],[2594442.6355635207,-2451538.9428913696],[2476196.64409514,-2519808.29789623],[2351196.64409514,-2447639.51424753],[2351196.64409514,-2303301.94695012]]]},properties:{hex:"ID1274"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2601196.64409514,-2303301.94695012],[2726196.64409514,-2231133.16330142],[2851196.64409514,-2303301.94695012],[2851196.64409514,-2447639.51424753],[2726196.64409514,-2519808.29789623],[2601196.64409514,-2447639.51424753],[2601196.64409514,-2303301.94695012]]]},properties:{hex:"ID1275"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2851196.64409514,-2303301.94695012],[2976196.64409514,-2231133.16330142],[3101196.64409514,-2303301.94695012],[3101196.64409514,-2447639.51424753],[2976196.64409514,-2519808.29789623],[2851196.64409514,-2447639.51424753],[2851196.64409514,-2303301.94695012]]]},properties:{hex:"ID1276"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3351196.64409514,-2425969.362599293],[3351196.64409514,-2447639.51424753],[3226196.64409514,-2519808.29789623],[3164673.2293885266,-2484287.7378539033],[3101196.64409514,-2447639.51424753],[3101196.64409514,-2303301.94695012],[3201479.348501713,-2245403.700565924],[3226196.64409514,-2231133.16330142],[3351196.64409514,-2303301.94695012],[3351196.64409514,-2418329.272487264],[3345610.7239464787,-2417515.712240818],[3350941.5476738485,-2425467.9946716414],[3351196.64409514,-2425969.362599293]]]},properties:{hex:"ID1277"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[3351196.64409514,-2418329.272487264],[3351196.64409514,-2303301.94695012],[3476196.64409514,-2231133.16330142],[3546346.2550276313,-2271634.060056842],[3543827.5356259868,-2274354.88825672],[3539006.673370283,-2281335.197096228],[3529177.0154319354,-2295529.6572642336],[3527361.982519722,-2304825.0004255855],[3519649.9194866912,-2307662.951930234],[3514362.232612909,-2298758.374931954],[3509893.858342778,-2315915.804197247],[3504684.131801524,-2317133.523814912],[3499420.9415033753,-2313622.1596104647],[3484480.0784032894,-2322110.5151582523],[3471200.990782586,-2331897.6303393757],[3449403.871153972,-2352529.728146185],[3417462.017313031,-2392447.2691181726],[3372969.4063607804,-2430965.42907852],[3367346.0170323257,-2432062.484842788],[3363649.234708542,-2431909.134397506],[3352416.004378069,-2418506.8659769464],[3351196.64409514,-2418329.272487264]]],[[[3351626.307913866,-2447887.5807689307],[3351196.64409514,-2447639.51424753],[3351196.64409514,-2425969.362599293],[3354308.833592957,-2432086.0771775646],[3351864.3267804566,-2445071.9775394215],[3351626.307913866,-2447887.5807689307]]]]},properties:{hex:"ID1278"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4276492.372347871,-2260171.4155472172],[4351196.64409514,-2303301.94695012],[4351196.64409514,-2447639.51424753],[4259236.213043126,-2500732.8938701954],[4260202.465984773,-2499408.5048641707],[4274641.3461925695,-2471151.5305374977],[4279679.2722036755,-2457830.5002457094],[4283860.422536524,-2444175.692728869],[4290650.708859397,-2414235.327308216],[4294688.309718105,-2399329.333366975],[4296298.066487987,-2384560.682292461],[4292321.856530194,-2369374.4264994687],[4281700.303344033,-2341801.1021677055],[4281917.161414299,-2336648.692656171],[4285742.962712012,-2316140.4341827235],[4286453.795049121,-2301301.001319187],[4283090.9975193925,-2286516.607520386],[4278096.182558311,-2272580.090401851],[4276492.372347871,-2260171.4155472172]]]},properties:{hex:"ID1281"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4351196.64409514,-2303301.94695012],[4476196.64409514,-2231133.16330142],[4601196.64409514,-2303301.94695012],[4601196.64409514,-2447639.51424753],[4476196.64409514,-2519808.29789623],[4351196.64409514,-2447639.51424753],[4351196.64409514,-2303301.94695012]]]},properties:{hex:"ID1282"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4685331.3368983,-2496214.7017856184],[4601196.64409514,-2447639.51424753],[4601196.64409514,-2303301.94695012],[4726196.64409514,-2231133.16330142],[4785412.261060173,-2265321.3156964052],[4780585.835125439,-2277490.222805641],[4767193.782076629,-2307556.531465729],[4747545.451841819,-2347177.5050935126],[4726444.097291693,-2396862.284531959],[4707070.489417531,-2447937.6226289603],[4693757.249444263,-2478612.0997538976],[4685331.3368983,-2496214.7017856184]]]},properties:{hex:"ID1283"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1153719.3598886163,-2044950.8164572422],[1226196.64409514,-2086795.59600401],[1226196.64409514,-2113799.118935034],[1226196.64409514,-2231133.16330142],[1166950.4100017597,-2265338.992503701],[1160128.7736717293,-2244341.2174381455],[1144180.9174674961,-2211752.698888812],[1141058.8406984927,-2181325.9646993186],[1141020.1360854814,-2146827.4230358647],[1143941.439191447,-2120400.199859386],[1148984.2847934838,-2074468.3609349136],[1153402.9110891349,-2054137.9206301142],[1153719.3598886163,-2044950.8164572422]]]},properties:{hex:"ID1354"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1226196.64409514,-2086795.59600401],[1351196.64409514,-2014626.81235531],[1476196.64409514,-2086795.59600401],[1476196.64409514,-2137357.635686742],[1476196.64409514,-2231133.16330142],[1351196.64409514,-2303301.94695012],[1226196.64409514,-2231133.16330142],[1226196.64409514,-2113799.118935034],[1226196.64409514,-2086795.59600401]]]},properties:{hex:"ID1355"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1476196.64409514,-2086795.59600401],[1601196.64409514,-2014626.81235531],[1726196.64409514,-2086795.59600401],[1726196.64409514,-2137821.6616824674],[1726196.64409514,-2231133.16330142],[1601196.64409514,-2303301.94695012],[1476196.64409514,-2231133.16330142],[1476196.64409514,-2137357.635686742],[1476196.64409514,-2086795.59600401]]]},properties:{hex:"ID1356"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1726196.64409514,-2086795.59600401],[1851196.64409514,-2014626.81235531],[1976196.64409514,-2086795.59600401],[1976196.64409514,-2196971.934434217],[1976196.64409514,-2231133.16330142],[1851196.64409514,-2303301.94695012],[1726196.64409514,-2231133.16330142],[1726196.64409514,-2137821.6616824674],[1726196.64409514,-2086795.59600401]]]},properties:{hex:"ID1357"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1976196.64409514,-2086795.59600401],[2101196.64409514,-2014626.81235531],[2188698.843651828,-2065146.2308240458],[2226196.64409514,-2086795.59600401],[2226196.64409514,-2113084.3253342006],[2226196.64409514,-2179020.1459399303],[2226196.64409514,-2216421.4402980977],[2226196.64409514,-2231133.16330142],[2101196.64409514,-2303301.94695012],[2034745.07682133,-2264936.1166965147],[1976196.64409514,-2231133.16330142],[1976196.64409514,-2196971.934434217],[1976196.64409514,-2086795.59600401]]]},properties:{hex:"ID1358"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2226196.64409514,-2086795.59600401],[2351196.64409514,-2014626.81235531],[2476196.64409514,-2086795.59600401],[2476196.64409514,-2192847.557602899],[2476196.64409514,-2231133.16330142],[2467915.768890835,-2235914.128829751],[2351196.64409514,-2303301.94695012],[2226196.64409514,-2231133.16330142],[2226196.64409514,-2216421.4402980977],[2226196.64409514,-2179020.1459399303],[2226196.64409514,-2113084.3253342006],[2226196.64409514,-2086795.59600401]]]},properties:{hex:"ID1359"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2476196.64409514,-2086795.59600401],[2601196.64409514,-2014626.81235531],[2719251.378049832,-2082785.7447831577],[2726196.64409514,-2086795.59600401],[2726196.64409514,-2231133.16330142],[2601196.64409514,-2303301.94695012],[2476196.64409514,-2231133.16330142],[2476196.64409514,-2192847.557602899],[2476196.64409514,-2086795.59600401]]]},properties:{hex:"ID1360"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2726196.64409514,-2086795.59600401],[2851196.64409514,-2014626.81235531],[2976196.64409514,-2086795.59600401],[2976196.64409514,-2231133.16330142],[2851196.64409514,-2303301.94695012],[2726196.64409514,-2231133.16330142],[2726196.64409514,-2086795.59600401]]]},properties:{hex:"ID1361"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2976196.64409514,-2086795.59600401],[3101196.64409514,-2014626.81235531],[3206722.662425881,-2075552.2874450698],[3226196.64409514,-2086795.59600401],[3226196.64409514,-2231133.16330142],[3201479.348501713,-2245403.700565924],[3101196.64409514,-2303301.94695012],[2976196.64409514,-2231133.16330142],[2976196.64409514,-2086795.59600401]]]},properties:{hex:"ID1362"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3226196.64409514,-2086795.59600401],[3351196.64409514,-2014626.81235531],[3395216.8146874383,-2040041.8696965454],[3441887.8388745068,-2066987.3980743038],[3476196.64409514,-2086795.59600401],[3476196.64409514,-2231133.16330142],[3351196.64409514,-2303301.94695012],[3226196.64409514,-2231133.16330142],[3226196.64409514,-2086795.59600401]]]},properties:{hex:"ID1363"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3546346.2550276313,-2271634.060056842],[3476196.64409514,-2231133.16330142],[3476196.64409514,-2086795.59600401],[3601196.64409514,-2014626.81235531],[3726196.64409514,-2086795.59600401],[3726196.64409514,-2115825.079010397],[3715937.3621903947,-2119617.1646349085],[3709873.3527187873,-2123650.870821166],[3705540.797094695,-2129167.1080192574],[3684314.392629138,-2137885.260093094],[3650257.0150373555,-2159443.7238183618],[3622093.6618402307,-2179986.718230594],[3601114.7957763122,-2200534.1564458963],[3595828.1842989624,-2203649.9845018312],[3589246.8410386285,-2210745.846240674],[3586199.883133578,-2221251.7585219657],[3583674.255347828,-2227184.8897906793],[3567480.387327903,-2248804.0683138208],[3546346.2550276313,-2271634.060056842]]]},properties:{hex:"ID1364"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3726196.64409514,-2115825.079010397],[3726196.64409514,-2086795.59600401],[3851196.64409514,-2014626.81235531],[3878231.1664656033,-2030235.2011233033],[3868571.080562635,-2038968.7883325105],[3828527.8993796585,-2064897.7546117574],[3822004.764486412,-2070906.2779077925],[3810871.0733304787,-2086815.2809729187],[3797961.8779137367,-2090673.171488414],[3790548.02564521,-2095171.7503281177],[3777983.6585308146,-2096821.5397387065],[3773780.2448242516,-2095670.252669787],[3769496.3000647537,-2096228.0955778693],[3765576.8499654224,-2099634.384488606],[3739820.1259757085,-2110789.501445149],[3726196.64409514,-2115825.079010397]]]},properties:{hex:"ID1365"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4338638.144500832,-2021877.4654767003],[4351196.64409514,-2014626.81235531],[4476196.64409514,-2086795.59600401],[4476196.64409514,-2231133.16330142],[4351196.64409514,-2303301.94695012],[4276492.372347871,-2260171.4155472172],[4274727.863773764,-2246519.4179281886],[4276850.996072938,-2203413.045457046],[4279448.063337132,-2187820.2703523166],[4279179.583481695,-2173965.6464287136],[4275913.685611871,-2160747.8832820724],[4282164.7485368205,-2137695.491068233],[4335073.769639033,-2053959.7616391547],[4337611.523304309,-2044088.939903611],[4338638.144500832,-2021877.4654767003]]]},properties:{hex:"ID1367"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4476196.64409514,-2086795.59600401],[4601196.64409514,-2014626.81235531],[4726196.64409514,-2086795.59600401],[4726196.64409514,-2231133.16330142],[4601196.64409514,-2303301.94695012],[4476196.64409514,-2231133.16330142],[4476196.64409514,-2086795.59600401]]]},properties:{hex:"ID1368"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[4785412.261060173,-2265321.3156964052],[4726196.64409514,-2231133.16330142],[4726196.64409514,-2086795.59600401],[4851196.64409514,-2014626.81235531],[4867523.095806528,-2024052.8936457965],[4867165.229155171,-2027669.6811894253],[4862640.301771485,-2041843.7289143004],[4853522.91589851,-2054007.2707544155],[4853099.0056808805,-2060741.312111929],[4854993.968281722,-2067640.8502666878],[4851773.919582377,-2071808.6921914187],[4841054.722996965,-2077092.293941037],[4836380.23844761,-2081746.228073553],[4829332.0402975045,-2094115.386334622],[4817204.381830537,-2119356.150575053],[4814299.052787526,-2132239.367338469],[4814509.48382355,-2171440.8743128497],[4809155.488226804,-2199230.9073184677],[4790568.979115718,-2252319.6403666646],[4785412.261060173,-2265321.3156964052]]],[[[4870105.289042829,-2078315.1738191806],[4856201.278141633,-2100631.3101580236],[4861745.724507933,-2081995.5357870243],[4877962.797278755,-2055147.4783899772],[4881854.362970304,-2053068.9588606425],[4870105.289042829,-2078315.1738191806]]]]},properties:{hex:"ID1369"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1203228.0569870987,-1811381.3813589334],[1226196.64409514,-1798120.4614092],[1351196.64409514,-1870289.2450579],[1351196.64409514,-2014626.81235531],[1226196.64409514,-2086795.59600401],[1153719.3598886163,-2044950.8164572422],[1154240.1177232116,-2029832.236506527],[1153876.4179473731,-1966790.3201642379],[1151435.2066422524,-1958130.962599707],[1149914.146910341,-1947971.379372355],[1159810.3348223271,-1940225.7030165624],[1164895.2428752992,-1934311.713196026],[1171853.326782327,-1923850.8446034584],[1177002.7640054296,-1909186.150610852],[1183530.562664269,-1876821.8508604614],[1203228.0569870987,-1811381.3813589334]]]},properties:{hex:"ID1436"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1351196.64409514,-1870289.2450579],[1476196.64409514,-1798120.4614092],[1601196.64409514,-1870289.2450579],[1601196.64409514,-2014626.81235531],[1476196.64409514,-2086795.59600401],[1351196.64409514,-2014626.81235531],[1351196.64409514,-1870289.2450579]]]},properties:{hex:"ID1437"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1601196.64409514,-1870289.2450579],[1726196.64409514,-1798120.4614092],[1851196.64409514,-1870289.2450579],[1851196.64409514,-2014626.81235531],[1726196.64409514,-2086795.59600401],[1601196.64409514,-2014626.81235531],[1601196.64409514,-1870289.2450579]]]},properties:{hex:"ID1438"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1851196.64409514,-1870289.2450579],[1976196.64409514,-1798120.4614092],[2101196.64409514,-1870289.2450579],[2101196.64409514,-2014626.81235531],[1976196.64409514,-2086795.59600401],[1851196.64409514,-2014626.81235531],[1851196.64409514,-1870289.2450579]]]},properties:{hex:"ID1439"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2101196.64409514,-1870289.2450579],[2156612.243115249,-1838295.0340463372],[2226196.64409514,-1798120.4614092],[2351196.64409514,-1870289.2450579],[2351196.64409514,-2014626.81235531],[2226196.64409514,-2086795.59600401],[2188698.843651828,-2065146.2308240458],[2101196.64409514,-2014626.81235531],[2101196.64409514,-1870289.2450579]]]},properties:{hex:"ID1440"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2351196.64409514,-1870289.2450579],[2476196.64409514,-1798120.4614092],[2601196.64409514,-1870289.2450579],[2601196.64409514,-2014626.81235531],[2476196.64409514,-2086795.59600401],[2351196.64409514,-2014626.81235531],[2351196.64409514,-1870289.2450579]]]},properties:{hex:"ID1441"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2601196.64409514,-1870289.2450579],[2726196.64409514,-1798120.4614092],[2851196.64409514,-1870289.2450579],[2851196.64409514,-1950796.5502974775],[2851196.64409514,-2014626.81235531],[2726196.64409514,-2086795.59600401],[2719251.378049832,-2082785.7447831577],[2601196.64409514,-2014626.81235531],[2601196.64409514,-1870289.2450579]]]},properties:{hex:"ID1442"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2851196.64409514,-1870289.2450579],[2976196.64409514,-1798120.4614092],[3017750.772666473,-1822111.7487257982],[3101196.64409514,-1870289.2450579],[3101196.64409514,-1999147.4458430638],[3101196.64409514,-2014626.81235531],[2976196.64409514,-2086795.59600401],[2851196.64409514,-2014626.81235531],[2851196.64409514,-1950796.5502974775],[2851196.64409514,-1870289.2450579]]]},properties:{hex:"ID1443"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3101196.64409514,-1870289.2450579],[3226196.64409514,-1798120.4614092],[3351196.64409514,-1870289.2450579],[3351196.64409514,-1949014.0283951187],[3351196.64409514,-1955283.0583015194],[3351196.64409514,-2014626.81235531],[3226196.64409514,-2086795.59600401],[3206722.662425881,-2075552.2874450698],[3101196.64409514,-2014626.81235531],[3101196.64409514,-1999147.4458430638],[3101196.64409514,-1870289.2450579]]]},properties:{hex:"ID1444"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3351196.64409514,-1870289.2450579],[3389967.3049723534,-1847904.993563782],[3476196.64409514,-1798120.4614092],[3519913.02060195,-1823360.1231534008],[3601196.64409514,-1870289.2450579],[3601196.64409514,-2014626.81235531],[3476196.64409514,-2086795.59600401],[3441887.8388745068,-2066987.3980743038],[3395216.8146874383,-2040041.8696965454],[3351196.64409514,-2014626.81235531],[3351196.64409514,-1955283.0583015194],[3351196.64409514,-1949014.0283951187],[3351196.64409514,-1870289.2450579]]]},properties:{hex:"ID1445"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3601196.64409514,-1870289.2450579],[3726196.64409514,-1798120.4614092],[3851196.64409514,-1870289.2450579],[3851196.64409514,-2014626.81235531],[3726196.64409514,-2086795.59600401],[3601196.64409514,-2014626.81235531],[3601196.64409514,-1870289.2450579]]]},properties:{hex:"ID1446"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3878231.1664656033,-2030235.2011233033],[3851196.64409514,-2014626.81235531],[3851196.64409514,-1870289.2450579],[3976196.64409514,-1798120.4614092],[4009115.1116831712,-1817125.947532464],[4008334.110916369,-1821094.5711029992],[4001942.9637891836,-1827316.5412565435],[3993553.5374977714,-1837971.2564208165],[3991308.125669967,-1847957.0610669514],[3991368.0693018967,-1854498.2824121257],[3986054.2155726515,-1856595.1528894948],[3983275.955164409,-1860633.8288486295],[3985844.2950718394,-1870044.5574918108],[3984834.8531431113,-1878370.1699329468],[3973313.1624051305,-1904281.3187357972],[3945841.4945297614,-1939690.253314038],[3934240.030277707,-1952254.3033919386],[3923176.465234687,-1965922.0583870916],[3922627.668736462,-1971523.922978485],[3921194.9098964115,-1976399.8792854405],[3907932.69188383,-1995899.948942738],[3895508.2993559754,-1999097.8596087669],[3888255.8842866705,-2004304.5173333464],[3891763.736160582,-2021478.6508381183],[3883539.7616009596,-2025435.7532675902],[3878231.1664656033,-2030235.2011233033]]]},properties:{hex:"ID1447"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4351196.64409514,-1994067.3695243278],[4351196.64409514,-2014626.81235531],[4338638.144500832,-2021877.4654767003],[4338793.347413246,-2018519.5711221648],[4341360.536109697,-2003638.8500921037],[4343487.9393926505,-1998123.0490970893],[4347142.059810647,-1994901.3114816553],[4351196.64409514,-1994067.3695243278]]]},properties:{hex:"ID1448"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4601196.64409514,-1873454.9124897746],[4601196.64409514,-2014626.81235531],[4476196.64409514,-2086795.59600401],[4351196.64409514,-2014626.81235531],[4351196.64409514,-1994067.3695243278],[4354714.209759618,-1993343.8809026997],[4390053.1108146,-1989693.8734151165],[4394831.131232668,-1987113.7730989337],[4404347.040982537,-1980026.8721390478],[4417869.3419756815,-1966350.243753613],[4423793.602013253,-1962413.2090391477],[4428370.425733794,-1963852.455300958],[4430748.709019568,-1969716.1563795367],[4434284.607265354,-1972915.3925544447],[4449081.807100006,-1966718.9566281668],[4454528.796691473,-1966528.6534750937],[4459935.364829251,-1967539.632472939],[4463168.447588905,-1961842.2593988779],[4465577.2735067,-1954205.3187087297],[4468237.488847681,-1948816.089711048],[4472365.031471852,-1945758.4237673392],[4490729.8766212305,-1944092.708208374],[4502560.235474928,-1941903.4167386943],[4518159.725994824,-1936560.7587772484],[4521272.546790345,-1937607.906845976],[4531178.459306435,-1956822.4413204612],[4534657.972753518,-1958475.9319433656],[4539268.436734738,-1959261.0276657455],[4543777.7370521305,-1955763.7091145096],[4535111.809615056,-1945710.8324905515],[4534276.207064502,-1940023.4225381834],[4535523.637906542,-1933562.0140277764],[4542341.270985957,-1919720.7795735525],[4552333.114106677,-1909162.3416284279],[4573679.858255016,-1893113.1361136052],[4596061.070497574,-1874546.9480587132],[4601196.64409514,-1873454.9124897746]]]},properties:{hex:"ID1449"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4625645.384225823,-1856173.758362107],[4654545.901011616,-1839488.0372161095],[4652871.635363325,-1846014.8290007578],[4657506.399664132,-1847683.0071292405],[4662288.44200611,-1845585.8623261673],[4670503.586583974,-1830274.8631552681],[4726196.64409514,-1798120.4614092],[4851196.64409514,-1870289.2450579],[4851196.64409514,-2014626.81235531],[4726196.64409514,-2086795.59600401],[4601196.64409514,-2014626.81235531],[4601196.64409514,-1873454.9124897746],[4602110.53476276,-1873260.5814971013],[4606781.760309562,-1876202.5132290046],[4608163.876614248,-1898090.2345488553],[4607279.304561569,-1901697.8020916071],[4610466.2468340555,-1902197.8454478309],[4614559.790088737,-1899495.185199724],[4618902.848732942,-1890660.170593274],[4619897.006515359,-1883324.5505947326],[4617954.105465971,-1876285.885935263],[4617285.040262839,-1870330.4325120468],[4617776.931949159,-1864850.9503280402],[4625645.384225823,-1856173.758362107]]]},properties:{hex:"ID1450"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4867523.095806528,-2024052.8936457965],[4851196.64409514,-2014626.81235531],[4851196.64409514,-1870289.2450579],[4933580.976447756,-1822724.6285971077],[4936661.5065516895,-1838829.28247694],[4946156.103700816,-1864755.65105132],[4946772.686945551,-1893577.522315461],[4935519.146068063,-1923255.7504503618],[4921011.304344886,-1951207.3927209],[4917504.091274437,-1956453.6714110456],[4911396.588614542,-1963626.4600987756],[4909086.577153601,-1963305.3076472958],[4901124.248566707,-1956096.7952872156],[4895334.474267187,-1944294.9759606677],[4889530.052077499,-1916483.1977818564],[4887897.071351815,-1902364.5257266795],[4884316.968051762,-1900138.1187830174],[4873435.843464813,-1901364.4377547828],[4864609.482227198,-1910150.4071682182],[4862531.135905524,-1915685.680676509],[4862315.325891483,-1931372.3669555306],[4863546.636497405,-1945472.8755803215],[4863103.17846974,-1959784.419469311],[4861107.86035025,-1977791.2420578024],[4863314.267897387,-1983237.4793984497],[4867010.723321742,-1987815.2854789116],[4869942.89406098,-1999597.1469267241],[4867523.095806528,-2024052.8936457965]]]},properties:{hex:"ID1451"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1226196.64409514,-1706722.872142114],[1226196.64409514,-1798120.4614092],[1203228.0569870987,-1811381.3813589334],[1205963.2977298957,-1802294.1626764592],[1217637.195423076,-1729191.0444325837],[1226196.64409514,-1706722.872142114]]]},properties:{hex:"ID1509"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1245834.1907886604,-1642445.1512420692],[1351196.64409514,-1581614.11046309],[1476196.64409514,-1653782.89411179],[1476196.64409514,-1798120.4614092],[1351196.64409514,-1870289.2450579],[1226196.64409514,-1798120.4614092],[1226196.64409514,-1706722.872142114],[1230844.4838129794,-1694522.4994826305],[1236473.1843123958,-1655668.470245014],[1245834.1907886604,-1642445.1512420692]]]},properties:{hex:"ID1510"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1476196.64409514,-1653782.89411179],[1601196.64409514,-1581614.11046309],[1726196.64409514,-1653782.89411179],[1726196.64409514,-1798120.4614092],[1601196.64409514,-1870289.2450579],[1476196.64409514,-1798120.4614092],[1476196.64409514,-1653782.89411179]]]},properties:{hex:"ID1511"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1726196.64409514,-1653782.89411179],[1851196.64409514,-1581614.11046309],[1976196.64409514,-1653782.89411179],[1976196.64409514,-1798120.4614092],[1851196.64409514,-1870289.2450579],[1726196.64409514,-1798120.4614092],[1726196.64409514,-1653782.89411179]]]},properties:{hex:"ID1512"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1976196.64409514,-1653782.89411179],[2101196.64409514,-1581614.11046309],[2166994.6906202747,-1619602.6303365265],[2226196.64409514,-1653782.89411179],[2226196.64409514,-1798120.4614092],[2156612.243115249,-1838295.0340463372],[2101196.64409514,-1870289.2450579],[1976196.64409514,-1798120.4614092],[1976196.64409514,-1653782.89411179]]]},properties:{hex:"ID1513"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2226196.64409514,-1653782.89411179],[2315522.3868665886,-1602210.6524771333],[2351196.64409514,-1581614.11046309],[2360338.667470499,-1586892.2601197911],[2476196.64409514,-1653782.89411179],[2476196.64409514,-1798120.4614092],[2351196.64409514,-1870289.2450579],[2226196.64409514,-1798120.4614092],[2226196.64409514,-1653782.89411179]]]},properties:{hex:"ID1514"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2476196.64409514,-1653782.89411179],[2601196.64409514,-1581614.11046309],[2726196.64409514,-1653782.89411179],[2726196.64409514,-1798120.4614092],[2601196.64409514,-1870289.2450579],[2476196.64409514,-1798120.4614092],[2476196.64409514,-1653782.89411179]]]},properties:{hex:"ID1515"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2726196.64409514,-1653782.89411179],[2833426.398528633,-1591873.766524478],[2851196.64409514,-1581614.11046309],[2937034.9301641025,-1631172.8680317793],[2976196.64409514,-1653782.89411179],[2976196.64409514,-1798120.4614092],[2851196.64409514,-1870289.2450579],[2726196.64409514,-1798120.4614092],[2726196.64409514,-1653782.89411179]]]},properties:{hex:"ID1516"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2976196.64409514,-1653782.89411179],[3101196.64409514,-1581614.11046309],[3226196.64409514,-1653782.89411179],[3226196.64409514,-1669549.7393679984],[3226196.64409514,-1682040.6838273315],[3226196.64409514,-1693752.917035668],[3226196.64409514,-1695991.991519784],[3226196.64409514,-1742094.6619830767],[3226196.64409514,-1798120.4614092],[3101196.64409514,-1870289.2450579],[3017750.772666473,-1822111.7487257982],[2976196.64409514,-1798120.4614092],[2976196.64409514,-1653782.89411179]]]},properties:{hex:"ID1517"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3226196.64409514,-1653782.89411179],[3242487.6700075082,-1644377.2659159095],[3351196.64409514,-1581614.11046309],[3405928.849365363,-1613213.7639091937],[3476196.64409514,-1653782.89411179],[3476196.64409514,-1725685.8001906367],[3476196.64409514,-1798120.4614092],[3389967.3049723534,-1847904.993563782],[3351196.64409514,-1870289.2450579],[3226196.64409514,-1798120.4614092],[3226196.64409514,-1742094.6619830767],[3226196.64409514,-1695991.991519784],[3226196.64409514,-1693752.917035668],[3226196.64409514,-1682040.6838273315],[3226196.64409514,-1669549.7393679984],[3226196.64409514,-1653782.89411179]]]},properties:{hex:"ID1518"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3476196.64409514,-1653782.89411179],[3601196.64409514,-1581614.11046309],[3726196.64409514,-1653782.89411179],[3726196.64409514,-1798120.4614092],[3601196.64409514,-1870289.2450579],[3519913.02060195,-1823360.1231534008],[3476196.64409514,-1798120.4614092],[3476196.64409514,-1725685.8001906367],[3476196.64409514,-1653782.89411179]]]},properties:{hex:"ID1519"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3726196.64409514,-1653782.89411179],[3851196.64409514,-1581614.11046309],[3976196.64409514,-1653782.89411179],[3976196.64409514,-1798120.4614092],[3851196.64409514,-1870289.2450579],[3726196.64409514,-1798120.4614092],[3726196.64409514,-1653782.89411179]]]},properties:{hex:"ID1520"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4009115.1116831712,-1817125.947532464],[3976196.64409514,-1798120.4614092],[3976196.64409514,-1653782.89411179],[3997439.0327278855,-1641518.5953164399],[3998880.637976164,-1647866.6121213615],[3994243.442012241,-1658738.8158614403],[3994823.709535212,-1667124.8908880467],[3994062.886747601,-1677994.3547161047],[3994716.2606825437,-1705471.5831731572],[3992245.7350471895,-1739430.9017682255],[3992434.746291904,-1744872.4784264248],[3996710.9948006175,-1748714.7496382548],[4003040.5587922214,-1750623.8769411955],[4001955.7325599445,-1759930.1499360981],[3993671.052747546,-1772074.217206883],[3992554.653427605,-1779624.4484444573],[3992624.2735253223,-1790226.8148115515],[4001852.907377699,-1775819.613613971],[4006596.3303712746,-1775891.1797822204],[4010321.9286300987,-1781544.6796196979],[4008966.857175248,-1789845.2048819354],[4010048.8568534344,-1793935.4788404098],[4008682.8175554625,-1801984.1579294044],[4010084.1796775605,-1812201.668008728],[4009115.1116831712,-1817125.947532464]]]},properties:{hex:"ID1521"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[4654545.901011616,-1839488.0372161095],[4625645.384225823,-1856173.758362107],[4629509.165802877,-1851912.8474129518],[4638990.382866769,-1839544.2959947272],[4644355.655011198,-1824789.6783126756],[4648351.576714473,-1817995.2970608172],[4657732.336097973,-1810329.960565437],[4660122.609722096,-1811545.98003513],[4661441.3015730055,-1817780.726813751],[4661836.249779176,-1824372.4986638871],[4658927.082694815,-1830915.969396987],[4655084.782237078,-1837387.31588862],[4654545.901011616,-1839488.0372161095]]],[[[4726196.64409514,-1676848.7358627745],[4726196.64409514,-1798120.4614092],[4670503.586583974,-1830274.8631552681],[4670664.792445665,-1829974.415270109],[4679878.66625862,-1815205.8321795673],[4685228.624968995,-1807528.266450589],[4691502.158260286,-1802198.7767464207],[4700851.10028998,-1803271.8609761817],[4709697.841003646,-1806574.4726084345],[4696396.274645792,-1790978.1033339016],[4694928.469187616,-1769616.939549472],[4716697.58692152,-1732640.2941494028],[4717671.545520692,-1724941.918547445],[4720502.315587753,-1722566.597814791],[4722022.162456199,-1719582.4178924444],[4714047.217264067,-1707083.362600829],[4712932.3331013275,-1700886.7752720804],[4715110.544688455,-1691489.427160801],[4720389.214438701,-1683141.8753351993],[4724998.808545758,-1677301.6221693433],[4726196.64409514,-1676848.7358627745]]]]},properties:{hex:"ID1523"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[4933580.976447756,-1822724.6285971077],[4851196.64409514,-1870289.2450579],[4726196.64409514,-1798120.4614092],[4726196.64409514,-1676848.7358627745],[4730937.788798723,-1675056.169667171],[4735152.330546872,-1678269.0572461225],[4744070.352576341,-1688539.8258546076],[4750621.255139133,-1690104.203727715],[4759743.053147729,-1680239.720057506],[4767629.105568612,-1667925.223101721],[4778469.849148326,-1659455.6103589947],[4790321.21403662,-1654222.8564237242],[4809522.026236068,-1634829.896030326],[4823492.636954639,-1597609.0264432912],[4851196.64409514,-1581614.11046309],[4924660.962729648,-1624028.7546025503],[4924875.657022305,-1635164.504589073],[4931440.950373412,-1672810.6506591875],[4935276.595230979,-1729334.2691068018],[4931879.378938854,-1787269.283954878],[4931880.531608942,-1813834.9003208345],[4933580.976447756,-1822724.6285971077]]],[[[4750160.334219108,-1639947.45116794],[4763512.726951168,-1632238.443629763],[4765110.343133131,-1639980.31817147],[4763573.341796337,-1646623.9767807743],[4763261.766011705,-1651092.5911668648],[4750475.900441456,-1649240.656742142],[4750160.334219108,-1639947.45116794]]]]},properties:{hex:"ID1524"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1351196.64409514,-1497887.5451750073],[1351196.64409514,-1581614.11046309],[1245834.1907886604,-1642445.1512420692],[1271997.949205109,-1605486.334395407],[1281232.0712133117,-1574625.0404893178],[1299335.4142510688,-1559494.9870066068],[1324857.992680147,-1543357.165889782],[1343472.5624945953,-1514650.639845675],[1351196.64409514,-1497887.5451750073]]]},properties:{hex:"ID1584"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1364062.2443068011,-1429848.5854201852],[1476196.64409514,-1365107.75951698],[1601196.64409514,-1437276.54316568],[1601196.64409514,-1581614.11046309],[1476196.64409514,-1653782.89411179],[1351196.64409514,-1581614.11046309],[1351196.64409514,-1497887.5451750073],[1352638.976547646,-1494757.3406149945],[1363472.0686030623,-1456621.6189374656],[1364062.2443068011,-1429848.5854201852]]]},properties:{hex:"ID1585"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1601196.64409514,-1437276.54316568],[1726196.64409514,-1365107.75951698],[1851196.64409514,-1437276.54316568],[1851196.64409514,-1581614.11046309],[1726196.64409514,-1653782.89411179],[1601196.64409514,-1581614.11046309],[1601196.64409514,-1437276.54316568]]]},properties:{hex:"ID1586"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1851196.64409514,-1437276.54316568],[1976196.64409514,-1365107.75951698],[2101196.64409514,-1437276.54316568],[2101196.64409514,-1581614.11046309],[1976196.64409514,-1653782.89411179],[1851196.64409514,-1581614.11046309],[1851196.64409514,-1437276.54316568]]]},properties:{hex:"ID1587"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2101196.64409514,-1437276.54316568],[2204754.9085998787,-1377487.1512770613],[2226196.64409514,-1365107.75951698],[2229086.1137824967,-1366775.9956187906],[2351196.64409514,-1437276.54316568],[2351196.64409514,-1581614.11046309],[2315522.3868665886,-1602210.6524771333],[2226196.64409514,-1653782.89411179],[2166994.6906202747,-1619602.6303365265],[2101196.64409514,-1581614.11046309],[2101196.64409514,-1437276.54316568]]]},properties:{hex:"ID1588"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2351196.64409514,-1437276.54316568],[2375820.5038935607,-1423059.951082575],[2409922.525433338,-1403371.139766675],[2476196.64409514,-1365107.75951698],[2601196.64409514,-1437276.54316568],[2601196.64409514,-1470528.9766129064],[2601196.64409514,-1581614.11046309],[2476196.64409514,-1653782.89411179],[2360338.667470499,-1586892.2601197911],[2351196.64409514,-1581614.11046309],[2351196.64409514,-1437276.54316568]]]},properties:{hex:"ID1589"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2601196.64409514,-1437276.54316568],[2726196.64409514,-1365107.75951698],[2808094.349072775,-1412391.421531828],[2851196.64409514,-1437276.54316568],[2851196.64409514,-1494040.6504654898],[2851196.64409514,-1581614.11046309],[2833426.398528633,-1591873.766524478],[2726196.64409514,-1653782.89411179],[2601196.64409514,-1581614.11046309],[2601196.64409514,-1470528.9766129064],[2601196.64409514,-1437276.54316568]]]},properties:{hex:"ID1590"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2851196.64409514,-1437276.54316568],[2976196.64409514,-1365107.75951698],[3101196.64409514,-1437276.54316568],[3101196.64409514,-1581614.11046309],[2976196.64409514,-1653782.89411179],[2937034.9301641025,-1631172.8680317793],[2851196.64409514,-1581614.11046309],[2851196.64409514,-1494040.6504654898],[2851196.64409514,-1437276.54316568]]]},properties:{hex:"ID1591"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3101196.64409514,-1437276.54316568],[3226196.64409514,-1365107.75951698],[3294380.0122360294,-1404473.445467376],[3351196.64409514,-1437276.54316568],[3351196.64409514,-1581614.11046309],[3242487.6700075082,-1644377.2659159095],[3226196.64409514,-1653782.89411179],[3101196.64409514,-1581614.11046309],[3101196.64409514,-1437276.54316568]]]},properties:{hex:"ID1592"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3351196.64409514,-1437276.54316568],[3439129.90399421,-1386508.2518922328],[3476196.64409514,-1365107.75951698],[3601196.64409514,-1437276.54316568],[3601196.64409514,-1444110.8577323093],[3601196.64409514,-1581614.11046309],[3476196.64409514,-1653782.89411179],[3405928.849365363,-1613213.7639091937],[3351196.64409514,-1581614.11046309],[3351196.64409514,-1437276.54316568]]]},properties:{hex:"ID1593"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3601196.64409514,-1437276.54316568],[3726196.64409514,-1365107.75951698],[3771619.470279456,-1391332.6404418473],[3851196.64409514,-1437276.54316568],[3851196.64409514,-1581614.11046309],[3726196.64409514,-1653782.89411179],[3601196.64409514,-1581614.11046309],[3601196.64409514,-1444110.8577323093],[3601196.64409514,-1437276.54316568]]]},properties:{hex:"ID1594"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3997439.0327278855,-1641518.5953164399],[3976196.64409514,-1653782.89411179],[3851196.64409514,-1581614.11046309],[3851196.64409514,-1437276.54316568],[3976196.64409514,-1365107.75951698],[4007377.1327957413,-1383109.8230617307],[4002748.8458977677,-1389493.9569161644],[4000378.030485058,-1397643.4613454596],[4005525.872271909,-1412047.1353954794],[4000522.1361970403,-1437553.5095681096],[4004822.583417633,-1460501.8096138467],[4005620.4785011136,-1472273.0630142076],[4007118.481926842,-1480139.635007509],[4003085.7257525446,-1494218.6487291588],[4002040.897290077,-1517929.832390841],[4002665.5847648196,-1527718.7772002916],[3998160.675894419,-1539899.504933794],[4003878.0629603826,-1544110.8928647821],[4006038.5486355415,-1557461.4851639352],[4003975.9233100037,-1572508.1985554127],[4001476.960486697,-1580616.4791801218],[3990263.061554422,-1590433.8215250631],[3988722.5621322505,-1594248.0311302373],[3988419.5404996607,-1600022.8042987122],[4001417.0529563176,-1600214.09397168],[4001131.327962368,-1609156.3720143144],[3999687.9418702913,-1616197.1072744292],[3999096.8312072884,-1629440.110102919],[3996650.074647963,-1638044.4687095145],[3997439.0327278855,-1641518.5953164399]]]},properties:{hex:"ID1595"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[4290457.476546052,-1402208.7684308589],[4291887.255951188,-1403034.2519553024],[4295725.491601329,-1407038.4618268043],[4292444.340557038,-1432258.7477120387],[4297873.115813714,-1449232.0168515402],[4301148.504068378,-1462669.372213728],[4298226.740361881,-1467471.3498644922],[4296213.926539564,-1469099.8907423713],[4287739.67921513,-1462106.5296261334],[4282712.881076485,-1460453.907071963],[4276018.579504316,-1449148.176645797],[4281952.142544925,-1409926.271418774],[4284769.650837984,-1404905.4980263913],[4286742.550753133,-1402856.3678616579],[4290457.476546052,-1402208.7684308589]]],[[[4326092.815137643,-1517211.7719496633],[4332413.792299525,-1524715.2005577285],[4313379.332774209,-1521603.8123530021],[4310900.241447412,-1514842.1290503147],[4311156.376092807,-1509863.2685533124],[4318274.5610219175,-1510952.4193581562],[4326092.815137643,-1517211.7719496633]]]]},properties:{hex:"ID1596"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4396342.271609187,-1489573.7869808765],[4399913.87740238,-1506488.0089264836],[4398792.765991773,-1519234.2931778284],[4396347.357201515,-1523279.1895822652],[4392141.10442395,-1520658.406152094],[4384823.805914904,-1510497.610837588],[4370103.319752694,-1500586.9665493122],[4377302.965843499,-1499772.997539635],[4381387.715840488,-1500790.457586243],[4385873.870487766,-1499880.7291786596],[4389097.340242778,-1494302.4454675766],[4389923.075020271,-1490974.4547934937],[4394022.29082496,-1488328.729732509],[4396342.271609187,-1489573.7869808765]]]},properties:{hex:"ID1597"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[4851196.64409514,-1508212.1501025567],[4851196.64409514,-1581614.11046309],[4823492.636954639,-1597609.0264432912],[4824758.652420563,-1594236.074644578],[4826806.71390465,-1582386.3200712528],[4825705.820600146,-1568011.2210395958],[4823018.562589008,-1554351.3258682732],[4817965.304419051,-1537291.2084604516],[4820055.4297735505,-1533510.2295902057],[4829295.286792383,-1535771.6585092966],[4832691.819862976,-1533390.5755541783],[4844375.872686597,-1518288.8603135024],[4851196.64409514,-1508212.1501025567]]],[[[4763512.726951168,-1632238.443629763],[4750160.334219108,-1639947.45116794],[4749955.3128671665,-1633909.7150739832],[4756355.320804556,-1633431.6946993787],[4758362.148065755,-1627133.5025774569],[4762298.9578832425,-1626356.6505228975],[4763512.726951168,-1632238.443629763]]]]},properties:{hex:"ID1598"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4924660.962729648,-1624028.7546025503],[4851196.64409514,-1581614.11046309],[4851196.64409514,-1508212.1501025567],[4863974.73607073,-1489334.3542970028],[4869547.611874433,-1489406.1841723025],[4873861.942227491,-1494769.3115072513],[4874914.602250453,-1502705.643508006],[4877711.331378759,-1508546.6939188498],[4887868.346328674,-1522285.9342637446],[4892677.044596758,-1532541.026953588],[4895987.815189855,-1545355.1255260906],[4900097.341426473,-1557652.8757264374],[4913690.958192748,-1587360.7995186446],[4919606.849905341,-1598791.3660251994],[4924408.567487313,-1610937.5341437405],[4924660.962729648,-1624028.7546025503]]]},properties:{hex:"ID1599"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1310073.379053382,-1172343.936712689],[1351196.64409514,-1148601.40857087],[1476196.64409514,-1220770.19221957],[1476196.64409514,-1365107.75951698],[1364062.2443068011,-1429848.5854201852],[1364350.3247112532,-1416779.958102581],[1371881.2739746775,-1363566.5774593179],[1370865.2600259902,-1348256.1119085937],[1361972.8953335108,-1327066.785799652],[1360572.396296765,-1311894.437546932],[1352187.2742358071,-1296995.6639203206],[1343104.873029487,-1285742.1255548762],[1339166.4031688015,-1265643.3799415247],[1323631.1787236892,-1233909.2995719349],[1319618.452710114,-1212743.8679154695],[1312160.1967358966,-1197554.498511369],[1311284.0133718105,-1178795.9755703511],[1310073.379053382,-1172343.936712689]]]},properties:{hex:"ID1667"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1476196.64409514,-1220770.19221957],[1601196.64409514,-1148601.40857087],[1726196.64409514,-1220770.19221957],[1726196.64409514,-1365107.75951698],[1601196.64409514,-1437276.54316568],[1476196.64409514,-1365107.75951698],[1476196.64409514,-1220770.19221957]]]},properties:{hex:"ID1668"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1726196.64409514,-1220770.19221957],[1851196.64409514,-1148601.40857087],[1976196.64409514,-1220770.19221957],[1976196.64409514,-1365107.75951698],[1851196.64409514,-1437276.54316568],[1726196.64409514,-1365107.75951698],[1726196.64409514,-1220770.19221957]]]},properties:{hex:"ID1669"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1976196.64409514,-1220770.19221957],[2101196.64409514,-1148601.40857087],[2175490.526686694,-1191495.0016842443],[2226196.64409514,-1220770.19221957],[2226196.64409514,-1365107.75951698],[2204754.9085998787,-1377487.1512770613],[2101196.64409514,-1437276.54316568],[1976196.64409514,-1365107.75951698],[1976196.64409514,-1220770.19221957]]]},properties:{hex:"ID1670"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2226196.64409514,-1220770.19221957],[2351196.64409514,-1148601.40857087],[2476196.64409514,-1220770.19221957],[2476196.64409514,-1365107.75951698],[2409922.525433338,-1403371.139766675],[2375820.5038935607,-1423059.951082575],[2351196.64409514,-1437276.54316568],[2229086.1137824967,-1366775.9956187906],[2226196.64409514,-1365107.75951698],[2226196.64409514,-1220770.19221957]]]},properties:{hex:"ID1671"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2476196.64409514,-1220770.19221957],[2601196.64409514,-1148601.40857087],[2726196.64409514,-1220770.19221957],[2726196.64409514,-1365107.75951698],[2601196.64409514,-1437276.54316568],[2476196.64409514,-1365107.75951698],[2476196.64409514,-1220770.19221957]]]},properties:{hex:"ID1672"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2726196.64409514,-1220770.19221957],[2830292.1533667413,-1160670.6219201824],[2851196.64409514,-1148601.40857087],[2976196.64409514,-1220770.19221957],[2976196.64409514,-1365107.75951698],[2851196.64409514,-1437276.54316568],[2808094.349072775,-1412391.421531828],[2726196.64409514,-1365107.75951698],[2726196.64409514,-1220770.19221957]]]},properties:{hex:"ID1673"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2976196.64409514,-1220770.19221957],[3101196.64409514,-1148601.40857087],[3226196.64409514,-1220770.19221957],[3226196.64409514,-1365107.75951698],[3101196.64409514,-1437276.54316568],[2976196.64409514,-1365107.75951698],[2976196.64409514,-1220770.19221957]]]},properties:{hex:"ID1674"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3226196.64409514,-1220770.19221957],[3281436.1712467596,-1188877.6363486764],[3307398.4826550987,-1173888.2888682876],[3351196.64409514,-1148601.40857087],[3476196.64409514,-1220770.19221957],[3476196.64409514,-1365107.75951698],[3439129.90399421,-1386508.2518922328],[3351196.64409514,-1437276.54316568],[3294380.0122360294,-1404473.445467376],[3226196.64409514,-1365107.75951698],[3226196.64409514,-1220770.19221957]]]},properties:{hex:"ID1675"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3476196.64409514,-1220770.19221957],[3601196.64409514,-1148601.40857087],[3726196.64409514,-1220770.19221957],[3726196.64409514,-1365107.75951698],[3601196.64409514,-1437276.54316568],[3476196.64409514,-1365107.75951698],[3476196.64409514,-1220770.19221957]]]},properties:{hex:"ID1676"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3976196.64409514,-1253371.330987475],[3976196.64409514,-1323887.5495734566],[3976196.64409514,-1365107.75951698],[3851196.64409514,-1437276.54316568],[3771619.470279456,-1391332.6404418473],[3726196.64409514,-1365107.75951698],[3726196.64409514,-1220770.19221957],[3851196.64409514,-1148601.40857087],[3947316.661286281,-1204096.326370684],[3950069.738036565,-1214016.5548464367],[3950388.0698006465,-1223537.2087860534],[3943928.702041841,-1234101.3656374682],[3957524.655721593,-1236742.2381785593],[3965077.4058389002,-1245384.6248534163],[3968373.121933095,-1253654.2325838571],[3976196.64409514,-1253371.330987475]]]},properties:{hex:"ID1677"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4007377.1327957413,-1383109.8230617307],[3976196.64409514,-1365107.75951698],[3976196.64409514,-1323887.5495734566],[3976196.64409514,-1253371.330987475],[3978330.3207207653,-1253294.176412969],[3983355.101478185,-1258946.9124423617],[3990813.777782018,-1263615.2847906167],[4007071.2132501523,-1277487.1256781043],[4011262.7621197053,-1284458.3257089138],[4012688.090316706,-1288477.6440891642],[4013612.052860489,-1291105.111054239],[4018053.3903974225,-1303761.569683956],[4026710.85797403,-1315324.9141424021],[4020647.5775930188,-1322041.5822019093],[4013459.2943968615,-1328050.208048263],[4023875.8747197064,-1336097.1040896568],[4015019.123765104,-1348244.1215389024],[4013464.753110209,-1356696.9567617087],[4015279.4204283627,-1360005.9464304498],[4016690.678277413,-1364945.2368218224],[4010464.9437854034,-1378850.580039474],[4007377.1327957413,-1383109.8230617307]]]},properties:{hex:"ID1678"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4291887.255951188,-1403034.2519553024],[4290457.476546052,-1402208.7684308589],[4291004.570400733,-1402113.397032173],[4291887.255951188,-1403034.2519553024]]]},properties:{hex:"ID1679"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1312507.4058941347,-981926.599183369],[1351196.64409514,-1004263.84127346],[1351196.64409514,-1148601.40857087],[1310073.379053382,-1172343.936712689],[1307567.5422307032,-1158989.1554176488],[1300012.9176577914,-1139395.0748142453],[1292722.1487164747,-1116961.64403444],[1292848.2353178978,-1109943.5405200005],[1297797.947318356,-1101482.7988306796],[1302422.9309028038,-1098706.4848114825],[1300802.3099483568,-1102961.0691197375],[1297661.9921977378,-1107996.6627668662],[1298310.746293631,-1111890.3857207508],[1329375.3526214352,-1072550.6549397747],[1331435.9720019568,-1064856.677774375],[1330566.8695857003,-1056248.4634940044],[1330585.141077095,-1045715.8036593939],[1332001.9270262872,-1033462.6441186111],[1312507.4058941347,-981926.599183369]]]},properties:{hex:"ID1752"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1351196.64409514,-1004263.84127346],[1476196.64409514,-932095.05762476],[1601196.64409514,-1004263.84127346],[1601196.64409514,-1148601.40857087],[1476196.64409514,-1220770.19221957],[1351196.64409514,-1148601.40857087],[1351196.64409514,-1004263.84127346]]]},properties:{hex:"ID1753"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1601196.64409514,-1004263.84127346],[1717108.490558416,-937342.1055156242],[1726196.64409514,-932095.05762476],[1823883.5215516465,-988494.6026205654],[1851196.64409514,-1004263.84127346],[1851196.64409514,-1148601.40857087],[1726196.64409514,-1220770.19221957],[1601196.64409514,-1148601.40857087],[1601196.64409514,-1004263.84127346]]]},properties:{hex:"ID1754"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1851196.64409514,-1004263.84127346],[1880866.9163246118,-987133.7016148458],[1929651.2785641688,-958968.0369435945],[1976196.64409514,-932095.05762476],[2101196.64409514,-1004263.84127346],[2101196.64409514,-1148601.40857087],[1976196.64409514,-1220770.19221957],[1851196.64409514,-1148601.40857087],[1851196.64409514,-1004263.84127346]]]},properties:{hex:"ID1755"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2101196.64409514,-1004263.84127346],[2171638.197337264,-963594.3915469861],[2226196.64409514,-932095.05762476],[2351196.64409514,-1004263.84127346],[2351196.64409514,-1148601.40857087],[2226196.64409514,-1220770.19221957],[2175490.526686694,-1191495.0016842443],[2101196.64409514,-1148601.40857087],[2101196.64409514,-1004263.84127346]]]},properties:{hex:"ID1756"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2351196.64409514,-1004263.84127346],[2476196.64409514,-932095.05762476],[2601196.64409514,-1004263.84127346],[2601196.64409514,-1148601.40857087],[2476196.64409514,-1220770.19221957],[2351196.64409514,-1148601.40857087],[2351196.64409514,-1004263.84127346]]]},properties:{hex:"ID1757"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2601196.64409514,-1004263.84127346],[2726196.64409514,-932095.05762476],[2851196.64409514,-1004263.84127346],[2851196.64409514,-1114282.4603753935],[2851196.64409514,-1148601.40857087],[2830292.1533667413,-1160670.6219201824],[2726196.64409514,-1220770.19221957],[2601196.64409514,-1148601.40857087],[2601196.64409514,-1004263.84127346]]]},properties:{hex:"ID1758"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2851196.64409514,-1004263.84127346],[2976196.64409514,-932095.05762476],[3050383.0712270886,-974926.6112996051],[3101196.64409514,-1004263.84127346],[3101196.64409514,-1063097.9478312242],[3101196.64409514,-1148601.40857087],[2976196.64409514,-1220770.19221957],[2851196.64409514,-1148601.40857087],[2851196.64409514,-1114282.4603753935],[2851196.64409514,-1004263.84127346]]]},properties:{hex:"ID1759"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3101196.64409514,-1004263.84127346],[3226196.64409514,-932095.05762476],[3351196.64409514,-1004263.84127346],[3351196.64409514,-1148601.40857087],[3307398.4826550987,-1173888.2888682876],[3281436.1712467596,-1188877.6363486764],[3226196.64409514,-1220770.19221957],[3101196.64409514,-1148601.40857087],[3101196.64409514,-1063097.9478312242],[3101196.64409514,-1004263.84127346]]]},properties:{hex:"ID1760"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3351196.64409514,-1004263.84127346],[3476196.64409514,-932095.05762476],[3601196.64409514,-1004263.84127346],[3601196.64409514,-1148601.40857087],[3476196.64409514,-1220770.19221957],[3351196.64409514,-1148601.40857087],[3351196.64409514,-1004263.84127346]]]},properties:{hex:"ID1761"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3601196.64409514,-1004263.84127346],[3726196.64409514,-932095.05762476],[3851196.64409514,-1004263.84127346],[3851196.64409514,-1148601.40857087],[3726196.64409514,-1220770.19221957],[3601196.64409514,-1148601.40857087],[3601196.64409514,-1004263.84127346]]]},properties:{hex:"ID1762"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[3947316.661286281,-1204096.326370684],[3851196.64409514,-1148601.40857087],[3851196.64409514,-1004263.84127346],[3925153.0934832883,-961565.0653109079],[3928951.680312288,-964864.1141526006],[3929037.909364316,-989346.2600717208],[3917584.34964668,-1017840.8353308273],[3913827.113246216,-1031153.7689310227],[3912753.3157194057,-1042589.4988340636],[3918289.633134565,-1076685.965087697],[3928415.2405178696,-1094043.0914067344],[3927297.524714402,-1099475.686605613],[3924186.053523381,-1104030.7002231814],[3941397.783786042,-1134733.3210059684],[3938316.6142733935,-1161427.6636602592],[3944191.371722065,-1182206.856803038],[3946237.6477542426,-1200208.290642967],[3947316.661286281,-1204096.326370684]]],[[[3956169.8971892633,-985147.9239714453],[3950702.0174343796,-986759.9084365973],[3948676.3704384877,-985196.0431968583],[3945616.2855410096,-980059.216715027],[3951576.827024107,-975680.1250924146],[3957558.708381216,-967174.1699113516],[3971102.4791750754,-954696.9918429486],[3975907.592032698,-946466.479525705],[3977605.446308473,-944709.6101030755],[3976214.747143308,-954432.2755003619],[3967893.3775878823,-975692.1557619213],[3961589.9242263385,-977075.6754854937],[3956169.8971892633,-985147.9239714453]]]]},properties:{hex:"ID1763"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1237142.0275068802,-781438.1702681965],[1336110.3548165448,-724298.779854719],[1351196.64409514,-715588.70667865],[1365966.7511242821,-724116.2319478844],[1476196.64409514,-787757.49032735],[1476196.64409514,-932095.05762476],[1351196.64409514,-1004263.84127346],[1312507.4058941347,-981926.599183369],[1304533.0604682788,-960845.485089305],[1282758.7824617664,-893269.2774690302],[1279357.52750279,-859114.0417241225],[1249795.508512094,-814172.013914619],[1238262.0039767346,-784950.4598052861],[1237142.0275068802,-781438.1702681965]]]},properties:{hex:"ID1833"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1476196.64409514,-787757.49032735],[1585572.0190421797,-724609.5881589632],[1601196.64409514,-715588.70667865],[1617023.5111654783,-724726.3526421378],[1659334.3346807272,-749154.5179883004],[1726196.64409514,-787757.49032735],[1726196.64409514,-932095.05762476],[1717108.490558416,-937342.1055156242],[1601196.64409514,-1004263.84127346],[1476196.64409514,-932095.05762476],[1476196.64409514,-787757.49032735]]]},properties:{hex:"ID1834"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1726196.64409514,-787757.49032735],[1851196.64409514,-715588.70667865],[1976196.64409514,-787757.49032735],[1976196.64409514,-864922.7232845965],[1976196.64409514,-932095.05762476],[1929651.2785641688,-958968.0369435945],[1880866.9163246118,-987133.7016148458],[1851196.64409514,-1004263.84127346],[1823883.5215516465,-988494.6026205654],[1726196.64409514,-932095.05762476],[1726196.64409514,-787757.49032735]]]},properties:{hex:"ID1835"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1976196.64409514,-787757.49032735],[2101196.64409514,-715588.70667865],[2226196.64409514,-787757.49032735],[2226196.64409514,-932095.05762476],[2171638.197337264,-963594.3915469861],[2101196.64409514,-1004263.84127346],[1976196.64409514,-932095.05762476],[1976196.64409514,-864922.7232845965],[1976196.64409514,-787757.49032735]]]},properties:{hex:"ID1836"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2226196.64409514,-787757.49032735],[2351196.64409514,-715588.70667865],[2476196.64409514,-787757.49032735],[2476196.64409514,-932095.05762476],[2351196.64409514,-1004263.84127346],[2226196.64409514,-932095.05762476],[2226196.64409514,-787757.49032735]]]},properties:{hex:"ID1837"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2476196.64409514,-787757.49032735],[2601196.64409514,-715588.70667865],[2726196.64409514,-787757.49032735],[2726196.64409514,-932095.05762476],[2601196.64409514,-1004263.84127346],[2476196.64409514,-932095.05762476],[2476196.64409514,-787757.49032735]]]},properties:{hex:"ID1838"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2726196.64409514,-787757.49032735],[2851196.64409514,-715588.70667865],[2948128.6266263216,-771552.4128861093],[2976196.64409514,-787757.49032735],[2976196.64409514,-828692.2038654446],[2976196.64409514,-932095.05762476],[2851196.64409514,-1004263.84127346],[2726196.64409514,-932095.05762476],[2726196.64409514,-787757.49032735]]]},properties:{hex:"ID1839"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2976196.64409514,-787757.49032735],[3101196.64409514,-715588.70667865],[3226196.64409514,-787757.49032735],[3226196.64409514,-932095.05762476],[3101196.64409514,-1004263.84127346],[3050383.0712270886,-974926.6112996051],[2976196.64409514,-932095.05762476],[2976196.64409514,-828692.2038654446],[2976196.64409514,-787757.49032735]]]},properties:{hex:"ID1840"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3226196.64409514,-787757.49032735],[3351196.64409514,-715588.70667865],[3476196.64409514,-787757.49032735],[3476196.64409514,-932095.05762476],[3351196.64409514,-1004263.84127346],[3226196.64409514,-932095.05762476],[3226196.64409514,-787757.49032735]]]},properties:{hex:"ID1841"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3476196.64409514,-787757.49032735],[3601196.64409514,-715588.70667865],[3726196.64409514,-787757.49032735],[3726196.64409514,-932095.05762476],[3601196.64409514,-1004263.84127346],[3476196.64409514,-932095.05762476],[3476196.64409514,-787757.49032735]]]},properties:{hex:"ID1842"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[3925153.0934832883,-961565.0653109079],[3851196.64409514,-1004263.84127346],[3726196.64409514,-932095.05762476],[3726196.64409514,-787757.49032735],[3851196.64409514,-715588.70667865],[3877502.5797796547,-730776.4457273898],[3875645.3986008824,-750000.7076378356],[3880092.1031205417,-766627.13397278],[3881384.2435755855,-782215.9422790321],[3891528.257680007,-797490.1119620104],[3899896.463433878,-802946.5481056975],[3905424.2222830467,-809932.4451243023],[3915065.604071915,-825878.4188401419],[3920294.442162848,-841870.945362722],[3938436.255842189,-849722.0935693658],[3945039.496610793,-867650.5759862728],[3941833.029178343,-879990.9663272408],[3932829.4063890995,-890211.6408374334],[3924098.424012447,-906775.0730771892],[3916681.085883303,-928523.6993931914],[3915005.855319246,-961771.9461340166],[3919572.603870715,-956718.4450752222],[3925153.0934832883,-961565.0653109079]]],[[[3915425.376539066,-752671.1826448527],[3946170.1281153825,-770421.6732436093],[3950912.07541147,-789142.4959480299],[3949737.005694973,-794057.161163872],[3944228.5462587774,-797068.5253982892],[3941401.2135054083,-797321.4774672454],[3938210.1475613443,-793129.6498201755],[3936181.9064022903,-784263.8230758561],[3932006.1555349757,-786371.9092560596],[3925427.1061877836,-775783.0236342831],[3918532.607147753,-775277.0532489846],[3912899.1351882042,-762639.348367034],[3915425.376539066,-752671.1826448527]]]]},properties:{hex:"ID1843"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1158126.2893009211,-538382.7933968119],[1226196.64409514,-499082.35573254],[1351196.64409514,-571251.13938124],[1351196.64409514,-591195.4360491377],[1351196.64409514,-715588.70667865],[1336110.3548165448,-724298.779854719],[1237142.0275068802,-781438.1702681965],[1231727.6781558036,-764458.5612426553],[1226726.7967631966,-756687.6160318288],[1228693.0579141066,-752771.8902532989],[1236478.1764935728,-751747.7627117555],[1253825.8897030065,-747012.6002959154],[1277568.9875846873,-741831.4864244158],[1299598.0454175537,-729950.4961312257],[1305493.6982911637,-724672.4791278831],[1299057.0427588702,-721129.6135805316],[1284797.5142358162,-723346.9253467214],[1277847.1987052688,-726263.130758738],[1266647.294757584,-736517.6735770928],[1249993.3870442172,-741867.634261554],[1243843.7017091918,-741409.7611079243],[1239747.2525744194,-739662.602586153],[1230215.853001936,-728432.1784205157],[1222881.46456038,-717574.6276200578],[1220272.9464474272,-711573.1714946257],[1218844.7514997132,-708271.0815027357],[1214622.1865011065,-696026.3201275564],[1217201.8038108947,-684419.5714635174],[1219935.6575566137,-675729.1120027031],[1217175.5534662125,-658021.5466311413],[1210671.562128922,-642265.423785222],[1203801.2672172338,-622264.1196064502],[1201678.4842428875,-618454.1290979864],[1200141.329055288,-615705.1058368143],[1196578.930190908,-612292.8914036676],[1189323.5874629642,-601344.500273294],[1182185.8574167883,-587730.5881402852],[1180295.1994653377,-581520.2435221112],[1178283.681695333,-577986.9026764464],[1178065.1409168572,-564311.2702406882],[1167245.0972400887,-548065.8853255407],[1158126.2893009211,-538382.7933968119]]]},properties:{hex:"ID1911"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1351196.64409514,-571251.13938124],[1371332.5681499704,-559625.6582078025],[1385683.2088059345,-551340.3119620383],[1476196.64409514,-499082.35573254],[1530625.256706237,-530506.7298751734],[1601196.64409514,-571251.13938124],[1601196.64409514,-715588.70667865],[1585572.0190421797,-724609.5881589632],[1476196.64409514,-787757.49032735],[1365966.7511242821,-724116.2319478844],[1351196.64409514,-715588.70667865],[1351196.64409514,-591195.4360491377],[1351196.64409514,-571251.13938124]]]},properties:{hex:"ID1912"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1601196.64409514,-571251.13938124],[1726196.64409514,-499082.35573254],[1851196.64409514,-571251.13938124],[1851196.64409514,-715588.70667865],[1726196.64409514,-787757.49032735],[1659334.3346807272,-749154.5179883004],[1617023.5111654783,-724726.3526421378],[1601196.64409514,-715588.70667865],[1601196.64409514,-571251.13938124]]]},properties:{hex:"ID1913"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1851196.64409514,-571251.13938124],[1976196.64409514,-499082.35573254],[2101196.64409514,-571251.13938124],[2101196.64409514,-715588.70667865],[1976196.64409514,-787757.49032735],[1851196.64409514,-715588.70667865],[1851196.64409514,-571251.13938124]]]},properties:{hex:"ID1914"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2101196.64409514,-571251.13938124],[2226196.64409514,-499082.35573254],[2351196.64409514,-571251.13938124],[2351196.64409514,-715588.70667865],[2226196.64409514,-787757.49032735],[2101196.64409514,-715588.70667865],[2101196.64409514,-571251.13938124]]]},properties:{hex:"ID1915"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2351196.64409514,-571251.13938124],[2476196.64409514,-499082.35573254],[2601196.64409514,-571251.13938124],[2601196.64409514,-715588.70667865],[2476196.64409514,-787757.49032735],[2351196.64409514,-715588.70667865],[2351196.64409514,-571251.13938124]]]},properties:{hex:"ID1916"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2601196.64409514,-571251.13938124],[2726196.64409514,-499082.35573254],[2851196.64409514,-571251.13938124],[2851196.64409514,-715588.70667865],[2726196.64409514,-787757.49032735],[2601196.64409514,-715588.70667865],[2601196.64409514,-571251.13938124]]]},properties:{hex:"ID1917"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2851196.64409514,-571251.13938124],[2937623.8022981957,-521352.39632741373],[2976196.64409514,-499082.35573254],[3007548.2156831436,-517183.194028391],[3101196.64409514,-571251.13938124],[3101196.64409514,-715588.70667865],[2976196.64409514,-787757.49032735],[2948128.6266263216,-771552.4128861093],[2851196.64409514,-715588.70667865],[2851196.64409514,-571251.13938124]]]},properties:{hex:"ID1918"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3101196.64409514,-571251.13938124],[3226196.64409514,-499082.35573254],[3351196.64409514,-571251.13938124],[3351196.64409514,-715588.70667865],[3226196.64409514,-787757.49032735],[3101196.64409514,-715588.70667865],[3101196.64409514,-571251.13938124]]]},properties:{hex:"ID1919"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3351196.64409514,-571251.13938124],[3476196.64409514,-499082.35573254],[3601196.64409514,-571251.13938124],[3601196.64409514,-715588.70667865],[3476196.64409514,-787757.49032735],[3351196.64409514,-715588.70667865],[3351196.64409514,-571251.13938124]]]},properties:{hex:"ID1920"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3601196.64409514,-571251.13938124],[3726196.64409514,-499082.35573254],[3851196.64409514,-571251.13938124],[3851196.64409514,-715588.70667865],[3726196.64409514,-787757.49032735],[3601196.64409514,-715588.70667865],[3601196.64409514,-571251.13938124]]]},properties:{hex:"ID1921"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[3877502.5797796547,-730776.4457273898],[3851196.64409514,-715588.70667865],[3851196.64409514,-571251.13938124],[3888518.3941558725,-549703.4169370489],[3972017.5948592187,-501495.1309338553],[3971347.233984994,-502809.4539549236],[3968297.8896913505,-509142.4677249097],[3966102.6850404823,-513304.077489229],[3950429.428977346,-553517.320032832],[3938532.4789799824,-571679.8123573584],[3929642.9964640657,-569593.4897353625],[3923509.0452315565,-576624.2001180763],[3922781.320796815,-579940.4973032491],[3920494.8347774264,-590323.2049933622],[3911899.344433062,-615512.190582509],[3911135.6594455,-626001.7012366917],[3907683.3561392864,-638347.2986334044],[3904462.541034031,-646508.969411347],[3895324.5883724666,-681936.6232961685],[3888171.29296549,-695194.7077195457],[3877939.7577225068,-726251.0804205923],[3877502.5797796547,-730776.4457273898]]],[[[3946170.1281153825,-770421.6732436093],[3915425.376539066,-752671.1826448527],[3915692.988060422,-751615.2281165449],[3914982.994280138,-732842.4940978679],[3922775.5700625493,-723226.4199733553],[3927532.8038438032,-707041.8211665639],[3931969.9263736396,-718092.8163571082],[3932463.1283347337,-735324.7548229694],[3938223.4473473392,-755591.2217778595],[3943443.323676065,-761856.2375138481],[3944262.966126732,-762892.3526441177],[3946170.1281153825,-770421.6732436093]]],[[[3986346.88614907,-606336.4569908426],[3986755.9087819774,-612558.1538525833],[3985045.355597203,-618417.9579715492],[3984800.6987675917,-637081.4267317001],[3983813.1733513228,-649462.5209489237],[3977547.5887802048,-666616.3651281898],[3972691.2282237816,-672715.6848636563],[3968582.0459377333,-670943.7678115893],[3965258.5015198397,-668123.1318360866],[3962747.162697176,-663421.9813427898],[3969173.4250870966,-631957.5797039801],[3967110.6866449136,-608916.7950714048],[3977776.367546767,-611123.3212154177],[3986346.88614907,-606336.4569908426]]]]},properties:{hex:"ID1922"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1002134.1041412255,-339769.7888954295],[1101196.64409514,-282576.00478643],[1161825.9614917345,-317580.3575061403],[1226196.64409514,-354744.78843514],[1226196.64409514,-499082.35573254],[1158126.2893009211,-538382.7933968119],[1140029.7380856606,-519166.40347180236],[1137150.7979664723,-510553.8038464172],[1113889.2585324114,-484086.96361968946],[1104139.3986866141,-472987.9637821548],[1095782.5412748323,-452682.8860356881],[1085974.3509894228,-440231.29012856964],[1065285.50684091,-420056.6723925678],[1059831.7396749628,-405226.525560312],[1036185.9631229704,-372486.81002184044],[1002134.1041412255,-339769.7888954295]]]},properties:{hex:"ID1989"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1226196.64409514,-354744.78843514],[1329093.9440947017,-295337.0045815018],[1351196.64409514,-282576.00478643],[1358674.1153525508,-286893.1248297542],[1476196.64409514,-354744.78843514],[1476196.64409514,-499082.35573254],[1385683.2088059345,-551340.3119620383],[1371332.5681499704,-559625.6582078025],[1351196.64409514,-571251.13938124],[1226196.64409514,-499082.35573254],[1226196.64409514,-354744.78843514]]]},properties:{hex:"ID1990"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1476196.64409514,-354744.78843514],[1601196.64409514,-282576.00478643],[1622484.4681723525,-294866.53574787115],[1726196.64409514,-354744.78843514],[1726196.64409514,-499082.35573254],[1601196.64409514,-571251.13938124],[1530625.256706237,-530506.7298751734],[1476196.64409514,-499082.35573254],[1476196.64409514,-354744.78843514]]]},properties:{hex:"ID1991"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1726196.64409514,-354744.78843514],[1851196.64409514,-282576.00478643],[1976196.64409514,-354744.78843514],[1976196.64409514,-499082.35573254],[1851196.64409514,-571251.13938124],[1726196.64409514,-499082.35573254],[1726196.64409514,-354744.78843514]]]},properties:{hex:"ID1992"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1976196.64409514,-354744.78843514],[2101196.64409514,-282576.00478643],[2226196.64409514,-354744.78843514],[2226196.64409514,-499082.35573254],[2101196.64409514,-571251.13938124],[1976196.64409514,-499082.35573254],[1976196.64409514,-354744.78843514]]]},properties:{hex:"ID1993"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2226196.64409514,-354744.78843514],[2351196.64409514,-282576.00478643],[2476196.64409514,-354744.78843514],[2476196.64409514,-499082.35573254],[2351196.64409514,-571251.13938124],[2226196.64409514,-499082.35573254],[2226196.64409514,-354744.78843514]]]},properties:{hex:"ID1994"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2476196.64409514,-354744.78843514],[2601196.64409514,-282576.00478643],[2726196.64409514,-354744.78843514],[2726196.64409514,-499082.35573254],[2601196.64409514,-571251.13938124],[2476196.64409514,-499082.35573254],[2476196.64409514,-354744.78843514]]]},properties:{hex:"ID1995"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2726196.64409514,-354744.78843514],[2851196.64409514,-282576.00478643],[2891350.655037755,-305758.9338131943],[2920968.2414151686,-322858.6552809425],[2934292.8985388605,-330551.6496581661],[2961246.098000011,-346113.0866225845],[2976196.64409514,-354744.78843514],[2976196.64409514,-499082.35573254],[2937623.8022981957,-521352.39632741373],[2851196.64409514,-571251.13938124],[2726196.64409514,-499082.35573254],[2726196.64409514,-354744.78843514]]]},properties:{hex:"ID1996"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2976196.64409514,-354744.78843514],[3054585.3522860818,-309487.0466596684],[3084321.6362495455,-292318.7951086621],[3085488.0647195936,-291645.3573174892],[3101196.64409514,-282576.00478643],[3226196.64409514,-354744.78843514],[3226196.64409514,-499082.35573254],[3101196.64409514,-571251.13938124],[3007548.2156831436,-517183.194028391],[2976196.64409514,-499082.35573254],[2976196.64409514,-354744.78843514]]]},properties:{hex:"ID1997"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3226196.64409514,-354744.78843514],[3351196.64409514,-282576.00478643],[3476196.64409514,-354744.78843514],[3476196.64409514,-499082.35573254],[3351196.64409514,-571251.13938124],[3226196.64409514,-499082.35573254],[3226196.64409514,-354744.78843514]]]},properties:{hex:"ID1998"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3476196.64409514,-354744.78843514],[3601196.64409514,-282576.00478643],[3726196.64409514,-354744.78843514],[3726196.64409514,-499082.35573254],[3601196.64409514,-571251.13938124],[3476196.64409514,-499082.35573254],[3476196.64409514,-354744.78843514]]]},properties:{hex:"ID1999"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3972017.5948592187,-501495.1309338553],[3888518.3941558725,-549703.4169370489],[3851196.64409514,-571251.13938124],[3726196.64409514,-499082.35573254],[3726196.64409514,-354744.78843514],[3732816.4887564695,-350922.8193379277],[3851196.64409514,-282576.00478643],[3976196.64409514,-354744.78843514],[3976196.64409514,-493136.0068335004],[3976047.949870854,-493593.13578684925],[3972017.5948592187,-501495.1309338553]]]},properties:{hex:"ID2000"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3976196.64409514,-493136.0068335004],[3976196.64409514,-354744.78843514],[4088911.663815635,-289668.7414577879],[4088210.008198428,-295772.9183331615],[4070999.5505979825,-313950.95215867035],[4046964.4497036906,-315954.59214104246],[4034203.0297886515,-324970.851210382],[4028468.3550891904,-332357.5156493701],[4023921.8823616626,-348506.3048058929],[4024975.80907627,-373247.11184049747],[4017945.9011569694,-392290.31521578337],[4016487.2758623525,-401835.64676837635],[4003850.111236667,-414204.3378230563],[3998120.8625797546,-425546.906871593],[3993818.831083317,-437082.11133481294],[3990170.705146416,-442137.6733370418],[3985408.882478205,-467993.26774597575],[3979266.0170314484,-483688.8551504696],[3977578.316666676,-488888.3466467618],[3976196.64409514,-493136.0068335004]]]},properties:{hex:"ID2001"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[889071.204985715,-116371.5495634117],[976196.64409514,-66069.65384032],[1101196.64409514,-138238.43748903],[1101196.64409514,-282576.00478643],[1002134.1041412255,-339769.7888954295],[1002132.4298368779,-339768.18022405735],[977538.2881216977,-311367.9321938962],[973815.2268899262,-305067.22837861103],[977979.4251436675,-305839.7334798421],[1001792.2782605939,-319998.05288178124],[1005055.666247624,-318416.8834146094],[1007826.4602929851,-315242.4561461254],[997545.2525365436,-307819.271426934],[987726.5337380215,-301977.19409634866],[978505.6013316044,-298331.89096709754],[969260.471848632,-298645.72620840155],[964097.0443189134,-292646.6062213752],[960763.0743107673,-283508.9595086973],[959086.6778379873,-275698.9646342739],[955023.5433506563,-267526.69957071956],[941954.9995956472,-250686.8206480978],[938793.921110222,-244180.081972975],[931646.842410295,-235282.98535967385],[936013.6592187692,-234124.0585235358],[950049.7447547823,-242610.72679250978],[951311.6044452068,-239230.5617082314],[950112.1893070786,-234244.78018124748],[936005.3529085325,-226180.51680236],[928335.8311605221,-225649.3337894626],[926579.2463049844,-219987.3757751578],[927642.3906720604,-213431.99258287236],[917590.5682862129,-188887.93665799257],[907137.6298005702,-170512.51993715402],[905499.917926288,-161831.73033364615],[933726.8531254481,-201781.83069103517],[937512.017110417,-202469.98089999368],[942493.4148910426,-202095.72385947936],[954226.2545272622,-197616.69551796588],[952007.4459533024,-192280.45516775682],[946736.0814589468,-186557.83423771293],[941602.8672064135,-189189.7628254366],[934937.9454990393,-189733.04959499036],[931449.7864363738,-187342.58462623524],[929892.8655498872,-183225.65362891817],[936595.4644141512,-163823.85319131587],[933706.8193608945,-164801.80259921745],[931576.7033200804,-168266.8728635624],[927913.6932633371,-169908.85201074442],[922265.418176246,-170923.01385616502],[908340.1479051381,-160527.7927127922],[896084.6281939639,-132480.5838301738],[892833.9584604608,-126733.39810419892],[889558.7238931842,-116977.59866673441],[889071.204985715,-116371.5495634117]]]},properties:{hex:"ID2067"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1101196.64409514,-138238.43748903],[1226196.64409514,-66069.65384032],[1351196.64409514,-138238.43748903],[1351196.64409514,-282576.00478643],[1329093.9440947017,-295337.0045815018],[1226196.64409514,-354744.78843514],[1161825.9614917345,-317580.3575061403],[1101196.64409514,-282576.00478643],[1101196.64409514,-138238.43748903]]]},properties:{hex:"ID2068"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1351196.64409514,-138238.43748903],[1450511.9895876793,-80898.69603424642],[1476196.64409514,-66069.65384032],[1601196.64409514,-138238.43748903],[1601196.64409514,-282576.00478643],[1476196.64409514,-354744.78843514],[1358674.1153525508,-286893.1248297542],[1351196.64409514,-282576.00478643],[1351196.64409514,-138238.43748903]]]},properties:{hex:"ID2069"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1601196.64409514,-138238.43748903],[1726196.64409514,-66069.65384032],[1764056.1092599193,-87927.82624458265],[1851196.64409514,-138238.43748903],[1851196.64409514,-282576.00478643],[1726196.64409514,-354744.78843514],[1622484.4681723525,-294866.53574787115],[1601196.64409514,-282576.00478643],[1601196.64409514,-138238.43748903]]]},properties:{hex:"ID2070"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1851196.64409514,-138238.43748903],[1976196.64409514,-66069.65384032],[2101196.64409514,-138238.43748903],[2101196.64409514,-282576.00478643],[1976196.64409514,-354744.78843514],[1851196.64409514,-282576.00478643],[1851196.64409514,-138238.43748903]]]},properties:{hex:"ID2071"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2101196.64409514,-138238.43748903],[2226196.64409514,-66069.65384032],[2351196.64409514,-138238.43748903],[2351196.64409514,-282576.00478643],[2226196.64409514,-354744.78843514],[2101196.64409514,-282576.00478643],[2101196.64409514,-138238.43748903]]]},properties:{hex:"ID2072"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2351196.64409514,-138238.43748903],[2476196.64409514,-66069.65384032],[2601196.64409514,-138238.43748903],[2601196.64409514,-282576.00478643],[2476196.64409514,-354744.78843514],[2351196.64409514,-282576.00478643],[2351196.64409514,-138238.43748903]]]},properties:{hex:"ID2073"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2601196.64409514,-138238.43748903],[2726196.64409514,-66069.65384032],[2851196.64409514,-138238.43748903],[2851196.64409514,-282576.00478643],[2726196.64409514,-354744.78843514],[2601196.64409514,-282576.00478643],[2601196.64409514,-138238.43748903]]]},properties:{hex:"ID2074"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2851196.64409514,-138238.43748903],[2970666.2007088843,-69262.65681811316],[2976196.64409514,-66069.65384032],[3079378.8972512265,-125641.95547558414],[3101196.64409514,-138238.43748903],[3101196.64409514,-282576.00478643],[3085488.0647195936,-291645.3573174892],[3084321.6362495455,-292318.7951086621],[3054585.3522860818,-309487.0466596684],[2976196.64409514,-354744.78843514],[2961246.098000011,-346113.0866225845],[2934292.8985388605,-330551.6496581661],[2920968.2414151686,-322858.6552809425],[2891350.655037755,-305758.9338131943],[2851196.64409514,-282576.00478643],[2851196.64409514,-138238.43748903]]]},properties:{hex:"ID2075"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3101196.64409514,-138238.43748903],[3126038.448334315,-123896.01512438498],[3226196.64409514,-66069.65384032],[3326354.839855969,-123896.01512438712],[3351196.64409514,-138238.43748903],[3351196.64409514,-282576.00478643],[3226196.64409514,-354744.78843514],[3101196.64409514,-282576.00478643],[3101196.64409514,-138238.43748903]]]},properties:{hex:"ID2076"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3351196.64409514,-138238.43748903],[3376038.448334315,-123896.01512438498],[3397422.9939069315,-111549.64198153591],[3476196.64409514,-66069.65384032],[3601196.64409514,-138238.43748903],[3601196.64409514,-259386.4214629647],[3601196.64409514,-282576.00478643],[3476196.64409514,-354744.78843514],[3351196.64409514,-282576.00478643],[3351196.64409514,-138238.43748903]]]},properties:{hex:"ID2077"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3601196.64409514,-138238.43748903],[3726196.64409514,-66069.65384032],[3851196.64409514,-138238.43748903],[3851196.64409514,-282576.00478643],[3732816.4887564695,-350922.8193379277],[3726196.64409514,-354744.78843514],[3601196.64409514,-282576.00478643],[3601196.64409514,-259386.4214629647],[3601196.64409514,-138238.43748903]]]},properties:{hex:"ID2078"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4088911.663815635,-289668.7414577879],[3976196.64409514,-354744.78843514],[3851196.64409514,-282576.00478643],[3851196.64409514,-138238.43748903],[3976196.64409514,-66069.65384032],[4101196.64409514,-138238.43748903],[4101196.64409514,-253476.80989173354],[4099167.17306702,-252521.73053268835],[4096506.3599377223,-250179.80493571196],[4097937.9895237964,-264267.4122681831],[4099497.460544917,-271220.5322509124],[4096950.1236622203,-280636.0553892913],[4089006.430116258,-288844.30530044454],[4088911.663815635,-289668.7414577879]]]},properties:{hex:"ID2079"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[4101196.64409514,-253476.80989173354],[4101196.64409514,-138238.43748903],[4119259.369602485,-127809.91805506499],[4226196.64409514,-66069.65384032],[4241599.353010646,-74962.41197893543],[4231082.454053974,-91247.49585932403],[4219713.712328235,-105857.33291826778],[4206965.194327932,-120310.035123329],[4201526.313973598,-130512.5386254348],[4197636.73859705,-142260.38111445226],[4193369.8981563165,-148792.26236429295],[4181715.0171578154,-176814.78443595662],[4171500.0225680633,-195165.89356479308],[4161399.045719767,-209604.96839652638],[4146552.090692554,-230828.34724504626],[4134470.4610739015,-240473.98202189527],[4118319.2345111985,-245085.47710458274],[4113506.7465922516,-244204.22586301528],[4107213.9298839313,-241162.08718922758],[4104666.1424864507,-246256.452531188],[4102707.082647641,-254187.6299352875],[4101196.64409514,-253476.80989173354]]],[[[4106776.673539207,-266850.70101723314],[4103044.2714529694,-267949.19819248107],[4105056.6796236085,-260839.10174297506],[4116151.019712674,-251785.35300137763],[4120595.9673035173,-253825.4783484677],[4121430.087823014,-255901.8106509409],[4121160.9821523638,-257784.98847552572],[4119267.985794857,-259644.01614433117],[4106776.673539207,-266850.70101723314]]]]},properties:{hex:"ID2080"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[667478.7128957286,14918.280215198869],[657144.0158138814,5856.226335512558],[653424.6806337611,8198.716526268026],[651143.648482227,14513.778300533524],[648254.0669310809,28109.859375466043],[649192.016926832,34636.20687483245],[653877.8437726075,42074.17648082118],[664053.8361897933,49487.97915405126],[670170.6452904725,50001.14880178216],[676477.2744068761,40262.98410009785],[676499.8213987544,30102.177440610576],[667478.7128957286,14918.280215198869]]]},properties:{hex:"ID2141"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[976196.64409514,10341.408471319257],[976196.64409514,-66069.65384032],[889071.204985715,-116371.5495634117],[886324.4104760701,-112956.9284603578],[872222.5297720812,-73075.55157034153],[877642.1801735834,-76033.78882418353],[884061.9863384498,-87588.97525907558],[896591.5502023457,-85162.03088951335],[901491.0857901681,-78472.82144166813],[905767.7863577374,-78726.38403590859],[910143.915231667,-77192.93347583666],[915659.2598242381,-70890.075186883],[931728.0387039785,-43432.57007735052],[935986.2638931079,-7202.554496888115],[934605.364064384,14320.583349780965],[932250.2797913023,35674.62565973023],[937561.717780916,42484.71327559093],[939658.2836344328,37986.9175840321],[940698.7345998908,30404.043736033716],[943206.0872412322,24783.29007092136],[948923.2007738247,19754.18957918904],[959562.3571465844,18413.900409007267],[976006.4902837037,10504.982306862252],[976196.64409514,10341.408471319257]]],[[[964652.1002485288,84933.15895459386],[976196.64409514,78267.91345708],[976196.64409514,25819.496729085204],[956767.0807606839,36592.297830115946],[949109.5441210443,44748.701956352146],[941955.4724931861,60179.99758563683],[934530.8413346795,68263.87777768703],[935043.5562104584,75526.66279311688],[951606.8472282881,82203.80994738489],[955982.3550403805,81443.12366661672],[957761.0704286258,73467.97108305966],[962216.959786559,70195.79347049125],[963909.2141759065,71282.49517221177],[964637.2082862108,78098.51468456215],[964652.1002485288,84933.15895459386]]]]},properties:{hex:"ID2142"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[976196.64409514,25819.496729085204],[976196.64409514,78267.91345708],[1055289.2503203205,123932.0509521013],[1101196.64409514,150436.69710579],[1135909.974452506,130394.94647949448],[1226196.64409514,78267.91345708],[1226196.64409514,-66069.65384032],[1101196.64409514,-138238.43748903],[976196.64409514,-66069.65384032],[976196.64409514,10341.408471319257],[981859.8238867181,5469.836174763209],[983453.8898072753,15528.051722828059],[1002370.7694296726,24107.10874928294],[996653.9935789962,27186.14797985464],[979840.3938542391,23799.20472658344],[976196.64409514,25819.496729085204]]]},properties:{hex:"ID2143"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1226196.64409514,78267.91345708],[1351196.64409514,150436.69710579],[1444265.6348002048,96703.29026900901],[1476196.64409514,78267.91345708],[1476196.64409514,-66069.65384032],[1450511.9895876793,-80898.69603424642],[1351196.64409514,-138238.43748903],[1226196.64409514,-66069.65384032],[1226196.64409514,78267.91345708]]]},properties:{hex:"ID2144"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1476196.64409514,78267.91345708],[1601196.64409514,150436.69710579],[1726196.64409514,78267.91345708],[1726196.64409514,-66069.65384032],[1601196.64409514,-138238.43748903],[1476196.64409514,-66069.65384032],[1476196.64409514,78267.91345708]]]},properties:{hex:"ID2145"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1726196.64409514,78267.91345708],[1792968.7911429373,116818.83052949866],[1851196.64409514,150436.69710579],[1976196.64409514,78267.91345708],[1976196.64409514,-66069.65384032],[1851196.64409514,-138238.43748903],[1764056.1092599193,-87927.82624458265],[1726196.64409514,-66069.65384032],[1726196.64409514,78267.91345708]]]},properties:{hex:"ID2146"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1976196.64409514,78267.91345708],[2101196.64409514,150436.69710579],[2226196.64409514,78267.91345708],[2226196.64409514,-66069.65384032],[2101196.64409514,-138238.43748903],[1976196.64409514,-66069.65384032],[1976196.64409514,78267.91345708]]]},properties:{hex:"ID2147"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2226196.64409514,78267.91345708],[2351196.64409514,150436.69710579],[2476196.64409514,78267.91345708],[2476196.64409514,-66069.65384032],[2351196.64409514,-138238.43748903],[2226196.64409514,-66069.65384032],[2226196.64409514,78267.91345708]]]},properties:{hex:"ID2148"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2476196.64409514,78267.91345708],[2601196.64409514,150436.69710579],[2726196.64409514,78267.91345708],[2726196.64409514,-66069.65384032],[2601196.64409514,-138238.43748903],[2476196.64409514,-66069.65384032],[2476196.64409514,78267.91345708]]]},properties:{hex:"ID2149"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2726196.64409514,78267.91345708],[2851196.64409514,150436.69710579],[2976196.64409514,78267.91345708],[2976196.64409514,-8433.004640126055],[2976196.64409514,-66069.65384032],[2970666.2007088843,-69262.65681811316],[2851196.64409514,-138238.43748903],[2726196.64409514,-66069.65384032],[2726196.64409514,78267.91345708]]]},properties:{hex:"ID2150"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2976196.64409514,78267.91345708],[2999334.6143776895,91626.62682821281],[3101196.64409514,150436.69710579],[3226196.64409514,78267.91345708],[3226196.64409514,-66069.65384032],[3126038.448334315,-123896.01512438498],[3101196.64409514,-138238.43748903],[3079378.8972512265,-125641.95547558414],[2976196.64409514,-66069.65384032],[2976196.64409514,-8433.004640126055],[2976196.64409514,78267.91345708]]]},properties:{hex:"ID2151"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3226196.64409514,78267.91345708],[3351196.64409514,150436.69710579],[3442032.3232361,97992.69330172936],[3476196.64409514,78267.91345708],[3476196.64409514,-66069.65384032],[3397422.9939069315,-111549.64198153591],[3376038.448334315,-123896.01512438498],[3351196.64409514,-138238.43748903],[3326354.839855969,-123896.01512438712],[3226196.64409514,-66069.65384032],[3226196.64409514,78267.91345708]]]},properties:{hex:"ID2152"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3476196.64409514,78267.91345708],[3601196.64409514,150436.69710579],[3726196.64409514,78267.91345708],[3726196.64409514,-66069.65384032],[3601196.64409514,-138238.43748903],[3476196.64409514,-66069.65384032],[3476196.64409514,78267.91345708]]]},properties:{hex:"ID2153"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3726196.64409514,78267.91345708],[3851196.64409514,150436.69710579],[3976196.64409514,78267.91345708],[3976196.64409514,-66069.65384032],[3851196.64409514,-138238.43748903],[3726196.64409514,-66069.65384032],[3726196.64409514,78267.91345708]]]},properties:{hex:"ID2154"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3976196.64409514,78267.91345708],[4101196.64409514,150436.69710579],[4105599.5550037874,147894.67530746438],[4226196.64409514,78267.91345708],[4226196.64409514,-66069.65384032],[4119259.369602485,-127809.91805506499],[4101196.64409514,-138238.43748903],[3976196.64409514,-66069.65384032],[3976196.64409514,78267.91345708]]]},properties:{hex:"ID2155"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4241599.353010646,-74962.41197893543],[4226196.64409514,-66069.65384032],[4226196.64409514,78267.91345708],[4351196.64409514,150436.69710579],[4398592.064694048,123072.93826464594],[4381193.127173632,106068.63100637788],[4356292.008436324,76860.88691123734],[4280712.811833917,-21722.36146802109],[4272889.649621138,-31007.776263210962],[4265513.369625739,-39749.812740265465],[4255938.5385758085,-56448.965587628314],[4249282.174110286,-63065.807612847224],[4241599.353010646,-74962.41197893543]]]},properties:{hex:"ID2156"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[743864.6895302924,193831.8325736613],[740142.2196257754,190596.2710264524],[735704.7994503039,193318.73148992326],[734521.8842177818,198238.44925605337],[740209.0033144176,207733.7019515533],[742895.348569708,210075.80229871414],[745159.4246772473,208089.84664004386],[746504.8888354753,205482.13851443474],[746707.7169297168,201667.1389185246],[743864.6895302924,193831.8325736613]]]},properties:{hex:"ID2218"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[989842.4325653682,359064.64840531023],[1101196.64409514,294774.26440319],[1101196.64409514,267977.4575799724],[1101196.64409514,150436.69710579],[1055289.2503203205,123932.0509521013],[976196.64409514,78267.91345708],[964652.1002485288,84933.15895459386],[964677.0265124448,96373.03122997197],[959583.4147751508,122567.87578292105],[961122.2457485783,127596.68543053183],[961979.2128794767,130373.68866392277],[952993.4012332977,137835.33713034115],[946523.534591449,138559.76595036307],[940569.7949892136,140859.8237599093],[945360.3862951583,160286.32255376826],[951354.53374075,177460.70318280306],[960348.5714484628,190433.28524468612],[965136.1930031171,193560.1908719336],[966676.9760026,199995.0513084767],[973756.8852177571,221146.33109935874],[982544.5909300146,238307.04867499633],[979753.2993254154,255702.62797470533],[981771.1897178005,284903.156545797],[983769.2288871947,313926.8118590713],[988260.813526926,338114.67285558477],[989842.4325653682,359064.64840531023]]]},properties:{hex:"ID2219"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1101196.64409514,294774.26440319],[1226196.64409514,366943.0480519],[1351196.64409514,294774.26440319],[1351196.64409514,267037.75087093655],[1351196.64409514,161032.77887565416],[1351196.64409514,150436.69710579],[1226196.64409514,78267.91345708],[1135909.974452506,130394.94647949448],[1101196.64409514,150436.69710579],[1101196.64409514,267977.4575799724],[1101196.64409514,294774.26440319]]]},properties:{hex:"ID2220"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1351196.64409514,294774.26440319],[1476196.64409514,366943.0480519],[1601196.64409514,294774.26440319],[1601196.64409514,216888.85249287332],[1601196.64409514,150436.69710579],[1476196.64409514,78267.91345708],[1444265.6348002048,96703.29026900901],[1351196.64409514,150436.69710579],[1351196.64409514,161032.77887565416],[1351196.64409514,267037.75087093655],[1351196.64409514,294774.26440319]]]},properties:{hex:"ID2221"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1601196.64409514,294774.26440319],[1614127.3027047312,302239.78363223735],[1634449.8542224413,313973.01422160835],[1726196.64409514,366943.0480519],[1828334.0484781514,307973.99013703316],[1851196.64409514,294774.26440319],[1851196.64409514,150436.69710579],[1792968.7911429373,116818.83052949866],[1726196.64409514,78267.91345708],[1601196.64409514,150436.69710579],[1601196.64409514,216888.85249287332],[1601196.64409514,294774.26440319]]]},properties:{hex:"ID2222"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1851196.64409514,294774.26440319],[1976196.64409514,366943.0480519],[2101196.64409514,294774.26440319],[2101196.64409514,150436.69710579],[1976196.64409514,78267.91345708],[1851196.64409514,150436.69710579],[1851196.64409514,294774.26440319]]]},properties:{hex:"ID2223"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2101196.64409514,294774.26440319],[2226196.64409514,366943.0480519],[2351196.64409514,294774.26440319],[2351196.64409514,150436.69710579],[2226196.64409514,78267.91345708],[2101196.64409514,150436.69710579],[2101196.64409514,294774.26440319]]]},properties:{hex:"ID2224"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2351196.64409514,294774.26440319],[2476196.64409514,366943.0480519],[2601196.64409514,294774.26440319],[2601196.64409514,150436.69710579],[2476196.64409514,78267.91345708],[2351196.64409514,150436.69710579],[2351196.64409514,294774.26440319]]]},properties:{hex:"ID2225"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2601196.64409514,294774.26440319],[2726196.64409514,366943.0480519],[2851196.64409514,294774.26440319],[2851196.64409514,150436.69710579],[2726196.64409514,78267.91345708],[2601196.64409514,150436.69710579],[2601196.64409514,294774.26440319]]]},properties:{hex:"ID2226"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2851196.64409514,294774.26440319],[2976196.64409514,366943.0480519],[3077971.293002,308183.42710883927],[3097323.22625548,297010.5832356016],[3101196.64409514,294774.26440319],[3101196.64409514,209263.1498547199],[3101196.64409514,150436.69710579],[2999334.6143776895,91626.62682821281],[2976196.64409514,78267.91345708],[2851196.64409514,150436.69710579],[2851196.64409514,294774.26440319]]]},properties:{hex:"ID2227"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3101196.64409514,294774.26440319],[3102822.287051854,295712.8298018553],[3226196.64409514,366943.0480519],[3351196.64409514,294774.26440319],[3351196.64409514,150436.69710579],[3226196.64409514,78267.91345708],[3101196.64409514,150436.69710579],[3101196.64409514,209263.1498547199],[3101196.64409514,294774.26440319]]]},properties:{hex:"ID2228"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3351196.64409514,294774.26440319],[3465160.9314114274,360571.57636325853],[3476196.64409514,366943.0480519],[3601196.64409514,294774.26440319],[3601196.64409514,150436.69710579],[3476196.64409514,78267.91345708],[3442032.3232361,97992.69330172936],[3351196.64409514,150436.69710579],[3351196.64409514,294774.26440319]]]},properties:{hex:"ID2229"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3601196.64409514,294774.26440319],[3726196.64409514,366943.0480519],[3851196.64409514,294774.26440319],[3851196.64409514,150436.69710579],[3726196.64409514,78267.91345708],[3601196.64409514,150436.69710579],[3601196.64409514,294774.26440319]]]},properties:{hex:"ID2230"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3851196.64409514,294774.26440319],[3976196.64409514,366943.0480519],[4101196.64409514,294774.26440319],[4101196.64409514,150436.69710579],[3976196.64409514,78267.91345708],[3851196.64409514,150436.69710579],[3851196.64409514,294774.26440319]]]},properties:{hex:"ID2231"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4101196.64409514,294774.26440319],[4103497.24273038,296102.5156445433],[4226196.64409514,366943.0480519],[4351196.64409514,294774.26440319],[4351196.64409514,150436.69710579],[4226196.64409514,78267.91345708],[4105599.5550037874,147894.67530746438],[4101196.64409514,150436.69710579],[4101196.64409514,294774.26440319]]]},properties:{hex:"ID2232"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4398592.064694048,123072.93826464594],[4351196.64409514,150436.69710579],[4351196.64409514,294774.26440319],[4476196.64409514,366943.0480519],[4600783.713300997,295012.67010834534],[4590532.554031526,285573.0938778875],[4500641.658152526,223802.26180709706],[4442339.095236783,171979.43101742587],[4412572.847585371,136736.61903344156],[4398592.064694048,123072.93826464594]]]},properties:{hex:"ID2233"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[660643.1830168695,549127.923749152],[679644.5126322588,538157.5009807468],[676007.7205920095,536861.1081777905],[671816.9959180566,536722.4020822243],[663601.5874407466,536451.0203622201],[662009.2978462102,540841.3362674294],[660643.1830168695,549127.923749152]]],[[[567952.2014810119,564255.7111056843],[601196.64409514,583449.39899801],[657854.5268460269,550737.9551400684],[655755.6062148178,536595.7573172197],[650299.1815031568,535425.797801778],[646507.7311628272,535576.5660958631],[630284.8226368466,531958.1013662323],[626666.9671372378,532645.6137803161],[625882.3552281292,535739.3957487609],[627797.6884669956,540334.7654174763],[627336.3828140498,547800.5468140742],[621723.5581843153,542041.4224897729],[620862.2560953902,530528.7930825314],[617645.4335956636,528689.375697173],[607956.3277417966,530323.7439555057],[597341.8935293137,536245.9761953058],[590889.3189797217,542318.8285049703],[580070.6523736971,550743.3755606266],[567952.2014810119,564255.7111056843]]]]},properties:{hex:"ID2288"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[976196.64409514,446417.4405213193],[976196.64409514,426388.711817343],[968221.6634758045,437299.2971465786],[976196.64409514,446417.4405213193]]],[[[891792.1223534719,560011.5886976739],[976196.64409514,511280.6153493],[976196.64409514,447791.0453966471],[965201.6442835106,446463.18703105545],[962496.4448113616,456929.8199320127],[956445.7533871916,469477.20854913443],[960099.8626916294,471485.9450773217],[963599.2281261184,478368.6222138069],[974772.7917189673,476257.3898826231],[974401.6517319239,479617.25766039407],[964714.0293334882,490142.9652161432],[965611.283453455,495456.9330170378],[969543.5998316029,501392.0439471239],[967593.6857164036,503895.1244766479],[960711.5011934995,497748.963322778],[955726.4471761995,497935.94386064063],[951823.4289679572,501916.7881267325],[949005.0614876857,502592.3193058352],[950762.3871178074,494515.98848609824],[946923.8429899164,487326.0970231626],[943263.2770598618,484828.89147228637],[936957.1784909185,485251.12592373457],[931806.3678545863,487060.6946372565],[930425.3389278995,491083.92526860867],[925580.2538387855,494160.1175653308],[912015.2733191614,499498.13088378427],[900595.6339150007,505740.75392351067],[898191.7669902929,522887.58282438444],[893644.4958123276,530275.4970772727],[891748.8149084011,538622.0656376255],[890617.0954851636,548174.4328132377],[891792.1223534719,560011.5886976739]]],[[[873308.8360206165,570682.9190374602],[882357.94068618,565458.4160228808],[880939.8538006977,565251.9483260808],[876412.2244830319,566065.9935766769],[873308.8360206165,570682.9190374602]]],[[[855813.5728655165,580783.8139296044],[866759.2105124887,574464.3470876685],[869206.0996171508,562387.6922536213],[865890.3792658348,558202.7998859897],[857697.0733082041,559420.8887011152],[854176.2951078543,565058.9890309968],[853477.2240708334,569255.8172342151],[855813.5728655165,580783.8139296044]]],[[[816048.9919857874,563156.8925912904],[832102.5942432082,572425.4441760753],[829531.6403496151,563298.2280246691],[816048.9919857874,563156.8925912904]]],[[[874358.1467059321,464566.9027985177],[876833.5185605382,464078.28044611396],[891805.4917330596,464554.83805930143],[895904.9087368051,458021.70612187934],[895493.5525345192,448411.75882848084],[880219.9042880783,420346.2696089346],[877398.5288959492,408514.7992551962],[871487.4806334182,398505.0694985],[866318.4467865268,397696.5546887853],[848527.4704615785,403573.3257424158],[845510.7027560746,407139.1585746642],[844424.4838995911,411947.84161186276],[846125.9458387868,423127.5957829056],[847401.2872753235,426548.41162777104],[855916.8401721814,428653.9741979836],[858655.7074096444,430475.9679015081],[863155.4482429612,442535.8404316906],[864598.7091227365,453515.38654178695],[868380.1410635815,461804.0640340461],[874358.1467059321,464566.9027985177]]]]},properties:{hex:"ID2289"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[976196.64409514,426388.711817343],[976196.64409514,446417.4405213193],[977539.9252756645,447953.2725165616],[976196.64409514,447791.0453966471],[976196.64409514,511280.6153493],[1101196.64409514,583449.39899801],[1226196.64409514,511280.6153493],[1226196.64409514,366943.0480519],[1101196.64409514,294774.26440319],[989842.4325653682,359064.64840531023],[989955.1051703021,360557.0990278147],[996171.6388064832,380638.8485842861],[992732.5832235557,400484.11225999775],[988798.3348701634,409148.31600243907],[976196.64409514,426388.711817343]]]},properties:{hex:"ID2290"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1226196.64409514,511280.6153493],[1351196.64409514,583449.39899801],[1476196.64409514,511280.6153493],[1476196.64409514,366943.0480519],[1351196.64409514,294774.26440319],[1226196.64409514,366943.0480519],[1226196.64409514,511280.6153493]]]},properties:{hex:"ID2291"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1476196.64409514,511280.6153493],[1507183.3456625994,529170.7958405729],[1601196.64409514,583449.39899801],[1726196.64409514,511280.6153493],[1726196.64409514,445442.5567786255],[1726196.64409514,366943.0480519],[1634449.8542224413,313973.01422160835],[1614127.3027047312,302239.78363223735],[1601196.64409514,294774.26440319],[1476196.64409514,366943.0480519],[1476196.64409514,511280.6153493]]]},properties:{hex:"ID2292"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1726196.64409514,511280.6153493],[1851196.64409514,583449.39899801],[1885931.7562515552,563395.07264417],[1976196.64409514,511280.6153493],[1976196.64409514,366943.0480519],[1851196.64409514,294774.26440319],[1828334.0484781514,307973.99013703316],[1726196.64409514,366943.0480519],[1726196.64409514,445442.5567786255],[1726196.64409514,511280.6153493]]]},properties:{hex:"ID2293"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1976196.64409514,511280.6153493],[2053349.7949304888,555825.0077529206],[2101196.64409514,583449.39899801],[2209912.3946258654,520682.3311639377],[2226196.64409514,511280.6153493],[2226196.64409514,366943.0480519],[2101196.64409514,294774.26440319],[1976196.64409514,366943.0480519],[1976196.64409514,511280.6153493]]]},properties:{hex:"ID2294"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2226196.64409514,511280.6153493],[2231728.945417935,514474.69100725395],[2254601.186491595,527679.985548103],[2338889.3403968588,576343.7738948083],[2351196.64409514,583449.39899801],[2354075.268489642,581787.4244289483],[2476196.64409514,511280.6153493],[2476196.64409514,366943.0480519],[2351196.64409514,294774.26440319],[2226196.64409514,366943.0480519],[2226196.64409514,511280.6153493]]]},properties:{hex:"ID2295"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2476196.64409514,511280.6153493],[2601196.64409514,583449.39899801],[2726196.64409514,511280.6153493],[2726196.64409514,366943.0480519],[2601196.64409514,294774.26440319],[2476196.64409514,366943.0480519],[2476196.64409514,511280.6153493]]]},properties:{hex:"ID2296"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2726196.64409514,511280.6153493],[2802040.156026643,555068.8873792436],[2851196.64409514,583449.39899801],[2921758.1819821233,542710.6761045223],[2976196.64409514,511280.6153493],[2976196.64409514,366943.0480519],[2851196.64409514,294774.26440319],[2726196.64409514,366943.0480519],[2726196.64409514,511280.6153493]]]},properties:{hex:"ID2297"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2976196.64409514,511280.6153493],[2997933.3768655956,523830.32386562653],[3101196.64409514,583449.39899801],[3226196.64409514,511280.6153493],[3226196.64409514,449679.9408086579],[3226196.64409514,366943.0480519],[3102822.287051854,295712.8298018553],[3101196.64409514,294774.26440319],[3097323.22625548,297010.5832356016],[3077971.293002,308183.42710883927],[2976196.64409514,366943.0480519],[2976196.64409514,511280.6153493]]]},properties:{hex:"ID2298"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3226196.64409514,511280.6153493],[3351196.64409514,583449.39899801],[3417980.29945545,544891.8375982643],[3476196.64409514,511280.6153493],[3476196.64409514,366943.0480519],[3465160.9314114274,360571.57636325853],[3351196.64409514,294774.26440319],[3226196.64409514,366943.0480519],[3226196.64409514,449679.9408086579],[3226196.64409514,511280.6153493]]]},properties:{hex:"ID2299"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3476196.64409514,511280.6153493],[3588780.7866004263,576281.1003312162],[3601196.64409514,583449.39899801],[3662154.403319516,548255.4203006166],[3726196.64409514,511280.6153493],[3726196.64409514,366943.0480519],[3601196.64409514,294774.26440319],[3476196.64409514,366943.0480519],[3476196.64409514,511280.6153493]]]},properties:{hex:"ID2300"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3726196.64409514,511280.6153493],[3732059.9549640147,514665.7994577876],[3851196.64409514,583449.39899801],[3976196.64409514,511280.6153493],[3976196.64409514,453145.1135074744],[3976196.64409514,366943.0480519],[3851196.64409514,294774.26440319],[3726196.64409514,366943.0480519],[3726196.64409514,511280.6153493]]]},properties:{hex:"ID2301"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3976196.64409514,511280.6153493],[4101196.64409514,583449.39899801],[4217471.813988888,516317.8983597785],[4226196.64409514,511280.6153493],[4226196.64409514,366943.0480519],[4103497.24273038,296102.5156445433],[4101196.64409514,294774.26440319],[3976196.64409514,366943.0480519],[3976196.64409514,453145.1135074744],[3976196.64409514,511280.6153493]]]},properties:{hex:"ID2302"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4226196.64409514,511280.6153493],[4245354.938026965,522341.661508054],[4295797.8460648395,551464.8880424313],[4351196.64409514,583449.39899801],[4476196.64409514,511280.6153493],[4476196.64409514,366943.0480519],[4351196.64409514,294774.26440319],[4226196.64409514,366943.0480519],[4226196.64409514,511280.6153493]]]},properties:{hex:"ID2303"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4600783.713300997,295012.67010834534],[4476196.64409514,366943.0480519],[4476196.64409514,511280.6153493],[4601196.64409514,583449.39899801],[4726196.64409514,511280.6153493],[4726196.64409514,451203.1781678232],[4693557.598243099,406167.7596310438],[4612718.61121287,306002.6835966119],[4600783.713300997,295012.67010834534]]]},properties:{hex:"ID2304"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4726196.64409514,451203.1781678232],[4726196.64409514,511280.6153493],[4796330.923103988,551772.660214477],[4754680.221507779,490504.87332208815],[4726196.64409514,451203.1781678232]]]},properties:{hex:"ID2305"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1069557.8361693185,773539.3884468019],[-1023803.35590486,799955.74994412],[-898803.35590486,727786.96629541],[-898803.35590486,615265.9018138888],[-913054.5706145018,624669.4419053072],[-937138.5442049976,647684.3675626366],[-964820.6641787342,681954.7031325665],[-1026350.5410073659,750928.4563174488],[-1040404.670359901,761994.7881570258],[-1058217.16228604,767374.0803923946],[-1069196.478493025,773241.1093884932],[-1069557.8361693185,773539.3884468019]]]},properties:{hex:"ID2356"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-898803.35590486,615265.9018138888],[-898803.35590486,727786.96629541],[-813697.7104849871,776922.733588135],[-773803.35590486,799955.74994412],[-648803.35590486,727786.96629541],[-648803.35590486,591458.7348759101],[-654904.0618587073,588508.3763809975],[-684634.5598938566,577359.8193335667],[-692429.464546597,573265.645994127],[-705995.1888887068,561706.2955979296],[-723379.9682887917,554452.01137335],[-742922.3728853571,540871.4892607011],[-754832.3876460531,537819.9872824504],[-766331.6704055084,539731.7034973186],[-800074.6374007342,557256.0631075568],[-826104.359027289,567296.1009462039],[-898803.35590486,615265.9018138888]]]},properties:{hex:"ID2357"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-648803.35590486,591458.7348759101],[-648803.35590486,727786.96629541],[-523803.35590486,799955.74994412],[-398803.35590486,727786.96629541],[-398803.35590486,654198.3841206385],[-411840.3592098388,656159.0857300254],[-435544.76969606004,655134.423417804],[-455102.0032868786,652476.3042571866],[-460725.3272783455,647045.4340334557],[-411362.235671843,650221.9986148878],[-406053.758264989,649607.1835830954],[-403579.91294791317,646334.1660239502],[-466016.0794246243,639227.3763817571],[-489843.7659489313,635001.7630489181],[-496878.4190697696,636165.1717087703],[-502206.06404532597,643061.0953638823],[-528063.4162153085,643880.8749370702],[-533378.8339563728,641626.4731387343],[-536607.3949141315,636538.9078051036],[-526429.8026709494,637642.0281119865],[-510344.22560541163,637943.4260684581],[-506054.25737258076,634055.3583965601],[-556356.6480697199,628967.6054190103],[-591295.7715261192,619274.0062993398],[-606121.720825569,612099.9730515563],[-648803.35590486,591458.7348759101]]]},properties:{hex:"ID2358"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-398803.35590486,654198.3841206385],[-398803.35590486,727786.96629541],[-316881.55864144606,775084.5379979444],[-273803.35590486,799955.74994412],[-148803.35590486,727786.96629541],[-148803.35590486,623160.1879077464],[-150141.55629655012,622613.7671714064],[-163829.8025090602,615560.4194125505],[-177682.77123686322,603153.1935618563],[-200203.86142343815,588592.7873438459],[-209037.37512199752,588791.7559148358],[-226638.39634221402,602375.4572984503],[-239877.97438437236,609200.1480628185],[-272266.59104597225,619617.630354056],[-296448.391150213,623638.5928780709],[-308125.2088215978,628105.5685268185],[-311335.5896829914,628871.1539167253],[-324562.1760762676,632005.8047412407],[-321403.20111811574,636098.863620508],[-308594.89525851165,633766.0108817673],[-301838.0414995779,634073.4426027267],[-302505.91886609665,636508.7678226082],[-306311.34528858535,637394.8814562237],[-316768.0541645425,642988.7617129518],[-314994.59268767637,660920.6823040718],[-319843.84350004414,661686.1434558714],[-323612.9368971019,659329.4779673804],[-331108.1499295397,637774.6432675647],[-334671.6163153726,634055.3583965601],[-386929.1576595691,645170.8154861009],[-398254.13049190555,654115.7833015772],[-398803.35590486,654198.3841206385]]]},properties:{hex:"ID2359"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-148803.35590486,623160.1879077464],[-148803.35590486,727786.96629541],[-23803.35590486,799955.74994412],[100036.05137574644,728457.0348143778],[94880.28012967457,717936.1548019754],[74815.60880315733,711747.9154759895],[67127.23095721976,711699.7102564132],[25943.57135202235,711404.4530095207],[-12642.60481649977,688059.5631316424],[-34851.344079334405,679742.9237992797],[-48520.01911800696,666592.2567664206],[-66914.13162364445,657250.043913055],[-79742.95789380552,645912.2261890426],[-106398.50318992506,640475.151338314],[-148803.35590486,623160.1879077464]]]},properties:{hex:"ID2360"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[179308.12809175113,772884.6526076599],[226196.64409514,799955.74994412],[252521.98778733984,784756.8056769116],[228338.23410159696,781824.4327834091],[181550.16613276943,773506.144896282],[179308.12809175113,772884.6526076599]]]},properties:{hex:"ID2361"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[445262.732079532,782096.0475148172],[476196.64409514,799955.74994412],[601196.64409514,727786.96629541],[601196.64409514,583449.39899801],[567952.2014810119,564255.7111056843],[558887.4904111819,574363.0605251119],[555426.665647867,584981.1753363289],[549338.51288735,598016.465260797],[544772.922728962,611237.8670325672],[538195.4682981734,633850.4039489498],[540180.2142342619,635490.0338078586],[545079.798329979,633548.9999786671],[547447.5458771548,636918.6712046397],[538669.9752262726,639378.074245783],[536833.1983603291,642000.199232554],[536213.4992264922,649932.6741287562],[536552.1665416432,659618.7888001177],[543662.6929438156,663024.1865132707],[549814.4273043494,664663.5782049159],[552881.7022366935,670558.042228252],[554640.5656432905,676464.381087841],[538303.580617444,667520.4265478324],[522925.75504827977,677645.6271845129],[519580.60057861934,683786.784344782],[521218.857737954,688493.4647639049],[528534.7487333526,689210.6055585559],[539007.5921765448,688842.9959109814],[545261.1025146176,693435.0519153824],[541399.0799230344,695038.0267077286],[534627.6370759498,694863.2669631501],[532115.5704101152,697906.473686392],[532286.538915744,705258.1739430736],[530098.6335907892,703631.1834145655],[527220.6248679097,697117.0525400641],[516908.0634906116,692326.219244172],[510846.5256151329,697117.0525400641],[510184.4142218474,707801.0711670128],[508845.7005712851,712609.581633313],[503735.94675404107,716363.5063163842],[485523.5627122932,744596.7744388222],[462704.5351682358,768145.118407333],[445262.732079532,782096.0475148172]]]},properties:{hex:"ID2362"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[832102.5942432082,572425.4441760753],[816048.9919857874,563156.8925912904],[803070.9325724947,563020.8466452645],[780313.3538745029,558932.4479093793],[764652.3325407142,559312.3463912751],[756765.6058851811,563708.2694555606],[753216.7342344932,575345.9053044834],[751884.9930850085,574145.9899391293],[751126.8547610786,567905.122259817],[746190.2541926524,563002.7565437718],[728641.3558847808,562068.0993808621],[720835.4657960386,570021.6095125113],[714499.9401493731,578915.4651965849],[707750.2384890387,582876.8869351919],[708804.5633907785,579132.5312084279],[716574.5091579488,570455.7583282532],[715689.2837291077,557961.5934270361],[701623.000316907,543500.8157680284],[692609.469705041,542680.6619574833],[687041.2619176604,548910.1422587626],[684121.5359378693,559083.2013491844],[682604.0131109859,574121.8709723408],[678844.7583910685,583932.048352197],[676852.3214338406,583932.048352197],[678732.0657627526,574953.9738473004],[679382.5342040858,567621.7165026462],[679542.0459939174,552371.5643048306],[686327.6324210439,540539.8061275876],[679644.5126322588,538157.5009807468],[660643.1830168695,549127.923749152],[660392.7684454465,550646.8899504015],[658222.2781786217,553215.805906715],[657854.5268460269,550737.9551400684],[601196.64409514,583449.39899801],[601196.64409514,727786.96629541],[726196.64409514,799955.74994412],[851196.64409514,727786.96629541],[851196.64409514,584057.3733348713],[843224.1443184299,586591.0330079786],[839403.1708359581,594929.5468204935],[834238.3668544455,596286.1081403189],[825227.3122105142,608536.9808993818],[823345.471599652,606499.2362435398],[832957.500131647,575460.4697564004],[832102.5942432082,572425.4441760753]]],[[[730362.2790180375,546075.8392955868],[720689.2430715169,542306.7673805277],[714334.5426824699,543229.4416551682],[722949.1837055896,559559.5815791052],[727372.3580270718,556050.0234543844],[733035.7406235503,554602.7676938501],[730362.2790180375,546075.8392955868]]]]},properties:{hex:"ID2363"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[882357.94068618,565458.4160228808],[873308.8360206165,570682.9190374602],[870960.7761448862,574176.138644027],[866184.7666309784,577299.5227665794],[866759.2105124887,574464.3470876685],[855813.5728655165,580783.8139296044],[857137.1421614833,587314.5607533435],[855669.7563785415,587700.4412543762],[854456.7189774326,588019.9980367058],[851590.9959518601,583932.048352197],[851196.64409514,584057.3733348713],[851196.64409514,727786.96629541],[929708.395346467,773115.7470149167],[976196.64409514,799955.74994412],[1101196.64409514,727786.96629541],[1101196.64409514,583449.39899801],[976196.64409514,511280.6153493],[891792.1223534719,560011.5886976739],[892071.0862342224,562821.8554512548],[889174.920720795,565167.5286543181],[885868.3288023806,565969.5142895991],[882357.94068618,565458.4160228808]]]},properties:{hex:"ID2364"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1101196.64409514,727786.96629541],[1226196.64409514,799955.74994412],[1351196.64409514,727786.96629541],[1351196.64409514,583449.39899801],[1226196.64409514,511280.6153493],[1101196.64409514,583449.39899801],[1101196.64409514,727786.96629541]]]},properties:{hex:"ID2365"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1351196.64409514,727786.96629541],[1476196.64409514,799955.74994412],[1479534.623198294,798028.5668103644],[1601196.64409514,727786.96629541],[1601196.64409514,583449.39899801],[1507183.3456625994,529170.7958405729],[1476196.64409514,511280.6153493],[1351196.64409514,583449.39899801],[1351196.64409514,727786.96629541]]]},properties:{hex:"ID2366"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1601196.64409514,727786.96629541],[1726196.64409514,799955.74994412],[1851196.64409514,727786.96629541],[1851196.64409514,583449.39899801],[1726196.64409514,511280.6153493],[1601196.64409514,583449.39899801],[1601196.64409514,727786.96629541]]]},properties:{hex:"ID2367"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1851196.64409514,727786.96629541],[1976196.64409514,799955.74994412],[2101196.64409514,727786.96629541],[2101196.64409514,583449.39899801],[2053349.7949304888,555825.0077529206],[1976196.64409514,511280.6153493],[1885931.7562515552,563395.07264417],[1851196.64409514,583449.39899801],[1851196.64409514,727786.96629541]]]},properties:{hex:"ID2368"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2101196.64409514,727786.96629541],[2226196.64409514,799955.74994412],[2351196.64409514,727786.96629541],[2351196.64409514,583449.39899801],[2338889.3403968588,576343.7738948083],[2254601.186491595,527679.985548103],[2231728.945417935,514474.69100725395],[2226196.64409514,511280.6153493],[2209912.3946258654,520682.3311639377],[2101196.64409514,583449.39899801],[2101196.64409514,727786.96629541]]]},properties:{hex:"ID2369"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2351196.64409514,727786.96629541],[2476196.64409514,799955.74994412],[2601196.64409514,727786.96629541],[2601196.64409514,643465.4679978035],[2601196.64409514,583449.39899801],[2476196.64409514,511280.6153493],[2354075.268489642,581787.4244289483],[2351196.64409514,583449.39899801],[2351196.64409514,727786.96629541]]]},properties:{hex:"ID2370"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2601196.64409514,727786.96629541],[2646195.264798002,753766.9320713716],[2726196.64409514,799955.74994412],[2851196.64409514,727786.96629541],[2851196.64409514,583449.39899801],[2802040.156026643,555068.8873792436],[2726196.64409514,511280.6153493],[2601196.64409514,583449.39899801],[2601196.64409514,643465.4679978035],[2601196.64409514,727786.96629541]]]},properties:{hex:"ID2371"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2851196.64409514,727786.96629541],[2976196.64409514,799955.74994412],[3101196.64409514,727786.96629541],[3101196.64409514,583449.39899801],[2997933.3768655956,523830.32386562653],[2976196.64409514,511280.6153493],[2921758.1819821233,542710.6761045223],[2851196.64409514,583449.39899801],[2851196.64409514,727786.96629541]]]},properties:{hex:"ID2372"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3101196.64409514,727786.96629541],[3226196.64409514,799955.74994412],[3351196.64409514,727786.96629541],[3351196.64409514,583449.39899801],[3226196.64409514,511280.6153493],[3101196.64409514,583449.39899801],[3101196.64409514,727786.96629541]]]},properties:{hex:"ID2373"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3351196.64409514,727786.96629541],[3472632.723652833,797898.1195173836],[3476196.64409514,799955.74994412],[3601196.64409514,727786.96629541],[3601196.64409514,583449.39899801],[3588780.7866004263,576281.1003312162],[3476196.64409514,511280.6153493],[3417980.29945545,544891.8375982643],[3351196.64409514,583449.39899801],[3351196.64409514,727786.96629541]]]},properties:{hex:"ID2374"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3601196.64409514,727786.96629541],[3726196.64409514,799955.74994412],[3851196.64409514,727786.96629541],[3851196.64409514,583449.39899801],[3732059.9549640147,514665.7994577876],[3726196.64409514,511280.6153493],[3662154.403319516,548255.4203006166],[3601196.64409514,583449.39899801],[3601196.64409514,727786.96629541]]]},properties:{hex:"ID2375"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3851196.64409514,727786.96629541],[3976196.64409514,799955.74994412],[4101196.64409514,727786.96629541],[4101196.64409514,583449.39899801],[3976196.64409514,511280.6153493],[3851196.64409514,583449.39899801],[3851196.64409514,727786.96629541]]]},properties:{hex:"ID2376"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4101196.64409514,727786.96629541],[4226196.64409514,799955.74994412],[4351196.64409514,727786.96629541],[4351196.64409514,596703.1578778296],[4351196.64409514,583449.39899801],[4295797.8460648395,551464.8880424313],[4245354.938026965,522341.661508054],[4226196.64409514,511280.6153493],[4217471.813988888,516317.8983597785],[4101196.64409514,583449.39899801],[4101196.64409514,727786.96629541]]]},properties:{hex:"ID2377"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4351196.64409514,727786.96629541],[4476196.64409514,799955.74994412],[4585324.673286065,736950.6529145997],[4601196.64409514,727786.96629541],[4601196.64409514,583449.39899801],[4476196.64409514,511280.6153493],[4351196.64409514,583449.39899801],[4351196.64409514,596703.1578778296],[4351196.64409514,727786.96629541]]]},properties:{hex:"ID2378"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4796330.923103988,551772.660214477],[4726196.64409514,511280.6153493],[4601196.64409514,583449.39899801],[4601196.64409514,727786.96629541],[4726196.64409514,799955.74994412],[4851196.64409514,727786.96629541],[4851196.64409514,660545.0011561493],[4823000.012657087,612081.8869470946],[4799078.857064517,555814.8449997485],[4796330.923103988,551772.660214477]]]},properties:{hex:"ID2379"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4851196.64409514,660545.0011561493],[4851196.64409514,727786.96629541],[4893726.891828701,752341.8162730853],[4861906.966874247,678953.4269001997],[4851196.64409514,660545.0011561493]]]},properties:{hex:"ID2380"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1273803.35590486,941943.5127086354],[-1273803.35590486,929057.7292992286],[-1291052.7944294314,935052.4447306412],[-1281267.763287572,941358.2592113345],[-1273803.35590486,941943.5127086354]]]},properties:{hex:"ID2434"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[-1260211.1231745344,952140.796467263],[-1148803.35590486,1016462.10089023],[-1059794.743672832,965072.9546578688],[-1023803.35590486,944293.31724152],[-1023803.35590486,799955.74994412],[-1069557.8361693185,773539.3884468019],[-1076916.9472782498,779613.8926723024],[-1083047.7316260855,798724.7520569701],[-1098448.2901613659,810107.0886668952],[-1126917.6000851863,826245.7354274602],[-1148144.685637984,853165.8752002546],[-1152073.700636809,858150.7917207704],[-1170404.5848612252,875608.7402075664],[-1189778.3519408242,887316.4573142336],[-1231144.11963941,906823.2198134928],[-1244928.7757185686,912305.8232866761],[-1244334.15178818,919232.498665133],[-1239373.494318497,931869.3435379505],[-1246906.078164439,946743.2445742459],[-1243739.693732377,957530.6276207236],[-1246746.7262808639,957542.6599181319],[-1252799.398330642,951039.0476705498],[-1260211.1231745344,952140.796467263]]],[[[-1273803.35590486,929057.7292992286],[-1273803.35590486,941943.5127086354],[-1257401.8120931347,943229.4903334874],[-1250374.3028983148,939553.1890359032],[-1247260.2709335012,936478.4985327524],[-1246161.8024498022,930647.8316860182],[-1248872.3943392523,918474.2518473376],[-1250368.8864484201,915260.6844988561],[-1256890.913603245,923180.1305180311],[-1273803.35590486,929057.7292992286]]]]},properties:{hex:"ID2435"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1023803.35590486,944293.31724152],[-941796.0478355734,991640.2586308436],[-898803.35590486,1016462.10089023],[-808873.3103694861,964540.9648921418],[-773803.35590486,944293.31724152],[-773803.35590486,799955.74994412],[-813697.7104849871,776922.733588135],[-898803.35590486,727786.96629541],[-1023803.35590486,799955.74994412],[-1023803.35590486,944293.31724152]]]},properties:{hex:"ID2436"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-773803.35590486,944293.31724152],[-648803.35590486,1016462.10089023],[-523803.35590486,944293.31724152],[-523803.35590486,799955.74994412],[-648803.35590486,727786.96629541],[-773803.35590486,799955.74994412],[-773803.35590486,944293.31724152]]]},properties:{hex:"ID2437"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-523803.35590486,944293.31724152],[-398803.35590486,1016462.10089023],[-287522.7503388611,952214.2133111099],[-273803.35590486,944293.31724152],[-273803.35590486,799955.74994412],[-316881.55864144606,775084.5379979444],[-398803.35590486,727786.96629541],[-523803.35590486,799955.74994412],[-523803.35590486,944293.31724152]]]},properties:{hex:"ID2438"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-273803.35590486,944293.31724152],[-148803.35590486,1016462.10089023],[-23803.35590486,944293.31724152],[-23803.35590486,799955.74994412],[-148803.35590486,727786.96629541],[-273803.35590486,799955.74994412],[-273803.35590486,944293.31724152]]]},properties:{hex:"ID2439"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[100036.05137574644,728457.0348143778],[-23803.35590486,799955.74994412],[-23803.35590486,944293.31724152],[58717.664601449025,991936.8506446447],[101196.64409514,1016462.10089023],[161855.85302678874,981440.4902847096],[226196.64409514,944293.31724152],[226196.64409514,799955.74994412],[179308.12809175113,772884.6526076599],[162036.3783452163,768096.9286341598],[130889.96249533523,759470.7392714358],[118570.51221073914,752380.3127913267],[110421.58815053102,747687.338697228],[104907.83498719442,740608.4802170425],[100694.10952088788,729799.8699511174],[100036.05137574644,728457.0348143778]]]},properties:{hex:"ID2440"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[252521.98778733984,784756.8056769116],[226196.64409514,799955.74994412],[226196.64409514,944293.31724152],[268914.90443127987,968956.7163459052],[351196.64409514,1016462.10089023],[476196.64409514,944293.31724152],[476196.64409514,799955.74994412],[445262.732079532,782096.0475148172],[442439.57023065374,784354.1701763534],[411909.4692299971,792099.7447156908],[348089.82988894585,791798.6016516344],[344504.167592804,794033.0700265425],[348400.86411392107,797761.1313204811],[353997.8372939598,800248.465708146],[374469.90156181785,813371.0812549122],[371003.0223190628,815111.4486077601],[349704.72137425805,806897.2304979766],[342406.0443130493,806114.3285553352],[333012.03908840084,790316.9697424942],[276802.1225521979,787703.0012717089],[270213.2421930974,786901.9381301122],[252521.98778733984,784756.8056769116]]]},properties:{hex:"ID2441"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[476196.64409514,944293.31724152],[601196.64409514,1016462.10089023],[726196.64409514,944293.31724152],[726196.64409514,799955.74994412],[601196.64409514,727786.96629541],[476196.64409514,799955.74994412],[476196.64409514,944293.31724152]]]},properties:{hex:"ID2442"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[726196.64409514,944293.31724152],[851196.64409514,1016462.10089023],[976196.64409514,944293.31724152],[976196.64409514,835289.1747251967],[976196.64409514,799955.74994412],[929708.395346467,773115.7470149167],[851196.64409514,727786.96629541],[726196.64409514,799955.74994412],[726196.64409514,944293.31724152]]]},properties:{hex:"ID2443"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[976196.64409514,944293.31724152],[1101196.64409514,1016462.10089023],[1200655.7373872506,959039.3666046686],[1226196.64409514,944293.31724152],[1226196.64409514,799955.74994412],[1101196.64409514,727786.96629541],[976196.64409514,799955.74994412],[976196.64409514,835289.1747251967],[976196.64409514,944293.31724152]]]},properties:{hex:"ID2444"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1226196.64409514,944293.31724152],[1351196.64409514,1016462.10089023],[1476196.64409514,944293.31724152],[1476196.64409514,799955.74994412],[1351196.64409514,727786.96629541],[1226196.64409514,799955.74994412],[1226196.64409514,944293.31724152]]]},properties:{hex:"ID2445"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1476196.64409514,944293.31724152],[1535667.4831549632,978628.8221816452],[1601196.64409514,1016462.10089023],[1708882.0133129666,954289.9239845278],[1726196.64409514,944293.31724152],[1726196.64409514,799955.74994412],[1601196.64409514,727786.96629541],[1479534.623198294,798028.5668103644],[1476196.64409514,799955.74994412],[1476196.64409514,944293.31724152]]]},properties:{hex:"ID2446"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1726196.64409514,944293.31724152],[1802501.6529222517,988348.0346283739],[1851196.64409514,1016462.10089023],[1858789.6244153457,1012078.2916584073],[1976196.64409514,944293.31724152],[1976196.64409514,799955.74994412],[1851196.64409514,727786.96629541],[1726196.64409514,799955.74994412],[1726196.64409514,944293.31724152]]]},properties:{hex:"ID2447"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1976196.64409514,944293.31724152],[2101196.64409514,1016462.10089023],[2226196.64409514,944293.31724152],[2226196.64409514,799955.74994412],[2101196.64409514,727786.96629541],[1976196.64409514,799955.74994412],[1976196.64409514,944293.31724152]]]},properties:{hex:"ID2448"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2226196.64409514,944293.31724152],[2351196.64409514,1016462.10089023],[2476196.64409514,944293.31724152],[2476196.64409514,799955.74994412],[2351196.64409514,727786.96629541],[2226196.64409514,799955.74994412],[2226196.64409514,944293.31724152]]]},properties:{hex:"ID2449"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2476196.64409514,944293.31724152],[2511032.4622268477,964405.7862173041],[2601196.64409514,1016462.10089023],[2726196.64409514,944293.31724152],[2726196.64409514,799955.74994412],[2646195.264798002,753766.9320713716],[2601196.64409514,727786.96629541],[2476196.64409514,799955.74994412],[2476196.64409514,944293.31724152]]]},properties:{hex:"ID2450"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2726196.64409514,944293.31724152],[2851196.64409514,1016462.10089023],[2976196.64409514,944293.31724152],[2976196.64409514,799955.74994412],[2851196.64409514,727786.96629541],[2726196.64409514,799955.74994412],[2726196.64409514,944293.31724152]]]},properties:{hex:"ID2451"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2976196.64409514,944293.31724152],[3101196.64409514,1016462.10089023],[3226196.64409514,944293.31724152],[3226196.64409514,799955.74994412],[3101196.64409514,727786.96629541],[2976196.64409514,799955.74994412],[2976196.64409514,944293.31724152]]]},properties:{hex:"ID2452"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3226196.64409514,944293.31724152],[3288675.19356637,980365.3245973154],[3351196.64409514,1016462.10089023],[3476196.64409514,944293.31724152],[3476196.64409514,799955.74994412],[3472632.723652833,797898.1195173836],[3351196.64409514,727786.96629541],[3226196.64409514,799955.74994412],[3226196.64409514,944293.31724152]]]},properties:{hex:"ID2453"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3476196.64409514,944293.31724152],[3601196.64409514,1016462.10089023],[3726196.64409514,944293.31724152],[3726196.64409514,799955.74994412],[3601196.64409514,727786.96629541],[3476196.64409514,799955.74994412],[3476196.64409514,944293.31724152]]]},properties:{hex:"ID2454"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3726196.64409514,944293.31724152],[3851196.64409514,1016462.10089023],[3976196.64409514,944293.31724152],[3976196.64409514,799955.74994412],[3851196.64409514,727786.96629541],[3726196.64409514,799955.74994412],[3726196.64409514,944293.31724152]]]},properties:{hex:"ID2455"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3976196.64409514,944293.31724152],[4101196.64409514,1016462.10089023],[4226196.64409514,944293.31724152],[4226196.64409514,799955.74994412],[4101196.64409514,727786.96629541],[3976196.64409514,799955.74994412],[3976196.64409514,944293.31724152]]]},properties:{hex:"ID2456"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4226196.64409514,944293.31724152],[4351196.64409514,1016462.10089023],[4476196.64409514,944293.31724152],[4476196.64409514,799955.74994412],[4351196.64409514,727786.96629541],[4226196.64409514,799955.74994412],[4226196.64409514,944293.31724152]]]},properties:{hex:"ID2457"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4476196.64409514,944293.31724152],[4601196.64409514,1016462.10089023],[4726196.64409514,944293.31724152],[4726196.64409514,919324.6969195065],[4726196.64409514,799955.74994412],[4601196.64409514,727786.96629541],[4585324.673286065,736950.6529145997],[4476196.64409514,799955.74994412],[4476196.64409514,944293.31724152]]]},properties:{hex:"ID2458"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4893726.891828701,752341.8162730853],[4851196.64409514,727786.96629541],[4726196.64409514,799955.74994412],[4726196.64409514,919324.6969195065],[4726196.64409514,944293.31724152],[4761904.438644643,964909.2220368455],[4851196.64409514,1016462.10089023],[4961001.189886481,953066.4168193457],[4959705.063671704,945979.1310165547],[4952076.485810763,922566.3291728623],[4943180.327843816,901298.2763611438],[4923129.820585912,863520.8321512411],[4913161.137104333,837234.7268710475],[4901216.079168983,791666.0985285884],[4898249.1830485035,762771.8744637154],[4893726.891828701,752341.8162730853]]]},properties:{hex:"ID2459"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1358391.7800268175,1184131.302399203],[-1273803.35590486,1232968.45183634],[-1242116.4262030816,1214673.9944432236],[-1148803.35590486,1160799.66818763],[-1148803.35590486,1016462.10089023],[-1260211.1231745344,952140.796467263],[-1265467.6699332613,952922.1792341997],[-1273731.2064533464,962193.0626865883],[-1280549.5074391507,965592.0266368748],[-1283474.493600851,970266.2134801059],[-1287492.717878158,994723.3019624811],[-1290480.730716155,1005825.5282375811],[-1296730.1737557412,1012675.2334279257],[-1309467.0755411135,1014359.0381590559],[-1314473.8825477778,1029289.8022563554],[-1321345.859698897,1040851.9607566758],[-1320076.29210749,1047976.3133569419],[-1314318.6960262982,1047567.5008353927],[-1309891.3891734465,1042397.1082710436],[-1302665.6739212405,1040238.7062255346],[-1293417.8069064138,1052761.7238621912],[-1285210.7931865372,1059542.7401194847],[-1283233.9748068291,1065481.8316535053],[-1284164.7855789906,1068739.7929999833],[-1289164.1686386326,1063678.4944139156],[-1302563.6888806114,1064982.911028453],[-1305966.2720761683,1060432.4200377213],[-1311983.6582618481,1058971.6583777373],[-1316363.6243354564,1073620.559847552],[-1315987.5489276594,1082245.5689630334],[-1313904.2085459977,1091741.3744620122],[-1300356.3336198076,1093370.0091010872],[-1299150.9087870002,1096422.8873740826],[-1308489.197177642,1098460.0987982813],[-1320018.755291971,1109498.886121683],[-1321972.17926604,1117105.847186281],[-1322896.5272325245,1120692.842672926],[-1319388.9720521937,1132035.9045542092],[-1321904.9825976389,1137935.2936233764],[-1331642.333538748,1149721.1367714868],[-1332474.577306656,1155421.389552013],[-1335385.3674599985,1162761.0125423234],[-1348203.968664672,1177901.202140707],[-1360454.0792237564,1176964.3845427574],[-1358391.7800268175,1184131.302399203]]]},properties:{hex:"ID2515"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1148803.35590486,1160799.66818763],[-1090254.4459698328,1194602.8970993801],[-1023803.35590486,1232968.45183634],[-898803.35590486,1160799.66818763],[-898803.35590486,1016462.10089023],[-941796.0478355734,991640.2586308436],[-1023803.35590486,944293.31724152],[-1059794.743672832,965072.9546578688],[-1148803.35590486,1016462.10089023],[-1148803.35590486,1160799.66818763]]]},properties:{hex:"ID2516"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-898803.35590486,1160799.66818763],[-808992.5987851938,1212651.9329867982],[-773803.35590486,1232968.45183634],[-648803.35590486,1160799.66818763],[-648803.35590486,1016462.10089023],[-773803.35590486,944293.31724152],[-808873.3103694861,964540.9648921418],[-898803.35590486,1016462.10089023],[-898803.35590486,1160799.66818763]]]},properties:{hex:"ID2517"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-648803.35590486,1160799.66818763],[-523803.35590486,1232968.45183634],[-398803.35590486,1160799.66818763],[-398803.35590486,1016462.10089023],[-523803.35590486,944293.31724152],[-648803.35590486,1016462.10089023],[-648803.35590486,1160799.66818763]]]},properties:{hex:"ID2518"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-398803.35590486,1160799.66818763],[-311564.8514999191,1211166.8421895276],[-274551.2438997838,1232536.6585011468],[-273803.35590486,1232968.45183634],[-148803.35590486,1160799.66818763],[-148803.35590486,1016462.10089023],[-273803.35590486,944293.31724152],[-287522.7503388611,952214.2133111099],[-398803.35590486,1016462.10089023],[-398803.35590486,1160799.66818763]]]},properties:{hex:"ID2519"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-148803.35590486,1160799.66818763],[-23803.35590486,1232968.45183634],[32531.384487535055,1200443.5743060599],[101196.64409514,1160799.66818763],[101196.64409514,1016462.10089023],[58717.664601449025,991936.8506446447],[-23803.35590486,944293.31724152],[-148803.35590486,1016462.10089023],[-148803.35590486,1160799.66818763]]]},properties:{hex:"ID2520"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[101196.64409514,1160799.66818763],[134109.51179348084,1179801.9212130713],[226196.64409514,1232968.45183634],[319328.5616071507,1179198.7141906295],[351196.64409514,1160799.66818763],[351196.64409514,1016462.10089023],[268914.90443127987,968956.7163459052],[226196.64409514,944293.31724152],[161855.85302678874,981440.4902847096],[101196.64409514,1016462.10089023],[101196.64409514,1160799.66818763]]]},properties:{hex:"ID2521"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[351196.64409514,1160799.66818763],[476196.64409514,1232968.45183634],[601196.64409514,1160799.66818763],[601196.64409514,1016462.10089023],[476196.64409514,944293.31724152],[351196.64409514,1016462.10089023],[351196.64409514,1160799.66818763]]]},properties:{hex:"ID2522"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[601196.64409514,1160799.66818763],[726196.64409514,1232968.45183634],[851196.64409514,1160799.66818763],[851196.64409514,1016462.10089023],[726196.64409514,944293.31724152],[601196.64409514,1016462.10089023],[601196.64409514,1160799.66818763]]]},properties:{hex:"ID2523"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[851196.64409514,1160799.66818763],[976196.64409514,1232968.45183634],[1101196.64409514,1160799.66818763],[1101196.64409514,1016462.10089023],[976196.64409514,944293.31724152],[851196.64409514,1016462.10089023],[851196.64409514,1160799.66818763]]]},properties:{hex:"ID2524"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1101196.64409514,1160799.66818763],[1226196.64409514,1232968.45183634],[1312047.125627604,1183402.6532135082],[1351196.64409514,1160799.66818763],[1351196.64409514,1016462.10089023],[1226196.64409514,944293.31724152],[1200655.7373872506,959039.3666046686],[1101196.64409514,1016462.10089023],[1101196.64409514,1160799.66818763]]]},properties:{hex:"ID2525"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1351196.64409514,1160799.66818763],[1391361.036066069,1183988.5907038855],[1466331.995833123,1227273.094506803],[1476196.64409514,1232968.45183634],[1484271.5661125912,1228306.3934358787],[1601196.64409514,1160799.66818763],[1601196.64409514,1016462.10089023],[1535667.4831549632,978628.8221816452],[1476196.64409514,944293.31724152],[1351196.64409514,1016462.10089023],[1351196.64409514,1160799.66818763]]]},properties:{hex:"ID2526"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1601196.64409514,1160799.66818763],[1726196.64409514,1232968.45183634],[1851196.64409514,1160799.66818763],[1851196.64409514,1016462.10089023],[1802501.6529222517,988348.0346283739],[1726196.64409514,944293.31724152],[1708882.0133129666,954289.9239845278],[1601196.64409514,1016462.10089023],[1601196.64409514,1160799.66818763]]]},properties:{hex:"ID2527"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1851196.64409514,1160799.66818763],[1976196.64409514,1232968.45183634],[2075630.261069728,1175560.426309558],[2101196.64409514,1160799.66818763],[2101196.64409514,1016462.10089023],[1976196.64409514,944293.31724152],[1858789.6244153457,1012078.2916584073],[1851196.64409514,1016462.10089023],[1851196.64409514,1160799.66818763]]]},properties:{hex:"ID2528"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2101196.64409514,1160799.66818763],[2226196.64409514,1232968.45183634],[2348345.611716657,1162445.7124988157],[2351196.64409514,1160799.66818763],[2351196.64409514,1080238.0610033134],[2351196.64409514,1016462.10089023],[2226196.64409514,944293.31724152],[2101196.64409514,1016462.10089023],[2101196.64409514,1160799.66818763]]]},properties:{hex:"ID2529"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2351196.64409514,1160799.66818763],[2476196.64409514,1232968.45183634],[2477939.337886498,1231962.3071067843],[2601196.64409514,1160799.66818763],[2601196.64409514,1016462.10089023],[2511032.4622268477,964405.7862173041],[2476196.64409514,944293.31724152],[2351196.64409514,1016462.10089023],[2351196.64409514,1080238.0610033134],[2351196.64409514,1160799.66818763]]]},properties:{hex:"ID2530"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2601196.64409514,1160799.66818763],[2634971.943299669,1180299.8462753266],[2726196.64409514,1232968.45183634],[2851196.64409514,1160799.66818763],[2851196.64409514,1151232.099967018],[2851196.64409514,1016462.10089023],[2726196.64409514,944293.31724152],[2601196.64409514,1016462.10089023],[2601196.64409514,1160799.66818763]]]},properties:{hex:"ID2531"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2851196.64409514,1160799.66818763],[2868727.2101123612,1170920.94519672],[2976196.64409514,1232968.45183634],[3101196.64409514,1160799.66818763],[3101196.64409514,1016462.10089023],[2976196.64409514,944293.31724152],[2851196.64409514,1016462.10089023],[2851196.64409514,1151232.099967018],[2851196.64409514,1160799.66818763]]]},properties:{hex:"ID2532"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3101196.64409514,1160799.66818763],[3226196.64409514,1232968.45183634],[3351196.64409514,1160799.66818763],[3351196.64409514,1041177.9467832375],[3351196.64409514,1016462.10089023],[3288675.19356637,980365.3245973154],[3226196.64409514,944293.31724152],[3101196.64409514,1016462.10089023],[3101196.64409514,1160799.66818763]]]},properties:{hex:"ID2533"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3351196.64409514,1160799.66818763],[3366766.9646614036,1169789.1969579316],[3387215.888692898,1181595.3887521545],[3476196.64409514,1232968.45183634],[3601196.64409514,1160799.66818763],[3601196.64409514,1016462.10089023],[3476196.64409514,944293.31724152],[3351196.64409514,1016462.10089023],[3351196.64409514,1041177.9467832375],[3351196.64409514,1160799.66818763]]]},properties:{hex:"ID2534"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3601196.64409514,1160799.66818763],[3726196.64409514,1232968.45183634],[3851196.64409514,1160799.66818763],[3851196.64409514,1016462.10089023],[3726196.64409514,944293.31724152],[3601196.64409514,1016462.10089023],[3601196.64409514,1160799.66818763]]]},properties:{hex:"ID2535"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3851196.64409514,1160799.66818763],[3976196.64409514,1232968.45183634],[4101196.64409514,1160799.66818763],[4101196.64409514,1016462.10089023],[3976196.64409514,944293.31724152],[3851196.64409514,1016462.10089023],[3851196.64409514,1160799.66818763]]]},properties:{hex:"ID2536"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4101196.64409514,1160799.66818763],[4226196.64409514,1232968.45183634],[4300194.483922319,1190245.7790926632],[4351196.64409514,1160799.66818763],[4351196.64409514,1136578.2882880806],[4351196.64409514,1016462.10089023],[4226196.64409514,944293.31724152],[4101196.64409514,1016462.10089023],[4101196.64409514,1160799.66818763]]]},properties:{hex:"ID2537"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4351196.64409514,1160799.66818763],[4476196.64409514,1232968.45183634],[4601196.64409514,1160799.66818763],[4601196.64409514,1020561.5719641612],[4601196.64409514,1016462.10089023],[4476196.64409514,944293.31724152],[4351196.64409514,1016462.10089023],[4351196.64409514,1136578.2882880806],[4351196.64409514,1160799.66818763]]]},properties:{hex:"ID2538"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4601196.64409514,1160799.66818763],[4726196.64409514,1232968.45183634],[4851196.64409514,1160799.66818763],[4851196.64409514,1140037.183741017],[4851196.64409514,1016462.10089023],[4761904.438644643,964909.2220368455],[4726196.64409514,944293.31724152],[4601196.64409514,1016462.10089023],[4601196.64409514,1020561.5719641612],[4601196.64409514,1160799.66818763]]]},properties:{hex:"ID2539"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4961001.189886481,953066.4168193457],[4851196.64409514,1016462.10089023],[4851196.64409514,1140037.183741017],[4851196.64409514,1160799.66818763],[4863425.541032296,1167860.0251261897],[4976196.64409514,1232968.45183634],[5049854.656246899,1190441.9786925465],[5051250.0984911565,1163727.9807671576],[5039020.3663293,1140722.6784211532],[5035486.559499084,1124496.017490557],[5017036.532552951,1092005.803750186],[5008102.956550581,1064225.509537013],[5005469.445152056,1050663.6207815295],[4989705.967028051,1012536.9199107673],[4966532.766295699,983313.3653843742],[4961001.189886481,953066.4168193457]]]},properties:{hex:"ID2540"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[-1557373.1317072327,1383339.4054723906],[-1557509.2277762454,1378311.1872264761],[-1561676.4071484255,1379264.1124117319],[-1562854.2816502827,1380768.3958177478],[-1560120.8968110187,1389871.4866535095],[-1556325.787289311,1393928.335620103],[-1551832.4468908652,1393281.1693307161],[-1550521.7278526241,1392052.7393214265],[-1551492.2354548264,1388541.1369035107],[-1553543.4161152274,1385652.6539357328],[-1557373.1317072327,1383339.4054723906]]],[[[-1574728.7328176086,1367013.187956968],[-1575739.9286963374,1363608.5369553566],[-1581550.0641850487,1364130.0319878254],[-1580135.715890532,1367582.6157810718],[-1581380.470138721,1368589.5954737968],[-1579414.2365868965,1378952.4649974992],[-1578499.865155576,1380552.643518018],[-1575776.3038232373,1376692.9900369933],[-1575437.7172807313,1375098.7386606385],[-1574728.7328176086,1367013.187956968]]],[[[-1596462.298407344,1364183.979584845],[-1604440.926978637,1362361.7325241354],[-1607886.2175560542,1368457.7297006503],[-1608357.8453908411,1370813.3039737698],[-1604160.7471987566,1372863.144802951],[-1602301.1413429638,1372947.0554584584],[-1599025.2409534699,1377370.2389485193],[-1595054.742223826,1380336.8907173194],[-1593311.5590284641,1381289.795140048],[-1591324.4449543008,1381098.016419258],[-1590152.655487286,1371316.7778124716],[-1592190.3120008984,1367210.989592725],[-1596462.298407344,1364183.979584845]]]]},properties:{hex:"ID2593"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1520523.8580442201,1379199.4381063923],[-1457188.1890350142,1415766.3036581632],[-1450871.9158910369,1419413.0056581139],[-1398803.35590486,1449474.80278245],[-1380040.6092350837,1438642.125941917],[-1273803.35590486,1377306.01913374],[-1273803.35590486,1232968.45183634],[-1358391.7800268175,1184131.302399203],[-1356797.7782034697,1189670.7896607583],[-1356609.744140795,1206548.3066289057],[-1360571.1403103848,1215757.4698052874],[-1359313.8095197843,1225163.9181053292],[-1361595.2414849023,1224569.6618963035],[-1365807.998250247,1218092.6522118594],[-1372358.8181217574,1220175.6634662508],[-1385504.0437195895,1230193.9521603233],[-1391970.1652005715,1239923.2002788812],[-1392590.4343108935,1248193.2452634568],[-1394017.9377031687,1251403.8608210566],[-1398150.8529222817,1249681.5430452023],[-1406497.6627437174,1249849.5753156955],[-1431624.2547341345,1264563.3342994552],[-1448886.5491341287,1301608.28644005],[-1449090.1348375285,1309957.244708851],[-1446146.0246158615,1324338.3364296064],[-1446657.009591312,1328242.0941509437],[-1455198.8124917157,1318695.3000846223],[-1456632.0788588414,1325087.918083265],[-1462614.0394915808,1339952.4202048383],[-1464241.616476929,1348495.9189854006],[-1470243.6392942322,1352290.7855025136],[-1475108.570409791,1352968.2101860933],[-1478953.8783415474,1350126.5910854978],[-1484362.7022448503,1332751.3078639063],[-1488067.285081095,1332865.2347366489],[-1491822.1895651936,1336576.77859996],[-1490682.8920496146,1349539.0727404451],[-1495488.5784954103,1358243.5641803183],[-1491196.6698230715,1374313.589811479],[-1495381.4965797656,1374079.841931801],[-1504065.4910429546,1361090.9341050643],[-1508144.4805214114,1360683.3158895986],[-1507208.2271571476,1376069.6769547095],[-1511816.923545017,1376639.0496465517],[-1517204.2675674495,1375548.2483866327],[-1520523.8580442201,1379199.4381063923]]]},properties:{hex:"ID2594"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1273803.35590486,1377306.01913374],[-1148803.35590486,1449474.80278245],[-1023803.35590486,1377306.01913374],[-1023803.35590486,1232968.45183634],[-1090254.4459698328,1194602.8970993801],[-1148803.35590486,1160799.66818763],[-1242116.4262030816,1214673.9944432236],[-1273803.35590486,1232968.45183634],[-1273803.35590486,1377306.01913374]]]},properties:{hex:"ID2595"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1023803.35590486,1377306.01913374],[-898803.35590486,1449474.80278245],[-860040.5029093777,1427095.0591709483],[-773803.35590486,1377306.01913374],[-773803.35590486,1266336.6897359216],[-773803.35590486,1232968.45183634],[-808992.5987851938,1212651.9329867982],[-898803.35590486,1160799.66818763],[-1023803.35590486,1232968.45183634],[-1023803.35590486,1377306.01913374]]]},properties:{hex:"ID2596"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-773803.35590486,1377306.01913374],[-648803.35590486,1449474.80278245],[-526577.3741737936,1378907.599328046],[-523803.35590486,1377306.01913374],[-523803.35590486,1273231.0673464008],[-523803.35590486,1232968.45183634],[-648803.35590486,1160799.66818763],[-773803.35590486,1232968.45183634],[-773803.35590486,1266336.6897359216],[-773803.35590486,1377306.01913374]]]},properties:{hex:"ID2597"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-523803.35590486,1377306.01913374],[-398803.35590486,1449474.80278245],[-273803.35590486,1377306.01913374],[-273803.35590486,1356542.307176346],[-273803.35590486,1232968.45183634],[-274551.2438997838,1232536.6585011468],[-311564.8514999191,1211166.8421895276],[-398803.35590486,1160799.66818763],[-523803.35590486,1232968.45183634],[-523803.35590486,1273231.0673464008],[-523803.35590486,1377306.01913374]]]},properties:{hex:"ID2598"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-273803.35590486,1377306.01913374],[-148803.35590486,1449474.80278245],[-23803.35590486,1377306.01913374],[-23803.35590486,1375764.0292587357],[-23803.35590486,1232968.45183634],[-148803.35590486,1160799.66818763],[-273803.35590486,1232968.45183634],[-273803.35590486,1356542.307176346],[-273803.35590486,1377306.01913374]]]},properties:{hex:"ID2599"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-23803.35590486,1377306.01913374],[101196.64409514,1449474.80278245],[171663.34859979642,1408790.831967777],[226196.64409514,1377306.01913374],[226196.64409514,1232968.45183634],[134109.51179348084,1179801.9212130713],[101196.64409514,1160799.66818763],[32531.384487535055,1200443.5743060599],[-23803.35590486,1232968.45183634],[-23803.35590486,1375764.0292587357],[-23803.35590486,1377306.01913374]]]},properties:{hex:"ID2600"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[226196.64409514,1377306.01913374],[351196.64409514,1449474.80278245],[351851.3592593727,1449096.8028061378],[359080.44099431904,1444923.0905204723],[476196.64409514,1377306.01913374],[476196.64409514,1232968.45183634],[351196.64409514,1160799.66818763],[319328.5616071507,1179198.7141906295],[226196.64409514,1232968.45183634],[226196.64409514,1377306.01913374]]]},properties:{hex:"ID2601"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[476196.64409514,1377306.01913374],[601196.64409514,1449474.80278245],[726196.64409514,1377306.01913374],[726196.64409514,1232968.45183634],[601196.64409514,1160799.66818763],[476196.64409514,1232968.45183634],[476196.64409514,1377306.01913374]]]},properties:{hex:"ID2602"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[726196.64409514,1377306.01913374],[851196.64409514,1449474.80278245],[976196.64409514,1377306.01913374],[976196.64409514,1232968.45183634],[851196.64409514,1160799.66818763],[726196.64409514,1232968.45183634],[726196.64409514,1377306.01913374]]]},properties:{hex:"ID2603"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[976196.64409514,1377306.01913374],[1101196.64409514,1449474.80278245],[1226196.64409514,1377306.01913374],[1226196.64409514,1232968.45183634],[1101196.64409514,1160799.66818763],[976196.64409514,1232968.45183634],[976196.64409514,1377306.01913374]]]},properties:{hex:"ID2604"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1226196.64409514,1377306.01913374],[1351196.64409514,1449474.80278245],[1426407.7966696888,1406051.6235974682],[1476196.64409514,1377306.01913374],[1476196.64409514,1232968.45183634],[1466331.995833123,1227273.094506803],[1391361.036066069,1183988.5907038855],[1351196.64409514,1160799.66818763],[1312047.125627604,1183402.6532135082],[1226196.64409514,1232968.45183634],[1226196.64409514,1377306.01913374]]]},properties:{hex:"ID2605"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1476196.64409514,1377306.01913374],[1488920.2165428041,1384651.9771114534],[1601196.64409514,1449474.80278245],[1726196.64409514,1377306.01913374],[1726196.64409514,1232968.45183634],[1601196.64409514,1160799.66818763],[1484271.5661125912,1228306.3934358787],[1476196.64409514,1232968.45183634],[1476196.64409514,1377306.01913374]]]},properties:{hex:"ID2606"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1726196.64409514,1377306.01913374],[1851196.64409514,1449474.80278245],[1976196.64409514,1377306.01913374],[1976196.64409514,1232968.45183634],[1851196.64409514,1160799.66818763],[1726196.64409514,1232968.45183634],[1726196.64409514,1377306.01913374]]]},properties:{hex:"ID2607"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1976196.64409514,1377306.01913374],[2101196.64409514,1449474.80278245],[2226196.64409514,1377306.01913374],[2226196.64409514,1355262.428421225],[2226196.64409514,1232968.45183634],[2101196.64409514,1160799.66818763],[2075630.261069728,1175560.426309558],[1976196.64409514,1232968.45183634],[1976196.64409514,1377306.01913374]]]},properties:{hex:"ID2608"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2226196.64409514,1377306.01913374],[2267511.395813897,1401159.102160069],[2351196.64409514,1449474.80278245],[2476196.64409514,1377306.01913374],[2476196.64409514,1232968.45183634],[2351196.64409514,1160799.66818763],[2348345.611716657,1162445.7124988157],[2226196.64409514,1232968.45183634],[2226196.64409514,1355262.428421225],[2226196.64409514,1377306.01913374]]]},properties:{hex:"ID2609"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2476196.64409514,1377306.01913374],[2601196.64409514,1449474.80278245],[2726196.64409514,1377306.01913374],[2726196.64409514,1232968.45183634],[2634971.943299669,1180299.8462753266],[2601196.64409514,1160799.66818763],[2477939.337886498,1231962.3071067843],[2476196.64409514,1232968.45183634],[2476196.64409514,1377306.01913374]]]},properties:{hex:"ID2610"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2726196.64409514,1377306.01913374],[2851196.64409514,1449474.80278245],[2976196.64409514,1377306.01913374],[2976196.64409514,1267420.1945489128],[2976196.64409514,1232968.45183634],[2868727.2101123612,1170920.94519672],[2851196.64409514,1160799.66818763],[2726196.64409514,1232968.45183634],[2726196.64409514,1377306.01913374]]]},properties:{hex:"ID2611"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2976196.64409514,1377306.01913374],[3101196.64409514,1449474.80278245],[3203248.0964969774,1390555.3692670513],[3226196.64409514,1377306.01913374],[3226196.64409514,1232968.45183634],[3101196.64409514,1160799.66818763],[2976196.64409514,1232968.45183634],[2976196.64409514,1267420.1945489128],[2976196.64409514,1377306.01913374]]]},properties:{hex:"ID2612"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3226196.64409514,1377306.01913374],[3276591.2675260087,1406401.3685372646],[3351196.64409514,1449474.80278245],[3462639.2749146223,1385133.369879616],[3476196.64409514,1377306.01913374],[3476196.64409514,1232968.45183634],[3387215.888692898,1181595.3887521545],[3366766.9646614036,1169789.1969579316],[3351196.64409514,1160799.66818763],[3226196.64409514,1232968.45183634],[3226196.64409514,1377306.01913374]]]},properties:{hex:"ID2613"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3476196.64409514,1377306.01913374],[3601196.64409514,1449474.80278245],[3726196.64409514,1377306.01913374],[3726196.64409514,1232968.45183634],[3601196.64409514,1160799.66818763],[3476196.64409514,1232968.45183634],[3476196.64409514,1377306.01913374]]]},properties:{hex:"ID2614"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3726196.64409514,1377306.01913374],[3851196.64409514,1449474.80278245],[3976196.64409514,1377306.01913374],[3976196.64409514,1232968.45183634],[3851196.64409514,1160799.66818763],[3726196.64409514,1232968.45183634],[3726196.64409514,1377306.01913374]]]},properties:{hex:"ID2615"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3976196.64409514,1377306.01913374],[4101196.64409514,1449474.80278245],[4133324.6936070384,1430925.664748216],[4226196.64409514,1377306.01913374],[4226196.64409514,1366234.9962242274],[4226196.64409514,1232968.45183634],[4101196.64409514,1160799.66818763],[3976196.64409514,1232968.45183634],[3976196.64409514,1377306.01913374]]]},properties:{hex:"ID2616"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4476196.64409514,1300378.706629994],[4476196.64409514,1232968.45183634],[4351196.64409514,1160799.66818763],[4300194.483922319,1190245.7790926632],[4226196.64409514,1232968.45183634],[4226196.64409514,1366234.9962242274],[4226196.64409514,1377306.01913374],[4274525.908054138,1405208.9326902071],[4286842.147446911,1412319.7168190293],[4301081.062416467,1399411.0893350581],[4322752.507229319,1361240.7933001788],[4346973.1700013345,1330400.786563777],[4379328.484027345,1301722.249682915],[4392030.667199569,1292028.9071815738],[4403030.899692195,1286911.9288278678],[4458171.418070791,1287709.7867976483],[4476196.64409514,1300378.706629994]]]},properties:{hex:"ID2617"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4726196.64409514,1370687.6556832225],[4726196.64409514,1232968.45183634],[4601196.64409514,1160799.66818763],[4476196.64409514,1232968.45183634],[4476196.64409514,1300378.706629994],[4495405.552894348,1313879.5706588442],[4529497.106853746,1332811.2693926622],[4541172.043596556,1336738.6682068594],[4562165.815981318,1331558.0656870282],[4585023.079667919,1330011.0262234164],[4605920.262084106,1324248.3862419464],[4616196.825474008,1325699.572419625],[4654960.272847421,1347728.5342142675],[4678679.995990741,1369153.0198698782],[4695267.630715248,1378251.2544987206],[4702078.8858973365,1378347.1468446087],[4726196.64409514,1370687.6556832225]]]},properties:{hex:"ID2618"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4915221.167817432,1412510.2267766404],[4976196.64409514,1377306.01913374],[4976196.64409514,1232968.45183634],[4863425.541032296,1167860.0251261897],[4851196.64409514,1160799.66818763],[4726196.64409514,1232968.45183634],[4726196.64409514,1370687.6556832225],[4726348.321140882,1370639.4849958096],[4756457.815071316,1373995.932293803],[4796477.675400602,1392502.1668356848],[4809401.230262481,1396229.3344275253],[4819464.083904936,1396492.9868610715],[4842815.820748128,1388175.5869937357],[4846289.256880428,1388613.048190883],[4858393.344422546,1390135.1572999684],[4889935.183324914,1398955.7036888932],[4913909.460746344,1412232.8584130122],[4915221.167817432,1412510.2267766404]]]},properties:{hex:"ID2619"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[5049854.656246899,1190441.9786925465],[4976196.64409514,1232968.45183634],[4976196.64409514,1377306.01913374],[5064414.754454335,1428238.7688970303],[5061218.87449451,1418882.6897911353],[5057933.203870601,1398086.8695348443],[5064493.303678462,1366311.887890525],[5070714.9027001085,1314755.1754864585],[5070410.535842375,1307264.3032222786],[5068407.68491103,1299886.8256809046],[5067792.705365916,1294074.4252321515],[5063688.202975439,1292040.9044774978],[5062082.880112934,1288699.6017372988],[5065301.412253935,1287367.848447833],[5077248.180181961,1292994.6848755926],[5076468.75943039,1299149.0476109725],[5076952.281928516,1302196.0954405672],[5087710.796092933,1295322.1105892267],[5095232.820825712,1292442.8130553376],[5097858.315725018,1285976.0873041],[5097660.3971904805,1281542.7191666542],[5085945.282075329,1283582.4528181218],[5079774.035832076,1287013.9110287076],[5063087.583415681,1281374.7392532553],[5053079.494089412,1275279.278291585],[5050754.941818552,1265151.3605708862],[5051488.055204057,1224719.7269123537],[5049436.392785951,1198449.1099615071],[5049854.656246899,1190441.9786925465]]]},properties:{hex:"ID2620"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[-1648803.35590486,1547136.3763425725],[-1648803.35590486,1523508.1978723449],[-1648803.35590486,1521645.3207964618],[-1650854.4801602124,1523069.7692590319],[-1654040.8082747692,1528568.3749204203],[-1657607.394052816,1537488.6282636633],[-1654971.1844207004,1544015.1818838734],[-1648803.35590486,1547136.3763425725]]],[[[-1653269.3816555804,1596390.8312492375],[-1648803.35590486,1593812.37007985],[-1648804.4870389793,1553531.8415487278],[-1648849.8625458893,1553496.011385789],[-1653114.32745622,1551324.788465287],[-1655319.4596977963,1556588.2600471203],[-1656183.6955215756,1561701.877373823],[-1654136.2427925526,1565643.0317914225],[-1654386.370884718,1587803.2262852509],[-1653269.3816555804,1596390.8312492375]]]]},properties:{hex:"ID2675"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[-1529622.6358729303,1662621.390872498],[-1523803.35590486,1665981.15372856],[-1502742.9736262963,1653821.9363507938],[-1398803.35590486,1593812.37007985],[-1398803.35590486,1562381.2630914787],[-1398803.35590486,1449474.80278245],[-1450871.9158910369,1419413.0056581139],[-1457188.1890350142,1415766.3036581632],[-1520523.8580442201,1379199.4381063923],[-1524483.9875163608,1383555.1512941418],[-1525063.852876084,1389565.8674613999],[-1524240.1763718408,1397943.0617082992],[-1519532.9204633252,1403293.7591542355],[-1520091.4261642862,1405534.6077063114],[-1524478.1360358123,1406163.7130464069],[-1529447.6072863287,1404725.7516067282],[-1532400.3847826035,1407248.1606289109],[-1527116.5014181808,1418115.887322153],[-1509398.6982863331,1427245.2056937865],[-1500583.8181785282,1428185.6405618999],[-1491511.845776918,1430252.1666065445],[-1496223.7524872625,1438074.5833928734],[-1506820.7488374196,1441165.027501312],[-1515420.9889991493,1439008.9150280869],[-1519828.5618523608,1433330.9024464574],[-1525130.481566715,1432390.5216127227],[-1533558.1962866816,1445704.6709243464],[-1533206.2828514602,1452399.9205521136],[-1529714.244547603,1460304.2114597575],[-1524524.4367757158,1463854.922410033],[-1504265.5591757707,1463753.1333776144],[-1496454.529099084,1468213.776687213],[-1493327.304817371,1469028.0439926803],[-1490274.6348458296,1473081.305365864],[-1490822.6600683571,1475775.3921772647],[-1494106.02087354,1475931.047968592],[-1501823.103484143,1470662.5428761407],[-1526158.6576401894,1472656.230696355],[-1534032.1922317918,1469471.0980046322],[-1547947.6163656486,1457304.2575111338],[-1564826.413536948,1450573.4493167012],[-1576848.3747544517,1453411.948973305],[-1572515.988977165,1469728.5472730498],[-1574179.5776433414,1471949.7639678621],[-1577915.2056930512,1474625.9253723756],[-1595830.829863186,1469435.1747903654],[-1609044.728720543,1476894.910294873],[-1614087.8258247278,1485904.4078409525],[-1612832.1693244856,1497199.3679138036],[-1606263.1173599665,1504836.237156042],[-1605143.100750725,1508642.4454917572],[-1611812.766317485,1509366.5632558933],[-1624263.1475389672,1504602.8320312265],[-1648803.35590486,1521645.3207964618],[-1648803.35590486,1523508.1978723449],[-1648803.35590486,1547136.3763425725],[-1646673.0671723343,1548214.3968112532],[-1634212.7179750975,1553705.3549149705],[-1627872.4688271328,1550882.1629810845],[-1624111.803321467,1550744.5897102226],[-1623300.32262974,1554267.5891796586],[-1624440.5211745305,1556145.6629405988],[-1633546.1977830348,1560924.3889231377],[-1638161.3832586722,1567227.8125288174],[-1642247.835191196,1563537.9168628745],[-1645926.0740494686,1555804.7419181727],[-1648804.4870389793,1553531.8415487278],[-1648803.35590486,1593812.37007985],[-1600494.927700994,1621703.2541074853],[-1536971.4652134748,1658378.5422745189],[-1524148.323964732,1658219.1356566928],[-1519795.3761645234,1659407.8242678724],[-1520785.6609698075,1661223.6747588469],[-1529622.6358729303,1662621.390872498]]],[[[-1539291.9535284243,1422794.4790942876],[-1540298.4602730128,1419943.023102064],[-1545856.6781120244,1422363.1722149549],[-1537351.0894035967,1432684.0173298789],[-1531947.7875372907,1434486.8984441808],[-1532360.705060579,1426538.3755478717],[-1536543.2997524692,1424861.1292124086],[-1539291.9535284243,1422794.4790942876]]],[[[-1574017.0495416597,1414060.1129877039],[-1578769.9426809286,1410207.8579046172],[-1583518.6807552616,1412017.1800344726],[-1585993.0384748902,1415449.9999957148],[-1585436.8403753499,1421602.389768665],[-1579767.3938994457,1430312.0652013698],[-1574928.935899139,1429185.964916588],[-1574017.0495416597,1414060.1129877039]]],[[[-1580926.8745290358,1465112.3065602728],[-1586497.495165304,1450112.3342059862],[-1592791.1357712776,1451765.1512319834],[-1596972.5848909211,1460693.419519468],[-1597363.3865305157,1464471.64165937],[-1584415.8403756751,1465681.117252725],[-1580926.8745290358,1465112.3065602728]]]]},properties:{hex:"ID2676"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1398803.35590486,1593812.37007985],[-1273803.35590486,1665981.15372856],[-1148803.35590486,1593812.37007985],[-1148803.35590486,1530656.3947031456],[-1148803.35590486,1449474.80278245],[-1273803.35590486,1377306.01913374],[-1380040.6092350837,1438642.125941917],[-1398803.35590486,1449474.80278245],[-1398803.35590486,1562381.2630914787],[-1398803.35590486,1593812.37007985]]]},properties:{hex:"ID2677"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1148803.35590486,1593812.37007985],[-1128629.9072873322,1605459.516069664],[-1023803.35590486,1665981.15372856],[-898803.35590486,1593812.37007985],[-898803.35590486,1533219.776403582],[-898803.35590486,1449474.80278245],[-1023803.35590486,1377306.01913374],[-1148803.35590486,1449474.80278245],[-1148803.35590486,1530656.3947031456],[-1148803.35590486,1593812.37007985]]]},properties:{hex:"ID2678"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-898803.35590486,1593812.37007985],[-773803.35590486,1665981.15372856],[-648803.35590486,1593812.37007985],[-648803.35590486,1449474.80278245],[-773803.35590486,1377306.01913374],[-860040.5029093777,1427095.0591709483],[-898803.35590486,1449474.80278245],[-898803.35590486,1533219.776403582],[-898803.35590486,1593812.37007985]]]},properties:{hex:"ID2679"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-648803.35590486,1593812.37007985],[-523803.35590486,1665981.15372856],[-425173.0086271747,1609036.8961775168],[-398803.35590486,1593812.37007985],[-398803.35590486,1449474.80278245],[-523803.35590486,1377306.01913374],[-526577.3741737936,1378907.599328046],[-648803.35590486,1449474.80278245],[-648803.35590486,1593812.37007985]]]},properties:{hex:"ID2680"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-398803.35590486,1593812.37007985],[-343615.2282129706,1625675.2504588368],[-340075.9581900636,1627718.6489592972],[-273803.35590486,1665981.15372856],[-148803.35590486,1593812.37007985],[-148803.35590486,1449474.80278245],[-273803.35590486,1377306.01913374],[-398803.35590486,1449474.80278245],[-398803.35590486,1593812.37007985]]]},properties:{hex:"ID2681"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-148803.35590486,1593812.37007985],[-23803.35590486,1665981.15372856],[101196.64409514,1593812.37007985],[101196.64409514,1449474.80278245],[-23803.35590486,1377306.01913374],[-148803.35590486,1449474.80278245],[-148803.35590486,1593812.37007985]]]},properties:{hex:"ID2682"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[101196.64409514,1593812.37007985],[111000.7541561314,1599472.7756627288],[226196.64409514,1665981.15372856],[351196.64409514,1593812.37007985],[351196.64409514,1450245.8711354432],[351196.64409514,1449474.80278245],[226196.64409514,1377306.01913374],[171663.34859979642,1408790.831967777],[101196.64409514,1449474.80278245],[101196.64409514,1593812.37007985]]]},properties:{hex:"ID2683"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[351196.64409514,1593812.37007985],[404864.65473204607,1624797.6104679424],[476196.64409514,1665981.15372856],[601196.64409514,1593812.37007985],[601196.64409514,1449474.80278245],[476196.64409514,1377306.01913374],[359080.44099431904,1444923.0905204723],[351851.3592593727,1449096.8028061378],[351196.64409514,1449474.80278245],[351196.64409514,1450245.8711354432],[351196.64409514,1593812.37007985]]]},properties:{hex:"ID2684"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[601196.64409514,1593812.37007985],[662842.8662449564,1629403.8330325733],[726196.64409514,1665981.15372856],[766469.8652943438,1642729.3986280642],[851196.64409514,1593812.37007985],[851196.64409514,1449474.80278245],[726196.64409514,1377306.01913374],[601196.64409514,1449474.80278245],[601196.64409514,1593812.37007985]]]},properties:{hex:"ID2685"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[851196.64409514,1593812.37007985],[855045.4124157754,1596034.4575058175],[976196.64409514,1665981.15372856],[1021534.44298153,1639805.3633370353],[1101196.64409514,1593812.37007985],[1101196.64409514,1449474.80278245],[976196.64409514,1377306.01913374],[851196.64409514,1449474.80278245],[851196.64409514,1593812.37007985]]]},properties:{hex:"ID2686"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1101196.64409514,1593812.37007985],[1167335.7754852779,1631997.8153919177],[1226196.64409514,1665981.15372856],[1256791.3791156288,1648317.275228694],[1351196.64409514,1593812.37007985],[1351196.64409514,1449474.80278245],[1226196.64409514,1377306.01913374],[1101196.64409514,1449474.80278245],[1101196.64409514,1593812.37007985]]]},properties:{hex:"ID2687"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1351196.64409514,1593812.37007985],[1385620.4720719373,1613686.9764287933],[1476196.64409514,1665981.15372856],[1601196.64409514,1593812.37007985],[1601196.64409514,1449474.80278245],[1488920.2165428041,1384651.9771114534],[1476196.64409514,1377306.01913374],[1426407.7966696888,1406051.6235974682],[1351196.64409514,1449474.80278245],[1351196.64409514,1593812.37007985]]]},properties:{hex:"ID2688"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1601196.64409514,1593812.37007985],[1726196.64409514,1665981.15372856],[1851196.64409514,1593812.37007985],[1851196.64409514,1449474.80278245],[1726196.64409514,1377306.01913374],[1601196.64409514,1449474.80278245],[1601196.64409514,1593812.37007985]]]},properties:{hex:"ID2689"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1851196.64409514,1593812.37007985],[1976196.64409514,1665981.15372856],[2101196.64409514,1593812.37007985],[2101196.64409514,1449474.80278245],[1976196.64409514,1377306.01913374],[1851196.64409514,1449474.80278245],[1851196.64409514,1593812.37007985]]]},properties:{hex:"ID2690"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2101196.64409514,1593812.37007985],[2190540.3023388623,1645394.9552172539],[2226196.64409514,1665981.15372856],[2351196.64409514,1593812.37007985],[2351196.64409514,1449474.80278245],[2267511.395813897,1401159.102160069],[2226196.64409514,1377306.01913374],[2101196.64409514,1449474.80278245],[2101196.64409514,1593812.37007985]]]},properties:{hex:"ID2691"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2351196.64409514,1593812.37007985],[2476196.64409514,1665981.15372856],[2601196.64409514,1593812.37007985],[2601196.64409514,1449474.80278245],[2476196.64409514,1377306.01913374],[2351196.64409514,1449474.80278245],[2351196.64409514,1593812.37007985]]]},properties:{hex:"ID2692"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2601196.64409514,1593812.37007985],[2726196.64409514,1665981.15372856],[2851196.64409514,1593812.37007985],[2851196.64409514,1449474.80278245],[2726196.64409514,1377306.01913374],[2601196.64409514,1449474.80278245],[2601196.64409514,1593812.37007985]]]},properties:{hex:"ID2693"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2851196.64409514,1593812.37007985],[2976196.64409514,1665981.15372856],[3101196.64409514,1593812.37007985],[3101196.64409514,1449474.80278245],[2976196.64409514,1377306.01913374],[2851196.64409514,1449474.80278245],[2851196.64409514,1593812.37007985]]]},properties:{hex:"ID2694"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3101196.64409514,1593812.37007985],[3226196.64409514,1665981.15372856],[3351196.64409514,1593812.37007985],[3351196.64409514,1449474.80278245],[3276591.2675260087,1406401.3685372646],[3226196.64409514,1377306.01913374],[3203248.0964969774,1390555.3692670513],[3101196.64409514,1449474.80278245],[3101196.64409514,1593812.37007985]]]},properties:{hex:"ID2695"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3351196.64409514,1593812.37007985],[3476196.64409514,1665981.15372856],[3565741.611161218,1614282.342888379],[3601196.64409514,1593812.37007985],[3601196.64409514,1449474.80278245],[3476196.64409514,1377306.01913374],[3462639.2749146223,1385133.369879616],[3351196.64409514,1449474.80278245],[3351196.64409514,1593812.37007985]]]},properties:{hex:"ID2696"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3601196.64409514,1593812.37007985],[3726196.64409514,1665981.15372856],[3851196.64409514,1593812.37007985],[3851196.64409514,1449474.80278245],[3726196.64409514,1377306.01913374],[3601196.64409514,1449474.80278245],[3601196.64409514,1593812.37007985]]]},properties:{hex:"ID2697"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3851196.64409514,1593812.37007985],[3976196.64409514,1665981.15372856],[4101196.64409514,1593812.37007985],[4101196.64409514,1449474.80278245],[3976196.64409514,1377306.01913374],[3851196.64409514,1449474.80278245],[3851196.64409514,1593812.37007985]]]},properties:{hex:"ID2698"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4286842.147446911,1412319.7168190293],[4274525.908054138,1405208.9326902071],[4226196.64409514,1377306.01913374],[4133324.6936070384,1430925.664748216],[4101196.64409514,1449474.80278245],[4101196.64409514,1593812.37007985],[4126515.0883440212,1608429.9806824066],[4176650.0392867336,1637375.4081049948],[4179580.6235553375,1628113.5203121935],[4191663.968864868,1629201.0865797081],[4214672.672594872,1604368.553021443],[4222373.965048708,1585471.490215655],[4240058.4024315765,1578625.3617390792],[4242017.1013646815,1589788.1379608072],[4251076.633244613,1580616.4791801171],[4255616.555755377,1566408.5146416987],[4257511.514355868,1560511.7189701137],[4276091.5777766835,1536429.734735234],[4282495.67760293,1524565.617229645],[4289834.191515858,1502861.2504701463],[4287900.843728128,1490764.9546524156],[4284229.629983017,1482887.3785455544],[4278401.795385758,1475841.2465846383],[4257610.427425651,1458615.6272479785],[4233834.528508747,1447621.073263471],[4219788.256482808,1425627.874279227],[4207972.766516965,1427107.4341528781],[4210379.700924699,1418780.8492131145],[4214808.364581359,1417858.2881572268],[4221513.890198586,1419427.8344615055],[4234588.676409931,1425825.5496810686],[4246406.6580616385,1428880.4778244721],[4259377.331576364,1429108.0957566923],[4271359.6164686205,1426352.681959434],[4280323.10503721,1418229.709975036],[4286842.147446911,1412319.7168190293]]]},properties:{hex:"ID2699"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[5064414.754454335,1428238.7688970303],[4976196.64409514,1377306.01913374],[4915221.167817432,1412510.2267766404],[4959380.565081414,1421847.9974023306],[4992433.120297731,1446165.8090286537],[4997503.117156175,1457897.0709146399],[5006777.120049728,1472686.1656003399],[5021778.858726323,1477577.3901750362],[5062861.0320524415,1460202.4182973837],[5069277.735561122,1458819.2171392222],[5067975.1473631365,1448309.7702123357],[5067610.83497754,1437595.4351610397],[5064414.754454335,1428238.7688970303]]]},properties:{hex:"ID2702"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-2385630.0144638414,1829003.0516569351],[-2393533.7677564127,1824354.6194798858],[-2398758.9613145245,1826380.8975857855],[-2403558.266139434,1831190.0903336601],[-2405608.20371618,1838150.0127336993],[-2403285.2288305704,1844132.121910356],[-2392594.174477586,1851209.8780601553],[-2386593.526187465,1848916.2411820912],[-2383907.1170002823,1837941.4636567465],[-2385630.0144638414,1829003.0516569351]]]},properties:{hex:"ID2752"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[-1536971.4652134748,1658378.5422745189],[-1600494.927700994,1621703.2541074853],[-1648803.35590486,1593812.37007985],[-1653269.3816555804,1596390.8312492375],[-1652849.843552103,1599616.3122172018],[-1653089.5788958645,1609945.3481091205],[-1653331.8168271338,1620267.0586288997],[-1657990.1047554184,1643833.9486338755],[-1650299.9602374283,1654151.172385709],[-1642104.1100201553,1660220.1837606688],[-1636898.8770282327,1655363.8183559421],[-1635607.2616655398,1645763.679058626],[-1631702.442301173,1639203.5942513144],[-1617740.6541328363,1635104.7531662912],[-1603676.1915639192,1638050.4436278245],[-1595184.1633359515,1636694.1253791684],[-1595286.5110689714,1642011.713168113],[-1592144.271241506,1649091.3052521294],[-1575098.8578899838,1652126.0706912722],[-1557107.139321056,1654151.172385709],[-1538563.7413039755,1658398.3361254411],[-1536971.4652134748,1658378.5422745189]]],[[[-1652249.067838479,1880498.121962244],[-1648803.35590486,1882487.50467467],[-1523803.35590486,1810318.72102596],[-1523803.35590486,1680977.0407649695],[-1523803.35590486,1665981.15372856],[-1529622.6358729303,1662621.390872498],[-1533663.2509916832,1663260.4820685755],[-1561441.9590899344,1658380.4160974254],[-1589620.4611184995,1656946.800281729],[-1611369.344290865,1644114.748315652],[-1620071.5398207766,1645315.6035335101],[-1628457.4096816517,1658135.5086278687],[-1631084.9982185534,1673957.3069670934],[-1633158.1719828353,1686461.8995664418],[-1638719.5752294837,1696421.0924917643],[-1648019.4392615845,1704910.4369515986],[-1649855.2066509123,1712795.9434341188],[-1646354.6776200226,1719671.9450487085],[-1636874.7859056692,1725329.8405220935],[-1634615.7635787986,1729370.0752316231],[-1639493.3018309237,1728767.3364659948],[-1646969.139220022,1725126.927744666],[-1651856.723005776,1724924.0144068594],[-1652050.215186728,1735814.8923457041],[-1659670.5317055762,1749878.130082475],[-1667950.5322153452,1773684.5232056356],[-1677951.96384264,1783435.0428045352],[-1685919.008175196,1802675.705098868],[-1694720.953393884,1810055.757168267],[-1702945.791823736,1813501.1041294334],[-1710107.0807549264,1812791.7819113564],[-1713062.9937842623,1804017.0486902946],[-1721457.7341098792,1816654.222145744],[-1709121.4569839002,1821178.011182499],[-1682518.717723947,1837023.8401929117],[-1652249.067838479,1880498.121962244]]]]},properties:{hex:"ID2755"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1523803.35590486,1810318.72102596],[-1398803.35590486,1882487.50467467],[-1273803.35590486,1810318.72102596],[-1273803.35590486,1665981.15372856],[-1398803.35590486,1593812.37007985],[-1502742.9736262963,1653821.9363507938],[-1523803.35590486,1665981.15372856],[-1523803.35590486,1680977.0407649695],[-1523803.35590486,1810318.72102596]]]},properties:{hex:"ID2756"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1273803.35590486,1810318.72102596],[-1221167.4776264,1840708.0595190641],[-1159594.316335779,1876257.340765064],[-1148803.35590486,1882487.50467467],[-1023803.35590486,1810318.72102596],[-1023803.35590486,1665981.15372856],[-1128629.9072873322,1605459.516069664],[-1148803.35590486,1593812.37007985],[-1273803.35590486,1665981.15372856],[-1273803.35590486,1810318.72102596]]]},properties:{hex:"ID2757"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1023803.35590486,1810318.72102596],[-898803.35590486,1882487.50467467],[-773803.35590486,1810318.72102596],[-773803.35590486,1665981.15372856],[-898803.35590486,1593812.37007985],[-1023803.35590486,1665981.15372856],[-1023803.35590486,1810318.72102596]]]},properties:{hex:"ID2758"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-773803.35590486,1810318.72102596],[-648803.35590486,1882487.50467467],[-523803.35590486,1810318.72102596],[-523803.35590486,1665981.15372856],[-648803.35590486,1593812.37007985],[-773803.35590486,1665981.15372856],[-773803.35590486,1810318.72102596]]]},properties:{hex:"ID2759"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-523803.35590486,1810318.72102596],[-398803.35590486,1882487.50467467],[-273803.35590486,1810318.72102596],[-273803.35590486,1732648.3784968122],[-273803.35590486,1665981.15372856],[-340075.9581900636,1627718.6489592972],[-343615.2282129706,1625675.2504588368],[-398803.35590486,1593812.37007985],[-425173.0086271747,1609036.8961775168],[-523803.35590486,1665981.15372856],[-523803.35590486,1810318.72102596]]]},properties:{hex:"ID2760"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-273803.35590486,1810318.72102596],[-148803.35590486,1882487.50467467],[-83038.81221146842,1844518.327670154],[-23803.35590486,1810318.72102596],[-23803.35590486,1665981.15372856],[-148803.35590486,1593812.37007985],[-273803.35590486,1665981.15372856],[-273803.35590486,1732648.3784968122],[-273803.35590486,1810318.72102596]]]},properties:{hex:"ID2761"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-23803.35590486,1810318.72102596],[20701.882746920375,1836013.8325419165],[21464.00065475994,1836453.8415211618],[34629.89333406829,1844055.173203683],[101196.64409514,1882487.50467467],[119668.47853666013,1871822.7860874312],[226196.64409514,1810318.72102596],[226196.64409514,1665981.15372856],[111000.7541561314,1599472.7756627288],[101196.64409514,1593812.37007985],[-23803.35590486,1665981.15372856],[-23803.35590486,1810318.72102596]]]},properties:{hex:"ID2762"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[226196.64409514,1810318.72102596],[351196.64409514,1882487.50467467],[476196.64409514,1810318.72102596],[476196.64409514,1694859.86218009],[476196.64409514,1665981.15372856],[404864.65473204607,1624797.6104679424],[351196.64409514,1593812.37007985],[226196.64409514,1665981.15372856],[226196.64409514,1810318.72102596]]]},properties:{hex:"ID2763"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[476196.64409514,1810318.72102596],[601196.64409514,1882487.50467467],[726196.64409514,1810318.72102596],[726196.64409514,1665981.15372856],[662842.8662449564,1629403.8330325733],[601196.64409514,1593812.37007985],[476196.64409514,1665981.15372856],[476196.64409514,1694859.86218009],[476196.64409514,1810318.72102596]]]},properties:{hex:"ID2764"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[726196.64409514,1810318.72102596],[851196.64409514,1882487.50467467],[976196.64409514,1810318.72102596],[976196.64409514,1665981.15372856],[855045.4124157754,1596034.4575058175],[851196.64409514,1593812.37007985],[766469.8652943438,1642729.3986280642],[726196.64409514,1665981.15372856],[726196.64409514,1810318.72102596]]]},properties:{hex:"ID2765"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[976196.64409514,1810318.72102596],[1101196.64409514,1882487.50467467],[1226196.64409514,1810318.72102596],[1226196.64409514,1665981.15372856],[1167335.7754852779,1631997.8153919177],[1101196.64409514,1593812.37007985],[1021534.44298153,1639805.3633370353],[976196.64409514,1665981.15372856],[976196.64409514,1810318.72102596]]]},properties:{hex:"ID2766"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1226196.64409514,1810318.72102596],[1351196.64409514,1882487.50467467],[1370348.9762835014,1871429.9005301094],[1476196.64409514,1810318.72102596],[1476196.64409514,1665981.15372856],[1385620.4720719373,1613686.9764287933],[1351196.64409514,1593812.37007985],[1256791.3791156288,1648317.275228694],[1226196.64409514,1665981.15372856],[1226196.64409514,1810318.72102596]]]},properties:{hex:"ID2767"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1476196.64409514,1810318.72102596],[1601196.64409514,1882487.50467467],[1726196.64409514,1810318.72102596],[1726196.64409514,1665981.15372856],[1601196.64409514,1593812.37007985],[1476196.64409514,1665981.15372856],[1476196.64409514,1810318.72102596]]]},properties:{hex:"ID2768"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1726196.64409514,1810318.72102596],[1851196.64409514,1882487.50467467],[1976196.64409514,1810318.72102596],[1976196.64409514,1665981.15372856],[1851196.64409514,1593812.37007985],[1726196.64409514,1665981.15372856],[1726196.64409514,1810318.72102596]]]},properties:{hex:"ID2769"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1976196.64409514,1810318.72102596],[2101196.64409514,1882487.50467467],[2224571.4971263334,1811257.0000658734],[2226196.64409514,1810318.72102596],[2226196.64409514,1665981.15372856],[2190540.3023388623,1645394.9552172539],[2101196.64409514,1593812.37007985],[1976196.64409514,1665981.15372856],[1976196.64409514,1810318.72102596]]]},properties:{hex:"ID2770"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2226196.64409514,1810318.72102596],[2351196.64409514,1882487.50467467],[2476196.64409514,1810318.72102596],[2476196.64409514,1665981.15372856],[2351196.64409514,1593812.37007985],[2226196.64409514,1665981.15372856],[2226196.64409514,1810318.72102596]]]},properties:{hex:"ID2771"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2476196.64409514,1810318.72102596],[2601196.64409514,1882487.50467467],[2726196.64409514,1810318.72102596],[2726196.64409514,1665981.15372856],[2601196.64409514,1593812.37007985],[2476196.64409514,1665981.15372856],[2476196.64409514,1810318.72102596]]]},properties:{hex:"ID2772"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2726196.64409514,1810318.72102596],[2851196.64409514,1882487.50467467],[2976196.64409514,1810318.72102596],[2976196.64409514,1665981.15372856],[2851196.64409514,1593812.37007985],[2726196.64409514,1665981.15372856],[2726196.64409514,1810318.72102596]]]},properties:{hex:"ID2773"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2976196.64409514,1810318.72102596],[3101196.64409514,1882487.50467467],[3226196.64409514,1810318.72102596],[3226196.64409514,1665981.15372856],[3101196.64409514,1593812.37007985],[2976196.64409514,1665981.15372856],[2976196.64409514,1810318.72102596]]]},properties:{hex:"ID2774"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3226196.64409514,1810318.72102596],[3351196.64409514,1882487.50467467],[3476196.64409514,1810318.72102596],[3476196.64409514,1665981.15372856],[3351196.64409514,1593812.37007985],[3226196.64409514,1665981.15372856],[3226196.64409514,1810318.72102596]]]},properties:{hex:"ID2775"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3476196.64409514,1810318.72102596],[3574621.7786001815,1867144.4989274761],[3601196.64409514,1882487.50467467],[3714870.675124451,1816857.7722600214],[3726196.64409514,1810318.72102596],[3726196.64409514,1665981.15372856],[3601196.64409514,1593812.37007985],[3565741.611161218,1614282.342888379],[3476196.64409514,1665981.15372856],[3476196.64409514,1810318.72102596]]]},properties:{hex:"ID2776"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3726196.64409514,1810318.72102596],[3732087.1372428886,1813719.5988304724],[3851196.64409514,1882487.50467467],[3976196.64409514,1810318.72102596],[3976196.64409514,1757987.2096851005],[3976196.64409514,1665981.15372856],[3851196.64409514,1593812.37007985],[3726196.64409514,1665981.15372856],[3726196.64409514,1810318.72102596]]]},properties:{hex:"ID2777"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[4176650.0392867336,1637375.4081049948],[4126515.0883440212,1608429.9806824066],[4101196.64409514,1593812.37007985],[3976196.64409514,1665981.15372856],[3976196.64409514,1757987.2096851005],[3976196.64409514,1810318.72102596],[3997576.0531459465,1822662.1285965585],[4005368.251099514,1815176.0296002172],[4043795.8225007104,1800195.6422516024],[4077832.5676067667,1754221.2517226648],[4098279.9318160606,1722345.7726438171],[4160369.9975185175,1673999.111817631],[4172398.581155131,1650811.8168759516],[4176650.0392867336,1637375.4081049948]]]},properties:{hex:"ID2778"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[-2379279.9799644435,2038096.8983267618],[-2365040.126272267,2046318.2816891635],[-2351321.5816502958,2044213.6714320753],[-2347511.705150274,2040631.9935406276],[-2346335.6718475325,2038071.826802393],[-2352415.69155883,2036735.2704006534],[-2366664.103194005,2041404.1806175935],[-2370723.1888641133,2038547.0398424382],[-2375214.5842711753,2028471.7366500357],[-2379279.9799644435,2038096.8983267618]]],[[[-2239859.056629303,1997332.4904199752],[-2231836.1290302435,1995109.3622621633],[-2228693.0081464546,1995905.8931657874],[-2223519.063526777,1995418.4650064136],[-2218333.6017612983,1989028.0511852086],[-2217669.6321782256,1982238.6412647036],[-2220911.933333852,1973724.095924451],[-2232104.657082566,1966742.744482398],[-2238276.6443076674,1967557.473134905],[-2245267.006481409,1973938.1627413023],[-2240324.9852104587,1986519.2649754686],[-2239859.056629303,1997332.4904199752]]],[[[-2233981.9367855256,2048662.2628377494],[-2237467.8748589875,2042437.708086933],[-2240747.317006222,2051578.3197249249],[-2242686.163658242,2053745.970161444],[-2242904.7397627747,2066874.933487565],[-2237010.79538503,2070787.5381807473],[-2234242.5948203956,2071120.0088272728],[-2234973.724786025,2057546.5954537082],[-2233981.9367855256,2048662.2628377494]]],[[[-2273268.3238471067,1863224.8880107054],[-2276021.886344047,1862778.1607484214],[-2279825.4589890777,1868269.7229435435],[-2278494.0016425345,1875880.9318208704],[-2278843.2459540963,1877887.8128232933],[-2274778.1476041735,1886004.0507140518],[-2267710.591081589,1885295.4822450979],[-2266236.0712671434,1879281.2794509635],[-2266572.9498655614,1866870.0721573797],[-2273268.3238471067,1863224.8880107054]]],[[[-2299831.5079608364,1847510.233429128],[-2306372.0060540223,1836302.8417283064],[-2319326.1922916374,1837202.5989721639],[-2325761.2055552322,1841820.3727147894],[-2332794.1901754867,1855922.0168625119],[-2331943.4705823227,1866804.5558775114],[-2328666.5294105913,1876250.1547881176],[-2328683.798809335,1884449.9537318158],[-2327456.387350859,1886611.3891311402],[-2323530.7768719858,1885194.2575644318],[-2323194.9130310705,1879674.303262975],[-2312119.2564923693,1866167.2578381193],[-2307879.4273780864,1863528.6608640687],[-2299831.5079608364,1847510.233429128]]]]},properties:{hex:"ID2832"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1648803.35590486,1886345.4604983225],[-1648803.35590486,1882487.50467467],[-1652249.067838479,1880498.121962244],[-1650923.7506227144,1882401.586795498],[-1648803.35590486,1886345.4604983225]]]},properties:{hex:"ID2834"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1603440.794622352,2053015.1589396643],[-1523803.35590486,2098993.85562078],[-1434594.4786928068,2047489.086348292],[-1398803.35590486,2026825.07197207],[-1398803.35590486,1882487.50467467],[-1523803.35590486,1810318.72102596],[-1648803.35590486,1882487.50467467],[-1648803.35590486,1886345.4604983225],[-1622058.179104179,1936090.7265912008],[-1618070.2319009162,1948756.603429859],[-1615865.237392644,2003365.4489932118],[-1609690.495508893,2023742.4296135062],[-1607206.0284740233,2041659.5942009524],[-1603440.794622352,2053015.1589396643]]]},properties:{hex:"ID2835"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1398803.35590486,2026825.07197207],[-1389192.646724395,2032373.8175045152],[-1273803.35590486,2098993.85562078],[-1148803.35590486,2026825.07197207],[-1148803.35590486,1902673.0413712827],[-1148803.35590486,1882487.50467467],[-1159594.316335779,1876257.340765064],[-1221167.4776264,1840708.0595190641],[-1273803.35590486,1810318.72102596],[-1398803.35590486,1882487.50467467],[-1398803.35590486,2026825.07197207]]]},properties:{hex:"ID2836"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1148803.35590486,2026825.07197207],[-1023803.35590486,2098993.85562078],[-898803.35590486,2026825.07197207],[-898803.35590486,1907043.3077500549],[-898803.35590486,1882487.50467467],[-1023803.35590486,1810318.72102596],[-1148803.35590486,1882487.50467467],[-1148803.35590486,1902673.0413712827],[-1148803.35590486,2026825.07197207]]]},properties:{hex:"ID2837"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-898803.35590486,2026825.07197207],[-773803.35590486,2098993.85562078],[-648803.35590486,2026825.07197207],[-648803.35590486,1907055.2126249615],[-648803.35590486,1882487.50467467],[-773803.35590486,1810318.72102596],[-898803.35590486,1882487.50467467],[-898803.35590486,1907043.3077500549],[-898803.35590486,2026825.07197207]]]},properties:{hex:"ID2838"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-648803.35590486,2026825.07197207],[-552970.6442384757,2082154.113849834],[-523803.35590486,2098993.85562078],[-398803.35590486,2026825.07197207],[-398803.35590486,1882487.50467467],[-523803.35590486,1810318.72102596],[-648803.35590486,1882487.50467467],[-648803.35590486,1907055.2126249615],[-648803.35590486,2026825.07197207]]]},properties:{hex:"ID2839"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-398803.35590486,2026825.07197207],[-273803.35590486,2098993.85562078],[-148803.35590486,2026825.07197207],[-148803.35590486,1882487.50467467],[-273803.35590486,1810318.72102596],[-398803.35590486,1882487.50467467],[-398803.35590486,2026825.07197207]]]},properties:{hex:"ID2840"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-148803.35590486,2026825.07197207],[-23803.35590486,2098993.85562078],[101196.64409514,2026825.07197207],[101196.64409514,1882487.50467467],[34629.89333406829,1844055.173203683],[21464.00065475994,1836453.8415211618],[20701.882746920375,1836013.8325419165],[-23803.35590486,1810318.72102596],[-83038.81221146842,1844518.327670154],[-148803.35590486,1882487.50467467],[-148803.35590486,2026825.07197207]]]},properties:{hex:"ID2841"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[101196.64409514,2026825.07197207],[226196.64409514,2098993.85562078],[351196.64409514,2026825.07197207],[351196.64409514,1912123.1452264567],[351196.64409514,1882487.50467467],[226196.64409514,1810318.72102596],[119668.47853666013,1871822.7860874312],[101196.64409514,1882487.50467467],[101196.64409514,2026825.07197207]]]},properties:{hex:"ID2842"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[351196.64409514,2026825.07197207],[408766.6344712681,2060063.1214129748],[476196.64409514,2098993.85562078],[601196.64409514,2026825.07197207],[601196.64409514,1882487.50467467],[476196.64409514,1810318.72102596],[351196.64409514,1882487.50467467],[351196.64409514,1912123.1452264567],[351196.64409514,2026825.07197207]]]},properties:{hex:"ID2843"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[601196.64409514,2026825.07197207],[726196.64409514,2098993.85562078],[851196.64409514,2026825.07197207],[851196.64409514,1882487.50467467],[726196.64409514,1810318.72102596],[601196.64409514,1882487.50467467],[601196.64409514,2026825.07197207]]]},properties:{hex:"ID2844"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[851196.64409514,2026825.07197207],[976196.64409514,2098993.85562078],[1101196.64409514,2026825.07197207],[1101196.64409514,1882487.50467467],[976196.64409514,1810318.72102596],[851196.64409514,1882487.50467467],[851196.64409514,2026825.07197207]]]},properties:{hex:"ID2845"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1101196.64409514,2026825.07197207],[1226196.64409514,2098993.85562078],[1351196.64409514,2026825.07197207],[1351196.64409514,1882487.50467467],[1226196.64409514,1810318.72102596],[1101196.64409514,1882487.50467467],[1101196.64409514,2026825.07197207]]]},properties:{hex:"ID2846"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1351196.64409514,2026825.07197207],[1476196.64409514,2098993.85562078],[1509149.0446371597,2079968.7782973987],[1601196.64409514,2026825.07197207],[1601196.64409514,1882487.50467467],[1476196.64409514,1810318.72102596],[1370348.9762835014,1871429.9005301094],[1351196.64409514,1882487.50467467],[1351196.64409514,2026825.07197207]]]},properties:{hex:"ID2847"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1601196.64409514,2026825.07197207],[1726196.64409514,2098993.85562078],[1851196.64409514,2026825.07197207],[1851196.64409514,1882487.50467467],[1726196.64409514,1810318.72102596],[1601196.64409514,1882487.50467467],[1601196.64409514,2026825.07197207]]]},properties:{hex:"ID2848"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1851196.64409514,2026825.07197207],[1976196.64409514,2098993.85562078],[2101196.64409514,2026825.07197207],[2101196.64409514,1882487.50467467],[1976196.64409514,1810318.72102596],[1851196.64409514,1882487.50467467],[1851196.64409514,2026825.07197207]]]},properties:{hex:"ID2849"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2101196.64409514,2026825.07197207],[2226196.64409514,2098993.85562078],[2341809.507259451,2032244.7379510754],[2351196.64409514,2026825.07197207],[2351196.64409514,1882487.50467467],[2226196.64409514,1810318.72102596],[2224571.4971263334,1811257.0000658734],[2101196.64409514,1882487.50467467],[2101196.64409514,2026825.07197207]]]},properties:{hex:"ID2850"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2351196.64409514,2026825.07197207],[2476196.64409514,2098993.85562078],[2601196.64409514,2026825.07197207],[2601196.64409514,1882487.50467467],[2476196.64409514,1810318.72102596],[2351196.64409514,1882487.50467467],[2351196.64409514,2026825.07197207]]]},properties:{hex:"ID2851"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2601196.64409514,2026825.07197207],[2726196.64409514,2098993.85562078],[2851196.64409514,2026825.07197207],[2851196.64409514,1882487.50467467],[2726196.64409514,1810318.72102596],[2601196.64409514,1882487.50467467],[2601196.64409514,2026825.07197207]]]},properties:{hex:"ID2852"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2851196.64409514,2026825.07197207],[2976196.64409514,2098993.85562078],[3101196.64409514,2026825.07197207],[3101196.64409514,1882487.50467467],[2976196.64409514,1810318.72102596],[2851196.64409514,1882487.50467467],[2851196.64409514,2026825.07197207]]]},properties:{hex:"ID2853"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3101196.64409514,2026825.07197207],[3226196.64409514,2098993.85562078],[3351196.64409514,2026825.07197207],[3351196.64409514,1882487.50467467],[3226196.64409514,1810318.72102596],[3101196.64409514,1882487.50467467],[3101196.64409514,2026825.07197207]]]},properties:{hex:"ID2854"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3351196.64409514,2026825.07197207],[3476196.64409514,2098993.85562078],[3601196.64409514,2026825.07197207],[3601196.64409514,1973683.3680282752],[3601196.64409514,1882487.50467467],[3574621.7786001815,1867144.4989274761],[3476196.64409514,1810318.72102596],[3351196.64409514,1882487.50467467],[3351196.64409514,2026825.07197207]]]},properties:{hex:"ID2855"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3851196.64409514,1950982.9164593937],[3851196.64409514,1882487.50467467],[3732087.1372428886,1813719.5988304724],[3726196.64409514,1810318.72102596],[3714870.675124451,1816857.7722600214],[3601196.64409514,1882487.50467467],[3601196.64409514,1973683.3680282752],[3601196.64409514,2026825.07197207],[3603708.0113915578,2028275.010556691],[3726196.64409514,2098993.85562078],[3822642.187970079,2043310.9949024396],[3833932.600032303,1992030.1403787183],[3844650.9843446813,1958832.794827773],[3851196.64409514,1950982.9164593937]]]},properties:{hex:"ID2856"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[3997576.0531459465,1822662.1285965585],[3976196.64409514,1810318.72102596],[3851196.64409514,1882487.50467467],[3851196.64409514,1950982.9164593937],[3858306.2752239476,1942456.6957676949],[3869532.3112241044,1911436.0606145796],[3876722.2598291817,1910263.498061772],[3882670.9034249736,1901733.5195995313],[3894194.670096032,1872605.477958651],[3901555.673686561,1861771.5245082662],[3904006.531340139,1871092.759968485],[3903128.444428773,1876464.54138578],[3899803.6015593694,1885432.4330394727],[3900976.298036602,1896982.921956384],[3905243.7010199185,1903900.3456689983],[3917366.104628837,1894488.4242883793],[3924190.9480318488,1887343.7604601844],[3927195.638479426,1873022.3627667243],[3930520.551709356,1865077.2855716895],[3943869.4039743207,1848260.9021898115],[3954251.9340127846,1843369.4916307598],[3967243.637719482,1842142.1156809893],[3978360.751640159,1838436.0218660673],[3987582.8960639527,1832262.726996083],[3997576.0531459465,1822662.1285965585]]],[[[3929752.0647260468,1931425.9189861014],[3934429.7844968997,1924939.8528694261],[3937197.955845998,1925576.5869952329],[3939205.1497155777,1927736.6761097708],[3940324.3569242023,1932318.4463393341],[3956691.2858014824,1923267.652386527],[3956380.2977529834,1917256.8991435133],[3947171.8819433814,1916947.4196938036],[3936261.8065172257,1919482.7275361202],[3926487.58495994,1918601.9274766871],[3914489.773680204,1921226.4386637514],[3910784.289595246,1931425.9189861014],[3918750.8808916267,1926487.0464978844],[3922501.650912047,1927736.6761097708],[3923062.5038815485,1929045.7862071015],[3917083.065286854,1935947.9313288052],[3909473.618203557,1937322.3226856678],[3909459.432970725,1942748.2064703973],[3912595.2489599353,1944883.928455984],[3914400.1940478464,1947525.225078619],[3909386.2777462658,1954972.622527762],[3917952.262568137,1953277.4041742345],[3923700.4033618686,1948768.5006904881],[3927707.1619327604,1943503.7485001027],[3929752.0647260468,1931425.9189861014]]],[[[3918761.644319211,1978480.9661328786],[3923222.497717546,1966707.0626977403],[3913223.522358087,1971202.810292801],[3911385.738999606,1973640.8475231777],[3915122.2036053124,1978302.5899362622],[3915723.379823724,1981168.4400482294],[3918761.644319211,1978480.9661328786]]]]},properties:{hex:"ID2857"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[-2365040.126272267,2046318.2816891635],[-2379279.9799644435,2038096.8983267618],[-2381652.7987832744,2043714.7437922454],[-2380793.922905969,2049315.5667253789],[-2379109.2113849437,2050936.9179560463],[-2369053.212452752,2046933.9433771025],[-2365040.126272267,2046318.2816891635]]],[[[-2427811.5972714643,2068003.0245868296],[-2436008.744982992,2065093.6941429225],[-2440943.6952700876,2065461.8212425376],[-2447793.048102194,2069754.4926918205],[-2445249.1403958914,2074397.1213390057],[-2437194.1272535347,2079567.7094374415],[-2431804.1915041516,2080648.0746166154],[-2428058.2544647357,2071452.4776405117],[-2427811.5972714643,2068003.0245868296]]],[[[-2454363.915548182,2083610.074921663],[-2464029.2446469525,2081111.0823096058],[-2467953.427296762,2082316.072752308],[-2468634.8667258713,2091984.7974760965],[-2470120.7012077444,2098346.6640672823],[-2469496.8500618767,2101177.238549833],[-2446864.1086511333,2113649.1446749573],[-2439325.5523010995,2111560.788162919],[-2434630.5224516084,2101628.219085743],[-2438642.951903389,2096109.4060353772],[-2454363.915548182,2083610.074921663]]]]},properties:{hex:"ID2915"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1559360.601926985,2263860.408480696],[-1523803.35590486,2243331.42291818],[-1523803.35590486,2098993.85562078],[-1603440.794622352,2053015.1589396643],[-1594105.1757107663,2081170.4420117645],[-1579137.0235946905,2113518.6245591403],[-1564743.1806622818,2156426.2598591307],[-1558175.77994852,2197945.4002815336],[-1557931.4147649717,2238599.3531307727],[-1559360.601926985,2263860.408480696]]]},properties:{hex:"ID2918"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1523803.35590486,2243331.42291818],[-1398803.35590486,2315500.20656689],[-1273803.35590486,2243331.42291818],[-1273803.35590486,2098993.85562078],[-1389192.646724395,2032373.8175045152],[-1398803.35590486,2026825.07197207],[-1434594.4786928068,2047489.086348292],[-1523803.35590486,2098993.85562078],[-1523803.35590486,2243331.42291818]]]},properties:{hex:"ID2919"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1273803.35590486,2243331.42291818],[-1148803.35590486,2315500.20656688],[-1023803.35590486,2243331.42291818],[-1023803.35590486,2098993.85562078],[-1148803.35590486,2026825.07197207],[-1273803.35590486,2098993.85562078],[-1273803.35590486,2243331.42291818]]]},properties:{hex:"ID2920"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1023803.35590486,2243331.42291818],[-898803.35590486,2315500.20656689],[-773803.35590486,2243331.42291818],[-773803.35590486,2098993.85562078],[-898803.35590486,2026825.07197207],[-1023803.35590486,2098993.85562078],[-1023803.35590486,2243331.42291818]]]},properties:{hex:"ID2921"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-773803.35590486,2243331.42291818],[-648803.35590486,2315500.20656688],[-567091.2800713587,2268323.717588367],[-523803.35590486,2243331.42291818],[-523803.35590486,2098993.85562078],[-552970.6442384757,2082154.113849834],[-648803.35590486,2026825.07197207],[-773803.35590486,2098993.85562078],[-773803.35590486,2243331.42291818]]]},properties:{hex:"ID2922"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-523803.35590486,2243331.42291818],[-398803.35590486,2315500.20656688],[-273803.35590486,2243331.42291818],[-273803.35590486,2098993.85562078],[-398803.35590486,2026825.07197207],[-523803.35590486,2098993.85562078],[-523803.35590486,2243331.42291818]]]},properties:{hex:"ID2923"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-273803.35590486,2243331.42291818],[-148803.35590486,2315500.20656688],[-23803.35590486,2243331.42291818],[-23803.35590486,2098993.85562078],[-148803.35590486,2026825.07197207],[-273803.35590486,2098993.85562078],[-273803.35590486,2243331.42291818]]]},properties:{hex:"ID2924"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-23803.35590486,2243331.42291818],[101196.64409514,2315500.20656689],[226196.64409514,2243331.42291818],[226196.64409514,2098993.85562078],[101196.64409514,2026825.07197207],[-23803.35590486,2098993.85562078],[-23803.35590486,2243331.42291818]]]},properties:{hex:"ID2925"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[226196.64409514,2243331.42291818],[351196.64409514,2315500.20656689],[410100.52191762987,2281492.0368497595],[476196.64409514,2243331.42291818],[476196.64409514,2098993.85562078],[408766.6344712681,2060063.1214129748],[351196.64409514,2026825.07197207],[226196.64409514,2098993.85562078],[226196.64409514,2243331.42291818]]]},properties:{hex:"ID2926"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[476196.64409514,2243331.42291818],[601196.64409514,2315500.20656688],[726196.64409514,2243331.42291818],[726196.64409514,2098993.85562078],[601196.64409514,2026825.07197207],[476196.64409514,2098993.85562078],[476196.64409514,2243331.42291818]]]},properties:{hex:"ID2927"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[726196.64409514,2243331.42291818],[851196.64409514,2315500.20656689],[976196.64409514,2243331.42291818],[976196.64409514,2098993.85562078],[851196.64409514,2026825.07197207],[726196.64409514,2098993.85562078],[726196.64409514,2243331.42291818]]]},properties:{hex:"ID2928"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[976196.64409514,2243331.42291818],[1101196.64409514,2315500.20656688],[1226196.64409514,2243331.42291818],[1226196.64409514,2098993.85562078],[1101196.64409514,2026825.07197207],[976196.64409514,2098993.85562078],[976196.64409514,2243331.42291818]]]},properties:{hex:"ID2929"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1226196.64409514,2243331.42291818],[1351196.64409514,2315500.20656689],[1476196.64409514,2243331.42291818],[1476196.64409514,2098993.85562078],[1351196.64409514,2026825.07197207],[1226196.64409514,2098993.85562078],[1226196.64409514,2243331.42291818]]]},properties:{hex:"ID2930"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1476196.64409514,2243331.42291818],[1513834.4584116833,2265061.6251455443],[1601196.64409514,2315500.20656688],[1726196.64409514,2243331.42291818],[1726196.64409514,2098993.85562078],[1601196.64409514,2026825.07197207],[1509149.0446371597,2079968.7782973987],[1476196.64409514,2098993.85562078],[1476196.64409514,2243331.42291818]]]},properties:{hex:"ID2931"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1726196.64409514,2243331.42291818],[1851196.64409514,2315500.20656689],[1976196.64409514,2243331.42291818],[1976196.64409514,2098993.85562078],[1851196.64409514,2026825.07197207],[1726196.64409514,2098993.85562078],[1726196.64409514,2243331.42291818]]]},properties:{hex:"ID2932"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1976196.64409514,2243331.42291818],[2101196.64409514,2315500.20656688],[2226196.64409514,2243331.42291818],[2226196.64409514,2098993.85562078],[2101196.64409514,2026825.07197207],[1976196.64409514,2098993.85562078],[1976196.64409514,2243331.42291818]]]},properties:{hex:"ID2933"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2226196.64409514,2243331.42291818],[2323994.1610830515,2299794.8456772254],[2351196.64409514,2315500.20656688],[2476196.64409514,2243331.42291818],[2476196.64409514,2098993.85562078],[2351196.64409514,2026825.07197207],[2341809.507259451,2032244.7379510754],[2226196.64409514,2098993.85562078],[2226196.64409514,2243331.42291818]]]},properties:{hex:"ID2934"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2476196.64409514,2243331.42291818],[2601196.64409514,2315500.20656689],[2726196.64409514,2243331.42291818],[2726196.64409514,2098993.85562078],[2601196.64409514,2026825.07197207],[2476196.64409514,2098993.85562078],[2476196.64409514,2243331.42291818]]]},properties:{hex:"ID2935"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2726196.64409514,2243331.42291818],[2851196.64409514,2315500.20656688],[2976196.64409514,2243331.42291818],[2976196.64409514,2098993.85562078],[2851196.64409514,2026825.07197207],[2726196.64409514,2098993.85562078],[2726196.64409514,2243331.42291818]]]},properties:{hex:"ID2936"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2976196.64409514,2243331.42291818],[3101196.64409514,2315500.20656689],[3226196.64409514,2243331.42291818],[3226196.64409514,2098993.85562078],[3101196.64409514,2026825.07197207],[2976196.64409514,2098993.85562078],[2976196.64409514,2243331.42291818]]]},properties:{hex:"ID2937"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3226196.64409514,2243331.42291818],[3351196.64409514,2315500.20656688],[3476196.64409514,2243331.42291818],[3476196.64409514,2098993.85562078],[3351196.64409514,2026825.07197207],[3226196.64409514,2098993.85562078],[3226196.64409514,2243331.42291818]]]},properties:{hex:"ID2938"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3726196.64409514,2234950.8225385263],[3726196.64409514,2168765.785262837],[3726196.64409514,2098993.85562078],[3603708.0113915578,2028275.010556691],[3601196.64409514,2026825.07197207],[3476196.64409514,2098993.85562078],[3476196.64409514,2243331.42291818],[3601196.64409514,2315500.20656688],[3692625.0745722223,2262713.977619359],[3694034.192600092,2261220.014897153],[3700297.7162242504,2251952.705642413],[3708553.8593458026,2241784.0897276034],[3713247.422563898,2243601.3199800467],[3715956.8338916404,2246306.336895589],[3721687.9128436535,2238102.0914565194],[3726196.64409514,2234950.8225385263]]]},properties:{hex:"ID2939"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3822642.187970079,2043310.9949024396],[3726196.64409514,2098993.85562078],[3726196.64409514,2168765.785262837],[3726196.64409514,2234950.8225385263],[3747033.7964552026,2220387.1976717524],[3751372.4081889247,2212155.4348862683],[3788281.8967708605,2142012.58326152],[3804587.768270502,2100512.629408449],[3819587.7148276945,2057184.3586023643],[3822642.187970079,2043310.9949024396]]]},properties:{hex:"ID2940"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[-1572689.5258053592,2503798.3788459366],[-1523803.35590486,2532006.55751299],[-1398803.35590486,2459837.77386429],[-1398803.35590486,2315500.20656689],[-1523803.35590486,2243331.42291818],[-1559360.601926985,2263860.408480696],[-1559975.0964131209,2274721.672588772],[-1565170.2470380918,2298580.9778991714],[-1569622.6167810312,2333103.1642419077],[-1577721.8189590408,2351312.824805412],[-1593408.5024891999,2367189.4121285398],[-1596645.562431712,2376489.8487904174],[-1592638.8735842113,2379955.6794693335],[-1582513.7348398967,2382329.0784149505],[-1575516.55566554,2394707.9461521674],[-1589245.5486697112,2389932.6654474293],[-1571737.8162578947,2427880.569106961],[-1565583.5640888603,2453703.793330914],[-1565484.0255421617,2470638.796037737],[-1561985.8279029117,2481098.7055312726],[-1572682.6043942994,2503772.8610609164],[-1572689.5258053592,2503798.3788459366]]],[[[-1580914.0420398684,2418129.285885088],[-1587708.8789493463,2406387.5046518743],[-1590226.430979026,2410872.122897725],[-1590899.0024395844,2418601.260560646],[-1584847.9948219438,2429667.8054218637],[-1581959.6951607037,2435382.9972726414],[-1577068.1043752362,2437429.4561878173],[-1580914.0420398684,2418129.285885088]]]]},properties:{hex:"ID3003"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1398803.35590486,2459837.77386429],[-1273803.35590486,2532006.55751299],[-1148803.35590486,2459837.77386429],[-1148803.35590486,2315500.20656688],[-1273803.35590486,2243331.42291818],[-1398803.35590486,2315500.20656689],[-1398803.35590486,2459837.77386429]]]},properties:{hex:"ID3004"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1148803.35590486,2459837.77386429],[-1023803.35590486,2532006.55751299],[-898803.35590486,2459837.77386429],[-898803.35590486,2315500.20656689],[-1023803.35590486,2243331.42291818],[-1148803.35590486,2315500.20656688],[-1148803.35590486,2459837.77386429]]]},properties:{hex:"ID3005"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-898803.35590486,2459837.77386429],[-773803.35590486,2532006.55751299],[-648803.35590486,2459837.77386429],[-648803.35590486,2315500.20656688],[-773803.35590486,2243331.42291818],[-898803.35590486,2315500.20656689],[-898803.35590486,2459837.77386429]]]},properties:{hex:"ID3006"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-648803.35590486,2459837.77386429],[-583903.1140768849,2497307.9459541417],[-523803.35590486,2532006.55751299],[-398803.35590486,2459837.77386429],[-398803.35590486,2315500.20656688],[-523803.35590486,2243331.42291818],[-567091.2800713587,2268323.717588367],[-648803.35590486,2315500.20656688],[-648803.35590486,2459837.77386429]]]},properties:{hex:"ID3007"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-398803.35590486,2459837.77386429],[-273803.35590486,2532006.55751299],[-148803.35590486,2459837.77386429],[-148803.35590486,2315500.20656688],[-273803.35590486,2243331.42291818],[-398803.35590486,2315500.20656688],[-398803.35590486,2459837.77386429]]]},properties:{hex:"ID3008"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-148803.35590486,2459837.77386429],[-23803.35590486,2532006.55751299],[101196.64409514,2459837.77386429],[101196.64409514,2315500.20656689],[-23803.35590486,2243331.42291818],[-148803.35590486,2315500.20656688],[-148803.35590486,2459837.77386429]]]},properties:{hex:"ID3009"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[101196.64409514,2459837.77386429],[165178.99717322184,2496778.002637305],[226196.64409514,2532006.55751299],[351196.64409514,2459837.77386429],[351196.64409514,2336488.313528897],[351196.64409514,2315500.20656689],[226196.64409514,2243331.42291818],[101196.64409514,2315500.20656689],[101196.64409514,2459837.77386429]]]},properties:{hex:"ID3010"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[351196.64409514,2459837.77386429],[476196.64409514,2532006.55751299],[601196.64409514,2459837.77386429],[601196.64409514,2431454.0416222946],[601196.64409514,2315500.20656688],[476196.64409514,2243331.42291818],[410100.52191762987,2281492.0368497595],[351196.64409514,2315500.20656689],[351196.64409514,2336488.313528897],[351196.64409514,2459837.77386429]]]},properties:{hex:"ID3011"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[601196.64409514,2459837.77386429],[655371.899137285,2491115.871946288],[726196.64409514,2532006.55751299],[851196.64409514,2459837.77386429],[851196.64409514,2315500.20656689],[726196.64409514,2243331.42291818],[601196.64409514,2315500.20656688],[601196.64409514,2431454.0416222946],[601196.64409514,2459837.77386429]]]},properties:{hex:"ID3012"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[851196.64409514,2459837.77386429],[976196.64409514,2532006.55751299],[1101196.64409514,2459837.77386429],[1101196.64409514,2315500.20656688],[976196.64409514,2243331.42291818],[851196.64409514,2315500.20656689],[851196.64409514,2459837.77386429]]]},properties:{hex:"ID3013"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1101196.64409514,2459837.77386429],[1226196.64409514,2532006.55751299],[1351196.64409514,2459837.77386429],[1351196.64409514,2315500.20656689],[1226196.64409514,2243331.42291818],[1101196.64409514,2315500.20656688],[1101196.64409514,2459837.77386429]]]},properties:{hex:"ID3014"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1351196.64409514,2459837.77386429],[1476196.64409514,2532006.55751299],[1536384.972747438,2497256.809763514],[1601196.64409514,2459837.77386429],[1601196.64409514,2315500.20656688],[1513834.4584116833,2265061.6251455443],[1476196.64409514,2243331.42291818],[1351196.64409514,2315500.20656689],[1351196.64409514,2459837.77386429]]]},properties:{hex:"ID3015"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1601196.64409514,2459837.77386429],[1726196.64409514,2532006.55751299],[1851196.64409514,2459837.77386429],[1851196.64409514,2315500.20656689],[1726196.64409514,2243331.42291818],[1601196.64409514,2315500.20656688],[1601196.64409514,2459837.77386429]]]},properties:{hex:"ID3016"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1851196.64409514,2459837.77386429],[1976196.64409514,2532006.55751299],[2101196.64409514,2459837.77386429],[2101196.64409514,2315500.20656688],[1976196.64409514,2243331.42291818],[1851196.64409514,2315500.20656689],[1851196.64409514,2459837.77386429]]]},properties:{hex:"ID3017"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2101196.64409514,2459837.77386429],[2153188.1303783925,2489855.0724654933],[2226196.64409514,2532006.55751299],[2351196.64409514,2459837.77386429],[2351196.64409514,2453073.8878152645],[2351196.64409514,2315500.20656688],[2323994.1610830515,2299794.8456772254],[2226196.64409514,2243331.42291818],[2101196.64409514,2315500.20656688],[2101196.64409514,2459837.77386429]]]},properties:{hex:"ID3018"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2351196.64409514,2459837.77386429],[2406108.1317056646,2491540.936017828],[2476196.64409514,2532006.55751299],[2601196.64409514,2459837.77386429],[2601196.64409514,2315500.20656689],[2476196.64409514,2243331.42291818],[2351196.64409514,2315500.20656688],[2351196.64409514,2453073.8878152645],[2351196.64409514,2459837.77386429]]]},properties:{hex:"ID3019"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2601196.64409514,2459837.77386429],[2726196.64409514,2532006.55751299],[2851196.64409514,2459837.77386429],[2851196.64409514,2315500.20656688],[2726196.64409514,2243331.42291818],[2601196.64409514,2315500.20656689],[2601196.64409514,2459837.77386429]]]},properties:{hex:"ID3020"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2851196.64409514,2459837.77386429],[2976196.64409514,2532006.55751299],[3101196.64409514,2459837.77386429],[3101196.64409514,2315500.20656689],[2976196.64409514,2243331.42291818],[2851196.64409514,2315500.20656688],[2851196.64409514,2459837.77386429]]]},properties:{hex:"ID3021"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3101196.64409514,2459837.77386429],[3226196.64409514,2532006.55751299],[3351196.64409514,2459837.77386429],[3351196.64409514,2315500.20656688],[3226196.64409514,2243331.42291818],[3101196.64409514,2315500.20656689],[3101196.64409514,2459837.77386429]]]},properties:{hex:"ID3022"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3601196.64409514,2393072.873968573],[3601196.64409514,2315500.20656688],[3476196.64409514,2243331.42291818],[3351196.64409514,2315500.20656688],[3351196.64409514,2459837.77386429],[3476196.64409514,2532006.55751299],[3585216.0363771007,2469064.1820321153],[3585337.311757817,2468157.557512631],[3596666.623317782,2428452.727554113],[3598219.2613420356,2403076.8952426664],[3601196.64409514,2393072.873968573]]]},properties:{hex:"ID3023"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3692625.0745722223,2262713.977619359],[3601196.64409514,2315500.20656688],[3601196.64409514,2393072.873968573],[3615851.1779385684,2343833.5653245216],[3630133.336033914,2310926.409951529],[3636874.9512835112,2302814.693754408],[3643918.641053823,2298492.279163053],[3656862.2521135663,2295695.2372465003],[3677332.1726723025,2278927.68356944],[3692625.0745722223,2262713.977619359]]]},properties:{hex:"ID3024"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1599745.4958545328,2720189.3397531733],[-1523803.35590486,2676344.1248104],[-1523803.35590486,2634267.1694055498],[-1523803.35590486,2613968.4940128755],[-1523803.35590486,2532006.55751299],[-1572689.5258053592,2503798.3788459366],[-1580416.9058239853,2532287.601691411],[-1584928.1351861653,2536802.019966194],[-1589726.3612657434,2539179.7176578417],[-1590518.541893485,2532487.7282994213],[-1593514.178857475,2526477.6814242783],[-1599073.7457405757,2530097.926791576],[-1608126.4954681639,2550825.2001006086],[-1620447.7212148877,2584550.9936207486],[-1625232.6252255575,2588002.205127264],[-1629641.8637921398,2583386.8139794027],[-1632493.8297951461,2578959.1403540233],[-1638857.6582215799,2550825.200100605],[-1643391.8004970695,2556938.088678637],[-1631276.4670711043,2619574.539348181],[-1630347.837963711,2624820.801715316],[-1620086.2375507085,2682448.989408197],[-1605095.0469024873,2713645.3142181756],[-1599745.4958545328,2720189.3397531733]]]},properties:{hex:"ID3087"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1523803.35590486,2676344.1248104],[-1398803.35590486,2748512.9084591],[-1361349.2562970135,2726888.7739682556],[-1273803.35590486,2676344.1248104],[-1273803.35590486,2614348.5468724407],[-1273803.35590486,2532006.55751299],[-1398803.35590486,2459837.77386429],[-1523803.35590486,2532006.55751299],[-1523803.35590486,2613968.4940128755],[-1523803.35590486,2634267.1694055498],[-1523803.35590486,2676344.1248104]]]},properties:{hex:"ID3088"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1273803.35590486,2676344.1248104],[-1249203.266168899,2690546.9932415453],[-1148803.35590486,2748512.9084591],[-1023803.35590486,2676344.1248104],[-1023803.35590486,2532006.55751299],[-1148803.35590486,2459837.77386429],[-1273803.35590486,2532006.55751299],[-1273803.35590486,2614348.5468724407],[-1273803.35590486,2676344.1248104]]]},properties:{hex:"ID3089"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1023803.35590486,2676344.1248104],[-898803.35590486,2748512.9084591],[-773803.35590486,2676344.1248104],[-773803.35590486,2532006.55751299],[-898803.35590486,2459837.77386429],[-1023803.35590486,2532006.55751299],[-1023803.35590486,2676344.1248104]]]},properties:{hex:"ID3090"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-773803.35590486,2676344.1248104],[-648803.35590486,2748512.9084591],[-599626.9981853028,2720120.9250919498],[-523803.35590486,2676344.1248104],[-523803.35590486,2532006.55751299],[-583903.1140768849,2497307.9459541417],[-648803.35590486,2459837.77386429],[-773803.35590486,2532006.55751299],[-773803.35590486,2676344.1248104]]]},properties:{hex:"ID3091"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-523803.35590486,2676344.1248104],[-398803.35590486,2748512.9084591],[-273803.35590486,2676344.1248104],[-273803.35590486,2532006.55751299],[-398803.35590486,2459837.77386429],[-523803.35590486,2532006.55751299],[-523803.35590486,2676344.1248104]]]},properties:{hex:"ID3092"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-273803.35590486,2676344.1248104],[-148803.35590486,2748512.9084591],[-23803.35590486,2676344.1248104],[-23803.35590486,2532006.55751299],[-148803.35590486,2459837.77386429],[-273803.35590486,2532006.55751299],[-273803.35590486,2676344.1248104]]]},properties:{hex:"ID3093"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-23803.35590486,2676344.1248104],[-9650.964653161383,2684515.0117092445],[101196.64409514,2748512.9084591],[226196.64409514,2676344.1248104],[226196.64409514,2532006.55751299],[165178.99717322184,2496778.002637305],[101196.64409514,2459837.77386429],[-23803.35590486,2532006.55751299],[-23803.35590486,2676344.1248104]]]},properties:{hex:"ID3094"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[226196.64409514,2676344.1248104],[351196.64409514,2748512.9084591],[476196.64409514,2676344.1248104],[476196.64409514,2532006.55751299],[351196.64409514,2459837.77386429],[226196.64409514,2532006.55751299],[226196.64409514,2676344.1248104]]]},properties:{hex:"ID3095"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[476196.64409514,2676344.1248104],[601196.64409514,2748512.9084591],[726196.64409514,2676344.1248104],[726196.64409514,2564286.695164497],[726196.64409514,2532006.55751299],[655371.899137285,2491115.871946288],[601196.64409514,2459837.77386429],[476196.64409514,2532006.55751299],[476196.64409514,2676344.1248104]]]},properties:{hex:"ID3096"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[726196.64409514,2676344.1248104],[851196.64409514,2748512.9084591],[918460.3124823575,2709678.21140906],[976196.64409514,2676344.1248104],[976196.64409514,2532006.55751299],[851196.64409514,2459837.77386429],[726196.64409514,2532006.55751299],[726196.64409514,2564286.695164497],[726196.64409514,2676344.1248104]]]},properties:{hex:"ID3097"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[976196.64409514,2676344.1248104],[1101196.64409514,2748512.9084591],[1226196.64409514,2676344.1248104],[1226196.64409514,2532006.55751299],[1101196.64409514,2459837.77386429],[976196.64409514,2532006.55751299],[976196.64409514,2676344.1248104]]]},properties:{hex:"ID3098"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1226196.64409514,2676344.1248104],[1351196.64409514,2748512.9084591],[1450539.4184056497,2691157.3309688857],[1476196.64409514,2676344.1248104],[1476196.64409514,2607512.9072866226],[1476196.64409514,2532006.55751299],[1351196.64409514,2459837.77386429],[1226196.64409514,2532006.55751299],[1226196.64409514,2676344.1248104]]]},properties:{hex:"ID3099"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1476196.64409514,2676344.1248104],[1601196.64409514,2748512.9084591],[1726196.64409514,2676344.1248104],[1726196.64409514,2532006.55751299],[1601196.64409514,2459837.77386429],[1536384.972747438,2497256.809763514],[1476196.64409514,2532006.55751299],[1476196.64409514,2607512.9072866226],[1476196.64409514,2676344.1248104]]]},properties:{hex:"ID3100"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1726196.64409514,2676344.1248104],[1783579.8654519147,2709474.3431077003],[1851196.64409514,2748512.9084591],[1976196.64409514,2676344.1248104],[1976196.64409514,2594842.791013177],[1976196.64409514,2532006.55751299],[1851196.64409514,2459837.77386429],[1726196.64409514,2532006.55751299],[1726196.64409514,2676344.1248104]]]},properties:{hex:"ID3101"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1976196.64409514,2676344.1248104],[2101196.64409514,2748512.9084591],[2226196.64409514,2676344.1248104],[2226196.64409514,2532006.55751299],[2153188.1303783925,2489855.0724654933],[2101196.64409514,2459837.77386429],[1976196.64409514,2532006.55751299],[1976196.64409514,2594842.791013177],[1976196.64409514,2676344.1248104]]]},properties:{hex:"ID3102"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2226196.64409514,2676344.1248104],[2351196.64409514,2748512.9084591],[2386323.6896352307,2728232.299260693],[2445692.6505092382,2693955.613718578],[2476196.64409514,2676344.1248104],[2476196.64409514,2532006.55751299],[2406108.1317056646,2491540.936017828],[2351196.64409514,2459837.77386429],[2226196.64409514,2532006.55751299],[2226196.64409514,2676344.1248104]]]},properties:{hex:"ID3103"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2476196.64409514,2676344.1248104],[2506673.5238075745,2693939.959516433],[2601196.64409514,2748512.9084591],[2695782.503179231,2693903.7372553702],[2726196.64409514,2676344.1248104],[2726196.64409514,2532006.55751299],[2601196.64409514,2459837.77386429],[2476196.64409514,2532006.55751299],[2476196.64409514,2676344.1248104]]]},properties:{hex:"ID3104"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2726196.64409514,2676344.1248104],[2756593.87915278,2693893.976653548],[2851196.64409514,2748512.9084591],[2945872.3551029116,2693851.861223046],[2976196.64409514,2676344.1248104],[2976196.64409514,2532006.55751299],[2851196.64409514,2459837.77386429],[2726196.64409514,2532006.55751299],[2726196.64409514,2676344.1248104]]]},properties:{hex:"ID3105"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2976196.64409514,2676344.1248104],[3006716.309951205,2693964.6621079757],[3101196.64409514,2748512.9084591],[3195611.444290652,2694002.498150739],[3226196.64409514,2676344.1248104],[3226196.64409514,2532006.55751299],[3101196.64409514,2459837.77386429],[2976196.64409514,2532006.55751299],[2976196.64409514,2676344.1248104]]]},properties:{hex:"ID3106"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3226196.64409514,2676344.1248104],[3256801.653469486,2694013.935211229],[3351196.64409514,2748512.9084591],[3445530.5361675615,2694049.2104773847],[3476196.64409514,2676344.1248104],[3476196.64409514,2532006.55751299],[3351196.64409514,2459837.77386429],[3226196.64409514,2532006.55751299],[3226196.64409514,2676344.1248104]]]},properties:{hex:"ID3107"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3585216.0363771007,2469064.1820321153],[3476196.64409514,2532006.55751299],[3476196.64409514,2676344.1248104],[3506886.3684112867,2694062.845405681],[3522703.6068673185,2703194.9322861065],[3526289.3639670713,2696357.7674189513],[3526676.193093747,2694070.242981528],[3531243.51123709,2666681.2927654474],[3538258.51287293,2644766.417346065],[3556967.7377190907,2613428.6647104835],[3571596.625940012,2596555.6461362103],[3577251.4734522826,2587249.662748356],[3578227.3887218614,2582928.1898411578],[3578150.368922957,2578923.8584137466],[3573764.577578192,2583527.9281988456],[3566952.689866822,2586673.4893334685],[3567852.13117778,2571984.5636960594],[3570644.803748606,2561520.76924604],[3574556.8684436907,2541886.853693068],[3582389.4001254137,2520761.26135022],[3580911.1852511563,2501246.176105943],[3585216.0363771007,2469064.1820321153]]]},properties:{hex:"ID3108"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1480358.1629087983,2939936.165533947],[-1398803.35590486,2892850.47575651],[-1398803.35590486,2748512.9084591],[-1523803.35590486,2676344.1248104],[-1599745.4958545328,2720189.3397531733],[-1593843.1817155944,2727409.552083993],[-1577229.2581172811,2734506.892968803],[-1560539.9982422905,2765824.6171871377],[-1553655.462582651,2794632.6711867675],[-1543114.5642127844,2807879.882520412],[-1539442.8810033845,2818251.262255957],[-1542832.4969101406,2826152.401384252],[-1532720.4104239838,2841675.503976153],[-1520192.5639428208,2865367.132654806],[-1514145.859831992,2880577.83995063],[-1499766.0704814186,2904118.8571149427],[-1497872.0279720929,2909301.6725402437],[-1498695.2251122838,2915201.57770972],[-1504071.8263454256,2910194.5912842117],[-1510037.6562072383,2901498.017083693],[-1516918.685184562,2894650.355176472],[-1513765.086354392,2903079.8804560974],[-1507941.507021862,2915464.164930527],[-1495636.7430532568,2928428.0309823817],[-1480358.1629087983,2939936.165533947]]]},properties:{hex:"ID3168"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1398803.35590486,2892850.47575651],[-1273803.35590486,2965019.25940521],[-1250247.7678126907,2951419.434279277],[-1148803.35590486,2892850.47575651],[-1148803.35590486,2866280.020810893],[-1148803.35590486,2748512.9084591],[-1249203.266168899,2690546.9932415453],[-1273803.35590486,2676344.1248104],[-1361349.2562970135,2726888.7739682556],[-1398803.35590486,2748512.9084591],[-1398803.35590486,2892850.47575651]]]},properties:{hex:"ID3169"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1148803.35590486,2892850.47575651],[-1140473.8852666067,2897659.4978717123],[-1023803.35590486,2965019.25940521],[-898803.35590486,2892850.47575651],[-898803.35590486,2748512.9084591],[-1023803.35590486,2676344.1248104],[-1148803.35590486,2748512.9084591],[-1148803.35590486,2866280.020810893],[-1148803.35590486,2892850.47575651]]]},properties:{hex:"ID3170"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-898803.35590486,2892850.47575651],[-773803.35590486,2965019.25940521],[-648803.35590486,2892850.47575651],[-648803.35590486,2748512.9084591],[-773803.35590486,2676344.1248104],[-898803.35590486,2748512.9084591],[-898803.35590486,2892850.47575651]]]},properties:{hex:"ID3171"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-648803.35590486,2892850.47575651],[-612737.663483118,2913673.012984712],[-523803.35590486,2965019.25940521],[-398803.35590486,2892850.47575651],[-398803.35590486,2748512.9084591],[-523803.35590486,2676344.1248104],[-599626.9981853028,2720120.9250919498],[-648803.35590486,2748512.9084591],[-648803.35590486,2892850.47575651]]]},properties:{hex:"ID3172"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-398803.35590486,2892850.47575651],[-318008.22020544345,2939497.569101779],[-273803.35590486,2965019.25940521],[-148803.35590486,2892850.47575651],[-148803.35590486,2799132.692426054],[-148803.35590486,2748512.9084591],[-273803.35590486,2676344.1248104],[-398803.35590486,2748512.9084591],[-398803.35590486,2892850.47575651]]]},properties:{hex:"ID3173"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-148803.35590486,2892850.47575651],[-23803.35590486,2965019.25940521],[101196.64409514,2892850.47575651],[101196.64409514,2748512.9084591],[-9650.964653161383,2684515.0117092445],[-23803.35590486,2676344.1248104],[-148803.35590486,2748512.9084591],[-148803.35590486,2799132.692426054],[-148803.35590486,2892850.47575651]]]},properties:{hex:"ID3174"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[101196.64409514,2892850.47575651],[226196.64409514,2965019.25940521],[351196.64409514,2892850.47575651],[351196.64409514,2748512.9084591],[226196.64409514,2676344.1248104],[101196.64409514,2748512.9084591],[101196.64409514,2892850.47575651]]]},properties:{hex:"ID3175"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[351196.64409514,2892850.47575651],[476196.64409514,2965019.25940521],[601196.64409514,2892850.47575651],[601196.64409514,2748512.9084591],[476196.64409514,2676344.1248104],[351196.64409514,2748512.9084591],[351196.64409514,2892850.47575651]]]},properties:{hex:"ID3176"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[601196.64409514,2892850.47575651],[726196.64409514,2965019.25940521],[851196.64409514,2892850.47575651],[851196.64409514,2748512.9084591],[726196.64409514,2676344.1248104],[601196.64409514,2748512.9084591],[601196.64409514,2892850.47575651]]]},properties:{hex:"ID3177"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[851196.64409514,2892850.47575651],[976196.64409514,2965019.25940521],[1101196.64409514,2892850.47575651],[1101196.64409514,2849093.2619186095],[1101196.64409514,2748512.9084591],[976196.64409514,2676344.1248104],[918460.3124823575,2709678.21140906],[851196.64409514,2748512.9084591],[851196.64409514,2892850.47575651]]]},properties:{hex:"ID3178"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1101196.64409514,2892850.47575651],[1123144.7589434243,2905522.2257723715],[1226196.64409514,2965019.25940521],[1351196.64409514,2892850.47575651],[1351196.64409514,2772571.807145345],[1351196.64409514,2748512.9084591],[1226196.64409514,2676344.1248104],[1101196.64409514,2748512.9084591],[1101196.64409514,2849093.2619186095],[1101196.64409514,2892850.47575651]]]},properties:{hex:"ID3179"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1351196.64409514,2892850.47575651],[1476196.64409514,2965019.25940521],[1601196.64409514,2892850.47575651],[1601196.64409514,2818409.8776528295],[1601196.64409514,2748512.9084591],[1476196.64409514,2676344.1248104],[1450539.4184056497,2691157.3309688857],[1351196.64409514,2748512.9084591],[1351196.64409514,2772571.807145345],[1351196.64409514,2892850.47575651]]]},properties:{hex:"ID3180"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1601196.64409514,2892850.47575651],[1726196.64409514,2965019.25940521],[1851196.64409514,2892850.47575651],[1851196.64409514,2748512.9084591],[1783579.8654519147,2709474.3431077003],[1726196.64409514,2676344.1248104],[1601196.64409514,2748512.9084591],[1601196.64409514,2818409.8776528295],[1601196.64409514,2892850.47575651]]]},properties:{hex:"ID3181"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1851196.64409514,2892850.47575651],[1976196.64409514,2965019.25940521],[2101196.64409514,2892850.47575651],[2101196.64409514,2748512.9084591],[1976196.64409514,2676344.1248104],[1851196.64409514,2748512.9084591],[1851196.64409514,2892850.47575651]]]},properties:{hex:"ID3182"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2101196.64409514,2892850.47575651],[2226196.64409514,2965019.25940521],[2351196.64409514,2892850.47575651],[2351196.64409514,2748512.9084591],[2226196.64409514,2676344.1248104],[2101196.64409514,2748512.9084591],[2101196.64409514,2892850.47575651]]]},properties:{hex:"ID3183"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2351196.64409514,2892850.47575651],[2370301.812945314,2903880.8501350707],[2476196.64409514,2965019.25940521],[2601196.64409514,2892850.47575651],[2601196.64409514,2748512.9084591],[2506673.5238075745,2693939.959516433],[2476196.64409514,2676344.1248104],[2445692.6505092382,2693955.613718578],[2386323.6896352307,2728232.299260693],[2351196.64409514,2748512.9084591],[2351196.64409514,2892850.47575651]]]},properties:{hex:"ID3184"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2601196.64409514,2892850.47575651],[2726196.64409514,2965019.25940521],[2851196.64409514,2892850.47575651],[2851196.64409514,2748512.9084591],[2756593.87915278,2693893.976653548],[2726196.64409514,2676344.1248104],[2695782.503179231,2693903.7372553702],[2601196.64409514,2748512.9084591],[2601196.64409514,2892850.47575651]]]},properties:{hex:"ID3185"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2851196.64409514,2892850.47575651],[2976196.64409514,2965019.25940521],[3101196.64409514,2892850.47575651],[3101196.64409514,2748512.9084591],[3006716.309951205,2693964.6621079757],[2976196.64409514,2676344.1248104],[2945872.3551029116,2693851.861223046],[2851196.64409514,2748512.9084591],[2851196.64409514,2892850.47575651]]]},properties:{hex:"ID3186"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3101196.64409514,2892850.47575651],[3226196.64409514,2965019.25940521],[3351196.64409514,2892850.47575651],[3351196.64409514,2748512.9084591],[3256801.653469486,2694013.935211229],[3226196.64409514,2676344.1248104],[3195611.444290652,2694002.498150739],[3101196.64409514,2748512.9084591],[3101196.64409514,2892850.47575651]]]},properties:{hex:"ID3187"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3522703.6068673185,2703194.9322861065],[3506886.3684112867,2694062.845405681],[3476196.64409514,2676344.1248104],[3445530.5361675615,2694049.2104773847],[3351196.64409514,2748512.9084591],[3351196.64409514,2892850.47575651],[3369181.669133791,2903234.134803961],[3375509.666834636,2867406.064703636],[3382170.2576033594,2846889.5142218145],[3399960.2945613475,2807979.338091553],[3410956.2538523953,2796300.500766728],[3416551.4000743194,2788745.0069549964],[3423707.706274681,2783225.320885253],[3455593.0232897834,2769935.3742469708],[3476879.2317426726,2741790.5865287525],[3521131.3787528374,2706192.788116393],[3522703.6068673185,2703194.9322861065]]]},properties:{hex:"ID3188"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1364161.288154011,3161525.003210078],[-1273803.35590486,3109356.82670262],[-1273803.35590486,2965019.25940521],[-1398803.35590486,2892850.47575651],[-1480358.1629087983,2939936.165533947],[-1476634.8454134122,2942740.6433263835],[-1436107.7892830607,2991204.611980394],[-1421456.8584675302,2999555.700974877],[-1407542.7496569632,3019936.7886930876],[-1401922.2546793686,3038026.936484931],[-1398215.547426053,3079528.3672979646],[-1392381.4216087796,3101423.7497294596],[-1383085.2357424817,3118494.3968847813],[-1371372.0597731199,3149491.987940141],[-1364161.288154011,3161525.003210078]]]},properties:{hex:"ID3242"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1273803.35590486,3109356.82670262],[-1148803.35590486,3181525.61035132],[-1131399.1192000026,3171477.269604731],[-1127523.3798419626,3169239.610443058],[-1023803.35590486,3109356.82670262],[-1023803.35590486,2965019.25940521],[-1140473.8852666067,2897659.4978717123],[-1148803.35590486,2892850.47575651],[-1250247.7678126907,2951419.434279277],[-1273803.35590486,2965019.25940521],[-1273803.35590486,3109356.82670262]]]},properties:{hex:"ID3243"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1023803.35590486,3109356.82670262],[-915838.7163384005,3171690.2404192733],[-898803.35590486,3181525.61035132],[-881775.029142417,3171694.301311175],[-773803.35590486,3109356.82670262],[-773803.35590486,2965019.25940521],[-898803.35590486,2892850.47575651],[-1023803.35590486,2965019.25940521],[-1023803.35590486,3109356.82670262]]]},properties:{hex:"ID3244"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-773803.35590486,3109356.82670262],[-648803.35590486,3181525.61035132],[-535489.1390384443,3116103.616740486],[-523803.35590486,3109356.82670262],[-523803.35590486,3107268.99647675],[-523803.35590486,3052753.0657322975],[-523803.35590486,2965019.25940521],[-612737.663483118,2913673.012984712],[-648803.35590486,2892850.47575651],[-773803.35590486,2965019.25940521],[-773803.35590486,3109356.82670262]]]},properties:{hex:"ID3245"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-523803.35590486,3109356.82670262],[-398803.35590486,3181525.61035132],[-273803.35590486,3109356.82670262],[-273803.35590486,2965019.25940521],[-318008.22020544345,2939497.569101779],[-398803.35590486,2892850.47575651],[-523803.35590486,2965019.25940521],[-523803.35590486,3052753.0657322975],[-523803.35590486,3107268.99647675],[-523803.35590486,3109356.82670262]]]},properties:{hex:"ID3246"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-273803.35590486,3109356.82670262],[-148803.35590486,3181525.61035132],[-23803.35590486,3109356.82670262],[-23803.35590486,2965019.25940521],[-148803.35590486,2892850.47575651],[-273803.35590486,2965019.25940521],[-273803.35590486,3109356.82670262]]]},properties:{hex:"ID3247"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-23803.35590486,3109356.82670262],[101196.64409514,3181525.61035132],[226196.64409514,3109356.82670262],[226196.64409514,2965019.25940521],[101196.64409514,2892850.47575651],[-23803.35590486,2965019.25940521],[-23803.35590486,3109356.82670262]]]},properties:{hex:"ID3248"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[226196.64409514,3109356.82670262],[351196.64409514,3181525.61035132],[476196.64409514,3109356.82670262],[476196.64409514,2965019.25940521],[351196.64409514,2892850.47575651],[226196.64409514,2965019.25940521],[226196.64409514,3109356.82670262]]]},properties:{hex:"ID3249"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[476196.64409514,3109356.82670262],[601196.64409514,3181525.61035132],[726196.64409514,3109356.82670262],[726196.64409514,2965019.25940521],[601196.64409514,2892850.47575651],[476196.64409514,2965019.25940521],[476196.64409514,3109356.82670262]]]},properties:{hex:"ID3250"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[726196.64409514,3109356.82670262],[851196.64409514,3181525.61035132],[904948.0577659968,3150492.217199129],[976196.64409514,3109356.82670262],[976196.64409514,2997239.340841407],[976196.64409514,2965019.25940521],[851196.64409514,2892850.47575651],[726196.64409514,2965019.25940521],[726196.64409514,3109356.82670262]]]},properties:{hex:"ID3251"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[976196.64409514,3109356.82670262],[1101196.64409514,3181525.61035132],[1226196.64409514,3109356.82670262],[1226196.64409514,2965019.25940521],[1123144.7589434243,2905522.2257723715],[1101196.64409514,2892850.47575651],[976196.64409514,2965019.25940521],[976196.64409514,2997239.340841407],[976196.64409514,3109356.82670262]]]},properties:{hex:"ID3252"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1226196.64409514,3109356.82670262],[1351196.64409514,3181525.61035132],[1476196.64409514,3109356.82670262],[1476196.64409514,2965019.25940521],[1351196.64409514,2892850.47575651],[1226196.64409514,2965019.25940521],[1226196.64409514,3109356.82670262]]]},properties:{hex:"ID3253"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1476196.64409514,3109356.82670262],[1601196.64409514,3181525.61035132],[1726196.64409514,3109356.82670262],[1726196.64409514,2965019.25940521],[1601196.64409514,2892850.47575651],[1476196.64409514,2965019.25940521],[1476196.64409514,3109356.82670262]]]},properties:{hex:"ID3254"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1726196.64409514,3109356.82670262],[1851196.64409514,3181525.61035132],[1976196.64409514,3109356.82670262],[1976196.64409514,2965019.25940521],[1851196.64409514,2892850.47575651],[1726196.64409514,2965019.25940521],[1726196.64409514,3109356.82670262]]]},properties:{hex:"ID3255"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1976196.64409514,3109356.82670262],[2101196.64409514,3181525.61035132],[2226196.64409514,3109356.82670262],[2226196.64409514,2965019.25940521],[2101196.64409514,2892850.47575651],[1976196.64409514,2965019.25940521],[1976196.64409514,3109356.82670262]]]},properties:{hex:"ID3256"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2226196.64409514,3109356.82670262],[2343170.2694195933,3176891.5807717764],[2351196.64409514,3181525.61035132],[2476196.64409514,3109356.82670262],[2476196.64409514,2965019.25940521],[2370301.812945314,2903880.8501350707],[2351196.64409514,2892850.47575651],[2226196.64409514,2965019.25940521],[2226196.64409514,3109356.82670262]]]},properties:{hex:"ID3257"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2476196.64409514,3109356.82670262],[2601196.64409514,3181525.61035132],[2726196.64409514,3109356.82670262],[2726196.64409514,2965019.25940521],[2601196.64409514,2892850.47575651],[2476196.64409514,2965019.25940521],[2476196.64409514,3109356.82670262]]]},properties:{hex:"ID3258"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2726196.64409514,3109356.82670262],[2851196.64409514,3181525.61035132],[2976196.64409514,3109356.82670262],[2976196.64409514,2965019.25940521],[2851196.64409514,2892850.47575651],[2726196.64409514,2965019.25940521],[2726196.64409514,3109356.82670262]]]},properties:{hex:"ID3259"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2976196.64409514,3109356.82670262],[3101196.64409514,3181525.61035132],[3226196.64409514,3109356.82670262],[3226196.64409514,2965019.25940521],[3101196.64409514,2892850.47575651],[2976196.64409514,2965019.25940521],[2976196.64409514,3109356.82670262]]]},properties:{hex:"ID3260"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3369181.669133791,2903234.134803961],[3351196.64409514,2892850.47575651],[3226196.64409514,2965019.25940521],[3226196.64409514,3109356.82670262],[3253449.6363000595,3125091.349088351],[3263097.4965494135,3105988.292367614],[3284545.3467639806,3069968.06201125],[3327720.441598278,2990767.7909136205],[3350276.5040467544,2966286.4708137047],[3359803.0694453577,2952536.0803846377],[3375162.935996285,2941935.9121836033],[3392338.9457351463,2926619.6391171813],[3377739.2775669075,2928118.8600237654],[3374245.538807907,2927191.333003709],[3369573.3295916957,2924571.975538372],[3368402.440126746,2915277.4364139386],[3368396.5771328676,2907679.195085907],[3369181.669133791,2903234.134803961]]]},properties:{hex:"ID3261"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1223992.3160977766,3369273.544056195],[-1148803.35590486,3325863.17764873],[-1148803.35590486,3181525.61035132],[-1273803.35590486,3109356.82670262],[-1364161.288154011,3161525.003210078],[-1363066.5340124702,3163351.880276476],[-1356459.2788641658,3191577.4432636793],[-1350492.2568897873,3202334.5127688088],[-1340681.7686359629,3207436.7801962118],[-1326339.2035968145,3221512.0661546355],[-1305578.404302971,3230205.775620655],[-1280534.5712589035,3248471.9074609787],[-1268666.8158184101,3259391.2496625218],[-1260238.884158261,3275677.26634043],[-1250320.688846638,3308093.9058642667],[-1234004.9322780508,3342136.160985724],[-1225168.0301288397,3367792.784940229],[-1225009.5406002058,3368248.190443274],[-1223992.3160977766,3369273.544056195]]]},properties:{hex:"ID3320"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1148803.35590486,3325863.17764873],[-1023803.35590486,3398031.96129743],[-898803.35590486,3325863.17764873],[-898803.35590486,3284244.365759853],[-898803.35590486,3181525.61035132],[-915838.7163384005,3171690.2404192733],[-1023803.35590486,3109356.82670262],[-1127523.3798419626,3169239.610443058],[-1131399.1192000026,3171477.269604731],[-1148803.35590486,3181525.61035132],[-1148803.35590486,3325863.17764873]]]},properties:{hex:"ID3321"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-898803.35590486,3325863.17764873],[-806900.0539853979,3378923.5737513443],[-773803.35590486,3398031.96129743],[-648803.35590486,3325863.17764873],[-648803.35590486,3202087.6330500366],[-648803.35590486,3181525.61035132],[-773803.35590486,3109356.82670262],[-881775.029142417,3171694.301311175],[-898803.35590486,3181525.61035132],[-898803.35590486,3284244.365759853],[-898803.35590486,3325863.17764873]]]},properties:{hex:"ID3322"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-648803.35590486,3325863.17764873],[-523803.35590486,3398031.96129743],[-398803.35590486,3325863.17764873],[-398803.35590486,3181525.61035132],[-523803.35590486,3109356.82670262],[-535489.1390384443,3116103.616740486],[-648803.35590486,3181525.61035132],[-648803.35590486,3202087.6330500366],[-648803.35590486,3325863.17764873]]]},properties:{hex:"ID3323"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-398803.35590486,3325863.17764873],[-273803.35590486,3398031.96129743],[-148803.35590486,3325863.17764873],[-148803.35590486,3181525.61035132],[-273803.35590486,3109356.82670262],[-398803.35590486,3181525.61035132],[-398803.35590486,3325863.17764873]]]},properties:{hex:"ID3324"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-148803.35590486,3325863.17764873],[-23803.35590486,3398031.96129743],[101196.64409514,3325863.17764873],[101196.64409514,3181525.61035132],[-23803.35590486,3109356.82670262],[-148803.35590486,3181525.61035132],[-148803.35590486,3325863.17764873]]]},properties:{hex:"ID3325"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[101196.64409514,3325863.17764873],[226196.64409514,3398031.96129743],[351196.64409514,3325863.17764873],[351196.64409514,3181525.61035132],[226196.64409514,3109356.82670262],[101196.64409514,3181525.61035132],[101196.64409514,3325863.17764873]]]},properties:{hex:"ID3326"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[351196.64409514,3325863.17764873],[476196.64409514,3398031.96129743],[601196.64409514,3325863.17764873],[601196.64409514,3181525.61035132],[476196.64409514,3109356.82670262],[351196.64409514,3181525.61035132],[351196.64409514,3325863.17764873]]]},properties:{hex:"ID3327"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[601196.64409514,3325863.17764873],[726196.64409514,3398031.96129743],[851196.64409514,3325863.17764873],[851196.64409514,3181525.61035132],[726196.64409514,3109356.82670262],[601196.64409514,3181525.61035132],[601196.64409514,3325863.17764873]]]},properties:{hex:"ID3328"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[851196.64409514,3325863.17764873],[915882.5814648548,3363209.6210019165],[976196.64409514,3398031.96129743],[1101196.64409514,3325863.17764873],[1101196.64409514,3181525.61035132],[976196.64409514,3109356.82670262],[904948.0577659968,3150492.217199129],[851196.64409514,3181525.61035132],[851196.64409514,3325863.17764873]]]},properties:{hex:"ID3329"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1101196.64409514,3325863.17764873],[1226196.64409514,3398031.96129743],[1351196.64409514,3325863.17764873],[1351196.64409514,3181525.61035132],[1226196.64409514,3109356.82670262],[1101196.64409514,3181525.61035132],[1101196.64409514,3325863.17764873]]]},properties:{hex:"ID3330"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1351196.64409514,3325863.17764873],[1476196.64409514,3398031.96129743],[1601196.64409514,3325863.17764873],[1601196.64409514,3181525.61035132],[1476196.64409514,3109356.82670262],[1351196.64409514,3181525.61035132],[1351196.64409514,3325863.17764873]]]},properties:{hex:"ID3331"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1601196.64409514,3325863.17764873],[1726196.64409514,3398031.96129743],[1851196.64409514,3325863.17764873],[1851196.64409514,3181525.61035132],[1726196.64409514,3109356.82670262],[1601196.64409514,3181525.61035132],[1601196.64409514,3325863.17764873]]]},properties:{hex:"ID3332"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1851196.64409514,3325863.17764873],[1976196.64409514,3398031.96129743],[2101196.64409514,3325863.17764873],[2101196.64409514,3181525.61035132],[1976196.64409514,3109356.82670262],[1851196.64409514,3181525.61035132],[1851196.64409514,3325863.17764873]]]},properties:{hex:"ID3333"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2101196.64409514,3325863.17764873],[2226196.64409514,3398031.96129743],[2325554.9973896067,3340667.3892766344],[2351196.64409514,3325863.17764873],[2351196.64409514,3181525.61035132],[2343170.2694195933,3176891.5807717764],[2226196.64409514,3109356.82670262],[2101196.64409514,3181525.61035132],[2101196.64409514,3325863.17764873]]]},properties:{hex:"ID3334"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2351196.64409514,3325863.17764873],[2476196.64409514,3398031.96129743],[2601196.64409514,3325863.17764873],[2601196.64409514,3181525.61035132],[2476196.64409514,3109356.82670262],[2351196.64409514,3181525.61035132],[2351196.64409514,3325863.17764873]]]},properties:{hex:"ID3335"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2601196.64409514,3325863.17764873],[2726196.64409514,3398031.96129743],[2851196.64409514,3325863.17764873],[2851196.64409514,3181525.61035132],[2726196.64409514,3109356.82670262],[2601196.64409514,3181525.61035132],[2601196.64409514,3325863.17764873]]]},properties:{hex:"ID3336"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2851196.64409514,3325863.17764873],[2976196.64409514,3398031.96129743],[3101196.64409514,3325863.17764873],[3101196.64409514,3181525.61035132],[2976196.64409514,3109356.82670262],[2851196.64409514,3181525.61035132],[2851196.64409514,3325863.17764873]]]},properties:{hex:"ID3337"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3253449.6363000595,3125091.349088351],[3226196.64409514,3109356.82670262],[3101196.64409514,3181525.61035132],[3101196.64409514,3325863.17764873],[3131972.858135658,3343631.8331096554],[3133214.7049751705,3341657.331680535],[3138499.476865345,3331086.777762838],[3149507.588378396,3322464.072279533],[3155412.2417752873,3312620.9470312945],[3161866.078960326,3296600.4354143785],[3174989.6579846675,3249194.9547027485],[3185142.1455369503,3237549.2212181375],[3220370.7042183545,3175120.001175656],[3248169.7525164573,3135545.6795606227],[3253449.6363000595,3125091.349088351]]]},properties:{hex:"ID3338"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-1023803.35590486,3493005.791148776],[-1023803.35590486,3398031.96129743],[-1148803.35590486,3325863.17764873],[-1223992.3160977766,3369273.544056195],[-1211647.1516978915,3381717.364362621],[-1202124.3243182707,3398746.4419858963],[-1187270.5910811229,3406324.9557308434],[-1156926.0320320283,3409981.149757006],[-1111357.9098275015,3424112.7588395923],[-1070046.725754481,3445416.8405515547],[-1058254.2008086317,3453887.4893975295],[-1045231.0757626441,3470845.24098584],[-1023916.369310396,3492928.8803870417],[-1023803.35590486,3493005.791148776]]]},properties:{hex:"ID3399"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-919022.8197334884,3602864.599359209],[-898803.35590486,3614538.31224354],[-773803.35590486,3542369.52859484],[-773803.35590486,3514105.2762836665],[-773803.35590486,3398031.96129743],[-806900.0539853979,3378923.5737513443],[-898803.35590486,3325863.17764873],[-1023803.35590486,3398031.96129743],[-1023803.35590486,3493005.791148776],[-984970.1759419789,3519433.536046457],[-966950.1573094326,3534206.2831114396],[-938790.0903734961,3571237.1486639194],[-919820.2154021977,3601849.3858401855],[-919022.8197334884,3602864.599359209]]]},properties:{hex:"ID3400"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-773803.35590486,3542369.52859484],[-648803.35590486,3614538.31224354],[-612900.8765472947,3593810.0061218753],[-523803.35590486,3542369.52859484],[-523803.35590486,3398031.96129743],[-648803.35590486,3325863.17764873],[-773803.35590486,3398031.96129743],[-773803.35590486,3514105.2762836665],[-773803.35590486,3542369.52859484]]]},properties:{hex:"ID3401"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-523803.35590486,3542369.52859484],[-398803.35590486,3614538.31224354],[-273803.35590486,3542369.52859484],[-273803.35590486,3398031.96129743],[-398803.35590486,3325863.17764873],[-523803.35590486,3398031.96129743],[-523803.35590486,3542369.52859484]]]},properties:{hex:"ID3402"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-273803.35590486,3542369.52859484],[-148803.35590486,3614538.31224354],[-23803.35590486,3542369.52859484],[-23803.35590486,3398031.96129743],[-148803.35590486,3325863.17764873],[-273803.35590486,3398031.96129743],[-273803.35590486,3542369.52859484]]]},properties:{hex:"ID3403"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-23803.35590486,3542369.52859484],[101196.64409514,3614538.31224354],[226196.64409514,3542369.52859484],[226196.64409514,3398031.96129743],[101196.64409514,3325863.17764873],[-23803.35590486,3398031.96129743],[-23803.35590486,3542369.52859484]]]},properties:{hex:"ID3404"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[226196.64409514,3542369.52859484],[351196.64409514,3614538.31224354],[476196.64409514,3542369.52859484],[476196.64409514,3398031.96129743],[351196.64409514,3325863.17764873],[226196.64409514,3398031.96129743],[226196.64409514,3542369.52859484]]]},properties:{hex:"ID3405"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[476196.64409514,3542369.52859484],[601196.64409514,3614538.31224354],[726196.64409514,3542369.52859484],[726196.64409514,3398031.96129743],[601196.64409514,3325863.17764873],[476196.64409514,3398031.96129743],[476196.64409514,3542369.52859484]]]},properties:{hex:"ID3406"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[726196.64409514,3542369.52859484],[851196.64409514,3614538.31224354],[889402.5740365337,3592480.1083072373],[976196.64409514,3542369.52859484],[976196.64409514,3398031.96129743],[915882.5814648548,3363209.6210019165],[851196.64409514,3325863.17764873],[726196.64409514,3398031.96129743],[726196.64409514,3542369.52859484]]]},properties:{hex:"ID3407"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[976196.64409514,3542369.52859484],[1101196.64409514,3614538.31224354],[1226196.64409514,3542369.52859484],[1226196.64409514,3398031.96129743],[1101196.64409514,3325863.17764873],[976196.64409514,3398031.96129743],[976196.64409514,3542369.52859484]]]},properties:{hex:"ID3408"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1226196.64409514,3542369.52859484],[1351196.64409514,3614538.31224354],[1476196.64409514,3542369.52859484],[1476196.64409514,3398031.96129743],[1351196.64409514,3325863.17764873],[1226196.64409514,3398031.96129743],[1226196.64409514,3542369.52859484]]]},properties:{hex:"ID3409"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1476196.64409514,3542369.52859484],[1601196.64409514,3614538.31224354],[1726196.64409514,3542369.52859484],[1726196.64409514,3398031.96129743],[1601196.64409514,3325863.17764873],[1476196.64409514,3398031.96129743],[1476196.64409514,3542369.52859484]]]},properties:{hex:"ID3410"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1726196.64409514,3542369.52859484],[1851196.64409514,3614538.31224354],[1976196.64409514,3542369.52859484],[1976196.64409514,3398031.96129743],[1851196.64409514,3325863.17764873],[1726196.64409514,3398031.96129743],[1726196.64409514,3542369.52859484]]]},properties:{hex:"ID3411"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1976196.64409514,3542369.52859484],[2101196.64409514,3614538.31224354],[2226196.64409514,3542369.52859484],[2226196.64409514,3398031.96129743],[2101196.64409514,3325863.17764873],[1976196.64409514,3398031.96129743],[1976196.64409514,3542369.52859484]]]},properties:{hex:"ID3412"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2226196.64409514,3542369.52859484],[2290366.688983587,3579418.1212850935],[2351196.64409514,3614538.31224354],[2476196.64409514,3542369.52859484],[2476196.64409514,3398031.96129743],[2351196.64409514,3325863.17764873],[2325554.9973896067,3340667.3892766344],[2226196.64409514,3398031.96129743],[2226196.64409514,3542369.52859484]]]},properties:{hex:"ID3413"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2476196.64409514,3542369.52859484],[2601196.64409514,3614538.31224354],[2726196.64409514,3542369.52859484],[2726196.64409514,3398031.96129743],[2601196.64409514,3325863.17764873],[2476196.64409514,3398031.96129743],[2476196.64409514,3542369.52859484]]]},properties:{hex:"ID3414"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2726196.64409514,3542369.52859484],[2851196.64409514,3614538.31224354],[2976196.64409514,3542369.52859484],[2976196.64409514,3398031.96129743],[2851196.64409514,3325863.17764873],[2726196.64409514,3398031.96129743],[2726196.64409514,3542369.52859484]]]},properties:{hex:"ID3415"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[3022044.349013374,3568839.7133711018],[3101196.64409514,3614538.31224354],[3199029.3118043523,3558054.595206088],[3197901.013477293,3498120.1522253477],[3189663.1313159685,3450977.9256879403],[3192530.4319594796,3421425.0474910974],[3191654.031086942,3410758.3994647986],[3186452.4028861728,3395774.4615006233],[3179579.395740613,3381066.217890849],[3162152.66502113,3388683.271677205],[3131752.70245436,3414488.947034355],[3112586.997085411,3438991.9618512425],[3093664.0301011465,3454807.456121],[3074858.5319060422,3475746.984652835],[3068297.2956985254,3490803.8947951025],[3066962.57142983,3500457.1018304178],[3056502.846632407,3524023.855714823],[3049744.570099744,3535158.3896583337],[3026915.478467074,3560189.7351267673],[3022044.349013374,3568839.7133711018]]],[[[3131972.858135658,3343631.8331096554],[3101196.64409514,3325863.17764873],[2976196.64409514,3398031.96129743],[2976196.64409514,3542369.52859484],[3003578.347415619,3558178.3623777903],[3007402.77386759,3547974.650735698],[3010274.7488208883,3525664.7358267168],[3013936.701863553,3518085.005097906],[3028078.9110580916,3501496.329938074],[3033747.7302741827,3491648.162463056],[3037548.55665396,3483147.052471447],[3042579.3005697406,3475453.9350391813],[3056315.483233128,3460982.0676272763],[3077114.336360669,3433423.1097496725],[3095708.784526449,3414834.3470777776],[3108450.992459932,3405858.546422053],[3114656.5993970325,3396857.3064615848],[3119252.8616643837,3373620.362510397],[3120080.2336825216,3362540.770372745],[3131972.858135658,3343631.8331096554]]]]},properties:{hex:"ID3416"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[-898803.35590486,3630470.637832589],[-898803.35590486,3614538.31224354],[-919022.8197334884,3602864.599359209],[-904374.338205239,3621514.4830546128],[-898803.35590486,3630470.637832589]]],[[[-898803.35590486,3735731.2933596186],[-898803.35590486,3718586.485366236],[-899725.8260592599,3719212.238898712],[-901270.5956946063,3727774.5562143014],[-898803.35590486,3735731.2933596186]]]]},properties:{hex:"ID3481"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-898803.35590486,3718586.485366236],[-898803.35590486,3735731.2933596186],[-896589.9364522704,3742869.471355037],[-895759.0003921419,3760633.5390157304],[-773803.35590486,3831044.66318965],[-648803.35590486,3758875.87954095],[-648803.35590486,3614538.31224354],[-773803.35590486,3542369.52859484],[-898803.35590486,3614538.31224354],[-898803.35590486,3630470.637832589],[-893522.363451228,3638960.5922510107],[-885679.3053407012,3656642.484285905],[-880359.8035866518,3685104.010384413],[-882488.3627852035,3696198.1349720974],[-892589.4853532674,3714371.3338738424],[-898803.35590486,3718586.485366236]]]},properties:{hex:"ID3482"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-648803.35590486,3758875.87954095],[-523803.35590486,3831044.66318965],[-398803.35590486,3758875.87954095],[-398803.35590486,3723644.6147063263],[-398803.35590486,3614538.31224354],[-523803.35590486,3542369.52859484],[-612900.8765472947,3593810.0061218753],[-648803.35590486,3614538.31224354],[-648803.35590486,3758875.87954095]]]},properties:{hex:"ID3483"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-398803.35590486,3758875.87954095],[-347935.9581349436,3788244.185336386],[-273803.35590486,3831044.66318965],[-148803.35590486,3758875.87954095],[-148803.35590486,3614538.31224354],[-273803.35590486,3542369.52859484],[-398803.35590486,3614538.31224354],[-398803.35590486,3723644.6147063263],[-398803.35590486,3758875.87954095]]]},properties:{hex:"ID3484"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-148803.35590486,3758875.87954095],[-23803.35590486,3831044.66318965],[101196.64409514,3758875.87954095],[101196.64409514,3614538.31224354],[-23803.35590486,3542369.52859484],[-148803.35590486,3614538.31224354],[-148803.35590486,3758875.87954095]]]},properties:{hex:"ID3485"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[101196.64409514,3758875.87954095],[226196.64409514,3831044.66318965],[351196.64409514,3758875.87954095],[351196.64409514,3614538.31224354],[226196.64409514,3542369.52859484],[101196.64409514,3614538.31224354],[101196.64409514,3758875.87954095]]]},properties:{hex:"ID3486"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[351196.64409514,3758875.87954095],[476196.64409514,3831044.66318965],[601196.64409514,3758875.87954095],[601196.64409514,3614538.31224354],[476196.64409514,3542369.52859484],[351196.64409514,3614538.31224354],[351196.64409514,3758875.87954095]]]},properties:{hex:"ID3487"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[601196.64409514,3758875.87954095],[726196.64409514,3831044.66318965],[849202.0044441562,3760027.485280382],[851196.64409514,3758875.87954095],[851196.64409514,3752014.16675646],[851196.64409514,3614538.31224354],[726196.64409514,3542369.52859484],[601196.64409514,3614538.31224354],[601196.64409514,3758875.87954095]]]},properties:{hex:"ID3488"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[851196.64409514,3758875.87954095],[922500.4693805403,3800043.162263724],[976196.64409514,3831044.66318965],[1101196.64409514,3758875.87954095],[1101196.64409514,3614538.31224354],[976196.64409514,3542369.52859484],[889402.5740365337,3592480.1083072373],[851196.64409514,3614538.31224354],[851196.64409514,3752014.16675646],[851196.64409514,3758875.87954095]]]},properties:{hex:"ID3489"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1101196.64409514,3758875.87954095],[1226196.64409514,3831044.66318965],[1351196.64409514,3758875.87954095],[1351196.64409514,3614538.31224354],[1226196.64409514,3542369.52859484],[1101196.64409514,3614538.31224354],[1101196.64409514,3758875.87954095]]]},properties:{hex:"ID3490"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1585928.2045543601,3767691.117219922],[1601196.64409514,3758875.87954095],[1601196.64409514,3614538.31224354],[1476196.64409514,3542369.52859484],[1351196.64409514,3614538.31224354],[1351196.64409514,3758875.87954095],[1433266.175138023,3806258.745380818],[1438844.3351667158,3802745.48450511],[1466208.9454561651,3791503.5459306347],[1496396.717432381,3787175.064872076],[1526591.4330711176,3785713.1329206508],[1579612.7184576038,3770184.83315783],[1585928.2045543601,3767691.117219922]]]},properties:{hex:"ID3491"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1834519.304189715,3768504.5462247124],[1851196.64409514,3758875.87954095],[1851196.64409514,3614538.31224354],[1726196.64409514,3542369.52859484],[1601196.64409514,3614538.31224354],[1601196.64409514,3758875.87954095],[1604062.680655184,3760530.5865203994],[1625060.6622858944,3752239.379691001],[1636696.6969376663,3743410.671454906],[1659483.9703009967,3734704.6960929106],[1707176.2564304809,3692472.0140609876],[1732933.2719052557,3677831.2691843193],[1750343.7918012252,3674987.9178725886],[1765471.7176375159,3677557.222830998],[1791324.9477510483,3692249.459341706],[1801754.290346166,3700967.8099656818],[1825494.7111973884,3737434.134835248],[1832523.8677799392,3756453.4450591966],[1834519.304189715,3768504.5462247124]]]},properties:{hex:"ID3492"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1851196.64409514,3758875.87954095],[1976196.64409514,3831044.66318965],[2101196.64409514,3758875.87954095],[2101196.64409514,3614538.31224354],[1976196.64409514,3542369.52859484],[1851196.64409514,3614538.31224354],[1851196.64409514,3758875.87954095]]]},properties:{hex:"ID3493"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2101196.64409514,3758875.87954095],[2226196.64409514,3831044.66318965],[2263995.664600483,3809221.388525787],[2351196.64409514,3758875.87954095],[2351196.64409514,3614538.31224354],[2290366.688983587,3579418.1212850935],[2226196.64409514,3542369.52859484],[2101196.64409514,3614538.31224354],[2101196.64409514,3758875.87954095]]]},properties:{hex:"ID3494"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2585834.3179380735,3767745.3226831127],[2601196.64409514,3758875.87954095],[2601196.64409514,3614538.31224354],[2476196.64409514,3542369.52859484],[2351196.64409514,3614538.31224354],[2351196.64409514,3758875.87954095],[2443893.8303374005,3812394.6249710363],[2476045.474120559,3804712.5179681857],[2505309.259745432,3785474.211000551],[2512940.104143808,3783033.682129793],[2531979.4782257597,3783414.85044304],[2546128.3881839486,3772040.24131523],[2585834.3179380735,3767745.3226831127]]]},properties:{hex:"ID3495"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2759359.5728704957,3811898.037334082],[2851196.64409514,3758875.87954095],[2851196.64409514,3614538.31224354],[2726196.64409514,3542369.52859484],[2601196.64409514,3614538.31224354],[2601196.64409514,3758875.87954095],[2606813.177194741,3762118.586437916],[2625192.8535272293,3753999.1099467683],[2641778.824537959,3743974.648400672],[2651289.4677070933,3740886.8854657956],[2659230.798975948,3741388.241558063],[2669517.5092143915,3745165.231107194],[2682103.837492659,3752222.2944167806],[2695490.3194696335,3762027.613543036],[2722438.6652885326,3787197.818097154],[2732637.0985424467,3791617.2949649743],[2739918.012379025,3790479.7846082477],[2748518.8123356286,3790798.2919908054],[2751063.2597542037,3797605.553058792],[2754876.5360516934,3802284.974716014],[2756899.72605282,3807605.974559791],[2759359.5728704957,3811898.037334082]]]},properties:{hex:"ID3496"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3069255.375806129,3777317.1793858656],[3101196.64409514,3758875.87954095],[3101196.64409514,3614538.31224354],[3022044.349013374,3568839.7133711018],[3019397.3745696666,3573540.116341092],[3014332.2675184244,3579405.6218478484],[3008847.738442962,3587823.9175114543],[2996887.220632112,3620250.3868302046],[2986140.382610844,3640806.980362135],[2978546.0826077494,3635124.5525661767],[2981425.1309490516,3626467.412398364],[2975894.2242076388,3614495.5235043033],[2973592.3231081082,3600590.21325197],[2978814.8934785295,3589232.472960982],[2996947.800815781,3571936.077027788],[3001254.3740871255,3564378.8094266914],[3003578.347415619,3558178.3623777903],[2976196.64409514,3542369.52859484],[2851196.64409514,3614538.31224354],[2851196.64409514,3758875.87954095],[2902468.478410852,3788477.686884977],[2911653.7940103174,3786384.379264477],[2918145.416235476,3778516.174185514],[2922586.046305599,3771505.25837727],[2931622.1887179916,3774561.3591655046],[2936897.390594934,3784097.527512647],[2932462.256053966,3789416.17220119],[2929134.2337022726,3794915.823414145],[2932236.9656871976,3795052.306181487],[2939623.0475252816,3790525.2858763356],[2961676.402373248,3772427.244159722],[2968716.6243429407,3768699.283698206],[2976012.2217857884,3769314.002946438],[2990628.043879372,3774407.708081733],[2995045.902089865,3773616.6767763156],[3014698.0490873293,3780285.7095357794],[3017972.341267609,3775397.889804362],[3022220.0215491387,3770537.711238824],[3038011.1365708136,3775949.8731164206],[3064287.5399144785,3775887.2775942297],[3069255.375806129,3777317.1793858656]]]},properties:{hex:"ID3497"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3199029.3118043523,3558054.595206088],[3101196.64409514,3614538.31224354],[3101196.64409514,3758875.87954095],[3122104.839470683,3770947.231769289],[3127311.1590775284,3760103.249770956],[3137320.065395041,3740602.0202706456],[3150133.501808812,3713572.9939420493],[3154472.0582081424,3703186.9344132394],[3156797.225454462,3696021.254502411],[3173706.1613890235,3666256.366838555],[3184898.789034487,3641750.1389339827],[3193421.9703276646,3621851.9479807196],[3205563.9959597113,3592765.034665697],[3210439.9075304037,3582612.8577015777],[3206199.0103987893,3577309.287362261],[3199034.9815119677,3558355.766234755],[3199029.3118043523,3558054.595206088]]]},properties:{hex:"ID3498"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-792654.4952150749,3986265.940842346],[-773803.35590486,3975382.23048706],[-773803.35590486,3831044.66318965],[-895759.0003921419,3760633.5390157304],[-895376.9228721411,3768801.7378009325],[-891045.2972389715,3810152.431633996],[-877218.0464294801,3843468.65835855],[-845376.5311459972,3887081.5842782464],[-838985.4998636578,3904976.932201113],[-834192.0417848813,3933416.980512879],[-833396.5216799895,3943454.3309376244],[-794539.5872644595,3983742.158452869],[-792654.4952150749,3986265.940842346]]]},properties:{hex:"ID3562"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-773803.35590486,3975382.23048706],[-648803.35590486,4047551.01413576],[-523803.35590486,3975382.23048706],[-523803.35590486,3831044.66318965],[-648803.35590486,3758875.87954095],[-773803.35590486,3831044.66318965],[-773803.35590486,3975382.23048706]]]},properties:{hex:"ID3563"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-523803.35590486,3975382.23048706],[-398803.35590486,4047551.01413576],[-273803.35590486,3975382.23048706],[-273803.35590486,3857625.0619815304],[-273803.35590486,3831044.66318965],[-347935.9581349436,3788244.185336386],[-398803.35590486,3758875.87954095],[-523803.35590486,3831044.66318965],[-523803.35590486,3975382.23048706]]]},properties:{hex:"ID3564"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-273803.35590486,3975382.23048706],[-148803.35590486,4047551.01413576],[-147823.61388225088,4046985.35981527],[-23803.35590486,3975382.23048706],[-23803.35590486,3831044.66318965],[-148803.35590486,3758875.87954095],[-273803.35590486,3831044.66318965],[-273803.35590486,3857625.0619815304],[-273803.35590486,3975382.23048706]]]},properties:{hex:"ID3565"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-23803.35590486,3975382.23048706],[101196.64409514,4047551.01413576],[226196.64409514,3975382.23048706],[226196.64409514,3831044.66318965],[101196.64409514,3758875.87954095],[-23803.35590486,3831044.66318965],[-23803.35590486,3975382.23048706]]]},properties:{hex:"ID3566"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[226196.64409514,3975382.23048706],[351196.64409514,4047551.01413576],[476196.64409514,3975382.23048706],[476196.64409514,3831044.66318965],[351196.64409514,3758875.87954095],[226196.64409514,3831044.66318965],[226196.64409514,3975382.23048706]]]},properties:{hex:"ID3567"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[476196.64409514,3975382.23048706],[601196.64409514,4047551.01413576],[726196.64409514,3975382.23048706],[726196.64409514,3831044.66318965],[601196.64409514,3758875.87954095],[476196.64409514,3831044.66318965],[476196.64409514,3975382.23048706]]]},properties:{hex:"ID3568"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[726196.64409514,3975382.23048706],[738908.8911512296,3982721.6497468976],[851196.64409514,4047551.01413576],[976196.64409514,3975382.23048706],[976196.64409514,3881923.1076936964],[976196.64409514,3831044.66318965],[922500.4693805403,3800043.162263724],[851196.64409514,3758875.87954095],[849202.0044441562,3760027.485280382],[726196.64409514,3831044.66318965],[726196.64409514,3975382.23048706]]]},properties:{hex:"ID3569"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1226196.64409514,3970252.7209029635],[1226196.64409514,3831044.66318965],[1101196.64409514,3758875.87954095],[976196.64409514,3831044.66318965],[976196.64409514,3881923.1076936964],[976196.64409514,3975382.23048706],[1032307.9003853088,4007778.079410751],[1038102.4710235898,4011123.5763286003],[1046721.911193629,4006688.627965973],[1060950.1960652845,4003776.229749906],[1104667.8564382733,3976578.698623982],[1118137.6786836796,3973171.4384714374],[1147737.1327776338,3969927.647251523],[1181547.4180517597,3981070.2054167343],[1194479.3710931642,3983069.9582392527],[1217987.4184454372,3972611.9968060753],[1226196.64409514,3970252.7209029635]]]},properties:{hex:"ID3570"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1433266.175138023,3806258.745380818],[1351196.64409514,3758875.87954095],[1226196.64409514,3831044.66318965],[1226196.64409514,3970252.7209029635],[1228232.3418173238,3969667.6751523768],[1245176.5394729273,3968853.833431532],[1274735.3385287158,3959357.2210163446],[1282324.6388828056,3956055.245308732],[1300325.8730746547,3940885.9318321687],[1308754.5967592576,3936342.5605858746],[1369692.1003972532,3922441.8831513887],[1378598.635830703,3913223.748157035],[1388368.2588703344,3895588.6835636706],[1390512.6422343035,3873706.4622603008],[1396419.225151734,3857794.3496190445],[1405552.3254419842,3837166.253672169],[1415757.4837912396,3822546.1491403608],[1426750.0941764184,3810362.731675151],[1433266.175138023,3806258.745380818]]]},properties:{hex:"ID3571"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1604062.680655184,3760530.5865203994],[1601196.64409514,3758875.87954095],[1585928.2045543601,3767691.117219922],[1604062.680655184,3760530.5865203994]]]},properties:{hex:"ID3572"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1964075.6508217978,3982380.289216269],[1976196.64409514,3975382.23048706],[1976196.64409514,3831044.66318965],[1851196.64409514,3758875.87954095],[1834519.304189715,3768504.5462247124],[1834741.9248130608,3769849.025878549],[1832438.288562881,3783471.740808998],[1827779.0556671105,3795706.2772112885],[1818835.5656477446,3808526.8175177383],[1811742.1881158655,3825443.4980809297],[1805409.5064663813,3855853.652184339],[1807453.5780034973,3876944.5159142707],[1811317.773175021,3889575.6047696318],[1818125.9095729578,3902444.625232107],[1837954.8301203703,3927032.821838475],[1858631.4930842842,3944348.122899345],[1895815.4110261833,3966971.731477548],[1918869.1727767724,3967220.425062948],[1928116.1777083774,3969707.236283839],[1945237.9095254992,3985690.8800779656],[1952849.2730605658,3986289.589620178],[1963931.6488387173,3982375.1455648434],[1964075.6508217978,3982380.289216269]]]},properties:{hex:"ID3573"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2226196.64409514,3878004.6442102888],[2226196.64409514,3831044.66318965],[2101196.64409514,3758875.87954095],[1976196.64409514,3831044.66318965],[1976196.64409514,3975382.23048706],[1989916.3403396069,3983303.3008070025],[1995086.267950752,3983487.9670522683],[2009406.173549704,3979047.70678184],[2027070.5757322046,3969102.5098666567],[2048595.293311057,3962918.8373380937],[2064020.6627030862,3956739.4202235932],[2080658.7658082321,3948816.6472179615],[2086644.786834695,3929047.839518938],[2085639.344083776,3923166.520793619],[2086207.8119906976,3915517.2430838384],[2104164.143528904,3901872.4166968144],[2151178.75554162,3895475.348104624],[2160753.323205395,3891820.0337958494],[2174794.2383577973,3881350.166894091],[2183413.9903176134,3878123.9597444325],[2215284.0643014163,3876649.647248651],[2226196.64409514,3878004.6442102888]]]},properties:{hex:"ID3574"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2443893.8303374005,3812394.6249710363],[2351196.64409514,3758875.87954095],[2263995.664600483,3809221.388525787],[2226196.64409514,3831044.66318965],[2226196.64409514,3878004.6442102888],[2233459.3963797595,3878906.448134274],[2251554.184195372,3875226.2955344245],[2258553.523773059,3871676.1095831674],[2266359.417758362,3863502.1817917977],[2277135.066066427,3843621.9427738716],[2281225.655918086,3836956.149587564],[2289881.4378429074,3822858.62238536],[2304431.8636437915,3820415.559284037],[2349133.1510680583,3832992.2754578986],[2402050.0452904645,3820336.0142083727],[2430990.4889392685,3815477.6663851333],[2443893.8303374005,3812394.6249710363]]]},properties:{hex:"ID3575"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2606813.177194741,3762118.586437916],[2601196.64409514,3758875.87954095],[2585834.3179380735,3767745.3226831127],[2596748.624684142,3766564.74185575],[2606813.177194741,3762118.586437916]]]},properties:{hex:"ID3576"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[2902468.478410852,3788477.686884977],[2851196.64409514,3758875.87954095],[2759359.5728704957,3811898.037334082],[2760561.046790487,3813994.42864155],[2776251.010884977,3815784.533636548],[2806511.4497950147,3826704.605790227],[2803771.042134727,3821529.16726126],[2776556.2253771815,3809265.744359709],[2789290.630965116,3807736.713309059],[2801423.901407487,3811931.408002476],[2815560.8447163873,3814596.8255814896],[2817364.675446157,3819807.6020548446],[2817701.4111040346,3829578.8154905927],[2820288.766754545,3830947.6560608624],[2830660.7689474006,3829118.7340771845],[2863114.556650393,3814068.308188234],[2870621.1712690056,3813778.4719589157],[2890400.1343884477,3821989.370218404],[2894621.5324649247,3823744.891663457],[2902215.7578790174,3819171.2218581866],[2920931.3361881212,3800425.8052392807],[2915415.420747392,3800823.802619647],[2896050.260688179,3816886.9557075333],[2895891.2548507154,3808884.9151923032],[2888686.0206740177,3794779.3400056753],[2901595.046305215,3788676.739608089],[2902468.478410852,3788477.686884977]]]},properties:{hex:"ID3577"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[3122104.839470683,3770947.231769289],[3101196.64409514,3758875.87954095],[3069255.375806129,3777317.1793858656],[3084747.6838556216,3781776.3603088465],[3107136.6275670137,3796098.652761917],[3108741.330322232,3798276.5250021187],[3110669.1624679775,3794745.219053384],[3115376.079299601,3784962.228864431],[3122104.839470683,3770947.231769289]]]},properties:{hex:"ID3578"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-648803.35590486,4082756.907477268],[-648803.35590486,4047551.01413576],[-773803.35590486,3975382.23048706],[-792654.4952150749,3986265.940842346],[-771507.6226653144,4014577.6111138426],[-763663.3202795599,4022120.199642198],[-744026.5718894918,4036201.150606587],[-676510.7101139901,4066886.0942106727],[-648803.35590486,4082756.907477268]]]},properties:{hex:"ID3646"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-542813.3948304877,4253081.9139908515],[-523803.35590486,4264057.36508187],[-398803.35590486,4191888.58143317],[-398803.35590486,4047551.01413576],[-523803.35590486,3975382.23048706],[-648803.35590486,4047551.01413576],[-648803.35590486,4082756.907477268],[-638264.9489166896,4088793.3225089684],[-615869.4128187437,4104773.120377453],[-602184.1336044009,4123636.9882106325],[-563582.3756703901,4197542.160255697],[-542813.3948304877,4253081.9139908515]]]},properties:{hex:"ID3647"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-269157.2997520557,4261374.963311382],[-258156.77199579866,4255023.80565008],[-253787.22742831634,4243005.223454698],[-251256.53650063172,4237870.860195838],[-241639.65839395658,4238715.47457018],[-233312.60529200407,4236136.79347137],[-226245.3534137047,4236599.739541488],[-170152.10474030868,4204214.287320179],[-148803.35590486,4191888.58143317],[-148803.35590486,4066147.6841984815],[-148803.35590486,4047551.01413576],[-273803.35590486,3975382.23048706],[-398803.35590486,4047551.01413576],[-398803.35590486,4191888.58143317],[-302124.3240995992,4247706.246470927],[-300146.34519686695,4247489.928223727],[-283401.0598495275,4250615.319591724],[-270604.5302429893,4259558.794485137],[-269157.2997520557,4261374.963311382]]]},properties:{hex:"ID3648"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-148803.35590486,4191888.58143317],[-23803.35590486,4264057.36508187],[101196.64409514,4191888.58143317],[101196.64409514,4047551.01413576],[-23803.35590486,3975382.23048706],[-147823.61388225088,4046985.35981527],[-148803.35590486,4047551.01413576],[-148803.35590486,4066147.6841984815],[-148803.35590486,4191888.58143317]]]},properties:{hex:"ID3649"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[101196.64409514,4191888.58143317],[226196.64409514,4264057.36508187],[351196.64409514,4191888.58143317],[351196.64409514,4047551.01413576],[226196.64409514,3975382.23048706],[101196.64409514,4047551.01413576],[101196.64409514,4191888.58143317]]]},properties:{hex:"ID3650"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[351196.64409514,4191888.58143317],[476196.64409514,4264057.36508187],[601196.64409514,4191888.58143317],[601196.64409514,4047551.01413576],[476196.64409514,3975382.23048706],[351196.64409514,4047551.01413576],[351196.64409514,4191888.58143317]]]},properties:{hex:"ID3651"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[601196.64409514,4191888.58143317],[726196.64409514,4264057.36508187],[738911.807704306,4256716.261949329],[851196.64409514,4191888.58143317],[851196.64409514,4047551.01413576],[738908.8911512296,3982721.6497468976],[726196.64409514,3975382.23048706],[601196.64409514,4047551.01413576],[601196.64409514,4191888.58143317]]]},properties:{hex:"ID3652"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[1038102.4710235898,4011123.5763286003],[1032307.9003853088,4007778.079410751],[976196.64409514,3975382.23048706],[851196.64409514,4047551.01413576],[851196.64409514,4191888.58143317],[975201.914895714,4263483.057910812],[975468.7727868775,4261604.157781337],[982975.3084836943,4250749.495692151],[969989.6587826486,4227078.521212443],[963146.1093882029,4209960.079099211],[949084.1249889751,4186340.0474003493],[936170.0827314074,4170983.0067507336],[907792.3171241431,4148151.7609570194],[900933.0028639702,4140566.7560573597],[896622.4198714782,4132693.0471208],[894883.7419221242,4124491.0452388395],[896238.9444159643,4114819.4467933914],[907415.4684120292,4091066.302168472],[921298.2892998654,4077031.437129468],[935066.9080109714,4069448.134485301],[958038.5351349242,4072505.3638110324],[957793.737313479,4063355.138100727],[960104.7901107561,4052365.041886658],[969508.2507503704,4052883.385858339],[975699.7634383097,4054590.468697519],[980377.1426433865,4065275.541324717],[992154.7020814858,4057959.239648236],[999427.426558344,4035609.1897971164],[1009465.6238187673,4028634.33787266],[1010748.9592556186,4026034.5128639266],[1007465.475864687,4024331.236589237],[1004980.4128658251,4021747.9152486124],[1007931.0759735543,4019942.8266118784],[1017419.4148217562,4017155.982205127],[1022915.474355714,4018938.693401585],[1032562.8169996404,4013973.88668036],[1038102.4710235898,4011123.5763286003]]],[[[1000636.1314489954,4194987.239493817],[987474.3412697471,4186709.9815270216],[989614.5159165468,4193928.2160207466],[998080.7745045264,4202617.613956082],[1000538.8164146409,4200539.378869791],[1000636.1314489954,4194987.239493817]]],[[[979662.3523378399,4076316.549560881],[977346.6355440331,4075781.7784153363],[973216.9899092132,4072640.481767662],[970950.265331184,4072291.4256260674],[964239.3651164359,4075809.9245366543],[961761.0660544463,4075787.407642012],[958486.117764321,4078258.5215709065],[958727.6631831517,4091707.651737492],[959507.8914927812,4095516.043362603],[975260.0515170023,4096027.911809038],[984324.1412152343,4087988.730349769],[985860.2642349844,4085878.6682754997],[986361.3825505575,4083577.0998729058],[982661.2857155841,4079069.041286259],[979662.3523378399,4076316.549560881]]]]},properties:{hex:"ID3653"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[1989916.3403396069,3983303.3008070025],[1976196.64409514,3975382.23048706],[1964075.6508217978,3982380.289216269],[1989916.3403396069,3983303.3008070025]]]},properties:{hex:"ID3657"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-523803.35590486,4304874.476244544],[-523803.35590486,4264057.36508187],[-542813.3948304877,4253081.9139908515],[-524828.837488096,4301175.650199281],[-523803.35590486,4304874.476244544]]]},properties:{hex:"ID3728"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[-302124.3240995992,4247706.246470927],[-398803.35590486,4191888.58143317],[-523803.35590486,4264057.36508187],[-523803.35590486,4304874.476244544],[-521514.8870385149,4313128.791470663],[-505827.77900845004,4316574.749143484],[-494768.68576974596,4318052.233845814],[-485791.3528704895,4321831.951967407],[-474549.8381896989,4329579.074598456],[-464139.7221465287,4326480.525336335],[-469570.6963516124,4321207.614674205],[-469981.4163028544,4308494.373666554],[-462972.55944058194,4293586.834984509],[-450502.8860399451,4276782.578722065],[-427455.4314126559,4255445.199312948],[-409232.15194673004,4246869.275706762],[-382985.1888664146,4241724.528803907],[-352022.21628283267,4251107.295059198],[-334831.55446228525,4251280.602262075],[-326370.32072671625,4255294.279897961],[-317426.5413970962,4249379.74704239],[-302124.3240995992,4247706.246470927]]]},properties:{hex:"ID3729"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[-258156.77199579866,4255023.80565008],[-269157.2997520557,4261374.963311382],[-262394.23528847424,4269862.11648124],[-261224.7571345735,4264805.983056047],[-260937.52905620827,4259318.481071472],[-258551.80287836152,4256110.351640966],[-258156.77199579866,4255023.80565008]]],[[[-23803.35590486,4319466.896090717],[-23803.35590486,4264057.36508187],[-148803.35590486,4191888.58143317],[-170152.10474030868,4204214.287320179],[-226245.3534137047,4236599.739541488],[-214440.47557673254,4237373.027645119],[-196411.5015082372,4235163.425466475],[-178575.76353152786,4232970.41049972],[-169316.17468090987,4234022.186757223],[-148007.6524679378,4244201.9698888175],[-131093.50297295736,4257938.0306411525],[-117970.29013372339,4264940.081813077],[-106340.02197777187,4279982.420928356],[-95896.46001888842,4289484.539644024],[-80833.00871121133,4299719.451330587],[-37486.006847311706,4321776.2082248945],[-30857.79237984881,4321965.736422477],[-23803.35590486,4319466.896090717]]]]},properties:{hex:"ID3730"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[226196.64409514,4406041.9729764415],[226196.64409514,4264057.36508187],[101196.64409514,4191888.58143317],[-23803.35590486,4264057.36508187],[-23803.35590486,4319466.896090717],[-16645.95640147984,4316931.583934604],[-4244.819628630929,4318498.249159636],[4216.792504510292,4326229.725979728],[13320.295775649598,4344781.7936161915],[27399.502878633823,4356095.379241645],[45155.77874257179,4367431.400932948],[69295.34646416779,4378222.568049457],[85083.34177718588,4388174.989025767],[110019.67691724777,4396784.0471773865],[172722.22819748288,4402245.741355779],[204874.00052254132,4407106.298637611],[226196.64409514,4406041.9729764415]]]},properties:{hex:"ID3731"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[246068.35262699163,4419867.868649405],[252186.06823770996,4423399.933404075],[259595.68545786806,4426910.223501896],[307391.525983234,4428120.008653529],[329689.8052301079,4439604.2679473935],[415108.59064169636,4439620.907660301],[425671.8992138745,4435765.720367826],[436125.94505724934,4429590.533986565],[454088.56118549407,4414670.089427576],[462918.56969938555,4411421.625342152],[468352.65528985317,4412923.661427534],[476196.64409514,4408394.93237928],[476196.64409514,4264057.36508187],[351196.64409514,4191888.58143317],[226196.64409514,4264057.36508187],[226196.64409514,4406041.9729764415],[226795.77688833998,4406012.067097085],[246068.35262699163,4419867.868649405]]]},properties:{hex:"ID3732"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[547782.4966788446,4449725.043638651],[565859.9086834475,4460162.042325761],[573194.0735238823,4451736.975082956],[604260.9867787112,4442244.285617617],[622972.5349120047,4444961.635130078],[631128.9529293191,4447817.279428849],[627509.4343187072,4461879.61555519],[636466.0256530286,4460200.9290913865],[726196.64409514,4408394.93237928],[726196.64409514,4404889.214072304],[726196.64409514,4389901.74391857],[726196.64409514,4331793.259417543],[726196.64409514,4314017.148876572],[726196.64409514,4264057.36508187],[601196.64409514,4191888.58143317],[476196.64409514,4264057.36508187],[476196.64409514,4408394.93237928],[519932.50493616634,4433645.843409093],[529241.8509458735,4435976.52421713],[545001.0015402776,4444390.463771497],[547782.4966788446,4449725.043638651]]]},properties:{hex:"ID3733"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[859641.4888353033,4475688.0826439755],[887762.089573948,4459452.64623775],[887890.6771383262,4455240.295552502],[901798.4318510214,4436104.115086382],[898851.189731572,4426571.69433161],[909614.0390099974,4420926.963718065],[918416.812128181,4427692.706432927],[922392.1655586617,4437701.715011571],[924292.2901955429,4438361.92507532],[956818.4861094038,4419582.917108743],[945145.3924694603,4393772.069786019],[932062.8567009573,4385406.52572261],[922554.6685276928,4374440.6581668155],[919754.1805616576,4366641.338536086],[919336.6543316727,4357553.727718284],[922944.6087512637,4341278.615965945],[931484.7535034439,4324713.727459521],[940765.8386357004,4314695.703812761],[949307.432051017,4311561.77738465],[969776.0654855102,4295768.862380702],[970078.9956447155,4286369.682098671],[973539.0674824474,4275190.878153497],[975201.914895714,4263483.057910812],[851196.64409514,4191888.58143317],[738911.807704306,4256716.261949329],[726196.64409514,4264057.36508187],[726196.64409514,4314017.148876572],[726196.64409514,4331793.259417543],[726196.64409514,4389901.74391857],[726196.64409514,4404889.214072304],[726196.64409514,4408394.93237928],[732764.2615337238,4412186.748075381],[851196.64409514,4480563.71602798],[853332.1804582378,4479330.763533877],[851368.314658724,4475385.072090207],[855934.1886025369,4466755.352523313],[861361.3596118325,4472006.687441042],[859660.5002424413,4475545.671352635],[859641.4888353033,4475688.0826439755]]]},properties:{hex:"ID3734"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[252186.06823770996,4423399.933404075],[246068.35262699163,4419867.868649405],[248653.31884467026,4421726.301036301],[252186.06823770996,4423399.933404075]]]},properties:{hex:"ID3814"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[519932.50493616634,4433645.843409093],[476196.64409514,4408394.93237928],[468352.65528985317,4412923.661427534],[474108.43751822074,4414514.617709447],[499900.08216650615,4428630.54123437],[519932.50493616634,4433645.843409093]]],[[[565859.9086834475,4460162.042325761],[547782.4966788446,4449725.043638651],[551377.8005083527,4456620.412664922],[565020.7671756513,4461125.999883741],[565859.9086834475,4460162.042325761]]]]},properties:{hex:"ID3815"}},{type:"Feature",geometry:{type:"Polygon",coordinates:[[[851196.64409514,4487887.97769819],[851196.64409514,4480563.71602798],[732764.2615337238,4412186.748075381],[726196.64409514,4408394.93237928],[636466.0256530286,4460200.9290913865],[647556.1092523612,4458122.37347511],[663153.0593959673,4451365.5474402625],[679847.4079829647,4437796.014331015],[690352.2857683949,4435077.820747056],[708950.725099984,4441212.718042306],[747989.6914906936,4444262.9187183445],[769147.8557498221,4451121.621543472],[788635.048219173,4469082.042300099],[795614.9426624175,4473479.946229865],[842113.7166257998,4490006.032529134],[848347.7413556627,4488860.390296704],[851196.64409514,4487887.97769819]]]},properties:{hex:"ID3816"}},{type:"Feature",geometry:{type:"MultiPolygon",coordinates:[[[[853332.1804582378,4479330.763533877],[851196.64409514,4480563.71602798],[851196.64409514,4487887.97769819],[855417.8530613402,4486447.157440336],[853807.4298392572,4480285.608522146],[853332.1804582378,4479330.763533877]]],[[[887762.089573948,4459452.64623775],[859641.4888353033,4475688.0826439755],[859035.1266339107,4480230.241122484],[868794.9990498472,4480639.956688675],[877481.0854364805,4479903.570721447],[887295.0034951691,4474753.739881804],[887762.089573948,4459452.64623775]]],[[[956818.4861094038,4419582.917108743],[924292.2901955429,4438361.92507532],[939009.328230359,4443475.451014922],[954147.2276735478,4458122.373475112],[962976.134249661,4459624.235894505],[965831.8282729387,4447612.128446072],[970893.3984393154,4437091.533637859],[965032.173211778,4433385.722479484],[958001.2252221528,4422198.119179711],[956818.4861094038,4419582.917108743]]]]},properties:{hex:"ID3817"}}];var hex$1 = {type:type,features:features};

    /* test/sandbox/src/examples/GeoPolygons.svelte generated by Svelte v3.15.0 */

    // (14:2) <Section     {...geoScales}     flipY   >
    function create_default_slot_1$8(ctx) {
    	let current;

    	const polygonlayer = new PolygonLayer({
    			props: {
    				geometry: ctx.data.column("$geometry"),
    				opacity: 0.5
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(polygonlayer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(polygonlayer, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(polygonlayer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(polygonlayer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(polygonlayer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$8.name,
    		type: "slot",
    		source: "(14:2) <Section     {...geoScales}     flipY   >",
    		ctx
    	});

    	return block;
    }

    // (12:0) <Graphic width={500} height={500}>
    function create_default_slot$8(ctx) {
    	let current;
    	const section_spread_levels = [ctx.geoScales, { flipY: true }];

    	let section_props = {
    		$$slots: { default: [create_default_slot_1$8] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < section_spread_levels.length; i += 1) {
    		section_props = assign(section_props, section_spread_levels[i]);
    	}

    	const section = new Section({ props: section_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const section_changes = changed.geoScales
    			? get_spread_update(section_spread_levels, [get_spread_object(ctx.geoScales), section_spread_levels[1]])
    			: {};

    			if (changed.$$scope) {
    				section_changes.$$scope = { changed, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(12:0) <Graphic width={500} height={500}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$x(ctx) {
    	let current;

    	const graphic = new Graphic({
    			props: {
    				width: 500,
    				height: 500,
    				$$slots: { default: [create_default_slot$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(graphic.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphic, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const graphic_changes = {};

    			if (changed.$$scope) {
    				graphic_changes.$$scope = { changed, ctx };
    			}

    			graphic.$set(graphic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphic, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self) {
    	const data = new florenceDatacontainer_umd(hex$1);
    	const geoScales = createGeoScales(data.domain("$geometry"));

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		
    	};

    	return { data, geoScales };
    }

    class GeoPolygons extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$x, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GeoPolygons",
    			options,
    			id: create_fragment$x.name
    		});
    	}
    }

    /* test/sandbox/src/examples/FuncLines.svelte generated by Svelte v3.15.0 */

    const file$h = "test/sandbox/src/examples/FuncLines.svelte";

    // (54:2) <Section     x1={50} x2={450}     y1={50} y2={450}     scaleX={scaleLinear().domain([-3, 3])}     scaleY={scaleLinear().domain([-2, 2])}     flipY     backgroundColor="#d3d3d3"     {zoomIdentity}     {...pan.handlers}     {...zoom.handlers}     {blockReindexing}   >
    function create_default_slot_1$9(ctx) {
    	let current;

    	const funcline = new FuncLine({
    			props: {
    				func: ctx.func,
    				stroke: "red",
    				strokeWidth: 7,
    				transition: 2000
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(funcline.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(funcline, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const funcline_changes = {};
    			if (changed.func) funcline_changes.func = ctx.func;
    			funcline.$set(funcline_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(funcline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(funcline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(funcline, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$9.name,
    		type: "slot",
    		source: "(54:2) <Section     x1={50} x2={450}     y1={50} y2={450}     scaleX={scaleLinear().domain([-3, 3])}     scaleY={scaleLinear().domain([-2, 2])}     flipY     backgroundColor=\\\"#d3d3d3\\\"     {zoomIdentity}     {...pan.handlers}     {...zoom.handlers}     {blockReindexing}   >",
    		ctx
    	});

    	return block;
    }

    // (52:0) <Graphic width={500} height={500}>
    function create_default_slot$9(ctx) {
    	let current;

    	const section_spread_levels = [
    		{ x1: 50 },
    		{ x2: 450 },
    		{ y1: 50 },
    		{ y2: 450 },
    		{ scaleX: linear$1().domain([-3, 3]) },
    		{ scaleY: linear$1().domain([-2, 2]) },
    		{ flipY: true },
    		{ backgroundColor: "#d3d3d3" },
    		{ zoomIdentity: ctx.zoomIdentity },
    		ctx.pan.handlers,
    		ctx.zoom.handlers,
    		{ blockReindexing: ctx.blockReindexing }
    	];

    	let section_props = {
    		$$slots: { default: [create_default_slot_1$9] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < section_spread_levels.length; i += 1) {
    		section_props = assign(section_props, section_spread_levels[i]);
    	}

    	const section = new Section({ props: section_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const section_changes = changed.scaleLinear || changed.zoomIdentity || changed.pan || changed.zoom || changed.blockReindexing
    			? get_spread_update(section_spread_levels, [
    					section_spread_levels[0],
    					section_spread_levels[1],
    					section_spread_levels[2],
    					section_spread_levels[3],
    					changed.scaleLinear && ({ scaleX: linear$1().domain([-3, 3]) }),
    					changed.scaleLinear && ({ scaleY: linear$1().domain([-2, 2]) }),
    					section_spread_levels[6],
    					section_spread_levels[7],
    					changed.zoomIdentity && ({ zoomIdentity: ctx.zoomIdentity }),
    					changed.pan && get_spread_object(ctx.pan.handlers),
    					changed.zoom && get_spread_object(ctx.zoom.handlers),
    					changed.blockReindexing && ({ blockReindexing: ctx.blockReindexing })
    				])
    			: {};

    			if (changed.$$scope || changed.func) {
    				section_changes.$$scope = { changed, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(52:0) <Graphic width={500} height={500}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$y(ctx) {
    	let div;
    	let label;
    	let t1;
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let option3;
    	let t6;
    	let current;
    	let dispose;

    	const graphic = new Graphic({
    			props: {
    				width: 500,
    				height: 500,
    				$$slots: { default: [create_default_slot$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			label = element("label");
    			label.textContent = "Function:";
    			t1 = space();
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "Sine";
    			option1 = element("option");
    			option1.textContent = "Exp";
    			option2 = element("option");
    			option2.textContent = "Linear";
    			option3 = element("option");
    			option3.textContent = "Power 2";
    			t6 = space();
    			create_component(graphic.$$.fragment);
    			attr_dev(label, "for", "func-name");
    			add_location(label, file$h, 40, 2, 887);
    			option0.__value = "sin";
    			option0.value = option0.__value;
    			add_location(option0, file$h, 43, 4, 987);
    			option1.__value = "exp";
    			option1.value = option1.__value;
    			add_location(option1, file$h, 44, 4, 1025);
    			option2.__value = "linear";
    			option2.value = option2.__value;
    			add_location(option2, file$h, 45, 4, 1062);
    			option3.__value = "power2";
    			option3.value = option3.__value;
    			add_location(option3, file$h, 46, 4, 1105);
    			attr_dev(select, "name", "func-name");
    			if (ctx.funcName === void 0) add_render_callback(() => ctx.select_change_handler.call(select));
    			add_location(select, file$h, 42, 2, 935);
    			add_location(div, file$h, 39, 0, 879);
    			dispose = listen_dev(select, "change", ctx.select_change_handler);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, label);
    			append_dev(div, t1);
    			append_dev(div, select);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			append_dev(select, option2);
    			append_dev(select, option3);
    			select_option(select, ctx.funcName);
    			insert_dev(target, t6, anchor);
    			mount_component(graphic, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (changed.funcName) {
    				select_option(select, ctx.funcName);
    			}

    			const graphic_changes = {};

    			if (changed.$$scope || changed.zoomIdentity || changed.blockReindexing || changed.func) {
    				graphic_changes.$$scope = { changed, ctx };
    			}

    			graphic.$set(graphic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t6);
    			destroy_component(graphic, detaching);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let funcName = "sin";

    	const funcs = {
    		sin: Math.sin,
    		exp: Math.exp,
    		linear: x => x,
    		power2: x => x ** 2
    	};

    	let zoomIdentity = { x: 0, y: 0, kx: 1, ky: 1 };
    	let blockReindexing = false;

    	const setZoomIdentity = zoomId => {
    		$$invalidate("zoomIdentity", zoomIdentity = zoomId);
    	};

    	const setBlockReindexing = bool => {
    		$$invalidate("blockReindexing", blockReindexing = bool);
    	};

    	const pan = createPanHandler(zoomIdentity, {
    		setZoomIdentity,
    		setBlockReindexing,
    		extentX: [-500, 500],
    		extentY: [-500, 500]
    	});

    	const zoom = createZoomHandler(zoomIdentity, {
    		setZoomIdentity,
    		minZoom: 0.2,
    		maxZoom: 3,
    		extentX: [-500, 500],
    		extentY: [-500, 500],
    		step: 1,
    		center: { x: 0, y: 0 }
    	});

    	function select_change_handler() {
    		funcName = select_value(this);
    		$$invalidate("funcName", funcName);
    	}

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("funcName" in $$props) $$invalidate("funcName", funcName = $$props.funcName);
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    		if ("func" in $$props) $$invalidate("func", func = $$props.func);
    	};

    	let func;

    	$$self.$$.update = (changed = { funcName: 1 }) => {
    		if (changed.funcName) {
    			 $$invalidate("func", func = funcs[funcName]);
    		}
    	};

    	return {
    		funcName,
    		zoomIdentity,
    		blockReindexing,
    		pan,
    		zoom,
    		func,
    		select_change_handler
    	};
    }

    class FuncLines extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$y, create_fragment$y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FuncLines",
    			options,
    			id: create_fragment$y.name
    		});
    	}
    }

    function colors(specifier) {
      var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
      while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
      return colors;
    }

    var schemeCategory10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

    var schemeAccent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

    var schemeDark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

    var c = rgb(),
        pi_1_3 = Math.PI / 3,
        pi_2_3 = Math.PI * 2 / 3;

    function sinebow(t) {
      var x;
      t = (0.5 - t) * Math.PI;
      c.r = 255 * (x = Math.sin(t)) * x;
      c.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
      c.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
      return c + "";
    }

    function ramp(range) {
      var n = range.length;
      return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }

    var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

    var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

    var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

    var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

    /* test/sandbox/src/examples/Legends.svelte generated by Svelte v3.15.0 */

    const { console: console_1$2 } = globals;
    const file$i = "test/sandbox/src/examples/Legends.svelte";

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.row = list[i];
    	child_ctx.i = i;
    	return child_ctx;
    }

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.container = list[i];
    	return child_ctx;
    }

    // (101:4) <Section        x1={50} x2={300}       y1={50} y2={500}       padding={30}       scaleX={scaleLinear().domain(data.domain('a'))}       scaleY={scaleLinear().domain(data.domain('b'))}       {zoomIdentity}     >
    function create_default_slot_3(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let current;

    	const discretelegend = new DiscreteLegend({
    			props: {
    				x1: func,
    				x2: func_1,
    				y1: func_2,
    				y2: func_3,
    				fill: ctx.linearColorScale,
    				orient: "horizontal",
    				titleVjust: "top",
    				labelCount: 8,
    				titleX: func_4,
    				titleY: func_5
    			},
    			$$inline: true
    		});

    	const gradientlegend0 = new GradientLegend({
    			props: {
    				x1: 20,
    				x2: 60,
    				y1: 80,
    				y2: 100,
    				fill: ctx.linearColorScale,
    				orient: "horizontal",
    				titleVjust: "top",
    				labelCount: 4,
    				titleX: 40,
    				titleY: 105
    			},
    			$$inline: true
    		});

    	const gradientlegend1 = new GradientLegend({
    			props: {
    				labels: ctx.bins2,
    				fillOpacity: ctx.binAlpha,
    				fill: "purple",
    				orient: "vertical",
    				labelCount: 6,
    				vjust: "center",
    				hjust: "right",
    				title: "Test title 12345",
    				titleVjust: "center",
    				titleHjust: "left",
    				titleRotation: -90,
    				titlePaddingX: -15,
    				usePadding: false
    			},
    			$$inline: true
    		});

    	const pointlayer = new PointLayer({
    			props: {
    				x: ctx.filteredData.column("a"),
    				y: ctx.filteredData.column("b"),
    				key: ctx.filteredData.column("$key"),
    				fill: ctx.linearColorScale
    			},
    			$$inline: true
    		});

    	const xaxis = new XAxis({
    			props: { zoomIdentity: { y: 0, ky: 1 } },
    			$$inline: true
    		});

    	const yaxis = new YAxis({
    			props: { zoomIdentity: { x: 0, kx: 1 } },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(discretelegend.$$.fragment);
    			t0 = space();
    			create_component(gradientlegend0.$$.fragment);
    			t1 = space();
    			create_component(gradientlegend1.$$.fragment);
    			t2 = space();
    			create_component(pointlayer.$$.fragment);
    			t3 = space();
    			create_component(xaxis.$$.fragment);
    			t4 = space();
    			create_component(yaxis.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(discretelegend, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(gradientlegend0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(gradientlegend1, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(pointlayer, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(xaxis, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(yaxis, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const pointlayer_changes = {};
    			if (changed.filteredData) pointlayer_changes.x = ctx.filteredData.column("a");
    			if (changed.filteredData) pointlayer_changes.y = ctx.filteredData.column("b");
    			if (changed.filteredData) pointlayer_changes.key = ctx.filteredData.column("$key");
    			pointlayer.$set(pointlayer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(discretelegend.$$.fragment, local);
    			transition_in(gradientlegend0.$$.fragment, local);
    			transition_in(gradientlegend1.$$.fragment, local);
    			transition_in(pointlayer.$$.fragment, local);
    			transition_in(xaxis.$$.fragment, local);
    			transition_in(yaxis.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(discretelegend.$$.fragment, local);
    			transition_out(gradientlegend0.$$.fragment, local);
    			transition_out(gradientlegend1.$$.fragment, local);
    			transition_out(pointlayer.$$.fragment, local);
    			transition_out(xaxis.$$.fragment, local);
    			transition_out(yaxis.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(discretelegend, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(gradientlegend0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(gradientlegend1, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(pointlayer, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(xaxis, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(yaxis, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(101:4) <Section        x1={50} x2={300}       y1={50} y2={500}       padding={30}       scaleX={scaleLinear().domain(data.domain('a'))}       scaleY={scaleLinear().domain(data.domain('b'))}       {zoomIdentity}     >",
    		ctx
    	});

    	return block;
    }

    // (164:4) <Section        x1={350} x2={600}       y1={50} y2={500}       padding={40}       scaleX={scaleLinear().domain(data.domain('a'))}       scaleY={scaleLinear().domain(data.domain('b'))}       {zoomIdentity}     >
    function create_default_slot_2$1(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let current;

    	const discretelegend0 = new DiscreteLegend({
    			props: {
    				labels: [0, 15, 50, 90, 120],
    				fillOpacity: linear$1().domain([0, 120]).range([0, 1]),
    				fill: "green",
    				orient: "horizontal",
    				width: 100,
    				vjust: "top",
    				hjust: "center",
    				title: "Test title 12345",
    				usePadding: true
    			},
    			$$inline: true
    		});

    	const discretelegend1 = new DiscreteLegend({
    			props: {
    				fill: ctx.seqScale,
    				strokeWidth: 2,
    				labelCount: 5,
    				stroke: "white",
    				orient: "vertical",
    				labelExtra: true,
    				titleVjust: "top",
    				titleHjust: "right",
    				vjust: "top",
    				hjust: "right",
    				usePadding: true
    			},
    			$$inline: true
    		});

    	const discretelegend2 = new DiscreteLegend({
    			props: {
    				fill: ctx.fruitScale,
    				strokeWidth: 2,
    				stroke: "white",
    				orient: "vertical",
    				labelAnchorPoint: "r",
    				labelExtra: true,
    				vjust: "centre",
    				hjust: "right",
    				usePadding: false
    			},
    			$$inline: true
    		});

    	const pointlayer = new PointLayer({
    			props: {
    				x: ctx.filteredData.column("a"),
    				y: ctx.filteredData.column("b"),
    				key: ctx.filteredData.column("$key"),
    				fill: ctx.seqScale
    			},
    			$$inline: true
    		});

    	const xaxis = new XAxis({
    			props: { zoomIdentity: { y: 0, ky: 1 } },
    			$$inline: true
    		});

    	const yaxis = new YAxis({
    			props: { zoomIdentity: { x: 0, kx: 1 } },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(discretelegend0.$$.fragment);
    			t0 = space();
    			create_component(discretelegend1.$$.fragment);
    			t1 = space();
    			create_component(discretelegend2.$$.fragment);
    			t2 = space();
    			create_component(pointlayer.$$.fragment);
    			t3 = space();
    			create_component(xaxis.$$.fragment);
    			t4 = space();
    			create_component(yaxis.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(discretelegend0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(discretelegend1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(discretelegend2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(pointlayer, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(xaxis, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(yaxis, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const pointlayer_changes = {};
    			if (changed.filteredData) pointlayer_changes.x = ctx.filteredData.column("a");
    			if (changed.filteredData) pointlayer_changes.y = ctx.filteredData.column("b");
    			if (changed.filteredData) pointlayer_changes.key = ctx.filteredData.column("$key");
    			pointlayer.$set(pointlayer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(discretelegend0.$$.fragment, local);
    			transition_in(discretelegend1.$$.fragment, local);
    			transition_in(discretelegend2.$$.fragment, local);
    			transition_in(pointlayer.$$.fragment, local);
    			transition_in(xaxis.$$.fragment, local);
    			transition_in(yaxis.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(discretelegend0.$$.fragment, local);
    			transition_out(discretelegend1.$$.fragment, local);
    			transition_out(discretelegend2.$$.fragment, local);
    			transition_out(pointlayer.$$.fragment, local);
    			transition_out(xaxis.$$.fragment, local);
    			transition_out(yaxis.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(discretelegend0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(discretelegend1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(discretelegend2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(pointlayer, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(xaxis, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(yaxis, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(164:4) <Section        x1={350} x2={600}       y1={50} y2={500}       padding={40}       scaleX={scaleLinear().domain(data.domain('a'))}       scaleY={scaleLinear().domain(data.domain('b'))}       {zoomIdentity}     >",
    		ctx
    	});

    	return block;
    }

    // (243:6) {#each container.rows() as row, i}
    function create_each_block_1$2(ctx) {
    	let current;

    	function func_6(...args) {
    		return ctx.func_6(ctx, ...args);
    	}

    	const rectangle = new Rectangle({
    			props: {
    				x1: ctx.row.fruit,
    				x2: func_6,
    				y1: ctx.i === 0
    				? 0
    				: ctx.container.prevRow(ctx.row.$key).cumsum_value,
    				y2: ctx.row.cumsum_value,
    				fill: ctx.nutrientColorScale(ctx.row.nutrient)
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(rectangle.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(rectangle, target, anchor);
    			current = true;
    		},
    		p: function update(changed, new_ctx) {
    			ctx = new_ctx;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rectangle.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rectangle.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(rectangle, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(243:6) {#each container.rows() as row, i}",
    		ctx
    	});

    	return block;
    }

    // (241:6) {#each containerPerFruit as container}
    function create_each_block$5(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = ctx.container.rows();
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (changed.containerPerFruit || changed.nutrientColorScale) {
    				each_value_1 = ctx.container.rows();
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(241:6) {#each containerPerFruit as container}",
    		ctx
    	});

    	return block;
    }

    // (222:4) <Section        x1={200} x2={500}       y1={550} y2={950}       padding={40}       scaleX={scaleBand().domain(fruitDomain).padding(0.3)}       scaleY={scaleLinear().domain([0, 1])}     >
    function create_default_slot_1$a(ctx) {
    	let t0;
    	let t1;
    	let current;

    	const discretelegend = new DiscreteLegend({
    			props: {
    				fill: ctx.nutrientColorScale,
    				strokeWidth: 2,
    				stroke: "white",
    				orient: "vertical",
    				vjust: "centre",
    				hjust: "left",
    				flipLabels: true,
    				labelPaddingX: 10,
    				usePadding: true
    			},
    			$$inline: true
    		});

    	let each_value = ctx.containerPerFruit;
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const xaxis = new XAxis({
    			props: { labelFontSize: 13 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(discretelegend.$$.fragment);
    			t0 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			create_component(xaxis.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(discretelegend, target, anchor);
    			insert_dev(target, t0, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t1, anchor);
    			mount_component(xaxis, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (changed.containerPerFruit || changed.nutrientColorScale) {
    				each_value = ctx.containerPerFruit;
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(t1.parentNode, t1);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(discretelegend.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(xaxis.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(discretelegend.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(xaxis.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(discretelegend, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(xaxis, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$a.name,
    		type: "slot",
    		source: "(222:4) <Section        x1={200} x2={500}       y1={550} y2={950}       padding={40}       scaleX={scaleBand().domain(fruitDomain).padding(0.3)}       scaleY={scaleLinear().domain([0, 1])}     >",
    		ctx
    	});

    	return block;
    }

    // (95:1) <Graphic      width={700} {height}     scaleX={scaleLinear().domain([0, 600])}     scaleY={scaleLinear().domain([0, 1000])}   >
    function create_default_slot$a(ctx) {
    	let t0;
    	let t1;
    	let current;

    	const section0 = new Section({
    			props: {
    				x1: 50,
    				x2: 300,
    				y1: 50,
    				y2: 500,
    				padding: 30,
    				scaleX: linear$1().domain(ctx.data.domain("a")),
    				scaleY: linear$1().domain(ctx.data.domain("b")),
    				zoomIdentity: ctx.zoomIdentity,
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const section1 = new Section({
    			props: {
    				x1: 350,
    				x2: 600,
    				y1: 50,
    				y2: 500,
    				padding: 40,
    				scaleX: linear$1().domain(ctx.data.domain("a")),
    				scaleY: linear$1().domain(ctx.data.domain("b")),
    				zoomIdentity: ctx.zoomIdentity,
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const section2 = new Section({
    			props: {
    				x1: 200,
    				x2: 500,
    				y1: 550,
    				y2: 950,
    				padding: 40,
    				scaleX: band().domain(ctx.fruitDomain).padding(0.3),
    				scaleY: linear$1().domain([0, 1]),
    				$$slots: { default: [create_default_slot_1$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(section0.$$.fragment);
    			t0 = space();
    			create_component(section1.$$.fragment);
    			t1 = space();
    			create_component(section2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(section0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(section1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(section2, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const section0_changes = {};

    			if (changed.$$scope || changed.filteredData) {
    				section0_changes.$$scope = { changed, ctx };
    			}

    			section0.$set(section0_changes);
    			const section1_changes = {};

    			if (changed.$$scope || changed.filteredData) {
    				section1_changes.$$scope = { changed, ctx };
    			}

    			section1.$set(section1_changes);
    			const section2_changes = {};

    			if (changed.$$scope) {
    				section2_changes.$$scope = { changed, ctx };
    			}

    			section2.$set(section2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section0.$$.fragment, local);
    			transition_in(section1.$$.fragment, local);
    			transition_in(section2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section0.$$.fragment, local);
    			transition_out(section1.$$.fragment, local);
    			transition_out(section2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(section1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(section2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$a.name,
    		type: "slot",
    		source: "(95:1) <Graphic      width={700} {height}     scaleX={scaleLinear().domain([0, 600])}     scaleY={scaleLinear().domain([0, 1000])}   >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$z(ctx) {
    	let div;
    	let current;

    	const graphic = new Graphic({
    			props: {
    				width: 700,
    				height,
    				scaleX: linear$1().domain([0, 600]),
    				scaleY: linear$1().domain([0, 1000]),
    				$$slots: { default: [create_default_slot$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(graphic.$$.fragment);
    			add_location(div, file$i, 93, 0, 3261);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(graphic, div, null);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const graphic_changes = {};

    			if (changed.$$scope || changed.filteredData) {
    				graphic_changes.$$scope = { changed, ctx };
    			}

    			graphic.$set(graphic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(graphic);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let threshold = 0;
    let height = 800;
    let transformation = "identity";
    let duration = 2000;
    let x = 0;
    let y = 0;
    let k = 1;

    function generateData$3(N, error) {
    	const getError = () => -error + Math.random() * (2 * error) * N;
    	let data = { a: [], b: [] };

    	for (let i = 0; i < N; i++) {
    		data.a.push(i + getError());
    		data.b.push(i + getError());
    	}

    	return data;
    }

    const func = () => {
    	return 200;
    };

    const func_1 = () => {
    	return 300;
    };

    const func_2 = () => {
    	return 60;
    };

    const func_3 = () => {
    	return 100;
    };

    const func_4 = () => {
    	return 170;
    };

    const func_5 = () => {
    	return 70;
    };

    function instance$z($$self, $$props, $$invalidate) {
    	let { N = 100 } = $$props;
    	const data = new florenceDatacontainer_umd(generateData$3(N, 0.25));
    	let filteredData;
    	const scaleA = linear$1().domain(data.domain("a"));
    	const scaleB = linear$1().domain(data.domain("b"));
    	let zoomIdentity = { x, y, kx: k, ky: k };
    	const radiusScale = linear$1().domain(data.domain("b")).range([10, 0]);
    	const bins = [[0, 30], [30, 70], [70, 100], [100, 155], [55, 300]];
    	const bins2 = [0, 10, 20, 40, 90, 120];
    	const fruits = ["apple", "banana", "orange", "pomelo"];
    	const linearColorScale = linear$1().domain(data.domain("a")).range(["red", "blue"]);
    	const linearColorScaleBin = linear$1().domain(bins).range(["red", "blue"]);
    	const seqScale = sequential().domain(data.domain("a")).interpolator(sinebow);
    	const linearColorScale2 = sequential().domain([0, 120]).interpolator(viridis);
    	const fruitScale = ordinal().domain(fruits).range(schemeDark2);
    	const binScale = linear$1().domain([0, 4]).range(["red", "blue"]);
    	const alphaScale = linear$1().domain(data.domain("a")).range([0, 1]);
    	const fruitAlpha = ordinal().domain(fruits).range([0, 1, 0.4, 0.2]);
    	const binAlpha = linear$1().domain([0, 120]).range([0, 1]);

    	let catData = new florenceDatacontainer_umd({
    			fruit: ["apple", "banana", "apple", "banana", "apple", "banana"],
    			nutrient: ["carbs", "carbs", "fibre", "fibre", "protein", "protein"],
    			value: [3, 5, 1, 3, 4, 2]
    		});

    	const fruitDomain = catData.domain("fruit");
    	const nutrientDomain = catData.domain("nutrient");

    	catData = catData.groupBy("fruit").mutarise({ totalValuePerFruit: { value: "sum" } }).mutate({
    		valueFraction: row => row.value / row.totalValuePerFruit
    	}).select(["fruit", "nutrient", "valueFraction"]).groupBy("fruit");

    	const containerPerFruit = catData.column("$grouped").map(container => {
    		return container.cumsum({ cumsum_value: "valueFraction" });
    	});

    	const nutrientColorScale = ordinal().domain(nutrientDomain).range(schemeAccent);
    	const writable_props = ["N"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<Legends> was created with unknown prop '${key}'`);
    	});

    	const func_6 = ({ row }, { scaleX }) => scaleX(row.fruit) + scaleX.bandwidth();

    	$$self.$set = $$props => {
    		if ("N" in $$props) $$invalidate("N", N = $$props.N);
    	};

    	$$self.$capture_state = () => {
    		return {
    			N,
    			threshold,
    			filteredData,
    			height,
    			transformation,
    			duration,
    			x,
    			y,
    			k,
    			zoomIdentity,
    			catData
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("N" in $$props) $$invalidate("N", N = $$props.N);
    		if ("threshold" in $$props) $$invalidate("threshold", threshold = $$props.threshold);
    		if ("filteredData" in $$props) $$invalidate("filteredData", filteredData = $$props.filteredData);
    		if ("height" in $$props) $$invalidate("height", height = $$props.height);
    		if ("transformation" in $$props) transformation = $$props.transformation;
    		if ("duration" in $$props) duration = $$props.duration;
    		if ("x" in $$props) x = $$props.x;
    		if ("y" in $$props) y = $$props.y;
    		if ("k" in $$props) k = $$props.k;
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("catData" in $$props) catData = $$props.catData;
    	};

    	$$self.$$.update = (changed = { threshold: 1 }) => {
    		if (changed.threshold) {
    			 {
    				$$invalidate("filteredData", filteredData = data.filter(row => row.a > threshold));
    			}
    		}
    	};

    	return {
    		N,
    		data,
    		filteredData,
    		zoomIdentity,
    		bins2,
    		linearColorScale,
    		seqScale,
    		fruitScale,
    		binAlpha,
    		fruitDomain,
    		containerPerFruit,
    		nutrientColorScale,
    		func_6
    	};
    }

    class Legends extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$z, safe_not_equal, { N: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Legends",
    			options,
    			id: create_fragment$z.name
    		});
    	}

    	get N() {
    		throw new Error("<Legends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set N(value) {
    		throw new Error("<Legends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* test/sandbox/src/examples/DragCategorical.svelte generated by Svelte v3.15.0 */
    const file$j = "test/sandbox/src/examples/DragCategorical.svelte";

    // (75:6) {#if dragPoint}
    function create_if_block$9(ctx) {
    	let current;

    	const point = new Point({
    			props: {
    				x: ctx.dragPoint.x,
    				y: ctx.dragPoint.y,
    				fill: "red",
    				radius: 10
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(point.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(point, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const point_changes = {};
    			if (changed.dragPoint) point_changes.x = ctx.dragPoint.x;
    			if (changed.dragPoint) point_changes.y = ctx.dragPoint.y;
    			point.$set(point_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(point.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(point.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(point, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(75:6) {#if dragPoint}",
    		ctx
    	});

    	return block;
    }

    // (57:2) <Section    x1={50} x2={450}    y1={50} y2={450}    scaleX={scaleA}    scaleY={scaleB}       backgroundColor="white"       transformation="polar"       zoomIdentity={{x: 0, y: 0, kx: 1.2, ky: 1.2}}       {blockReindexing}   >
    function create_default_slot_1$b(ctx) {
    	let t;
    	let if_block_anchor;
    	let current;

    	const pointlayer = new PointLayer({
    			props: {
    				x: ctx.data.column("a"),
    				y: ctx.data.column("b"),
    				key: ctx.data.column("$key"),
    				onMousedrag: ctx.onMousedrag
    			},
    			$$inline: true
    		});

    	let if_block = ctx.dragPoint && create_if_block$9(ctx);

    	const block = {
    		c: function create() {
    			create_component(pointlayer.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(pointlayer, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const pointlayer_changes = {};
    			if (changed.data) pointlayer_changes.x = ctx.data.column("a");
    			if (changed.data) pointlayer_changes.y = ctx.data.column("b");
    			if (changed.data) pointlayer_changes.key = ctx.data.column("$key");
    			pointlayer.$set(pointlayer_changes);

    			if (ctx.dragPoint) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$9(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointlayer.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointlayer.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pointlayer, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$b.name,
    		type: "slot",
    		source: "(57:2) <Section    x1={50} x2={450}    y1={50} y2={450}    scaleX={scaleA}    scaleY={scaleB}       backgroundColor=\\\"white\\\"       transformation=\\\"polar\\\"       zoomIdentity={{x: 0, y: 0, kx: 1.2, ky: 1.2}}       {blockReindexing}   >",
    		ctx
    	});

    	return block;
    }

    // (55:1) <Graphic width={500} height={500}>
    function create_default_slot$b(ctx) {
    	let current;

    	const section = new Section({
    			props: {
    				x1: 50,
    				x2: 450,
    				y1: 50,
    				y2: 450,
    				scaleX: ctx.scaleA,
    				scaleY: ctx.scaleB,
    				backgroundColor: "white",
    				transformation: "polar",
    				zoomIdentity: { x: 0, y: 0, kx: 1.2, ky: 1.2 },
    				blockReindexing: ctx.blockReindexing,
    				$$slots: { default: [create_default_slot_1$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const section_changes = {};
    			if (changed.blockReindexing) section_changes.blockReindexing = ctx.blockReindexing;

    			if (changed.$$scope || changed.dragPoint || changed.data) {
    				section_changes.$$scope = { changed, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$b.name,
    		type: "slot",
    		source: "(55:1) <Graphic width={500} height={500}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$A(ctx) {
    	let div;
    	let current;

    	const graphic = new Graphic({
    			props: {
    				width: 500,
    				height: 500,
    				$$slots: { default: [create_default_slot$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(graphic.$$.fragment);
    			add_location(div, file$j, 52, 0, 1277);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(graphic, div, null);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const graphic_changes = {};

    			if (changed.$$scope || changed.blockReindexing || changed.dragPoint || changed.data) {
    				graphic_changes.$$scope = { changed, ctx };
    			}

    			graphic.$set(graphic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(graphic);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const N$1 = 100;

    function generateData$4(N, error) {
    	const getError = () => -error + Math.random() * (2 * error) * N;
    	const categories = ["a", "b", "c", "d", "e"];
    	let data = { a: [], b: [] };

    	for (let i = 0; i < N; i++) {
    		data.a.push(i + getError());
    		data.b.push(categories[Math.floor(Math.random() * 5)]);
    	}

    	return data;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let data = new florenceDatacontainer_umd(generateData$4(N$1, 0.25));
    	const domainB = data.domain("b");
    	domainB.sort();
    	const scaleA = linear$1().domain(data.domain("a"));
    	const scaleB = point().domain(domainB);
    	let hitKey;
    	let dragPoint;
    	let blockReindexing = false;

    	function onMousedrag(event) {
    		if (event.dragType === "start") {
    			hitKey = event.key;
    			$$invalidate("blockReindexing", blockReindexing = true);
    		}

    		if (event.dragType === "drag") {
    			$$invalidate("dragPoint", dragPoint = event.localCoordinates);
    		}

    		if (event.dragType === "end") {
    			data.updateRow(hitKey, { a: dragPoint.x, b: dragPoint.y });
    			$$invalidate("data", data);
    			hitKey = undefined;
    			$$invalidate("dragPoint", dragPoint = undefined);
    			$$invalidate("blockReindexing", blockReindexing = false);
    		}
    	}

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate("data", data = $$props.data);
    		if ("hitKey" in $$props) hitKey = $$props.hitKey;
    		if ("dragPoint" in $$props) $$invalidate("dragPoint", dragPoint = $$props.dragPoint);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    	};

    	return {
    		data,
    		scaleA,
    		scaleB,
    		dragPoint,
    		blockReindexing,
    		onMousedrag
    	};
    }

    class DragCategorical extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$A, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DragCategorical",
    			options,
    			id: create_fragment$A.name
    		});
    	}
    }

    /* test/sandbox/src/examples/FunctionAPI.svelte generated by Svelte v3.15.0 */

    // (35:2) <Section {scaleX} {scaleY} padding={20}>
    function create_default_slot_1$c(ctx) {
    	let current;

    	const pointlayer = new PointLayer({
    			props: {
    				x: ctx.data.column("a"),
    				y: ctx.data.column("b"),
    				fill: ctx.func,
    				radius: 7,
    				onMouseover: ctx.onMouseover,
    				onMouseout: ctx.onMouseout
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pointlayer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pointlayer, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const pointlayer_changes = {};
    			if (changed.hoverKey) pointlayer_changes.fill = ctx.func;
    			pointlayer.$set(pointlayer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointlayer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointlayer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pointlayer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$c.name,
    		type: "slot",
    		source: "(35:2) <Section {scaleX} {scaleY} padding={20}>",
    		ctx
    	});

    	return block;
    }

    // (33:0) <Graphic width={500} height={500}>
    function create_default_slot$c(ctx) {
    	let current;

    	const section = new Section({
    			props: {
    				scaleX: ctx.scaleX,
    				scaleY: ctx.scaleY,
    				padding: 20,
    				$$slots: { default: [create_default_slot_1$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const section_changes = {};

    			if (changed.$$scope || changed.hoverKey) {
    				section_changes.$$scope = { changed, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$c.name,
    		type: "slot",
    		source: "(33:0) <Graphic width={500} height={500}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let current;

    	const graphic = new Graphic({
    			props: {
    				width: 500,
    				height: 500,
    				$$slots: { default: [create_default_slot$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(graphic.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphic, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const graphic_changes = {};

    			if (changed.$$scope || changed.hoverKey) {
    				graphic_changes.$$scope = { changed, ctx };
    			}

    			graphic.$set(graphic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphic, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const N$2 = 100;

    function generateData$5(N, error) {
    	const getError = () => -error + Math.random() * (2 * error) * N;
    	let data = { a: [], b: [] };

    	for (let i = 0; i < N; i++) {
    		data.a.push(i + getError());
    		data.b.push(i + getError());
    	}

    	return data;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	const data = new florenceDatacontainer_umd(generateData$5(N$2, 0.25));
    	const scaleX = linear$1().domain(data.domain("a"));
    	const scaleY = linear$1().domain(data.domain("b"));
    	let hoverKey;

    	function onMouseover({ key }) {
    		$$invalidate("hoverKey", hoverKey = key);
    	}

    	function onMouseout({ key }) {
    		if (hoverKey === key) $$invalidate("hoverKey", hoverKey = undefined);
    	}

    	const func = key => key === hoverKey ? "red" : "black";

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("hoverKey" in $$props) $$invalidate("hoverKey", hoverKey = $$props.hoverKey);
    	};

    	return {
    		data,
    		scaleX,
    		scaleY,
    		hoverKey,
    		onMouseover,
    		onMouseout,
    		func
    	};
    }

    class FunctionAPI extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$B, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FunctionAPI",
    			options,
    			id: create_fragment$B.name
    		});
    	}
    }

    /* test/sandbox/src/examples/FlipTest.svelte generated by Svelte v3.15.0 */

    // (5:0) <Graphic width={200} height={200} flipY flipX>
    function create_default_slot$d(ctx) {
    	let current;
    	const point = new Point({ props: { x: 10, y: 10 }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(point.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(point, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(point.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(point.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(point, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$d.name,
    		type: "slot",
    		source: "(5:0) <Graphic width={200} height={200} flipY flipX>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$C(ctx) {
    	let current;

    	const graphic = new Graphic({
    			props: {
    				width: 200,
    				height: 200,
    				flipY: true,
    				flipX: true,
    				$$slots: { default: [create_default_slot$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(graphic.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphic, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const graphic_changes = {};

    			if (changed.$$scope) {
    				graphic_changes.$$scope = { changed, ctx };
    			}

    			graphic.$set(graphic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphic, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    class FlipTest extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, null, create_fragment$C, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FlipTest",
    			options,
    			id: create_fragment$C.name
    		});
    	}
    }

    /* test/sandbox/src/examples/NonNumericAxis.svelte generated by Svelte v3.15.0 */

    // (8:2) <Section     padding={20}     scaleX={scalePoint().domain(['a', 'b', 'c'])}     scaleY={scalePoint().domain(['a', 'b', 'c'])}   >
    function create_default_slot_1$d(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;

    	const rectangle0 = new Rectangle({
    			props: {
    				x1: "a",
    				x2: "b",
    				y1: "a",
    				y2: "c",
    				fill: "blue",
    				opacity: 0.5
    			},
    			$$inline: true
    		});

    	const rectangle1 = new Rectangle({
    			props: {
    				x1: "b",
    				x2: "c",
    				y1: "b",
    				y2: "c",
    				fill: "red",
    				opacity: 0.5
    			},
    			$$inline: true
    		});

    	const rectangle2 = new Rectangle({
    			props: {
    				x1: "a",
    				x2: "c",
    				y1: "b",
    				y2: "a",
    				fill: "green",
    				opacity: 0.5
    			},
    			$$inline: true
    		});

    	const xaxis = new XAxis({ $$inline: true });
    	const yaxis = new YAxis({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(rectangle0.$$.fragment);
    			t0 = space();
    			create_component(rectangle1.$$.fragment);
    			t1 = space();
    			create_component(rectangle2.$$.fragment);
    			t2 = space();
    			create_component(xaxis.$$.fragment);
    			t3 = space();
    			create_component(yaxis.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(rectangle0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(rectangle1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(rectangle2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(xaxis, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(yaxis, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rectangle0.$$.fragment, local);
    			transition_in(rectangle1.$$.fragment, local);
    			transition_in(rectangle2.$$.fragment, local);
    			transition_in(xaxis.$$.fragment, local);
    			transition_in(yaxis.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rectangle0.$$.fragment, local);
    			transition_out(rectangle1.$$.fragment, local);
    			transition_out(rectangle2.$$.fragment, local);
    			transition_out(xaxis.$$.fragment, local);
    			transition_out(yaxis.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(rectangle0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(rectangle1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(rectangle2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(xaxis, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(yaxis, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$d.name,
    		type: "slot",
    		source: "(8:2) <Section     padding={20}     scaleX={scalePoint().domain(['a', 'b', 'c'])}     scaleY={scalePoint().domain(['a', 'b', 'c'])}   >",
    		ctx
    	});

    	return block;
    }

    // (6:0) <Graphic width={500} height={500}>
    function create_default_slot$e(ctx) {
    	let current;

    	const section = new Section({
    			props: {
    				padding: 20,
    				scaleX: point().domain(["a", "b", "c"]),
    				scaleY: point().domain(["a", "b", "c"]),
    				$$slots: { default: [create_default_slot_1$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const section_changes = {};

    			if (changed.$$scope) {
    				section_changes.$$scope = { changed, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$e.name,
    		type: "slot",
    		source: "(6:0) <Graphic width={500} height={500}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$D(ctx) {
    	let current;

    	const graphic = new Graphic({
    			props: {
    				width: 500,
    				height: 500,
    				$$slots: { default: [create_default_slot$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(graphic.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphic, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const graphic_changes = {};

    			if (changed.$$scope) {
    				graphic_changes.$$scope = { changed, ctx };
    			}

    			graphic.$set(graphic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphic, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    class NonNumericAxis extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, null, create_fragment$D, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NonNumericAxis",
    			options,
    			id: create_fragment$D.name
    		});
    	}
    }

    /* test/sandbox/src/examples/DragAllMarks.svelte generated by Svelte v3.15.0 */

    // (108:2) <Section      scaleX={scaleLinear().domain([0, 10])}     scaleY={scaleLinear().domain([0, 10])}     {blockReindexing}   >
    function create_default_slot_1$e(ctx) {
    	let t0;
    	let t1;
    	let current;
    	const rectangle_spread_levels = [ctx.rectangleCoords, { fill: "green" }, { onMousedrag: ctx.dragRectangle }];
    	let rectangle_props = {};

    	for (let i = 0; i < rectangle_spread_levels.length; i += 1) {
    		rectangle_props = assign(rectangle_props, rectangle_spread_levels[i]);
    	}

    	const rectangle = new Rectangle({ props: rectangle_props, $$inline: true });

    	const line_spread_levels = [
    		ctx.lineCoords,
    		{ strokeWidth: 6 },
    		{ stroke: "red" },
    		{ onMousedrag: ctx.dragLine }
    	];

    	let line_props = {};

    	for (let i = 0; i < line_spread_levels.length; i += 1) {
    		line_props = assign(line_props, line_spread_levels[i]);
    	}

    	const line = new Line({ props: line_props, $$inline: true });

    	const funcline = new FuncLine({
    			props: {
    				func: ctx.func,
    				stroke: "blue",
    				strokeWidth: 8,
    				onMousedrag: ctx.dragFuncLine
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(rectangle.$$.fragment);
    			t0 = space();
    			create_component(line.$$.fragment);
    			t1 = space();
    			create_component(funcline.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(rectangle, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(line, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(funcline, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const rectangle_changes = changed.rectangleCoords || changed.dragRectangle
    			? get_spread_update(rectangle_spread_levels, [
    					changed.rectangleCoords && get_spread_object(ctx.rectangleCoords),
    					rectangle_spread_levels[1],
    					changed.dragRectangle && ({ onMousedrag: ctx.dragRectangle })
    				])
    			: {};

    			rectangle.$set(rectangle_changes);

    			const line_changes = changed.lineCoords || changed.dragLine
    			? get_spread_update(line_spread_levels, [
    					changed.lineCoords && get_spread_object(ctx.lineCoords),
    					line_spread_levels[1],
    					line_spread_levels[2],
    					changed.dragLine && ({ onMousedrag: ctx.dragLine })
    				])
    			: {};

    			line.$set(line_changes);
    			const funcline_changes = {};
    			if (changed.func) funcline_changes.func = ctx.func;
    			funcline.$set(funcline_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rectangle.$$.fragment, local);
    			transition_in(line.$$.fragment, local);
    			transition_in(funcline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rectangle.$$.fragment, local);
    			transition_out(line.$$.fragment, local);
    			transition_out(funcline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(rectangle, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(line, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(funcline, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$e.name,
    		type: "slot",
    		source: "(108:2) <Section      scaleX={scaleLinear().domain([0, 10])}     scaleY={scaleLinear().domain([0, 10])}     {blockReindexing}   >",
    		ctx
    	});

    	return block;
    }

    // (106:0) <Graphic width={500} height={500}>
    function create_default_slot$f(ctx) {
    	let current;

    	const section = new Section({
    			props: {
    				scaleX: linear$1().domain([0, 10]),
    				scaleY: linear$1().domain([0, 10]),
    				blockReindexing: ctx.blockReindexing,
    				$$slots: { default: [create_default_slot_1$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const section_changes = {};
    			if (changed.blockReindexing) section_changes.blockReindexing = ctx.blockReindexing;

    			if (changed.$$scope || changed.func || changed.lineCoords || changed.rectangleCoords) {
    				section_changes.$$scope = { changed, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$f.name,
    		type: "slot",
    		source: "(106:0) <Graphic width={500} height={500}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$E(ctx) {
    	let current;

    	const graphic = new Graphic({
    			props: {
    				width: 500,
    				height: 500,
    				$$slots: { default: [create_default_slot$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(graphic.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphic, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const graphic_changes = {};

    			if (changed.$$scope || changed.blockReindexing || changed.func || changed.lineCoords || changed.rectangleCoords) {
    				graphic_changes.$$scope = { changed, ctx };
    			}

    			graphic.$set(graphic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphic, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let blockReindexing = false;
    	let rectanglePosition = { x: 1, y: 1 };
    	let rectangleWH = { w: 2, h: 2 };
    	let rectStartDelta;

    	function dragRectangle(event) {
    		const localCoordinates = event.localCoordinates;

    		if (event.dragType === "start") {
    			$$invalidate("blockReindexing", blockReindexing = true);

    			rectStartDelta = {
    				x: localCoordinates.x - rectanglePosition.x,
    				y: localCoordinates.y - rectanglePosition.y
    			};
    		}

    		if (event.dragType === "drag") {
    			$$invalidate("rectanglePosition", rectanglePosition = {
    				x: localCoordinates.x - rectStartDelta.x,
    				y: localCoordinates.y - rectStartDelta.y
    			});
    		}

    		if (event.dragType === "end") {
    			$$invalidate("blockReindexing", blockReindexing = false);
    		}
    	}

    	let lineBaseX = new Array(10).fill(0).map(_ => Math.round(Math.random() * 10));
    	let lineBaseY = new Array(10).fill(0).map(_ => Math.round(Math.random() * 10));
    	let previousLinePosition;
    	let currentLinePosition;
    	let lineOffset = { x: 0, y: 0 };

    	function dragLine(event) {
    		const localCoordinates = event.localCoordinates;

    		if (event.dragType === "start") {
    			$$invalidate("blockReindexing", blockReindexing = true);
    			currentLinePosition = localCoordinates;
    		}

    		if (event.dragType === "drag") {
    			previousLinePosition = currentLinePosition;
    			currentLinePosition = localCoordinates;

    			$$invalidate("lineOffset", lineOffset = {
    				x: lineOffset.x + (currentLinePosition.x - previousLinePosition.x),
    				y: lineOffset.y + (currentLinePosition.y - previousLinePosition.y)
    			});
    		}

    		if (event.dragType === "end") {
    			$$invalidate("blockReindexing", blockReindexing = false);
    		}
    	}

    	let baseA = 1;
    	let previousY;
    	let currentY;

    	function dragFuncLine(event) {
    		const localCoordinates = event.localCoordinates;

    		if (event.dragType === "start") {
    			$$invalidate("blockReindexing", blockReindexing = true);
    			currentY = localCoordinates.y;
    		}

    		if (event.dragType === "drag") {
    			previousY = currentY;
    			currentY = localCoordinates.y;
    			$$invalidate("baseA", baseA = baseA + (currentY - previousY));
    		}

    		if (event.dragType === "end") {
    			$$invalidate("blockReindexing", blockReindexing = false);
    		}
    	}

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    		if ("rectanglePosition" in $$props) $$invalidate("rectanglePosition", rectanglePosition = $$props.rectanglePosition);
    		if ("rectangleWH" in $$props) $$invalidate("rectangleWH", rectangleWH = $$props.rectangleWH);
    		if ("rectStartDelta" in $$props) rectStartDelta = $$props.rectStartDelta;
    		if ("lineBaseX" in $$props) $$invalidate("lineBaseX", lineBaseX = $$props.lineBaseX);
    		if ("lineBaseY" in $$props) $$invalidate("lineBaseY", lineBaseY = $$props.lineBaseY);
    		if ("previousLinePosition" in $$props) previousLinePosition = $$props.previousLinePosition;
    		if ("currentLinePosition" in $$props) currentLinePosition = $$props.currentLinePosition;
    		if ("lineOffset" in $$props) $$invalidate("lineOffset", lineOffset = $$props.lineOffset);
    		if ("baseA" in $$props) $$invalidate("baseA", baseA = $$props.baseA);
    		if ("previousY" in $$props) previousY = $$props.previousY;
    		if ("currentY" in $$props) currentY = $$props.currentY;
    		if ("rectangleCoords" in $$props) $$invalidate("rectangleCoords", rectangleCoords = $$props.rectangleCoords);
    		if ("lineCoords" in $$props) $$invalidate("lineCoords", lineCoords = $$props.lineCoords);
    		if ("func" in $$props) $$invalidate("func", func = $$props.func);
    	};

    	let rectangleCoords;
    	let lineCoords;
    	let func;

    	$$self.$$.update = (changed = { rectanglePosition: 1, rectangleWH: 1, lineBaseX: 1, lineOffset: 1, lineBaseY: 1, baseA: 1 }) => {
    		if (changed.rectanglePosition || changed.rectangleWH) {
    			 $$invalidate("rectangleCoords", rectangleCoords = {
    				x1: rectanglePosition.x,
    				y1: rectanglePosition.y,
    				x2: rectanglePosition.x + rectangleWH.w,
    				y2: rectanglePosition.y + rectangleWH.h
    			});
    		}

    		if (changed.lineBaseX || changed.lineOffset || changed.lineBaseY) {
    			 $$invalidate("lineCoords", lineCoords = {
    				x: lineBaseX.map(x => x + lineOffset.x),
    				y: lineBaseY.map(y => y + lineOffset.y)
    			});
    		}

    		if (changed.baseA) {
    			 $$invalidate("func", func = x => Math.sin(x) * 2 + baseA);
    		}
    	};

    	return {
    		blockReindexing,
    		dragRectangle,
    		dragLine,
    		dragFuncLine,
    		rectangleCoords,
    		lineCoords,
    		func
    	};
    }

    class DragAllMarks extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$E, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DragAllMarks",
    			options,
    			id: create_fragment$E.name
    		});
    	}
    }

    /* test/sandbox/src/examples/StackedBarChart.svelte generated by Svelte v3.15.0 */

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.row = list[i];
    	child_ctx.i = i;
    	return child_ctx;
    }

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.container = list[i];
    	return child_ctx;
    }

    // (43:6) {#each container.rows() as row, i}
    function create_each_block_1$3(ctx) {
    	let current;

    	function func(...args) {
    		return ctx.func(ctx, ...args);
    	}

    	const rectangle = new Rectangle({
    			props: {
    				x1: ctx.row.fruit,
    				x2: func,
    				y1: ctx.i === 0
    				? 0
    				: ctx.container.prevRow(ctx.row.$key).cumsum_value,
    				y2: ctx.row.cumsum_value,
    				fill: ctx.nutrientColorScale(ctx.row.nutrient)
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(rectangle.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(rectangle, target, anchor);
    			current = true;
    		},
    		p: function update(changed, new_ctx) {
    			ctx = new_ctx;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rectangle.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rectangle.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(rectangle, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$3.name,
    		type: "each",
    		source: "(43:6) {#each container.rows() as row, i}",
    		ctx
    	});

    	return block;
    }

    // (41:4) {#each containerPerFruit as container}
    function create_each_block$6(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = ctx.container.rows();
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (changed.containerPerFruit || changed.nutrientColorScale) {
    				each_value_1 = ctx.container.rows();
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(41:4) {#each containerPerFruit as container}",
    		ctx
    	});

    	return block;
    }

    // (35:2) <Section     padding={24}     scaleX={scaleBand().domain(fruitDomain).padding(0.3)}     scaleY={scaleLinear().domain([0, 1])}   >
    function create_default_slot_1$f(ctx) {
    	let t;
    	let current;
    	let each_value = ctx.containerPerFruit;
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const xaxis = new XAxis({
    			props: { labelFontSize: 13 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			create_component(xaxis.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			mount_component(xaxis, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (changed.containerPerFruit || changed.nutrientColorScale) {
    				each_value = ctx.containerPerFruit;
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(t.parentNode, t);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(xaxis.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(xaxis.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(xaxis, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$f.name,
    		type: "slot",
    		source: "(35:2) <Section     padding={24}     scaleX={scaleBand().domain(fruitDomain).padding(0.3)}     scaleY={scaleLinear().domain([0, 1])}   >",
    		ctx
    	});

    	return block;
    }

    // (33:0) <Graphic width={500} height={500}>
    function create_default_slot$g(ctx) {
    	let current;

    	const section = new Section({
    			props: {
    				padding: 24,
    				scaleX: band().domain(ctx.fruitDomain).padding(0.3),
    				scaleY: linear$1().domain([0, 1]),
    				$$slots: { default: [create_default_slot_1$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const section_changes = {};

    			if (changed.$$scope) {
    				section_changes.$$scope = { changed, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$g.name,
    		type: "slot",
    		source: "(33:0) <Graphic width={500} height={500}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$F(ctx) {
    	let current;

    	const graphic = new Graphic({
    			props: {
    				width: 500,
    				height: 500,
    				$$slots: { default: [create_default_slot$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(graphic.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphic, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const graphic_changes = {};

    			if (changed.$$scope) {
    				graphic_changes.$$scope = { changed, ctx };
    			}

    			graphic.$set(graphic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphic, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self) {
    	let data = new florenceDatacontainer_umd({
    			fruit: ["apple", "banana", "apple", "banana", "apple", "banana"],
    			nutrient: ["carbs", "carbs", "fibre", "fibre", "protein", "protein"],
    			value: [3, 5, 1, 3, 4, 2]
    		});

    	const fruitDomain = data.domain("fruit");
    	const nutrientDomain = data.domain("nutrient");

    	data = data.groupBy("fruit").mutarise({ totalValuePerFruit: { value: "sum" } }).mutate({
    		valueFraction: row => row.value / row.totalValuePerFruit
    	}).select(["fruit", "nutrient", "valueFraction"]).groupBy("fruit");

    	const containerPerFruit = data.column("$grouped").map(container => {
    		return container.cumsum({ cumsum_value: "valueFraction" });
    	});

    	const nutrientColorScale = ordinal().domain(nutrientDomain).range(schemeAccent);
    	const func = ({ row }, { scaleX }) => scaleX(row.fruit) + scaleX.bandwidth();

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) data = $$props.data;
    	};

    	return {
    		fruitDomain,
    		containerPerFruit,
    		nutrientColorScale,
    		func
    	};
    }

    class StackedBarChart extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$D, create_fragment$F, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "StackedBarChart",
    			options,
    			id: create_fragment$F.name
    		});
    	}
    }

    /* test/sandbox/src/examples/SelectRectangle.svelte generated by Svelte v3.15.0 */

    // (84:2) <Section     bind:this={section}     padding={30}     scaleX={scaleLinear().domain([0, 10])}     scaleY={scaleLinear().domain([0, 10])}     {onMousedown}     {onMousemove}     {onMouseup}   >
    function create_default_slot_1$g(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let current;

    	const point = new Point({
    			props: {
    				x: 2,
    				y: 2,
    				radius: 7,
    				fill: ctx.highlightPoint ? "blue" : "red",
    				onSelect: ctx.func,
    				onDeselect: ctx.func_1
    			},
    			$$inline: true
    		});

    	const rectangle = new Rectangle({
    			props: {
    				x1: 5,
    				x2: 8,
    				y1: 5,
    				y2: 9,
    				fill: ctx.highlightRect ? "blue" : "red",
    				onSelect: ctx.func_2,
    				onDeselect: ctx.func_3
    			},
    			$$inline: true
    		});

    	const polygon = new Polygon({
    			props: {
    				x: [3, 5, 7, 8, 6, 4],
    				y: [6, 8, 7, 3, 4, 4],
    				fill: ctx.highlightPolygon ? "yellow" : "orange",
    				opacity: 0.7,
    				onSelect: ctx.func_4,
    				onDeselect: ctx.func_5
    			},
    			$$inline: true
    		});

    	const line = new Line({
    			props: {
    				x: [1, 3, 4],
    				y: [9, 8, 7],
    				stroke: ctx.highlightLine ? "blue" : "red",
    				onSelect: ctx.func_6,
    				onDeselect: ctx.func_7
    			},
    			$$inline: true
    		});

    	const xaxis = new XAxis({ $$inline: true });
    	const yaxis = new YAxis({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(point.$$.fragment);
    			t0 = space();
    			create_component(rectangle.$$.fragment);
    			t1 = space();
    			create_component(polygon.$$.fragment);
    			t2 = space();
    			create_component(line.$$.fragment);
    			t3 = space();
    			create_component(xaxis.$$.fragment);
    			t4 = space();
    			create_component(yaxis.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(point, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(rectangle, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(polygon, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(line, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(xaxis, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(yaxis, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const point_changes = {};
    			if (changed.highlightPoint) point_changes.fill = ctx.highlightPoint ? "blue" : "red";
    			if (changed.highlightPoint) point_changes.onSelect = ctx.func;
    			if (changed.highlightPoint) point_changes.onDeselect = ctx.func_1;
    			point.$set(point_changes);
    			const rectangle_changes = {};
    			if (changed.highlightRect) rectangle_changes.fill = ctx.highlightRect ? "blue" : "red";
    			if (changed.highlightRect) rectangle_changes.onSelect = ctx.func_2;
    			if (changed.highlightRect) rectangle_changes.onDeselect = ctx.func_3;
    			rectangle.$set(rectangle_changes);
    			const polygon_changes = {};
    			if (changed.highlightPolygon) polygon_changes.fill = ctx.highlightPolygon ? "yellow" : "orange";
    			if (changed.highlightPolygon) polygon_changes.onSelect = ctx.func_4;
    			if (changed.highlightPolygon) polygon_changes.onDeselect = ctx.func_5;
    			polygon.$set(polygon_changes);
    			const line_changes = {};
    			if (changed.highlightLine) line_changes.stroke = ctx.highlightLine ? "blue" : "red";
    			if (changed.highlightLine) line_changes.onSelect = ctx.func_6;
    			if (changed.highlightLine) line_changes.onDeselect = ctx.func_7;
    			line.$set(line_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(point.$$.fragment, local);
    			transition_in(rectangle.$$.fragment, local);
    			transition_in(polygon.$$.fragment, local);
    			transition_in(line.$$.fragment, local);
    			transition_in(xaxis.$$.fragment, local);
    			transition_in(yaxis.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(point.$$.fragment, local);
    			transition_out(rectangle.$$.fragment, local);
    			transition_out(polygon.$$.fragment, local);
    			transition_out(line.$$.fragment, local);
    			transition_out(xaxis.$$.fragment, local);
    			transition_out(yaxis.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(point, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(rectangle, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(polygon, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(line, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(xaxis, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(yaxis, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$g.name,
    		type: "slot",
    		source: "(84:2) <Section     bind:this={section}     padding={30}     scaleX={scaleLinear().domain([0, 10])}     scaleY={scaleLinear().domain([0, 10])}     {onMousedown}     {onMousemove}     {onMouseup}   >",
    		ctx
    	});

    	return block;
    }

    // (132:2) {#if selectionRectangle}
    function create_if_block$a(ctx) {
    	let current;

    	const rectangle_spread_levels = [
    		ctx.selectionRectangle,
    		{ fill: "green" },
    		{ opacity: 0.2 },
    		{
    			onMousedrag: ctx.onDragSelectionRectangle
    		},
    		{ blockReindexing: ctx.blockReindexing }
    	];

    	let rectangle_props = {};

    	for (let i = 0; i < rectangle_spread_levels.length; i += 1) {
    		rectangle_props = assign(rectangle_props, rectangle_spread_levels[i]);
    	}

    	const rectangle = new Rectangle({ props: rectangle_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(rectangle.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(rectangle, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const rectangle_changes = changed.selectionRectangle || changed.onDragSelectionRectangle || changed.blockReindexing
    			? get_spread_update(rectangle_spread_levels, [
    					changed.selectionRectangle && get_spread_object(ctx.selectionRectangle),
    					rectangle_spread_levels[1],
    					rectangle_spread_levels[2],
    					changed.onDragSelectionRectangle && ({
    						onMousedrag: ctx.onDragSelectionRectangle
    					}),
    					changed.blockReindexing && ({ blockReindexing: ctx.blockReindexing })
    				])
    			: {};

    			rectangle.$set(rectangle_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rectangle.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rectangle.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(rectangle, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(132:2) {#if selectionRectangle}",
    		ctx
    	});

    	return block;
    }

    // (82:0) <Graphic width={500} height={500}>
    function create_default_slot$h(ctx) {
    	let t;
    	let if_block_anchor;
    	let current;

    	let section_1_props = {
    		padding: 30,
    		scaleX: linear$1().domain([0, 10]),
    		scaleY: linear$1().domain([0, 10]),
    		onMousedown: ctx.onMousedown,
    		onMousemove: ctx.onMousemove,
    		onMouseup: ctx.onMouseup,
    		$$slots: { default: [create_default_slot_1$g] },
    		$$scope: { ctx }
    	};

    	const section_1 = new Section({ props: section_1_props, $$inline: true });
    	ctx.section_1_binding(section_1);
    	let if_block = ctx.selectionRectangle && create_if_block$a(ctx);

    	const block = {
    		c: function create() {
    			create_component(section_1.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(section_1, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const section_1_changes = {};

    			if (changed.$$scope || changed.highlightLine || changed.highlightPolygon || changed.highlightRect || changed.highlightPoint) {
    				section_1_changes.$$scope = { changed, ctx };
    			}

    			section_1.$set(section_1_changes);

    			if (ctx.selectionRectangle) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$a(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section_1.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section_1.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			ctx.section_1_binding(null);
    			destroy_component(section_1, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$h.name,
    		type: "slot",
    		source: "(82:0) <Graphic width={500} height={500}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$G(ctx) {
    	let current;

    	const graphic = new Graphic({
    			props: {
    				width: 500,
    				height: 500,
    				$$slots: { default: [create_default_slot$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(graphic.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphic, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const graphic_changes = {};

    			if (changed.$$scope || changed.selectionRectangle || changed.blockReindexing || changed.section || changed.highlightLine || changed.highlightPolygon || changed.highlightRect || changed.highlightPoint) {
    				graphic_changes.$$scope = { changed, ctx };
    			}

    			graphic.$set(graphic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphic, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let section;
    	let makingSelection = false;
    	let selectionRectangle;
    	let rectStartDelta;
    	let brushing = false;
    	let blockReindexing = false;

    	const onMousedown = ({ screenCoordinates }) => {
    		tick().then(() => {
    			if (!brushing) {
    				section.resetSelectRectangle();
    				makingSelection = true;
    				const { x, y } = screenCoordinates;
    				$$invalidate("selectionRectangle", selectionRectangle = { x1: x, x2: x, y1: y, y2: y });
    				section.selectRectangle(selectionRectangle);
    			}
    		});
    	};

    	const onMousemove = ({ screenCoordinates }) => {
    		if (makingSelection) {
    			const { x, y } = screenCoordinates;
    			$$invalidate("selectionRectangle", selectionRectangle.x2 = x, selectionRectangle);
    			$$invalidate("selectionRectangle", selectionRectangle.y2 = y, selectionRectangle);
    			section.updateSelectRectangle(selectionRectangle);
    		}
    	};

    	const onMouseup = () => {
    		tick().then(() => {
    			if (makingSelection) makingSelection = false;
    		});
    	};

    	const onDragSelectionRectangle = event => {
    		const localCoordinates = event.localCoordinates;

    		if (event.dragType === "start") {
    			brushing = true;
    			$$invalidate("blockReindexing", blockReindexing = true);

    			rectStartDelta = {
    				x1: localCoordinates.x - selectionRectangle.x1,
    				x2: localCoordinates.x - selectionRectangle.x2,
    				y1: localCoordinates.y - selectionRectangle.y1,
    				y2: localCoordinates.y - selectionRectangle.y2
    			};
    		}

    		if (event.dragType === "drag") {
    			$$invalidate("selectionRectangle", selectionRectangle = {
    				x1: localCoordinates.x - rectStartDelta.x1,
    				x2: localCoordinates.x - rectStartDelta.x2,
    				y1: localCoordinates.y - rectStartDelta.y1,
    				y2: localCoordinates.y - rectStartDelta.y2
    			});

    			section.updateSelectRectangle(selectionRectangle);
    		}

    		if (event.dragType === "end") {
    			brushing = false;
    			$$invalidate("blockReindexing", blockReindexing = false);
    		}
    	};

    	let highlightPoint;
    	let highlightRect;
    	let highlightPolygon;
    	let highlightLine;

    	const func = () => {
    		$$invalidate("highlightPoint", highlightPoint = true);
    	};

    	const func_1 = () => {
    		$$invalidate("highlightPoint", highlightPoint = false);
    	};

    	const func_2 = () => {
    		$$invalidate("highlightRect", highlightRect = true);
    	};

    	const func_3 = () => {
    		$$invalidate("highlightRect", highlightRect = false);
    	};

    	const func_4 = () => {
    		$$invalidate("highlightPolygon", highlightPolygon = true);
    	};

    	const func_5 = () => {
    		$$invalidate("highlightPolygon", highlightPolygon = false);
    	};

    	const func_6 = () => {
    		$$invalidate("highlightLine", highlightLine = true);
    	};

    	const func_7 = () => {
    		$$invalidate("highlightLine", highlightLine = false);
    	};

    	function section_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate("section", section = $$value);
    		});
    	}

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("section" in $$props) $$invalidate("section", section = $$props.section);
    		if ("makingSelection" in $$props) makingSelection = $$props.makingSelection;
    		if ("selectionRectangle" in $$props) $$invalidate("selectionRectangle", selectionRectangle = $$props.selectionRectangle);
    		if ("rectStartDelta" in $$props) rectStartDelta = $$props.rectStartDelta;
    		if ("brushing" in $$props) brushing = $$props.brushing;
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    		if ("highlightPoint" in $$props) $$invalidate("highlightPoint", highlightPoint = $$props.highlightPoint);
    		if ("highlightRect" in $$props) $$invalidate("highlightRect", highlightRect = $$props.highlightRect);
    		if ("highlightPolygon" in $$props) $$invalidate("highlightPolygon", highlightPolygon = $$props.highlightPolygon);
    		if ("highlightLine" in $$props) $$invalidate("highlightLine", highlightLine = $$props.highlightLine);
    	};

    	return {
    		section,
    		selectionRectangle,
    		blockReindexing,
    		onMousedown,
    		onMousemove,
    		onMouseup,
    		onDragSelectionRectangle,
    		highlightPoint,
    		highlightRect,
    		highlightPolygon,
    		highlightLine,
    		func,
    		func_1,
    		func_2,
    		func_3,
    		func_4,
    		func_5,
    		func_6,
    		func_7,
    		section_1_binding
    	};
    }

    class SelectRectangle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$G, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SelectRectangle",
    			options,
    			id: create_fragment$G.name
    		});
    	}
    }

    /* test/sandbox/src/examples/SelectPolygon.svelte generated by Svelte v3.15.0 */

    // (80:2) <Section     bind:this={section}     padding={30}     scaleX={scaleLinear().domain([0, 10])}     scaleY={scaleLinear().domain([0, 10])}     {onMousedown}     {onMousemove}     {onMouseup}   >
    function create_default_slot_1$h(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let current;

    	const point = new Point({
    			props: {
    				x: 2,
    				y: 2,
    				radius: 7,
    				fill: ctx.highlightPoint ? "blue" : "red",
    				onSelect: ctx.func,
    				onDeselect: ctx.func_1
    			},
    			$$inline: true
    		});

    	const rectangle = new Rectangle({
    			props: {
    				x1: 5,
    				x2: 8,
    				y1: 5,
    				y2: 9,
    				fill: ctx.highlightRect ? "blue" : "red",
    				onSelect: ctx.func_2,
    				onDeselect: ctx.func_3
    			},
    			$$inline: true
    		});

    	const polygon = new Polygon({
    			props: {
    				x: [3, 5, 7, 8, 6, 4],
    				y: [6, 8, 7, 3, 4, 4],
    				fill: ctx.highlightPolygon ? "yellow" : "orange",
    				opacity: 0.7,
    				onSelect: ctx.func_4,
    				onDeselect: ctx.func_5
    			},
    			$$inline: true
    		});

    	const line = new Line({
    			props: {
    				x: [1, 3, 4],
    				y: [9, 8, 7],
    				stroke: ctx.highlightLine ? "blue" : "red",
    				onSelect: ctx.func_6,
    				onDeselect: ctx.func_7
    			},
    			$$inline: true
    		});

    	const xaxis = new XAxis({ $$inline: true });
    	const yaxis = new YAxis({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(point.$$.fragment);
    			t0 = space();
    			create_component(rectangle.$$.fragment);
    			t1 = space();
    			create_component(polygon.$$.fragment);
    			t2 = space();
    			create_component(line.$$.fragment);
    			t3 = space();
    			create_component(xaxis.$$.fragment);
    			t4 = space();
    			create_component(yaxis.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(point, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(rectangle, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(polygon, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(line, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(xaxis, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(yaxis, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const point_changes = {};
    			if (changed.highlightPoint) point_changes.fill = ctx.highlightPoint ? "blue" : "red";
    			if (changed.highlightPoint) point_changes.onSelect = ctx.func;
    			if (changed.highlightPoint) point_changes.onDeselect = ctx.func_1;
    			point.$set(point_changes);
    			const rectangle_changes = {};
    			if (changed.highlightRect) rectangle_changes.fill = ctx.highlightRect ? "blue" : "red";
    			if (changed.highlightRect) rectangle_changes.onSelect = ctx.func_2;
    			if (changed.highlightRect) rectangle_changes.onDeselect = ctx.func_3;
    			rectangle.$set(rectangle_changes);
    			const polygon_changes = {};
    			if (changed.highlightPolygon) polygon_changes.fill = ctx.highlightPolygon ? "yellow" : "orange";
    			if (changed.highlightPolygon) polygon_changes.onSelect = ctx.func_4;
    			if (changed.highlightPolygon) polygon_changes.onDeselect = ctx.func_5;
    			polygon.$set(polygon_changes);
    			const line_changes = {};
    			if (changed.highlightLine) line_changes.stroke = ctx.highlightLine ? "blue" : "red";
    			if (changed.highlightLine) line_changes.onSelect = ctx.func_6;
    			if (changed.highlightLine) line_changes.onDeselect = ctx.func_7;
    			line.$set(line_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(point.$$.fragment, local);
    			transition_in(rectangle.$$.fragment, local);
    			transition_in(polygon.$$.fragment, local);
    			transition_in(line.$$.fragment, local);
    			transition_in(xaxis.$$.fragment, local);
    			transition_in(yaxis.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(point.$$.fragment, local);
    			transition_out(rectangle.$$.fragment, local);
    			transition_out(polygon.$$.fragment, local);
    			transition_out(line.$$.fragment, local);
    			transition_out(xaxis.$$.fragment, local);
    			transition_out(yaxis.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(point, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(rectangle, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(polygon, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(line, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(xaxis, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(yaxis, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$h.name,
    		type: "slot",
    		source: "(80:2) <Section     bind:this={section}     padding={30}     scaleX={scaleLinear().domain([0, 10])}     scaleY={scaleLinear().domain([0, 10])}     {onMousedown}     {onMousemove}     {onMouseup}   >",
    		ctx
    	});

    	return block;
    }

    // (128:2) {#if selectionPolygon}
    function create_if_block$b(ctx) {
    	let current;

    	const polygon = new Polygon({
    			props: {
    				geometry: ctx.selectionPolygon,
    				fill: "green",
    				opacity: 0.2,
    				onMousedrag: ctx.onDragSelectionPolygon,
    				blockReindexing: ctx.blockReindexing
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(polygon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(polygon, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const polygon_changes = {};
    			if (changed.selectionPolygon) polygon_changes.geometry = ctx.selectionPolygon;
    			if (changed.blockReindexing) polygon_changes.blockReindexing = ctx.blockReindexing;
    			polygon.$set(polygon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(polygon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(polygon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(polygon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(128:2) {#if selectionPolygon}",
    		ctx
    	});

    	return block;
    }

    // (78:0) <Graphic width={500} height={500}>
    function create_default_slot$i(ctx) {
    	let t;
    	let if_block_anchor;
    	let current;

    	let section_1_props = {
    		padding: 30,
    		scaleX: linear$1().domain([0, 10]),
    		scaleY: linear$1().domain([0, 10]),
    		onMousedown: ctx.onMousedown,
    		onMousemove: ctx.onMousemove,
    		onMouseup: ctx.onMouseup,
    		$$slots: { default: [create_default_slot_1$h] },
    		$$scope: { ctx }
    	};

    	const section_1 = new Section({ props: section_1_props, $$inline: true });
    	ctx.section_1_binding(section_1);
    	let if_block = ctx.selectionPolygon && create_if_block$b(ctx);

    	const block = {
    		c: function create() {
    			create_component(section_1.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(section_1, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const section_1_changes = {};

    			if (changed.$$scope || changed.highlightLine || changed.highlightPolygon || changed.highlightRect || changed.highlightPoint) {
    				section_1_changes.$$scope = { changed, ctx };
    			}

    			section_1.$set(section_1_changes);

    			if (ctx.selectionPolygon) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section_1.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section_1.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			ctx.section_1_binding(null);
    			destroy_component(section_1, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$i.name,
    		type: "slot",
    		source: "(78:0) <Graphic width={500} height={500}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$H(ctx) {
    	let current;

    	const graphic = new Graphic({
    			props: {
    				width: 500,
    				height: 500,
    				$$slots: { default: [create_default_slot$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(graphic.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphic, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const graphic_changes = {};

    			if (changed.$$scope || changed.selectionPolygon || changed.blockReindexing || changed.section || changed.highlightLine || changed.highlightPolygon || changed.highlightRect || changed.highlightPoint) {
    				graphic_changes.$$scope = { changed, ctx };
    			}

    			graphic.$set(graphic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphic, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let section;
    	let selecting = false;
    	let selectionPolygon;
    	let previousMousePosition;
    	let currentMousePosition;
    	let brushing = false;
    	let blockReindexing = false;

    	const onMousedown = ({ screenCoordinates }) => {
    		tick().then(() => {
    			if (!brushing) {
    				section.resetSelectPolygon();
    				$$invalidate("selectionPolygon", selectionPolygon = undefined);
    				section.startSelectPolygon(screenCoordinates);
    				selecting = true;
    			}
    		});
    	};

    	const onMousemove = ({ screenCoordinates }) => {
    		if (selecting) {
    			section.addPointToSelectPolygon(screenCoordinates);
    			$$invalidate("selectionPolygon", selectionPolygon = section.getSelectPolygon());
    		}
    	};

    	const onMouseup = ({ screenCoordinates }) => {
    		if (selecting) {
    			selecting = false;
    		}
    	};

    	const onDragSelectionPolygon = event => {
    		const screenCoordinates = event.screenCoordinates;

    		if (event.dragType === "start") {
    			brushing = true;
    			$$invalidate("blockReindexing", blockReindexing = true);
    			currentMousePosition = screenCoordinates;
    		}

    		if (event.dragType === "drag") {
    			previousMousePosition = currentMousePosition;
    			currentMousePosition = screenCoordinates;

    			let delta = {
    				x: currentMousePosition.x - previousMousePosition.x,
    				y: currentMousePosition.y - previousMousePosition.y
    			};

    			section.moveSelectPolygon(delta);
    			$$invalidate("selectionPolygon", selectionPolygon = section.getSelectPolygon());
    		}

    		if (event.dragType === "end") {
    			brushing = false;
    			$$invalidate("blockReindexing", blockReindexing = false);
    		}
    	};

    	let highlightPoint;
    	let highlightRect;
    	let highlightPolygon;
    	let highlightLine;

    	const func = () => {
    		$$invalidate("highlightPoint", highlightPoint = true);
    	};

    	const func_1 = () => {
    		$$invalidate("highlightPoint", highlightPoint = false);
    	};

    	const func_2 = () => {
    		$$invalidate("highlightRect", highlightRect = true);
    	};

    	const func_3 = () => {
    		$$invalidate("highlightRect", highlightRect = false);
    	};

    	const func_4 = () => {
    		$$invalidate("highlightPolygon", highlightPolygon = true);
    	};

    	const func_5 = () => {
    		$$invalidate("highlightPolygon", highlightPolygon = false);
    	};

    	const func_6 = () => {
    		$$invalidate("highlightLine", highlightLine = true);
    	};

    	const func_7 = () => {
    		$$invalidate("highlightLine", highlightLine = false);
    	};

    	function section_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate("section", section = $$value);
    		});
    	}

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("section" in $$props) $$invalidate("section", section = $$props.section);
    		if ("selecting" in $$props) selecting = $$props.selecting;
    		if ("selectionPolygon" in $$props) $$invalidate("selectionPolygon", selectionPolygon = $$props.selectionPolygon);
    		if ("previousMousePosition" in $$props) previousMousePosition = $$props.previousMousePosition;
    		if ("currentMousePosition" in $$props) currentMousePosition = $$props.currentMousePosition;
    		if ("brushing" in $$props) brushing = $$props.brushing;
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    		if ("highlightPoint" in $$props) $$invalidate("highlightPoint", highlightPoint = $$props.highlightPoint);
    		if ("highlightRect" in $$props) $$invalidate("highlightRect", highlightRect = $$props.highlightRect);
    		if ("highlightPolygon" in $$props) $$invalidate("highlightPolygon", highlightPolygon = $$props.highlightPolygon);
    		if ("highlightLine" in $$props) $$invalidate("highlightLine", highlightLine = $$props.highlightLine);
    	};

    	return {
    		section,
    		selectionPolygon,
    		blockReindexing,
    		onMousedown,
    		onMousemove,
    		onMouseup,
    		onDragSelectionPolygon,
    		highlightPoint,
    		highlightRect,
    		highlightPolygon,
    		highlightLine,
    		func,
    		func_1,
    		func_2,
    		func_3,
    		func_4,
    		func_5,
    		func_6,
    		func_7,
    		section_1_binding
    	};
    }

    class SelectPolygon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$F, create_fragment$H, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SelectPolygon",
    			options,
    			id: create_fragment$H.name
    		});
    	}
    }

    var EOL = {},
        EOF = {},
        QUOTE = 34,
        NEWLINE = 10,
        RETURN = 13;

    function objectConverter(columns) {
      return new Function("d", "return {" + columns.map(function(name, i) {
        return JSON.stringify(name) + ": d[" + i + "] || \"\"";
      }).join(",") + "}");
    }

    function customConverter(columns, f) {
      var object = objectConverter(columns);
      return function(row, i) {
        return f(object(row), i, columns);
      };
    }

    // Compute unique columns in order of discovery.
    function inferColumns(rows) {
      var columnSet = Object.create(null),
          columns = [];

      rows.forEach(function(row) {
        for (var column in row) {
          if (!(column in columnSet)) {
            columns.push(columnSet[column] = column);
          }
        }
      });

      return columns;
    }

    function pad$1(value, width) {
      var s = value + "", length = s.length;
      return length < width ? new Array(width - length + 1).join(0) + s : s;
    }

    function formatYear$1(year) {
      return year < 0 ? "-" + pad$1(-year, 6)
        : year > 9999 ? "+" + pad$1(year, 6)
        : pad$1(year, 4);
    }

    function formatDate(date) {
      var hours = date.getUTCHours(),
          minutes = date.getUTCMinutes(),
          seconds = date.getUTCSeconds(),
          milliseconds = date.getUTCMilliseconds();
      return isNaN(date) ? "Invalid Date"
          : formatYear$1(date.getUTCFullYear()) + "-" + pad$1(date.getUTCMonth() + 1, 2) + "-" + pad$1(date.getUTCDate(), 2)
          + (milliseconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "." + pad$1(milliseconds, 3) + "Z"
          : seconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "Z"
          : minutes || hours ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + "Z"
          : "");
    }

    function dsvFormat(delimiter) {
      var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
          DELIMITER = delimiter.charCodeAt(0);

      function parse(text, f) {
        var convert, columns, rows = parseRows(text, function(row, i) {
          if (convert) return convert(row, i - 1);
          columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
        });
        rows.columns = columns || [];
        return rows;
      }

      function parseRows(text, f) {
        var rows = [], // output rows
            N = text.length,
            I = 0, // current character index
            n = 0, // current line number
            t, // current token
            eof = N <= 0, // current token followed by EOF?
            eol = false; // current token followed by EOL?

        // Strip the trailing newline.
        if (text.charCodeAt(N - 1) === NEWLINE) --N;
        if (text.charCodeAt(N - 1) === RETURN) --N;

        function token() {
          if (eof) return EOF;
          if (eol) return eol = false, EOL;

          // Unescape quotes.
          var i, j = I, c;
          if (text.charCodeAt(j) === QUOTE) {
            while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
            if ((i = I) >= N) eof = true;
            else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
            else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
            return text.slice(j + 1, i - 1).replace(/""/g, "\"");
          }

          // Find next delimiter or newline.
          while (I < N) {
            if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
            else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
            else if (c !== DELIMITER) continue;
            return text.slice(j, i);
          }

          // Return last token before EOF.
          return eof = true, text.slice(j, N);
        }

        while ((t = token()) !== EOF) {
          var row = [];
          while (t !== EOL && t !== EOF) row.push(t), t = token();
          if (f && (row = f(row, n++)) == null) continue;
          rows.push(row);
        }

        return rows;
      }

      function preformatBody(rows, columns) {
        return rows.map(function(row) {
          return columns.map(function(column) {
            return formatValue(row[column]);
          }).join(delimiter);
        });
      }

      function format(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
      }

      function formatBody(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return preformatBody(rows, columns).join("\n");
      }

      function formatRows(rows) {
        return rows.map(formatRow).join("\n");
      }

      function formatRow(row) {
        return row.map(formatValue).join(delimiter);
      }

      function formatValue(value) {
        return value == null ? ""
            : value instanceof Date ? formatDate(value)
            : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
            : value;
      }

      return {
        parse: parse,
        parseRows: parseRows,
        format: format,
        formatBody: formatBody,
        formatRows: formatRows,
        formatRow: formatRow,
        formatValue: formatValue
      };
    }

    var csv = dsvFormat(",");

    var csvParse = csv.parse;

    function autoType(object) {
      for (var key in object) {
        var value = object[key].trim(), number, m;
        if (!value) value = null;
        else if (value === "true") value = true;
        else if (value === "false") value = false;
        else if (value === "NaN") value = NaN;
        else if (!isNaN(number = +value)) value = number;
        else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
          if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, "/").replace(/T/, " ");
          value = new Date(value);
        }
        else continue;
        object[key] = value;
      }
      return object;
    }

    // https://github.com/d3/d3-dsv/issues/45
    var fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();

    function responseText(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.text();
    }

    function text$1(input, init) {
      return fetch(input, init).then(responseText);
    }

    function dsvParse(parse) {
      return function(input, init, row) {
        if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
        return text$1(input, init).then(function(response) {
          return parse(response, row);
        });
      };
    }

    var csv$1 = dsvParse(csvParse);

    /* test/sandbox/src/examples/AreaChart.svelte generated by Svelte v3.15.0 */

    // (80:2) {#if done}
    function create_if_block$c(ctx) {
    	let current;

    	const section = new Section({
    			props: {
    				scaleX: ctx.scaleDate,
    				scaleY: ctx.scaleClose,
    				padding: ctx.padding,
    				flipY: true,
    				$$slots: { default: [create_default_slot_1$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const section_changes = {};
    			if (changed.scaleDate) section_changes.scaleX = ctx.scaleDate;
    			if (changed.scaleClose) section_changes.scaleY = ctx.scaleClose;

    			if (changed.$$scope || changed.stockData) {
    				section_changes.$$scope = { changed, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(80:2) {#if done}",
    		ctx
    	});

    	return block;
    }

    // (81:2) <Section     scaleX={scaleDate}   scaleY={scaleClose}     {padding}     flipY   >
    function create_default_slot_1$i(ctx) {
    	let t0;
    	let t1;
    	let current;

    	const area = new Area({
    			props: {
    				x1: ctx.stockData.column("date"),
    				y1: ctx.stockData.column("close"),
    				y2: Array(1280).fill(0),
    				fill: "steelblue"
    			},
    			$$inline: true
    		});

    	const xaxis = new XAxis({
    			props: { baseLine: false },
    			$$inline: true
    		});

    	const yaxis = new YAxis({
    			props: {
    				baseLine: false,
    				title: "$ close",
    				titleVjust: "top",
    				titleHjust: 0.035,
    				titleRotation: 0,
    				titleFontWeight: "bold"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(area.$$.fragment);
    			t0 = space();
    			create_component(xaxis.$$.fragment);
    			t1 = space();
    			create_component(yaxis.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(area, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(xaxis, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(yaxis, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const area_changes = {};
    			if (changed.stockData) area_changes.x1 = ctx.stockData.column("date");
    			if (changed.stockData) area_changes.y1 = ctx.stockData.column("close");
    			area.$set(area_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(area.$$.fragment, local);
    			transition_in(xaxis.$$.fragment, local);
    			transition_in(yaxis.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(area.$$.fragment, local);
    			transition_out(xaxis.$$.fragment, local);
    			transition_out(yaxis.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(area, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(xaxis, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(yaxis, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$i.name,
    		type: "slot",
    		source: "(81:2) <Section     scaleX={scaleDate}   scaleY={scaleClose}     {padding}     flipY   >",
    		ctx
    	});

    	return block;
    }

    // (75:0) <Graphic   width={700}   height={500} >
    function create_default_slot$j(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = ctx.done && create_if_block$c(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (ctx.done) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$c(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$j.name,
    		type: "slot",
    		source: "(75:0) <Graphic   width={700}   height={500} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$I(ctx) {
    	let current;

    	const graphic = new Graphic({
    			props: {
    				width: 700,
    				height: 500,
    				$$slots: { default: [create_default_slot$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(graphic.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphic, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const graphic_changes = {};

    			if (changed.$$scope || changed.done || changed.scaleDate || changed.scaleClose || changed.stockData) {
    				graphic_changes.$$scope = { changed, ctx };
    			}

    			graphic.$set(graphic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphic, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	const padding = { top: 20, right: 20, bottom: 30, left: 30 };
    	let done;
    	let parsedData;

    	csv$1("https://gist.githubusercontent.com/mbostock/14613fb82f32f40119009c94f5a46d72/raw/d0d70ffb7b749714e4ba1dece761f6502b2bdea2/aapl.csv", autoType).then(d => {
    		$$invalidate("parsedData", parsedData = d);
    		$$invalidate("done", done = true);
    	});

    	let stockData;
    	let closeDomain, dateDomain;
    	let scaleDate, scaleClose;

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("done" in $$props) $$invalidate("done", done = $$props.done);
    		if ("parsedData" in $$props) $$invalidate("parsedData", parsedData = $$props.parsedData);
    		if ("stockData" in $$props) $$invalidate("stockData", stockData = $$props.stockData);
    		if ("closeDomain" in $$props) $$invalidate("closeDomain", closeDomain = $$props.closeDomain);
    		if ("dateDomain" in $$props) $$invalidate("dateDomain", dateDomain = $$props.dateDomain);
    		if ("scaleDate" in $$props) $$invalidate("scaleDate", scaleDate = $$props.scaleDate);
    		if ("scaleClose" in $$props) $$invalidate("scaleClose", scaleClose = $$props.scaleClose);
    	};

    	$$self.$$.update = (changed = { done: 1, parsedData: 1, stockData: 1, dateDomain: 1, closeDomain: 1 }) => {
    		if (changed.done || changed.parsedData || changed.stockData || changed.dateDomain || changed.closeDomain) {
    			 {
    				if (done) {
    					$$invalidate("stockData", stockData = new florenceDatacontainer_umd(parsedData));
    					$$invalidate("dateDomain", dateDomain = stockData.domain("date"));
    					$$invalidate("closeDomain", closeDomain = stockData.domain("close"));
    					$$invalidate("scaleDate", scaleDate = scaleUtc().domain(dateDomain));
    					$$invalidate("scaleClose", scaleClose = linear$1().domain([0, closeDomain[1]]));
    				}
    			}
    		}
    	};

    	return {
    		padding,
    		done,
    		stockData,
    		scaleDate,
    		scaleClose
    	};
    }

    class AreaChart extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$G, create_fragment$I, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AreaChart",
    			options,
    			id: create_fragment$I.name
    		});
    	}
    }

    /* test/sandbox/src/examples/StackedAreaChart.svelte generated by Svelte v3.15.0 */

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.c = list[i];
    	return child_ctx;
    }

    // (63:2) {#if done}
    function create_if_block$d(ctx) {
    	let current;

    	const section = new Section({
    			props: {
    				scaleX: ctx.scaleDate,
    				scaleY: ctx.scaleUnemployment,
    				padding: ctx.padding,
    				flipY: true,
    				$$slots: { default: [create_default_slot_1$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const section_changes = {};
    			if (changed.scaleDate) section_changes.scaleX = ctx.scaleDate;
    			if (changed.scaleUnemployment) section_changes.scaleY = ctx.scaleUnemployment;

    			if (changed.$$scope || changed.columnNames || changed.rowCumSum || changed.scaleColor) {
    				section_changes.$$scope = { changed, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(63:2) {#if done}",
    		ctx
    	});

    	return block;
    }

    // (70:6) {#each columnNames as c}
    function create_each_block$7(ctx) {
    	let current;

    	const area = new Area({
    			props: {
    				x1: ctx.rowCumSum.column("date"),
    				y1: ctx.rowCumSum.column(ctx.c).map(func$1),
    				y2: ctx.rowCumSum.column(ctx.c).map(func_1$1),
    				fill: ctx.scaleColor(ctx.c)
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(area.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(area, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const area_changes = {};
    			if (changed.rowCumSum) area_changes.x1 = ctx.rowCumSum.column("date");
    			if (changed.rowCumSum || changed.columnNames) area_changes.y1 = ctx.rowCumSum.column(ctx.c).map(func$1);
    			if (changed.rowCumSum || changed.columnNames) area_changes.y2 = ctx.rowCumSum.column(ctx.c).map(func_1$1);
    			if (changed.scaleColor || changed.columnNames) area_changes.fill = ctx.scaleColor(ctx.c);
    			area.$set(area_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(area.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(area.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(area, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(70:6) {#each columnNames as c}",
    		ctx
    	});

    	return block;
    }

    // (64:4) <Section       scaleX={scaleDate}       scaleY={scaleUnemployment}       {padding}       flipY     >
    function create_default_slot_1$j(ctx) {
    	let t0;
    	let t1;
    	let current;
    	let each_value = ctx.columnNames;
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const xaxis = new XAxis({
    			props: { baseLine: false },
    			$$inline: true
    		});

    	const yaxis = new YAxis({
    			props: {
    				baseLine: false,
    				title: "Unemployment",
    				titleVjust: "top",
    				titleHjust: 0.05,
    				titleRotation: 0,
    				titleFontWeight: "bold"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			create_component(xaxis.$$.fragment);
    			t1 = space();
    			create_component(yaxis.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t0, anchor);
    			mount_component(xaxis, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(yaxis, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (changed.rowCumSum || changed.columnNames || changed.scaleColor) {
    				each_value = ctx.columnNames;
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(t0.parentNode, t0);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(xaxis.$$.fragment, local);
    			transition_in(yaxis.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(xaxis.$$.fragment, local);
    			transition_out(yaxis.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(xaxis, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(yaxis, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$j.name,
    		type: "slot",
    		source: "(64:4) <Section       scaleX={scaleDate}       scaleY={scaleUnemployment}       {padding}       flipY     >",
    		ctx
    	});

    	return block;
    }

    // (58:0) <Graphic   width={700}   height={500} >
    function create_default_slot$k(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = ctx.done && create_if_block$d(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (ctx.done) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$d(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$k.name,
    		type: "slot",
    		source: "(58:0) <Graphic   width={700}   height={500} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$J(ctx) {
    	let current;

    	const graphic = new Graphic({
    			props: {
    				width: 700,
    				height: 500,
    				$$slots: { default: [create_default_slot$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(graphic.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphic, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const graphic_changes = {};

    			if (changed.$$scope || changed.done || changed.scaleDate || changed.scaleUnemployment || changed.columnNames || changed.rowCumSum || changed.scaleColor) {
    				graphic_changes.$$scope = { changed, ctx };
    			}

    			graphic.$set(graphic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphic, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func$1 = d => d[0];
    const func_1$1 = d => d[1];

    function instance$H($$self, $$props, $$invalidate) {
    	const padding = { top: 20, right: 20, bottom: 30, left: 40 };
    	let done;
    	let parsedData;

    	csv$1("https://gist.githubusercontent.com/mbostock/7d600b18fdea7542393d23e990a887b7/raw/df6ef37f1f22cae3d1583ab60ba613fed5e81397/unemployment.csv", autoType).then(d => {
    		$$invalidate("parsedData", parsedData = d);
    		$$invalidate("done", done = true);
    	});

    	let columnNames;
    	let dataContainer, rowCumSum;
    	let unemploymentDomain, dateDomain;
    	let scaleDate, scaleUnemployment, scaleColor;

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("done" in $$props) $$invalidate("done", done = $$props.done);
    		if ("parsedData" in $$props) $$invalidate("parsedData", parsedData = $$props.parsedData);
    		if ("columnNames" in $$props) $$invalidate("columnNames", columnNames = $$props.columnNames);
    		if ("dataContainer" in $$props) $$invalidate("dataContainer", dataContainer = $$props.dataContainer);
    		if ("rowCumSum" in $$props) $$invalidate("rowCumSum", rowCumSum = $$props.rowCumSum);
    		if ("unemploymentDomain" in $$props) $$invalidate("unemploymentDomain", unemploymentDomain = $$props.unemploymentDomain);
    		if ("dateDomain" in $$props) $$invalidate("dateDomain", dateDomain = $$props.dateDomain);
    		if ("scaleDate" in $$props) $$invalidate("scaleDate", scaleDate = $$props.scaleDate);
    		if ("scaleUnemployment" in $$props) $$invalidate("scaleUnemployment", scaleUnemployment = $$props.scaleUnemployment);
    		if ("scaleColor" in $$props) $$invalidate("scaleColor", scaleColor = $$props.scaleColor);
    	};

    	$$self.$$.update = (changed = { done: 1, parsedData: 1, dataContainer: 1, rowCumSum: 1, dateDomain: 1, unemploymentDomain: 1 }) => {
    		if (changed.done || changed.parsedData || changed.dataContainer || changed.rowCumSum || changed.dateDomain || changed.unemploymentDomain) {
    			 {
    				if (done) {
    					$$invalidate("columnNames", columnNames = parsedData.columns.splice(1));
    					$$invalidate("dataContainer", dataContainer = new florenceDatacontainer_umd(parsedData));

    					$$invalidate("rowCumSum", rowCumSum = dataContainer.rowCumsum(
    						[
    							"Wholesale and Retail Trade",
    							"Manufacturing",
    							"Leisure and hospitality",
    							"Business services",
    							"Construction",
    							"Education and Health",
    							"Government",
    							"Finance",
    							"Self-employed",
    							"Other",
    							"Transportation and Utilities",
    							"Information",
    							"Agriculture",
    							"Mining and Extraction"
    						],
    						{ asInterval: "true" }
    					));

    					$$invalidate("dateDomain", dateDomain = rowCumSum.domain("date"));
    					$$invalidate("unemploymentDomain", unemploymentDomain = rowCumSum.domain("Mining and Extraction"));
    					$$invalidate("scaleDate", scaleDate = scaleUtc().domain(dateDomain));
    					$$invalidate("scaleUnemployment", scaleUnemployment = linear$1().domain([0, unemploymentDomain[1]]));
    					$$invalidate("scaleColor", scaleColor = ordinal().domain(parsedData.columns.slice(1)).range(schemeCategory10));
    				}
    			}
    		}
    	};

    	return {
    		padding,
    		done,
    		columnNames,
    		rowCumSum,
    		scaleDate,
    		scaleUnemployment,
    		scaleColor
    	};
    }

    class StackedAreaChart extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$J, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "StackedAreaChart",
    			options,
    			id: create_fragment$J.name
    		});
    	}
    }

    /* test/sandbox/src/examples/ViolinPlot.svelte generated by Svelte v3.15.0 */

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.d = list[i];
    	child_ctx.i = i;
    	return child_ctx;
    }

    // (79:2) {#if done}
    function create_if_block$e(ctx) {
    	let current;

    	const section = new Section({
    			props: {
    				scaleX: ctx.scaleSpecies,
    				scaleY: ctx.scaleDimension,
    				flipY: true,
    				padding: ctx.padding,
    				$$slots: { default: [create_default_slot_1$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const section_changes = {};
    			if (changed.scaleSpecies) section_changes.scaleX = ctx.scaleSpecies;
    			if (changed.scaleDimension) section_changes.scaleY = ctx.scaleDimension;

    			if (changed.$$scope || changed.density || changed.violinScaleX || changed.scaleDimension || changed.groupedCols) {
    				section_changes.$$scope = { changed, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(79:2) {#if done}",
    		ctx
    	});

    	return block;
    }

    // (89:6) <Section         scaleX={violinScaleX}         scaleY={scaleDimension}         flipY         x1={groupedCols[i]}         x2={({scaleX}) => scaleX(groupedCols[i]) + scaleX.bandwidth()}       >
    function create_default_slot_2$2(ctx) {
    	let current;

    	const area = new Area({
    			props: {
    				x1: ctx.d.map(func_1$2),
    				y1: ctx.d.map(func_2$1),
    				x2: ctx.d.map(func_3$1),
    				independentAxis: "y",
    				fill: "#c080ff"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(area.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(area, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const area_changes = {};
    			if (changed.density) area_changes.x1 = ctx.d.map(func_1$2);
    			if (changed.density) area_changes.y1 = ctx.d.map(func_2$1);
    			if (changed.density) area_changes.x2 = ctx.d.map(func_3$1);
    			area.$set(area_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(area.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(area.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(area, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(89:6) <Section         scaleX={violinScaleX}         scaleY={scaleDimension}         flipY         x1={groupedCols[i]}         x2={({scaleX}) => scaleX(groupedCols[i]) + scaleX.bandwidth()}       >",
    		ctx
    	});

    	return block;
    }

    // (87:4) {#each density as d, i}
    function create_each_block$8(ctx) {
    	let current;

    	function func(...args) {
    		return ctx.func(ctx, ...args);
    	}

    	const section = new Section({
    			props: {
    				scaleX: ctx.violinScaleX,
    				scaleY: ctx.scaleDimension,
    				flipY: true,
    				x1: ctx.groupedCols[ctx.i],
    				x2: func,
    				$$slots: { default: [create_default_slot_2$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(changed, new_ctx) {
    			ctx = new_ctx;
    			const section_changes = {};
    			if (changed.violinScaleX) section_changes.scaleX = ctx.violinScaleX;
    			if (changed.scaleDimension) section_changes.scaleY = ctx.scaleDimension;
    			if (changed.groupedCols) section_changes.x1 = ctx.groupedCols[ctx.i];
    			if (changed.groupedCols) section_changes.x2 = func;

    			if (changed.$$scope || changed.density) {
    				section_changes.$$scope = { changed, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(87:4) {#each density as d, i}",
    		ctx
    	});

    	return block;
    }

    // (80:4) <Section       scaleX={scaleSpecies}       scaleY={scaleDimension}       flipY       {padding}     >
    function create_default_slot_1$k(ctx) {
    	let t0;
    	let t1;
    	let current;
    	let each_value = ctx.density;
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const xaxis = new XAxis({
    			props: { baseLine: false },
    			$$inline: true
    		});

    	const yaxis = new YAxis({
    			props: { baseLine: false },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			create_component(xaxis.$$.fragment);
    			t1 = space();
    			create_component(yaxis.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t0, anchor);
    			mount_component(xaxis, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(yaxis, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (changed.violinScaleX || changed.scaleDimension || changed.groupedCols || changed.density) {
    				each_value = ctx.density;
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(t0.parentNode, t0);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(xaxis.$$.fragment, local);
    			transition_in(yaxis.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(xaxis.$$.fragment, local);
    			transition_out(yaxis.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(xaxis, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(yaxis, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$k.name,
    		type: "slot",
    		source: "(80:4) <Section       scaleX={scaleSpecies}       scaleY={scaleDimension}       flipY       {padding}     >",
    		ctx
    	});

    	return block;
    }

    // (74:0) <Graphic   width={700}   height={500} >
    function create_default_slot$l(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = ctx.done && create_if_block$e(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (ctx.done) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$e(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$l.name,
    		type: "slot",
    		source: "(74:0) <Graphic   width={700}   height={500} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$K(ctx) {
    	let current;

    	const graphic = new Graphic({
    			props: {
    				width: 700,
    				height: 500,
    				$$slots: { default: [create_default_slot$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(graphic.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphic, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const graphic_changes = {};

    			if (changed.$$scope || changed.done || changed.scaleSpecies || changed.scaleDimension || changed.density || changed.violinScaleX || changed.groupedCols) {
    				graphic_changes.$$scope = { changed, ctx };
    			}

    			graphic.$set(graphic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphic, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function kernelDensityEstimator(kernel, X) {
    	return function (V) {
    		return X.map(function (x) {
    			return [x, mean(V, v => kernel(x - v))];
    		});
    	};
    }

    function kernelEpanechnikov(k) {
    	return function (v) {
    		return Math.abs(v /= k) <= 1 ? 0.75 * (1 - v * v) / k : 0;
    	};
    }

    const func_1$2 = v => v[1];
    const func_2$1 = v => v[0];
    const func_3$1 = v => -v[1];

    function instance$I($$self, $$props, $$invalidate) {
    	const padding = { top: 20, right: 20, bottom: 30, left: 30 };
    	let done;
    	let parsedData;

    	csv$1("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/iris.csv", autoType).then(d => {
    		$$invalidate("parsedData", parsedData = d);
    		$$invalidate("done", done = true);
    	});

    	let dataContainer;
    	let speciesDomain, dimensionDomain;
    	let scaleSpecies, scaleDimension, violinScaleX;
    	let groupedCols, density;
    	const func = ({ i }, { scaleX }) => scaleX(groupedCols[i]) + scaleX.bandwidth();

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("done" in $$props) $$invalidate("done", done = $$props.done);
    		if ("parsedData" in $$props) $$invalidate("parsedData", parsedData = $$props.parsedData);
    		if ("dataContainer" in $$props) $$invalidate("dataContainer", dataContainer = $$props.dataContainer);
    		if ("speciesDomain" in $$props) $$invalidate("speciesDomain", speciesDomain = $$props.speciesDomain);
    		if ("dimensionDomain" in $$props) dimensionDomain = $$props.dimensionDomain;
    		if ("scaleSpecies" in $$props) $$invalidate("scaleSpecies", scaleSpecies = $$props.scaleSpecies);
    		if ("scaleDimension" in $$props) $$invalidate("scaleDimension", scaleDimension = $$props.scaleDimension);
    		if ("violinScaleX" in $$props) $$invalidate("violinScaleX", violinScaleX = $$props.violinScaleX);
    		if ("groupedCols" in $$props) $$invalidate("groupedCols", groupedCols = $$props.groupedCols);
    		if ("density" in $$props) $$invalidate("density", density = $$props.density);
    	};

    	$$self.$$.update = (changed = { done: 1, parsedData: 1, dataContainer: 1, speciesDomain: 1, scaleDimension: 1, density: 1 }) => {
    		if (changed.done || changed.parsedData || changed.dataContainer || changed.speciesDomain || changed.scaleDimension || changed.density) {
    			 {
    				if (done) {
    					$$invalidate("dataContainer", dataContainer = new florenceDatacontainer_umd(parsedData));
    					const grouped = dataContainer.groupBy("Species");
    					$$invalidate("groupedCols", groupedCols = grouped.column("Species"));
    					$$invalidate("speciesDomain", speciesDomain = dataContainer.domain("Species"));
    					dimensionDomain = dataContainer.domain("Sepal_Length");
    					$$invalidate("scaleDimension", scaleDimension = linear$1().domain([3.5, 8]));
    					$$invalidate("scaleSpecies", scaleSpecies = band().domain(speciesDomain).padding(0.05));
    					const kde = kernelDensityEstimator(kernelEpanechnikov(0.2), scaleDimension.ticks(50));
    					const groupedSepalLengths = grouped.map("$grouped", group => group.column("Sepal_Length"));
    					$$invalidate("density", density = groupedSepalLengths.map(specie => kde(specie)));
    					let maxNum = 0;

    					for (const i in density) {
    						const allBins = density[i];
    						const kdeValues = allBins.map(a => a[1]);
    						const biggest = max(kdeValues);

    						if (biggest > maxNum) {
    							maxNum = biggest;
    						}
    					}

    					$$invalidate("violinScaleX", violinScaleX = linear$1().domain([-maxNum, maxNum]));
    				}
    			}
    		}
    	};

    	return {
    		padding,
    		done,
    		scaleSpecies,
    		scaleDimension,
    		violinScaleX,
    		groupedCols,
    		density,
    		func
    	};
    }

    class ViolinPlot extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$I, create_fragment$K, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ViolinPlot",
    			options,
    			id: create_fragment$K.name
    		});
    	}
    }

    /* test/sandbox/src/examples/Title.svelte generated by Svelte v3.15.0 */

    // (19:1) <Section      x1={50} x2={450}     y1={50} y2={450}     padding={30}     scaleX={scaleLinear().domain([0, 4])}     scaleY={scaleLinear().domain([0, 4])}     {zoomIdentity}     {blockReindexing}   >
    function create_default_slot_1$l(ctx) {
    	let t0;
    	let t1;
    	let current;

    	const title = new Title({
    			props: {
    				title: "Lorem ipsum dolor sit amet",
    				titleFontFamily: "Papyrus",
    				subtitle: "elit, sed do eiusmod tempor incididunt",
    				subtitleFontFamily: "Garamond",
    				subtitleStroke: "green",
    				subtitleStrokeWidth: 2,
    				usePadding: true
    			},
    			$$inline: true
    		});

    	const xaxis = new XAxis({
    			props: { zoomIdentity: { y: 0, ky: 1 } },
    			$$inline: true
    		});

    	const yaxis = new YAxis({
    			props: { zoomIdentity: { x: 0, kx: 1 } },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(title.$$.fragment);
    			t0 = space();
    			create_component(xaxis.$$.fragment);
    			t1 = space();
    			create_component(yaxis.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(title, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(xaxis, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(yaxis, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title.$$.fragment, local);
    			transition_in(xaxis.$$.fragment, local);
    			transition_in(yaxis.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title.$$.fragment, local);
    			transition_out(xaxis.$$.fragment, local);
    			transition_out(yaxis.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(title, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(xaxis, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(yaxis, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$l.name,
    		type: "slot",
    		source: "(19:1) <Section      x1={50} x2={450}     y1={50} y2={450}     padding={30}     scaleX={scaleLinear().domain([0, 4])}     scaleY={scaleLinear().domain([0, 4])}     {zoomIdentity}     {blockReindexing}   >",
    		ctx
    	});

    	return block;
    }

    // (17:0) <Graphic width={500} height={500} padding={graphicPadding}>
    function create_default_slot$m(ctx) {
    	let t;
    	let current;

    	const section = new Section({
    			props: {
    				x1: 50,
    				x2: 450,
    				y1: 50,
    				y2: 450,
    				padding: 30,
    				scaleX: linear$1().domain([0, 4]),
    				scaleY: linear$1().domain([0, 4]),
    				zoomIdentity: ctx.zoomIdentity,
    				blockReindexing,
    				$$slots: { default: [create_default_slot_1$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const title = new Title({
    			props: {
    				title: "Test text at bottom of chart",
    				subtitle: "elit, sed do eiusmod tempor incididunt",
    				vjust: "bottom",
    				hjust,
    				titleFontFamily: "Baskerville",
    				titleFill: "pink",
    				usePadding: false
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    			t = space();
    			create_component(title.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(title, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const section_changes = {};

    			if (changed.$$scope) {
    				section_changes.$$scope = { changed, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			transition_in(title.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			transition_out(title.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(title, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$m.name,
    		type: "slot",
    		source: "(17:0) <Graphic width={500} height={500} padding={graphicPadding}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$L(ctx) {
    	let current;

    	const graphic = new Graphic({
    			props: {
    				width: 500,
    				height: 500,
    				padding: graphicPadding,
    				$$slots: { default: [create_default_slot$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(graphic.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphic, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const graphic_changes = {};

    			if (changed.$$scope) {
    				graphic_changes.$$scope = { changed, ctx };
    			}

    			graphic.$set(graphic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphic, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let blockReindexing = false;
    let vjust = "top";
    let hjust = "center";
    let graphicPadding = 10;
    let sectionPadding = 40;

    function instance$J($$self) {
    	let zoomIdentity = { x: 0, y: 0, kx: 1, ky: 1 };

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("zoomIdentity" in $$props) $$invalidate("zoomIdentity", zoomIdentity = $$props.zoomIdentity);
    		if ("blockReindexing" in $$props) $$invalidate("blockReindexing", blockReindexing = $$props.blockReindexing);
    		if ("vjust" in $$props) vjust = $$props.vjust;
    		if ("hjust" in $$props) $$invalidate("hjust", hjust = $$props.hjust);
    		if ("graphicPadding" in $$props) $$invalidate("graphicPadding", graphicPadding = $$props.graphicPadding);
    		if ("sectionPadding" in $$props) sectionPadding = $$props.sectionPadding;
    	};

    	return { zoomIdentity };
    }

    class Title_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$J, create_fragment$L, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Title_1",
    			options,
    			id: create_fragment$L.name
    		});
    	}
    }

    /* test/sandbox/src/App.svelte generated by Svelte v3.15.0 */
    const file$k = "test/sandbox/src/App.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.component = list[i];
    	return child_ctx;
    }

    function get_each_context_1$4(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.component = list[i];
    	return child_ctx;
    }

    // (156:14) <Link to={component.url}>
    function create_default_slot_1$m(ctx) {
    	let t_value = ctx.component.name + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$m.name,
    		type: "slot",
    		source: "(156:14) <Link to={component.url}>",
    		ctx
    	});

    	return block;
    }

    // (155:8) {#each components as component}
    function create_each_block_1$4(ctx) {
    	let li;
    	let current;

    	const link = new Link({
    			props: {
    				to: ctx.component.url,
    				$$slots: { default: [create_default_slot_1$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(link.$$.fragment);
    			add_location(li, file$k, 155, 10, 3817);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(link, li, null);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const link_changes = {};

    			if (changed.$$scope) {
    				link_changes.$$scope = { changed, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$4.name,
    		type: "each",
    		source: "(155:8) {#each components as component}",
    		ctx
    	});

    	return block;
    }

    // (167:6) {#each components as component}
    function create_each_block$9(ctx) {
    	let current;

    	const route = new Route({
    			props: {
    				path: ctx.component.url,
    				component: ctx.component.component
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(route.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(route, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(route.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(route.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(route, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(167:6) {#each components as component}",
    		ctx
    	});

    	return block;
    }

    // (148:0) <Router url="">
    function create_default_slot$n(ctx) {
    	let div2;
    	let div0;
    	let ul;
    	let t0;
    	let div1;
    	let t1;
    	let current;
    	let each_value_1 = ctx.components;
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
    		each_blocks_1[i] = null;
    	});

    	const route = new Route({
    			props: {
    				path: "/",
    				component: ctx.components[0].component
    			},
    			$$inline: true
    		});

    	let each_value = ctx.components;
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	const out_1 = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			ul = element("ul");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t0 = space();
    			div1 = element("div");
    			create_component(route.$$.fragment);
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "toc svelte-tcumm");
    			add_location(ul, file$k, 152, 6, 3743);
    			attr_dev(div0, "class", "left-col svelte-tcumm");
    			add_location(div0, file$k, 150, 4, 3709);
    			attr_dev(div1, "class", "right-col");
    			add_location(div1, file$k, 162, 4, 3923);
    			attr_dev(div2, "class", "flex-grid svelte-tcumm");
    			add_location(div2, file$k, 148, 2, 3676);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, ul);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(ul, null);
    			}

    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			mount_component(route, div1, null);
    			append_dev(div1, t1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			current = true;
    		},
    		p: function update(changed, ctx) {
    			if (changed.components) {
    				each_value_1 = ctx.components;
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(changed, child_ctx);
    						transition_in(each_blocks_1[i], 1);
    					} else {
    						each_blocks_1[i] = create_each_block_1$4(child_ctx);
    						each_blocks_1[i].c();
    						transition_in(each_blocks_1[i], 1);
    						each_blocks_1[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (changed.components) {
    				each_value = ctx.components;
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div1, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out_1(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			transition_in(route.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks_1 = each_blocks_1.filter(Boolean);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			transition_out(route.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks_1, detaching);
    			destroy_component(route);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$n.name,
    		type: "slot",
    		source: "(148:0) <Router url=\\\"\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$M(ctx) {
    	let current;

    	const router = new Router({
    			props: {
    				url: "",
    				$$slots: { default: [create_default_slot$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(router.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(router, target, anchor);
    			current = true;
    		},
    		p: function update(changed, ctx) {
    			const router_changes = {};

    			if (changed.$$scope) {
    				router_changes.$$scope = { changed, ctx };
    			}

    			router.$set(router_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(router, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$K($$self) {
    	const components = [
    		{
    			name: "Bar Chart",
    			url: "/barchart",
    			component: BarChart
    		},
    		{
    			name: "Polygons",
    			url: "/polygons",
    			component: Polygons
    		},
    		{
    			name: "Grid Layout",
    			url: "/gridlayout",
    			component: GridLayout
    		},
    		{
    			name: "Resize Layout",
    			url: "/resizelayout",
    			component: ResizeLayout
    		},
    		{
    			name: "Scatterplot",
    			url: "/scatterplot",
    			component: Scatterplot
    		},
    		{
    			name: "ZoomPan",
    			url: "/zoompan",
    			component: ZoomPan
    		},
    		{
    			name: "Base mark",
    			url: "/basemark",
    			component: BaseMark
    		},
    		{
    			name: "Line",
    			url: "/line",
    			component: Line_1
    		},
    		{
    			name: "Geo Polygons",
    			url: "/geopolygons",
    			component: GeoPolygons
    		},
    		{
    			name: "FuncLines",
    			url: "funclines",
    			component: FuncLines
    		},
    		{
    			name: "Legends",
    			url: "/legends",
    			component: Legends
    		},
    		{
    			name: "DragCategorical",
    			url: "dragcategorical",
    			component: DragCategorical
    		},
    		{
    			name: "Function API",
    			url: "functionapi",
    			component: FunctionAPI
    		},
    		{
    			name: "Flip test",
    			url: "fliptest",
    			component: FlipTest
    		},
    		{
    			name: "Non numeric axis",
    			url: "nonnumericaxis",
    			component: NonNumericAxis
    		},
    		{
    			name: "Drag all marks",
    			url: "dragallmarks",
    			component: DragAllMarks
    		},
    		{
    			name: "Stacked bar chart",
    			url: "stackedbarchart",
    			component: StackedBarChart
    		},
    		{
    			name: "Select rectangle",
    			url: "selectrectangle",
    			component: SelectRectangle
    		},
    		{
    			name: "Select polygon",
    			url: "selectpolygon",
    			component: SelectPolygon
    		},
    		{
    			name: "Area chart",
    			url: "areachart",
    			component: AreaChart
    		},
    		{
    			name: "Stacked area chart",
    			url: "stackedareachart",
    			component: StackedAreaChart
    		},
    		{
    			name: "Violin plot",
    			url: "violinplot",
    			component: ViolinPlot
    		},
    		{
    			name: "Title",
    			url: "title",
    			component: Title_1
    		}
    	];

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		
    	};

    	return { components };
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$K, create_fragment$M, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment$M.name
    		});
    	}
    }

    const app = new App({
      target: document.body,
      props: {
        name: 'world'
      }
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
