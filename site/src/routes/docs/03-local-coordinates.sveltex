# Local coordinates

## Description

Understanding how local coordinates work is key to understanding `florence`.
The `Graphic` and `Section` components can create local coordinate systems,
while all other components are affected by local coordinate systems.

## Creating local coordinate systems

As stated above, local coordinate systems are created with the `Graphic` and `Section`
components. The following props are used to create local coordinate systems:

|      Prop      | Component |      Type(s)       | Required |   Default   |     Units     |
| -------------- | --------- | ------------------ | -------- | ----------- | ------------- |
| padding        | Both      | `Number`, `Object` | no       | `0`         | screen pixels |
| scaleX         | Both      | `Function`         | no       | `undefined` |               |
| scaleY         | Both      | `Function`         | no       | `undefined` |               |
| flipX          | Both      | `Boolean`          | no       | `false`     |               |
| flipY          | Both      | `Boolean`          | no       | `false`     |               |
| zoomIdentity   | `Section` | `Object`           | no       | `undefined` |               |
| transformation | `Section` | `String`           | no       | `undefined` |               |

As you can see, the `Section` has a few options that the `Graphic` does not have.
All these props will now be discussed in detail.

### Padding

`padding` can be either a `Number` or an `Object` with the following structure:

```js
{
  left: <Number>,
  right: <Number>,
  bottom: <Number>,
  top: <Number>
}
```

Try changing the 'Padding' slider in the following example.
Note that `Section` components clip everything outside of their boundaries.

```html
<script>
  import { Graphic, Section, Point } from '../../../../src'
  let padding = 0
</script>

<label for="padding-slider">Padding: {padding}</label>
<input type="range" min="0" max="50" bind:value={padding} name="padding-slider" />
<br />

<Graphic width={300} height={300}>

  <Section x1={50} x2={250} y1={50} y2={250} {padding}>
  
    <Point x={50} y={50} />
    <Point x={150} y={150} />
    <Point x={250} y={250} />

  </Section>

</Graphic>
```

```js exec
import Padding from './doc-examples/Padding.svelte'
```

<Padding />

### scaleX and scaleY

`scaleX` and `scaleY` can be used to create a local coordinate system
inside of the `Graphic` or `Section`. Concretely this means that the
positioning props of the direct children of the `Graphic` or `Section` 
will behave differently depending on `scaleX` and `scaleY`. For example:

```html
<script>
  import { scaleLinear } from 'd3-scale'
  import { Graphic, Point } from 'florence'
</script>

<Graphic
  width={200} height={200}
  scaleX={scaleLinear().domain([0, 1])}
  scaleY={scaleLinear().domain([0, 1])}
>

  <!-- This point will be in the center of the graphic -->
  <Point x={0.5} y={0.5} />

</Graphic>
```

It is also possible to use non-numeric domains:

```html
<script>
  import { scalePoint, scaleLinear } from 'd3-scale'
  import { Graphic, Section, Rectangle } from 'florence'
</script>

<Graphic width={200} height={200} padding={10}>

  <Section
    scaleX={scalePoint().domain(['a', 'b', 'c'])}
    scaleY={scaleLinear().domain([0, 1])}
  >

    <Rectangle 
      x1={'a'} x2={'c'}
      y1={0} y2={0.5}
    />

    <XAxis />
    <YAxis />
  
  </Section>

</Graphic>
```

```js exec
import NonNumericDomains from './doc-examples/NonNumericDomains.svelte'
```

<NonNumericDomains />

Note that you should not provide the `.range` of the scales. `florence` determines this
automatically by looking at what was provided to the positioning props, `padding`, and `flipX`
and `flipY`. So for example

```html
<Section
  x1={50} x2={450}
  flipX
  padding={20}
  scaleX={scaleLinear().domain([0, 1])}
>
```

is equivalent to 

```js
scaleLinear().domain([0, 1]).range([430, 70])
```

Throughout the documentation, [d3 scales](https://github.com/d3/d3-scale) like `scaleLinear`,
`scaleBand` and `scalePoint` will be passed to `scaleX` and `scaleY`. It is also possible 
to use your own scale functions, but there are currently too many caveats, so a guide for
this will be added in the future.

### flipX and flipY

`flipX` and `flipY` can be used to invert the coordinate system:

```html
<Graphic width={200} height={200} flipY>

  <!-- This point will be at the bottom of the graphic -->
  <Point x={100} y={0} />

</Graphic>
```

### zoomIdentity

The `zoomIdentity` prop takes an `Object` with the following structure:

```js
{
  x: <Number>,
  y: <Number>,
  kx: <Number>,
  ky: <Number>
}
```

where `x` is the translation to the right in screen pixels, `y` the translation down in screen pixels,
`kx` the magnification factor in the x dimension and `ky` the magnification factor in the y dimension.
The identity transformation is 
```js
{ x: 0, y: 0, kx: 1, ky: 1 }
``` 
Using `zoomIdentity` will zoom and/or pan
everything inside of the `Section`.

With `zoomIdentity` it is possible to zoom/pan programmatically, or on user interaction- see the
[zooming and panning documentation](/docs/05-zooming-panning) for more information.

### transformation

The `transformation` prop only accepts two values right now:
- `'identity'`
- `'polar'`

where `'identity'` does nothing, and `'polar'` results in a polar transformation.
`transformation` can be used freely in combination with `zoomIdentity`, `scaleX` and `scaleY`.
The only caveat is that inside of a `Section` that has a `transformation`, it is not allowed
to use anything other than marks, layers and axes. An example:

```html
<script>
  import { scalePoint, scaleLinear } from 'd3-scale'
  import { Graphic, Section, Rectangle, XAxis, YAxis } from '../../../../../src'
</script>

<Graphic width={500} height={500}>

  <Section
    scaleX={scalePoint().domain(['a', 'b', 'c'])}
    scaleY={scaleLinear().domain([0, 1])}
    transformation="polar"
  >

    <Rectangle x1={'a'} x2={'b'} y1={0} y2={0.75} fill="blue" />
    <Rectangle x1={'b'} x2={'c'} y1={0.25} y2={1} fill="red" />
  
  </Section>

</Graphic>
```

```js exec
import Polar from './doc-examples/Polar.svelte'
```

<Polar />

## Function syntax

As explained above under [scaleX and scaleY](#scalex-and-scaley), positioning
props of children of the `Graphic` or `Section` that uses the scales will expect
values of the type of domain that the `scaleX` or `scaleY` is expecting.
However, in some cases it is desirable to be able to override this behavior and
provide unscaled screen coordinates directly. This can be done using the so-called
'Function syntax'. For example:

```html
<script>
  import { scaleLinear } from 'd3-scale'
  import { Graphic, Point } from 'florence'
</script>

<Graphic
  width={200} height={200}
  scaleX={scaleLinear().domain([0, 1])}
  scaleY={scaleLinear().domain([0, 1])}
>

  <!-- This point will be in the center of the graphic -->
  <Point x={() => 100} y={() => 100} />

</Graphic>
```

In fact, the `Function` passed to a positioning props receives an `Object` containing
all kinds of data related to the parent `Section`, including the `scaleX` and `scaleY`.
This is convenient when working with `d3`'s `scaleBand`, that uses a `.bandwidth` method
that returns a pixel value:

```html
<Section scaleX={scaleBand().domain(['a', 'b', 'c'])}>
  
  <Rectangle
    x1={'a'}
    x2={({ scaleX }) => scaleX('a') + scaleX.bandwidth()}
  />

</Section>
```

The full list of available `Section`-related attributes is

```js
({
  scaleX, // what was passed to scaleX with the rangeX applied
  scaleY, // what was passed to scaleY with the rangeY apllied
  rangeX, // [x1, x2], flipped if flipX === true, with padding applied
  rangeY, // [y1, y2], flipped if flipY === true, with padding applied
  minX, // Math.min(...rangeX)
  maxX, // Math.max(...rangeX)
  minY, // Math.min(...rangeY)
  maxY, // Math.max(...rangeY)
  padding, // An object with the specified padding for each side
  flipX, // what was passed to flipX
  flipY // what was passed to flipY
}) => { ... }
```